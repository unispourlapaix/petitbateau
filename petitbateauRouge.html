<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- SEO Meta Tags Fran√ßais -->
    <title>Petit Bateau Rouge ‚õµ - Jeu d'√ânigmes Po√©tique par Emmanuel Payet</title>
    <meta name="description" content="D√©couvrez Petit Bateau Rouge, un jeu d'√©nigmes philosophique et po√©tique cr√©√© par Emmanuel Payet. Naviguez √† travers 14 langues dans un univers o√π chaque √©nigme r√©v√®le une v√©rit√© sur l'humanit√©. Objectif : 33 millions de joueurs !">
    <meta name="keywords" content="jeu d'√©nigmes, petit bateau rouge, Emmanuel Payet, jeu philosophique, √©nigmes po√©tiques, multilingue, 14 langues, cr√©ole r√©unionnais, jeu fran√ßais, puzzle game, dreamer unisona, unispourlapaix">
    <meta name="author" content="Emmanuel Payet - Dreamer Unisona">
    <meta name="robots" content="index, follow">
    <meta name="language" content="French">
    <meta name="revisit-after" content="7 days">
    <meta name="distribution" content="global">
    <meta name="rating" content="general">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://unispourlapaix.github.io/petitbateau/">
    <meta property="og:title" content="Petit Bateau Rouge ‚õµ - Jeu d'√ânigmes Po√©tique">
    <meta property="og:description" content="Un voyage philosophique √† travers les √©nigmes de l'humanit√©. Cr√©√© par Emmanuel Payet, disponible en 14 langues. Objectif : 33 millions de joueurs !">
    <meta property="og:image" content="https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:site_name" content="Petit Bateau Rouge">
    <meta property="og:locale" content="fr_FR">
    <meta property="og:locale:alternate" content="en_US">
    <meta property="og:locale:alternate" content="es_ES">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://unispourlapaix.github.io/petitbateau/">
    <meta name="twitter:title" content="Petit Bateau Rouge ‚õµ - Jeu d'√ânigmes Po√©tique">
    <meta name="twitter:description" content="Un voyage philosophique √† travers les √©nigmes de l'humanit√©. Cr√©√© par Emmanuel Payet, disponible en 14 langues.">
    <meta name="twitter:image" content="https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png">
    <meta name="twitter:creator" content="@unispourlapaix">
    
    <!-- Liens Canoniques et Alternatives -->
    <link rel="canonical" href="https://unispourlapaix.github.io/petitbateau/">
    <link rel="alternate" hreflang="fr" href="https://unispourlapaix.github.io/petitbateau/?lang=fr">
    <link rel="alternate" hreflang="en" href="https://unispourlapaix.github.io/petitbateau/?lang=en">
    <link rel="alternate" hreflang="es" href="https://unispourlapaix.github.io/petitbateau/?lang=es">
    <link rel="alternate" hreflang="de" href="https://unispourlapaix.github.io/petitbateau/?lang=de">
    <link rel="alternate" hreflang="x-default" href="https://unispourlapaix.github.io/petitbateau/">
    
    <!-- JSON-LD Schema.org -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Petit Bateau Rouge",
      "description": "Jeu d'√©nigmes philosophique et po√©tique cr√©√© par Emmanuel Payet, disponible en 14 langues",
      "author": {
        "@type": "Person",
        "name": "Emmanuel Payet",
        "url": "https://emmanuelpayet.art",
        "sameAs": [
          "https://emmanuel.gallery",
          "https://www.tiktok.com/@unispourlapaix",
          "https://audiomack.com/emmanuelpayet888"
        ]
      },
      "genre": "Puzzle",
      "gamePlatform": ["Web Browser", "Mobile", "Desktop"],
      "inLanguage": ["fr", "en", "es", "de", "it", "pt", "ru", "zh", "ko", "ja", "ar", "he", "uk", "rc"],
      "url": "https://unispourlapaix.github.io/petitbateau/",
      "image": "https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png",
      "publisher": {
        "@type": "Organization",
        "name": "UnisPourLaPaix",
        "url": "https://github.com/unispourlapaix"
      },
      "datePublished": "2025-10-12",
      "applicationCategory": "Game",
      "operatingSystem": "Web Browser"
    }
    </script>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#ff6b6b">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Petit Bateau Rouge">
    <meta name="msapplication-TileColor" content="#ff6b6b">
    <meta name="msapplication-TileImage" content="./icons/icon-144x144.png">
    
    <!-- Firefox PWA Support -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Petit Bateau Rouge">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Icons -->
    <link rel="icon" href="data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'&gt;&lt;text y='0.9em' font-size='90'&gt;üö£&lt;/text&gt;&lt;/svg&gt;">
    <link rel="apple-touch-icon" href="./icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="192x192" href="./icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-72x72.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-72x72.png">
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; 
            min-height: -webkit-fill-available; /* iOS fix */
            width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
            position: fixed; /* Emp√™che le scroll sur mobile */
        }

        .game-container {
            position: relative;
            width: 100vw; 
            width: 100dvw; /* Dynamic viewport for mobile */
            height: 100vh;
            height: 100dvh; /* Dynamic viewport for mobile */
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
        
        /* Optimisation mobile - Plein √©cran natif */
        @media (max-width: 499px) {
            body {
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            .game-container {
                width: 100vw;
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            #gameCanvas {
                max-width: 100%;
                max-height: 100%;
            }
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: transparent;
            backdrop-filter: none; -webkit-backdrop-filter: none;
            border: none;
            border-radius: 0; padding: 25px 113px;
            box-shadow: none;
            max-width: none; width: 100%; text-align: center; z-index: 200;
            display: none; font-size: clamp(21px, 5.25vw, 24px); color: #ffffff;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow:
                0 0 2px rgba(0,0,0,0.8),
                1px 1px 2px rgba(0,0,0,0.6);
        }

        .message.show {
            display: block;
        }

        /* Messages narratifs - style cin√©matique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: transparent;
            border: none;
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow:
                0 0 10px rgba(0,0,0,1),
                2px 2px 6px rgba(0,0,0,0.95),
                4px 4px 12px rgba(0,0,0,0.8),
                6px 6px 20px rgba(0,0,0,0.6);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: none; width: 100%;
                font-size: clamp(21px, 2.7vw, 24px);
                padding: 20px 113px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Indicateur d'√©tape */
        .etape-indicateur {
            display: none !important;
        }

        .etape-indicateur.show {
            display: block;
        }

        /* Animation shake pour le bouton skip */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes etapeGlow {
            0% {
                box-shadow:
                    0 4px 15px rgba(0,0,0,0.3),
                    0 0 20px rgba(77,166,255,0.2),
                    inset 0 1px 1px rgba(255,255,255,0.1);
            }
            100% {
                box-shadow:
                    0 4px 20px rgba(0,0,0,0.4),
                    0 0 30px rgba(77,166,255,0.5),
                    inset 0 1px 1px rgba(255,255,255,0.2);
            }
        }
        
        /* Message d'orientation 100% VISUEL - Pas de texte, juste des ic√¥nes */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        /* Animation de rotation du t√©l√©phone */
        @keyframes rotate-pulse {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(90deg) scale(1.1); }
        }
        
        /* Afficher le warning en mode paysage sur mobile UNIQUEMENT sur tr√®s petits √©crans */
        @media (max-width: 768px) and (max-height: 500px) and (orientation: landscape) {
            .orientation-warning {
                display: flex !important;
            }
            
            .game-container {
                display: none !important;
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* üé¨ STYLES TEXTANIMATOR OPTIMIS√â */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .text-animator-display {
            font-size: 1.2em;
            line-height: 1.6;
            background: transparent;
        }

        /* Animations de base */
        .ta-typewriter { border-right: 2px solid #ffffff; animation: ta-blink 1s infinite; }
        .ta-digital { color: #00cc44; text-shadow: 0 0 8px #00cc44; font-family: 'Courier New', monospace; letter-spacing: 2px; }
        .ta-fade-in { animation: ta-fadeIn 1s ease-in; }
        .ta-glitch { position: relative; color: #fff; animation: ta-glitch 2s infinite; }

        /* Effets 3D optimis√©s */
        .ta-effect-shadow3d { text-shadow: 2px 2px 0px var(--ta-effect-color, #64ffda), 4px 4px 0px rgba(0,0,0,0.5), 6px 6px 10px rgba(0,0,0,0.8); }
        .ta-effect-neon { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda), 0 0 80px var(--ta-effect-color, #64ffda); animation: ta-neonPulse 2s ease-in-out infinite alternate; }
        .ta-effect-emboss { text-shadow: 1px 1px 0px var(--ta-effect-color, #64ffda), -1px -1px 0px rgba(0,0,0,0.8), 2px 2px 5px rgba(0,0,0,0.6); color: var(--ta-text-color, #fff); }
        .ta-effect-outline { text-shadow: -2px -2px 0 var(--ta-effect-color, #64ffda), 2px -2px 0 var(--ta-effect-color, #64ffda), -2px 2px 0 var(--ta-effect-color, #64ffda), 2px 2px 0 var(--ta-effect-color, #64ffda), 0 0 10px rgba(0,0,0,0.5); }
        .ta-effect-fire { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; animation: ta-fireFlicker 1.5s ease-in-out infinite alternate; }
        .ta-effect-ice { background: linear-gradient(45deg, #87ceeb, #add8e6, #e0ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); animation: ta-iceShimmer 3s ease-in-out infinite; }

        /* Keyframes optimis√©es */
        @keyframes ta-blink { 0%, 50% { border-color: transparent; } 51%, 100% { border-color: #ffffff; } }
        @keyframes ta-fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes ta-glitch { 0%, 100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000; transform: translate(0); } 20% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; transform: translate(-2px, 2px); } 40% { text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff; transform: translate(-2px, -2px); } 60% { text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; transform: translate(2px, 2px); } 80% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff; transform: translate(2px, -2px); } }
        @keyframes ta-neonPulse { from { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda); } to { text-shadow: 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-text-color, #fff), 0 0 30px var(--ta-effect-color, #64ffda), 0 0 60px var(--ta-effect-color, #64ffda), 0 0 100px var(--ta-effect-color, #64ffda); } }
        @keyframes ta-fireFlicker { 0%, 100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; } 50% { text-shadow: 0 0 5px #ff4500, 0 0 15px #ff8c00, 0 0 25px #ffd700, 0 0 35px #ff4500; } }
        @keyframes ta-iceShimmer { 0%, 100% { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); } 50% { text-shadow: 1px 1px 3px rgba(0,0,0,1); } }
        /* ===========================================
           MODULE OISEAUX VOLANTS - INT√âGRATION
           Par Emmanuel Payet / Dreamer Unisona
           ========================================== */

        /* Variables CSS pour le module oiseaux */
        :root {
            --bird-scale: 1;
            --animation-speed: 1;
            --crow-color: #1A1A1A;
            --dove-color: #FFFFFF;
            --bat-color: #000000;
        }

        /* Container pour oiseaux sur canvas */
        .flying-birds-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 150;
        }

        /* Base commune pour tous les oiseaux */
        .bird-base {
            position: absolute;
            transform-origin: center;
            pointer-events: auto;
            transition: opacity 0.3s ease;
            cursor: pointer;
        }

        /* √âtats de visibilit√© */
        .bird-hidden {
            opacity: 0;
        }


        .bird-visible {
            opacity: 1;
        }

        /* CORBEAU BADASS - ID: crow */
        #crow {
            width: 45px;
            height: 30px;
            background: linear-gradient(135deg, var(--crow-color), #000000);
            clip-path: polygon(10% 15%, 25% 0%, 75% 5%, 90% 25%, 95% 60%, 85% 90%, 15% 95%, 5% 70%);
            animation: crow-auto-flight calc(2s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* Aile du corbeau */
        #crow::before {
            content: '';
            position: absolute;
            width: 28px;
            height: 18px;
            background: linear-gradient(45deg, #4A4A4A, #2F2F2F, #1A1A1A);
            clip-path: polygon(0% 20%, 30% 0%, 70% 5%, 100% 30%, 90% 70%, 60% 100%, 20% 85%, 5% 50%);
            top: 5px;
            left: 2px;
            z-index: -1;
            animation: crow-wing-beat calc(0.15s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        /* ≈íil rouge du corbeau */
        #crow::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 5px;
            background: linear-gradient(135deg, #FF0000, #8B0000);
            clip-path: polygon(0% 40%, 30% 0%, 100% 20%, 80% 100%, 20% 80%);
            top: 9px;
            right: 8px;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
            animation: crow-evil-glow calc(1.5s / var(--animation-speed)) infinite;
        }

        /* COLOMBE √âL√âGANTE - ID: dove */
        #dove {
            width: 40px;
            height: 25px;
            background: linear-gradient(135deg, var(--dove-color), #F8F8FF, #E6E6FA);
            clip-path: polygon(15% 10%, 40% 0%, 85% 8%, 95% 35%, 90% 65%, 75% 90%, 25% 95%, 5% 60%, 10% 30%);
            animation: dove-auto-flight calc(3s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.15));
        }

        /* Aile de la colombe */
        #dove::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 12px;
            background: linear-gradient(45deg, #F8F8FF, #E6E6FA, #D6D6EA);
            clip-path: polygon(0% 30%, 25% 0%, 60% 5%, 85% 15%, 100% 40%, 95% 70%, 75% 100%, 40% 95%, 15% 85%, 5% 60%);
            top: 6px;
            left: 6px;
            z-index: -1;
            animation: dove-wing-beat calc(0.4s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.2));
        }

        /* ≈íil bleu de la colombe */
        #dove::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle at 30% 30%, #87CEEB, #4169E1);
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            top: 8px;
            right: 8px;
            box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
            animation: dove-sparkle calc(3s / var(--animation-speed)) infinite;
        }

        /* ANIMATIONS DU MODULE */
        @keyframes crow-auto-flight {
            0%, 100% {
                transform: translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: translateY(-15px) rotate(2deg) scale(var(--bird-scale));
            }
            50% {
                transform: translateY(-8px) rotate(-1deg) scale(var(--bird-scale));
            }
            75% {
                transform: translateY(-20px) rotate(1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-auto-flight-left {
            0%, 100% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(0px) rotate(0deg);
            }
            25% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-15px) rotate(-2deg);
            }
            50% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-8px) rotate(1deg);
            }
            75% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-20px) rotate(-1deg);
            }
        }

        @keyframes crow-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-15deg) scaleX(1);
            }
            100% {
                transform: rotateY(-20deg) rotateZ(10deg) scaleX(1.1);
            }
        }

        @keyframes crow-evil-glow {
            0%, 100% {
                box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 0, 0, 1);
                filter: brightness(1.3);
            }
        }

        @keyframes dove-auto-flight {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(var(--bird-scale));
            }
            33% {
                transform: translateY(-12px) translateX(2px) scale(var(--bird-scale));
            }
            66% {
                transform: translateY(-8px) translateX(-1px) scale(var(--bird-scale));
            }
        }

        @keyframes dove-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-8deg) translateX(0px);
            }
            100% {
                transform: rotateY(-12deg) rotateZ(5deg) translateX(1px);
            }
        }

        @keyframes dove-sparkle {
            0%, 100% {
                box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 8px rgba(135, 206, 235, 0.8);
                filter: brightness(1.2);
            }
        }

    </style>
<style id="kawaii-objects-styles">
/* ===============================
   OBJETS KAWAII - STYLES DE BASE
   =============================== */

.kawaii-object {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid #FF69B4;
    box-shadow: 0 4px 15px rgba(255,105,180,0.3);
    border-radius: 15px;
    background: transparent; /* FOND TRANSPARENT */
}

.kawaii-object:hover {
    transform: scale(1.15) rotate(-5deg);
    box-shadow: 0 8px 25px rgba(255,105,180,0.5);
    filter: brightness(1.1);
}

/* EXPLOSION KAWAII */
.explode {
    animation: explodeKawaii 0.6s ease-out forwards !important;
}

@keyframes explodeKawaii {
    0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1); }
    25% { transform: scale(1.3) rotate(10deg); opacity: 0.9; filter: brightness(1.3); }
    50% { transform: scale(1.8) rotate(-5deg); opacity: 0.7; filter: brightness(1.6); }
    100% { transform: scale(2.5) rotate(15deg); opacity: 0; filter: brightness(2); }
}

/* ===============================
   BALEINE KAWAII (ID: baleine)
   =============================== */

.obj-baleine {
    width: 60px;
    height: 70px;
    background: linear-gradient(180deg, #4FC3F7 0%, #4FC3F7 40%, #87CEEB 60%, #87CEEB 100%);
    border-radius: 8px 8px 30px 30px;
}

.obj-baleine::before {
    content: '';
    position: absolute;
    bottom: 15px;
    left: 18px;
    width: 8px;
    height: 8px;
    background: #000;
    border-radius: 50%;
    box-shadow: 
        0 0 0 2px #FFF,
        12px 0 0 -6px #000,
        12px 0 0 -4px #FFF,
        -5px 8px 0 -4px #FFB3BA,
        17px 8px 0 -4px #FFB3BA,
        6px 6px 0 -6px #FF69B4;
}

.obj-baleine::after {
    content: '';
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 25px solid #4FC3F7;
}

.baleine-nageoire-gauche {
    position: absolute;
    top: 15px;
    left: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 15px 0 0 15px;
    transform: rotate(45deg);
    animation: nageoireGauche 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

.baleine-nageoire-droite {
    position: absolute;
    top: 15px;
    right: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 0 15px 15px 0;
    transform: rotate(-45deg);
    animation: nageoireDroite 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

@keyframes nageoireGauche {
    0%, 100% { transform: rotate(45deg) translateY(0px); }
    25% { transform: rotate(55deg) translateY(-4px); }
    50% { transform: rotate(45deg) translateY(0px); }
    75% { transform: rotate(35deg) translateY(2px); }
}

@keyframes nageoireDroite {
    0%, 100% { transform: rotate(-45deg) translateY(0px); }
    25% { transform: rotate(-55deg) translateY(-4px); }
    50% { transform: rotate(-45deg) translateY(0px); }
    75% { transform: rotate(-35deg) translateY(2px); }
}

@keyframes heartFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.7; }
    50% { transform: translateY(-8px) rotate(10deg); opacity: 1; }
}

/* ===============================
   AST√âRO√èDE KAWAII (ID: asteroide)
   =============================== */

.obj-asteroide {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #654321 0%, #8B4513 30%, #A0522D 60%, #654321 100%);
    border-radius: 50%;
    position: relative;
    animation: asteroidFloat 3s ease-in-out infinite;
}

.obj-asteroide::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    box-shadow:
        /* Morceaux d√©tach√©s autour */
        -15px -10px 0 -20px #654321,
        20px -5px 0 -22px #8B4513,
        -8px 18px 0 -25px #A0522D,
        15px 15px 0 -23px #654321,
        /* Crat√®res sur la surface */
        inset -8px -8px 0 -15px rgba(0,0,0,0.4),
        inset 10px -5px 0 -18px rgba(0,0,0,0.3),
        inset -5px 12px 0 -20px rgba(0,0,0,0.2);
}

.obj-asteroide::after {
    content: '';
    position: absolute;
    top: -30px;
    left: 50%;
    width: 3px;
    height: 25px;
    background: linear-gradient(180deg, transparent 0%, #FFA500 30%, #FF6500 70%, transparent 100%);
    transform: translateX(-50%) skewY(-20deg);
    animation: trailingEffect 2s ease-in-out infinite;
}

@keyframes asteroidFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-3px) rotate(5deg); }
}

@keyframes trailingEffect {
    0% { opacity: 0.8; transform: translateX(-50%) skewY(-20deg) scaleY(1); }
    50% { opacity: 1; transform: translateX(-50%) skewY(-15deg) scaleY(1.2); }
    100% { opacity: 0.6; transform: translateX(-50%) skewY(-25deg) scaleY(0.8); }
}

/* ===============================
   √âTOILE KAWAII (ID: etoile)
   =============================== */

.obj-etoile {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #FFEE58 0%, #FFD54F 100%);
    border-radius: 50%;
}

.obj-etoile::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 6px;
    height: 3px;
    background: #000;
    border-radius: 3px 3px 0 0;
    box-shadow: 
        10px 0 0 #000,
        3px 8px 0 -4px #FF6B6B,
        1px 10px 0 -5px #000,
        7px 10px 0 -5px #000,
        -8px 6px 0 -2px #FFCDD2,
        18px 6px 0 -2px #FFCDD2;
}

.obj-etoile::after {
    content: '‚ú®';
    position: absolute;
    top: -10px;
    left: -8px;
    font-size: 16px;
    animation: sparkleKawaii 1.5s ease-in-out infinite;
}

@keyframes sparkleKawaii {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
}

/* ===============================
   TANK KAWAII (ID: tank)
   =============================== */

.obj-tank {
    width: 75px;
    height: 40px;
    background: linear-gradient(135deg, #2E7D32 0%, #4CAF50 50%, #388E3C 100%);
    border-radius: 8px 8px 3px 3px;
    border: 3px solid #1B5E20;
    position: relative;
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.3),
        inset 0 -3px 6px rgba(0,0,0,0.3),
        0 4px 12px rgba(0,0,0,0.4);
    animation: tankRumble 3s ease-in-out infinite;
}

/* Yeux s√©rieux et d√©termin√©s */
.obj-tank::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 25px;
    width: 6px;
    height: 6px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        14px 0 0 -2px #FFF,
        14px 0 0 0 #000,
        /* Petites pupilles noires mignonnes */
        1px 1px 0 -3px #000,
        15px 1px 0 -3px #000,
        /* Petits reflets blancs kawaii */
        -1px -1px 0 -4px #FFF,
        13px -1px 0 -4px #FFF,
        /* Sourcils s√©rieux plus marqu√©s */
        -3px -5px 0 -2px #1B5E20,
        17px -5px 0 -2px #1B5E20,
        /* Bouche souriante kawaii */
        7px 8px 0 -3px #FF69B4,
        4px 10px 0 -4px #FF69B4,
        10px 10px 0 -4px #FF69B4,
        /* Casque militaire */
        -5px -8px 0 -1px #795548,
        19px -8px 0 -1px #795548,
        /* Joues roses kawaii */
        -8px 2px 0 -2px #FFB6C1,
        22px 2px 0 -2px #FFB6C1;
}

/* Canon principal plus imposant */
.obj-tank::after {
    content: '';
    position: absolute;
    bottom: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 10px;
    height: 15px;
    background: linear-gradient(180deg, #263238 0%, #37474F 50%, #263238 100%);
    border: 2px solid #000;
    border-radius: 4px;
    box-shadow:
        0 -6px 0 -3px #FFD54F,
        inset 0 2px 4px rgba(255,255,255,0.2),
        0 0 8px rgba(0,0,0,0.5),
        /* Tourelle ronde au bout du canon */
        0 20px 0 -2px #37474F,      /* Tourelle gris fonc√© */
        0 20px 0 0px #000,          /* Contour noir */
        /* Mini yeux kawaii espac√©s */
        -3px 22px 0 -5px #FFF,      /* ≈íil gauche blanc */
        3px 22px 0 -5px #FFF,       /* ≈íil droit blanc */
        -2px 23px 0 -6px #000,      /* Pupille gauche */
        4px 23px 0 -6px #000;       /* Pupille droite */
}

@keyframes tankRumble {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-1px); }
    75% { transform: translateX(1px); }
}

@keyframes nervousEyes {
    0% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -4px 32px 0 -5px #FF0000,
            4px 32px 0 -5px #FF0000;
    }
    100% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -3px 31px 0 -5px #FF0000,
            5px 31px 0 -5px #FF0000;
    }
}

@keyframes tankSmoke {
    0% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            7px -15px 0 -3px #FF8C00,
            5px -18px 0 -4px #FF6500,
            9px -18px 0 -4px #FF6500,
            6px -21px 0 -5px #FF4500,
            8px -21px 0 -5px #FF4500;
    }
    50% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            8px -16px 0 -3px #FF8C00,
            4px -19px 0 -4px #FF6500,
            10px -19px 0 -4px #FF6500,
            5px -22px 0 -5px #FF4500,
            9px -22px 0 -5px #FF4500;
    }
    100% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            6px -17px 0 -3px #FF8C00,
            6px -20px 0 -4px #FF6500,
            8px -20px 0 -4px #FF6500,
            7px -23px 0 -5px #FF4500,
            7px -23px 0 -5px #FF4500;
    }
}

/* Syst√®me de chenilles complet */
.obj-tank {
    overflow: visible;
}

/* Rectangles noirs pour les chenilles */
.tank-track {
    position: absolute;
    width: 8px;
    height: 80px;
    background: #000;
    top: -5px;
    border-radius: 2px;
}

.tank-track.center {
    left: 50%;
    transform: translateX(-50%);
}

/* Fum√©e du tank */
.tank-smoke {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 30px;
    pointer-events: none;
}

.tank-smoke::before {
    content: 'üíï';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    animation: smokeAnimation 2s ease-in-out infinite;
}

.tank-smoke::after {
    content: '‚ú®';
    position: absolute;
    top: 3px;
    left: 70%;
    transform: translateX(-50%);
    font-size: 12px;
    animation: fireAnimation 1.5s ease-in-out infinite alternate;
}

@keyframes smokeAnimation {
    0% {
        opacity: 0.6;
        transform: translateX(-50%) scale(0.8) rotate(-5deg);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scale(1.1) rotate(5deg) translateY(-3px);
    }
    100% {
        opacity: 0.7;
        transform: translateX(-50%) scale(0.9) rotate(-3deg) translateY(-1px);
    }
}

@keyframes fireAnimation {
    0% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1);
    }
    100% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
    }
}


/* Anciennes classes tank supprim√©es - tout en CSS box-shadow maintenant */

@keyframes powerPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.2); }
}

/* ===============================
   LUNE KAWAII (ID: lune)
   =============================== */

.obj-lune {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #F8F8FF 0%, #E6E6FA 100%);
    border-radius: 50%;
}

.obj-lune::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 8px;
    height: 4px;
    background: #000;
    border-radius: 4px 4px 0 0;
    box-shadow: 
        12px 0 0 #000,
        6px 8px 0 -4px #DDA0DD,
        4px 10px 0 -5px #000,
        8px 10px 0 -5px #000,
        -8px 6px 0 -2px #F8BBD9,
        20px 6px 0 -2px #F8BBD9,
        -15px -8px 0 -3px #E0E0E0,
        25px 15px 0 -3px #E0E0E0;
}

.obj-lune::after {
    content: 'üí§';
    position: absolute;
    top: -15px;
    right: -10px;
    font-size: 12px;
    animation: sleepFloat 2s ease-in-out infinite;
}

@keyframes sleepFloat {
    0%, 100% { transform: translateY(0); opacity: 0.6; }
    50% { transform: translateY(-10px); opacity: 1; }
}

/* ===============================
   AUTRES OBJETS KAWAII
   =============================== */

.obj-banane {
    width: 60px;
    height: 60px;
    position: relative;
    border: 3px solid #FFD700;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,193,7,0.2) 100%);
}

.obj-banane::before {
    content: 'üçå';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-30deg);
    font-size: 35px;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
}

@keyframes bananaGlow {
    0% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.4),
            inset 0 -4px 8px rgba(0,0,0,0.3),
            0 6px 20px rgba(255,193,7,0.4),
            0 0 15px rgba(255,235,59,0.3);
    }
    100% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.6),
            inset 0 -4px 8px rgba(0,0,0,0.2),
            0 8px 25px rgba(255,193,7,0.6),
            0 0 25px rgba(255,235,59,0.5);
        transform: rotate(-30deg) scale(1.05);
    }
}

/* IPHONE KAWAII üì± */
.obj-smartphone {
    width: 42px;
    height: 70px;
    background: linear-gradient(145deg, #1A1A1A 0%, #000 100%);
    border-radius: 12px;
    border: 1px solid #333;
    position: relative;
    box-shadow:
        0 6px 12px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 0 0 1px rgba(255,255,255,0.05);
}

.obj-smartphone::before {
    content: '';
    position: absolute;
    top: 6px;
    left: 3px;
    width: 34px;
    height: 56px;
    background: linear-gradient(145deg, #0066CC 0%, #004499 100%);
    border-radius: 8px;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.2),
        inset 0 -1px 2px rgba(0,0,0,0.3);
}

.obj-smartphone::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 3px;
    background: #333;
    border-radius: 2px;
    box-shadow: 0 0 0 1px #000;
}

/* POUBELLE KAWAII MIGNONNE üóëÔ∏è */
.obj-poubelle {
    width: 50px;
    height: 60px;
    background: linear-gradient(180deg, #4CAF50 0%, #388E3C 50%, #2E7D32 100%);
    border-radius: 8px 8px 12px 12px;
    border: 2px solid #2E7D32;
    position: relative;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.2),
        0 4px 8px rgba(0,0,0,0.3);
    animation: binHappy 3s ease-in-out infinite;
}

.obj-poubelle::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    width: 8px;
    height: 8px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        12px 0 0 -2px #FFF,
        12px 0 0 0 #000,
        /* Pupilles mignonnes */
        1px 1px 0 -4px #000,
        11px 1px 0 -4px #000,
        /* Joues roses */
        -6px 8px 0 -3px #FFB6C1,
        18px 8px 0 -3px #FFB6C1,
        /* Sourire kawaii */
        6px 15px 0 -4px #FF69B4,
        3px 17px 0 -5px #FF69B4,
        9px 17px 0 -5px #FF69B4;
}

.obj-poubelle::after {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 35px;
    height: 6px;
    background: linear-gradient(90deg, #66BB6A 0%, #4CAF50 50%, #66BB6A 100%);
    border-radius: 3px;
    border: 1px solid #388E3C;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

@keyframes binHappy {
    0%, 100% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.05) rotate(1deg); }
}

/* BOMBARDIER FURTIF B-2 SPIRIT üõ©Ô∏è */
.obj-avion {
    width: 90px;
    height: 70px;
    background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 30%, #2c2c2c 60%, #000000 100%);
    border-radius: 0;
    border: none;
    position: relative;
    transform: rotate(180deg); /* Orient√© vers le bas - nez pointant vers le sol */
    /* Forme en triangle caract√©ristique du B-2 avec ailes diagonales */
    clip-path: polygon(
        50% 0%,      /* Nez pointu */
        15% 35%,     /* Aile gauche diagonale */
        0% 70%,      /* Bout aile gauche */
        30% 85%,     /* Arri√®re gauche */
        50% 100%,    /* Queue centrale */
        70% 85%,     /* Arri√®re droite */
        100% 70%,    /* Bout aile droite */
        85% 35%      /* Aile droite diagonale */
    );
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.08),
        inset 0 -3px 6px rgba(0,0,0,0.7),
        0 8px 16px rgba(0,0,0,0.8),
        0 0 20px rgba(0,100,255,0.2);
    animation: stealthFly 4s ease-in-out infinite;
}

.obj-avion::before {
    content: '';
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 6px;
    background: linear-gradient(90deg, transparent, #00ffff 50%, transparent);
    border-radius: 2px;
    opacity: 0.6;
    box-shadow:
        0 0 10px rgba(0,255,255,0.5),
        0 0 20px rgba(0,255,255,0.3);
    animation: stealthLights 2s ease-in-out infinite alternate;
}

.obj-avion::after {
    content: '';
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 3px;
    background: linear-gradient(90deg,
        transparent 0%,
        #ff4500 20%,
        #ff6600 40%,
        #ffaa00 60%,
        #ff4500 80%,
        transparent 100%);
    border-radius: 50%;
    opacity: 0.9;
    box-shadow:
        0 0 8px rgba(255,69,0,0.6),
        0 0 16px rgba(255,102,0,0.4);
    animation: stealthJet 1s ease-in-out infinite;
}

@keyframes stealthFly {
    0%, 100% {
        transform: rotate(180deg) translateY(0);
        filter: brightness(0.8);
    }
    50% {
        transform: rotate(180deg) translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }
}

@keyframes stealthLights {
    0% {
        opacity: 0.6;
        box-shadow:
            0 0 8px #FF0000,
            8px 15px 0 -2px #FF0000,
            -8px 15px 0 -2px #FF0000;
    }
    100% {
        opacity: 1;
        box-shadow:
            0 0 15px #FF0000,
            8px 15px 0 -2px #FF4444,
            -8px 15px 0 -2px #FF4444,
            0 0 25px rgba(255,0,0,0.8);
    }
}

@keyframes stealthJet {
    0%, 100% {
        opacity: 0.8;
        transform: translateX(-50%) scaleY(1);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scaleY(1.3);
    }
}

@keyframes phoneGlow {
    0%, 100% { text-shadow: 0 0 10px #FF69B4; }
    50% { text-shadow: 0 0 20px #FF1493; }
}


/* ===============================
   NOUVELLES ANIMATIONS D√âBRIS ET AVION FURTIF
   =============================== */

@keyframes debrisFloat {
    0%, 100% { transform: translate(0, 0) rotate(0deg); opacity: 0.8; }
    25% { transform: translate(-3px, -5px) rotate(90deg); opacity: 1; }
    50% { transform: translate(5px, -8px) rotate(180deg); opacity: 0.6; }
    75% { transform: translate(-2px, -3px) rotate(270deg); opacity: 1; }
}

@keyframes dustTrail {
    0%, 100% { transform: scale(0.8) rotate(0deg); opacity: 0.5; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 0.9; }
}

@keyframes reactorFlame {
    0%, 100% { transform: scale(0.8); opacity: 0.7; filter: hue-rotate(0deg); }
    50% { transform: scale(1.2); opacity: 1; filter: hue-rotate(60deg); }
}

@keyframes missileGlow {
    0%, 100% { transform: translateX(-50%) scale(0.8); opacity: 0.6; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
}

@keyframes sonicBoom {
    0%, 100% { transform: scale(0.9) translateX(0); opacity: 0.4; }
    50% { transform: scale(1.3) translateX(-5px); opacity: 0.8; }
}

        </style></head>
<body>
    <!-- Message d'orientation pour mobile en mode paysage - 100% VISUEL -->
    <div class="orientation-warning">
        <div style="font-size: 120px; margin-bottom: 30px; animation: rotate-pulse 2s ease-in-out infinite;">
            üì±
        </div>
        <div style="font-size: 100px; margin-bottom: 20px;">
            ‚Üª
        </div>
        <div style="font-size: 60px; opacity: 0.9;">
            ‚¨ÜÔ∏è
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="449" height="799" style="width: 449px; height: 799px;"></canvas>

        <!-- CHARGER LES MODULES AVANT LE SCRIPT PRINCIPAL -->
        <script src="modules/i18n.js"></script>
    <script src="modules/i18n-apply.js"></script>

    <!-- Initialisation du syst√®me de traduction -->
    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // R√©cup√©rer la langue sauvegard√©e ou utiliser fran√ßais
            const savedLang = localStorage.getItem('petit_bateau_lang') || 'fr';

            // Initialiser i18n
            await window.i18n.init();

            // Cr√©er l'applicateur
            if (!window.i18nApplicator) {
                window.i18nApplicator = new I18nApplicator(window.i18n);
            }

            // Appliquer les traductions
            await window.i18nApplicator.applyAll(savedLang);

            // Mettre √† jour le titre du document
            if (window.i18n && window.i18n.t) {
                const docTitle = window.i18n.t('meta.document_title');
                const docDescription = window.i18n.t('meta.description');
                const ogTitle = window.i18n.t('meta.og_title');
                const ogDescription = window.i18n.t('meta.og_description');
                
                if (docTitle) document.title = docTitle;
                
                // Mettre √† jour meta description
                const metaDesc = document.querySelector('meta[name="description"]');
                if (metaDesc && docDescription) metaDesc.setAttribute('content', docDescription);
                
                // Mettre √† jour Open Graph title
                const ogTitleMeta = document.querySelector('meta[property="og:title"]');
                if (ogTitleMeta && ogTitle) ogTitleMeta.setAttribute('content', ogTitle);
                
                // Mettre √† jour Open Graph description
                const ogDescMeta = document.querySelector('meta[property="og:description"]');
                if (ogDescMeta && ogDescription) ogDescMeta.setAttribute('content', ogDescription);
                
                // Mettre √† jour l'attribut lang du HTML
                const htmlLang = savedLang === 'fr' ? 'fr' : savedLang === 'en' ? 'en' : savedLang === 'es' ? 'es' : 'fr';
                document.documentElement.setAttribute('lang', htmlLang);
            }

            console.log(`üåç Jeu charg√© en ${window.i18n.supportedLanguages[savedLang]}`);
        } catch (error) {
            console.error('‚ùå Erreur initialisation i18n:', error);
        }
    });
    </script>

        <script src="modules/kawaii_objects_module.js"></script>
        <script src="modules/secret-mode.js"></script>
        <script src="modules/info-auteur.js"></script>
        <script src="modules/audio-manager.js"></script>
        <script src="modules/supabase-scores.js"></script>

        <!-- MODULE OISEAUX VOLANTS CSS -->
        <div class="flying-birds-overlay">
            <!-- Corbeau Badass -->
            <div id="crow" class="bird-base bird-visible" style="left: 318.067px; top: 367.076px; animation: crow-auto-flight-left calc(2s / var(--animation-speed)) infinite;"></div>

            <!-- Colombe √âl√©gante -->
            <div id="dove" class="bird-base bird-hidden"></div>
        </div>
        <div id="message" class="message" data-i18n="game.messages.intro_bonus" style="transform: translate(-50%, -50%) scale(1); display: none;">üåü +100 Points pour avoir regard√© l'introduction compl√®te ! üåü</div>
        <div id="etapeIndicateur" class="etape-indicateur show">
                    <div>üß± 2/23</div>
                    <div id="voyageLight" data-i18n="game.voyage_light" style="font-size: 10px; margin-top: 2px; opacity: 0.8;">Voyage ‚Äî La lumi√®re</div>
                </div>

    <div id="kawaii-secret-container" style="position: absolute; top: 110px; left: 0px; width: 100%; height: calc(-110px + 100vh); pointer-events: none; z-index: 30; overflow: visible; background: transparent;"></div></div>


    <script>
        // ============================================
        // üåç SYST√àME DE TRADUCTION MULTILINGUE
        // ============================================

        // üåç Syst√®me de traduction unifi√© - utilise le module i18n.js
        let currentLang = localStorage.getItem('petit_bateau_lang') || 'fr';
        
        // √âtat du survol du drapeau avec animation
        let flagHover = false;
        let flagHoverAnimation = 0; // 0 = normal, 1 = survol√©
        let flagHoverAnimationSpeed = 0.15; // Vitesse de transition

        // Charger l'ic√¥ne du jeu pour le menu Info
        const gameIcon = new Image();
        gameIcon.src = 'icons/icon-96x96.png';

        // Obtenir le drapeau de la langue actuelle
        function getCurrentLanguageFlag() {
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            const flags = {
                'fr': 'üá´üá∑',
                'en': 'üá¨üáß',
                'jp': 'üáØüáµ',
                'uk': 'üá∫üá¶',
                'es': 'üá™üá∏',
                'de': 'üá©üá™',
                'it': 'üáÆüáπ',
                'pt': 'üáµüáπ',
                'ru': 'üá∑üá∫',
                'zh': 'üá®üá≥',
                'ko': 'üá∞üá∑',
                'ar': 'üá∏üá¶',
                'he': 'üáÆüá±',
                'rc': 'üá∑üá™'
            };
            return flags[currentLang] || 'üåç';
        }

        // ============================================
        // üéÆ D√âBUT DU CODE DU JEU
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // D√©tection mobile et tactile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                         || (window.innerWidth < 500);
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // üîí ORIENTATION FLEXIBLE - Autoriser portrait et paysage
        if (isMobile && screen.orientation && screen.orientation.lock) {
            // NE PAS verrouiller - laisser l'utilisateur choisir
            console.log('üì± Orientation libre - Portrait et Paysage autoris√©s');
            // Note: Le CSS bloquera uniquement les tr√®s petits √©crans en paysage (< 500px hauteur)
        }
        
        // Alternative : API ScreenOrientation pour PWA
        if (isMobile && window.screen && window.screen.orientation) {
            // √âcouter les changements d'orientation
            window.screen.orientation.addEventListener('change', () => {
                const orientation = window.screen.orientation.type;
                console.log('üì± Orientation chang√©e:', orientation);
            });
        }

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            let width = container.clientWidth;
            let height = container.clientHeight;

            // Sur mobile, utiliser les dimensions r√©elles de l'√©cran
            if (isMobile) {
                // Utiliser window.screen pour une meilleure r√©solution sur mobile
                const pixelRatio = window.devicePixelRatio || 1;
                
                // Dimensions physiques de l'√©cran
                width = window.innerWidth;
                height = window.innerHeight;
                
                // Sur iOS, corriger pour la barre d'adresse
                if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                    height = window.innerHeight;
                }
                
                // Optimiser le canvas pour le pixel ratio
                canvas.width = width * pixelRatio;
                canvas.height = height * pixelRatio;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Scaler le contexte pour compenser le pixel ratio
                ctx.scale(pixelRatio, pixelRatio);
                
                return { width, height };
            }

            // PC : comportement normal
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            return { width, height };
        }

        let size = setupCanvas();
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: Math.max(Math.min(size.width, size.height) * 0.002, 1.5)
        };

        // D√©claration des tableaux (seront initialis√©s apr√®s chargement des traductions)
        let JOUR = [];
        let NUIT = [];

        // Chargement initial des traductions
        window.translationsReady = (async () => {
            try {
                await loadTranslations(currentLang);
                initializeBrickArrays();
            } catch (error) {
                console.error('‚ùå Erreur chargement traductions:', error);
            }
        })();

        // Fonction pour initialiser les tableaux de briques
        function initializeBrickArrays() {
            // V√©rifier si i18n est disponible
            if (!window.i18n) {
                console.warn('‚ö†Ô∏è i18n non disponible, utilisation des textes fran√ßais par d√©faut');
                initializeFrenchBricks();
                return;
            }

            const currentLang = window.i18n.getCurrentLanguage();
            
            // Pour le fran√ßais, TOUJOURS utiliser les textes originaux cod√©s en dur
            if (currentLang === 'fr') {
                console.log('üá´üá∑ Utilisation des textes fran√ßais originaux (cod√©s en dur)');
                initializeFrenchBricks();
            } else {
                // Pour les autres langues, essayer les traductions, sinon fran√ßais
                console.log(`üåç Tentative de chargement des traductions pour: ${currentLang}`);
                initializeTranslatedBricks();
            }
        }

        // Fonction pour initialiser les briques en fran√ßais (fallback)
        function initializeFrenchBricks() {
            // Voyage de d√©couverte de la v√©rit√© - Le Jour : La Lumi√®re
            JOUR = [
                { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: 'üó£Ô∏è Les manipulations s\'effacent devant la v√©rit√© !' },
                { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Non... des humains comme nous !' },
                { nom: 'PR√âJUG√âS', couleur: '#DDA0DD', msg: 'üé≠ Les masques tombent un √† un...' },
                { nom: 'PEURS', couleur: '#98FB98', msg: 'üëÅÔ∏è J\'ai choisi de voir par moi-m√™me !' },
                { nom: 'M√âFIANCE', couleur: '#FFCCCB', msg: 'ü§ù La m√©fiance c√®de √† la compassion...' },
                { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '‚ùì Cette question hante mes nuits...' },
                { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: 'üëÅÔ∏è Et mes yeux se sont ouverts...' },
                { nom: 'UN P√àRE', couleur: '#FFDAB9', msg: 'üë® Un homme qui aime ses enfants...' },
                { nom: 'UNE M√àRE', couleur: '#AFEEEE', msg: 'üë© Une femme courageuse...' },
                { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: 'üë∂ Des rires purs et innocents...' },
                { nom: 'L\'HUMANIT√â', couleur: '#FFE4E1', msg: 'üí´ L\'essence m√™me de ce que nous sommes...' },
                { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '‚ù§Ô∏è Plus fort que toutes les barri√®res...' },
                { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: 'ü§ó Qui unit au-del√† des diff√©rences...' },
                { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: 'üåÖ Une lumi√®re dans l\'obscurit√©...' },
                { nom: 'LA PAIX', couleur: '#F5F5DC', msg: 'üïäÔ∏è Possible quand on choisis d\'aimer...' },
                { nom: 'COMME MOI', couleur: '#FFFACD', msg: 'üåç On est tous des immigr√©s...' },
                { nom: 'V√âRIT√â R√âV√âL√âE', couleur: '#FFE4B5', msg: 'üëÅÔ∏è Mes yeux se sont enfin ouverts...' },
                { nom: 'COURAGE DU C≈íUR', couleur: '#FFF0F5', msg: 'üí™ J\'ai choisi de voir par moi-m√™me...' },
                { nom: 'PR√âCIEUX', couleur: '#F0F8FF', msg: 'üíé Chaque √™tre humain est pr√©cieux...' }
            ];

            // La Nuit : L'Obscurit√© - Les maux qui tentent de corrompre
            NUIT = [
                { nom: 'DISCORDES', couleur: '#8B0000', msg: '‚ö° Des discordes... des haines... des destructions...' },
                { nom: 'HAINES', couleur: '#4B0000', msg: 'üíî Venues avec les maux de l\'ombre...' },
                { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: 'üå™Ô∏è Le vol, le mensonge, la manipulation...' },
                { nom: 'VOL', couleur: '#36454F', msg: 'ü¶π Qui s\'empare de ce qui n\'appartient pas...' },
                { nom: 'MENSONGE', couleur: '#2F2F2F', msg: 'üé≠ Les masques de la tromperie...' },
                { nom: 'MANIPULATION', couleur: '#654321', msg: 'üï∑Ô∏è Les fils invisibles tirent les c≈ìurs...' },
                { nom: 'CUPIDIT√â', couleur: '#654321', msg: 'üí∞ La cupidit√© et l\'avidit√©...' },
                { nom: 'AVIDIT√â', couleur: '#483C32', msg: '‚õìÔ∏è Comme des cha√Ænes invisibles...' },
                { nom: 'CHA√éNES', couleur: '#2E4B2E', msg: 'üîó Serrant le c≈ìur des hommes...' },
                { nom: 'MURS DE FER', couleur: '#191970', msg: 'üß± Enferm√©s derri√®re des murs de fer et de peur...' },
                { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: 'üíö Le poison vert de l\'envie...' },
                { nom: 'ORGUEIL', couleur: '#191970', msg: 'üëë La couronne qui aveugle...' },
                { nom: 'COL√àRE', couleur: '#8B1538', msg: 'üî• Les flammes qui consument la raison...' },
                { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '‚öîÔ∏è La spirale sans fin de la souffrance...' },
                { nom: 'INDIFF√âRENCE', couleur: '#708090', msg: 'üßä Le froid qui glace les √¢mes...' },
                { nom: '√âGO√èSME', couleur: '#5D5D5D', msg: 'ü™û Ne voir que son propre reflet...' },
                { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: 'üôà Choisir de fermer les yeux...' },
                { nom: 'R√âSISTANCE', couleur: '#1C1C1C', msg: 'üõ°Ô∏è Mais je garde mon c≈ìur pur dans la temp√™te...' },
                { nom: 'LUMI√àRE', couleur: '#483D8B', msg: '‚ú® Car au-del√† des nuages, elle existe toujours...' },
                { nom: 'ESPOIR RENAISSANT', couleur: '#4682B4', msg: 'üåÖ La lumi√®re perce enfin les t√©n√®bres...' },
                { nom: 'FORCE INT√âRIEURE', couleur: '#556B2F', msg: 'üåü Mon c≈ìur r√©siste √† l\'obscurit√©...' },
                { nom: 'SAGESSE ACQUISE', couleur: '#2F4F4F', msg: 'üß† Dans la nuit, j\'ai appris √† voir...' }
            ];

            // Initialiser VOYAGE avec JOUR
            VOYAGE = JOUR;
            window.brickArraysInitialized = true;
        }

        // Fonction pour initialiser les briques traduites
        function initializeTranslatedBricks() {
            try {
                const currentLang = window.i18n.getCurrentLanguage();
                
                // Acc√©der directement aux donn√©es JSON charg√©es
                const translations = window.i18n.translations[currentLang];
                
                if (!translations || !translations.bricks) {
                    console.warn('‚ö†Ô∏è Structure bricks non trouv√©e dans les traductions, utilisation du fran√ßais');
                    initializeFrenchBricks();
                    return;
                }

                // Support pour les cl√©s en fran√ßais (jour/nuit) et anglais (day/night)
                let jourBricks = translations.bricks.jour || translations.bricks.day;
                let nuitBricks = translations.bricks.nuit || translations.bricks.night;

                // Convertir objet en tableau si n√©cessaire
                if (jourBricks && !Array.isArray(jourBricks) && typeof jourBricks === 'object') {
                    jourBricks = Object.values(jourBricks);
                }
                if (nuitBricks && !Array.isArray(nuitBricks) && typeof nuitBricks === 'object') {
                    nuitBricks = Object.values(nuitBricks);
                }

                if (jourBricks && Array.isArray(jourBricks)) {
                    // Ajouter les couleurs aux briques traduites du jour
                    const jourColors = ['#FFB6C1', '#87CEEB', '#DDA0DD', '#98FB98', '#FFCCCB', '#F0E68C', '#E6E6FA', '#FFDAB9', '#AFEEEE', '#F5DEB3', '#FFE4E1', '#E0FFFF', '#FFF8DC', '#F0FFF0', '#F5F5DC', '#FFFACD', '#FFE4B5', '#FFF0F5', '#F0F8FF'];
                    
                    JOUR = jourBricks.map((brick, index) => ({
                        nom: brick.name || brick.nom,
                        couleur: jourColors[index] || '#FFE4E1',
                        msg: brick.msg
                    }));

                    console.log(`üåç ${jourBricks.length} briques JOUR charg√©es en ${currentLang}`);
                } else {
                    console.warn('‚ö†Ô∏è Briques JOUR non trouv√©es dans les traductions, utilisation du fran√ßais');
                    initializeFrenchBricks();
                    return;
                }

                if (nuitBricks && Array.isArray(nuitBricks)) {
                    // Ajouter les couleurs aux briques traduites de la nuit
                    const nuitColors = ['#8B0000', '#4B0000', '#2F1B14', '#36454F', '#2F2F2F', '#654321', '#654321', '#483C32', '#2E4B2E', '#191970'];
                    
                    NUIT = nuitBricks.map((brick, index) => ({
                        nom: brick.name || brick.nom,
                        couleur: nuitColors[index] || '#2F2F2F',
                        msg: brick.msg
                    }));

                    console.log(`üåç ${nuitBricks.length} briques NUIT charg√©es en ${currentLang}`);
                } else {
                    console.warn('‚ö†Ô∏è Briques NUIT non trouv√©es dans les traductions, utilisation du fran√ßais pour NUIT');
                    // Utiliser la version fran√ßaise pour NUIT si pas trouv√©e
                    NUIT = [
                        { nom: 'DISCORDES', couleur: '#8B0000', msg: '‚ö° Des discordes... des haines... des destructions...' },
                        { nom: 'HAINES', couleur: '#4B0000', msg: 'üíî Venues avec les maux de l\'ombre...' },
                        { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: 'üå™Ô∏è Le vol, le mensonge, la manipulation...' },
                        { nom: 'VOL', couleur: '#36454F', msg: 'ü¶π Qui s\'empare de ce qui n\'appartient pas...' },
                        { nom: 'MENSONGE', couleur: '#2F2F2F', msg: 'üé≠ Les masques de la tromperie...' },
                        { nom: 'MANIPULATION', couleur: '#654321', msg: 'üï∑Ô∏è Les fils invisibles tirent les c≈ìurs...' },
                        { nom: 'CUPIDIT√â', couleur: '#654321', msg: 'üí∞ La cupidit√© et l\'avidit√©...' },
                        { nom: 'AVIDIT√â', couleur: '#483C32', msg: '‚õìÔ∏è Comme des cha√Ænes invisibles...' },
                        { nom: 'CHA√éNES', couleur: '#2E4B2E', msg: 'üîó Serrant le c≈ìur des hommes...' },
                        { nom: 'MURS DE FER', couleur: '#191970', msg: 'üß± Enferm√©s derri√®re des murs de fer et de peur...' }
                    ];
                }

                // Initialiser VOYAGE avec JOUR
                VOYAGE = JOUR;
                window.brickArraysInitialized = true;
                console.log(`üåç Briques initialis√©es en ${currentLang} avec succ√®s !`);

            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation des briques traduites:', error);
                initializeFrenchBricks();
            }
        }

        // ===============================================
        // FONCTION HELPER POUR TRADUCTIONS AVEC FALLBACK FRAN√áAIS
        // ===============================================
        
        // üåç Cache des traductions pour √©viter les appels r√©p√©titifs (boucle infinie 60fps)
        const translationCache = new Map();
        
        /**
         * üåç SYST√àME DE TRADUCTION UNIFI√â - G√®re fran√ßais int√©gr√© + JSON externes
         * @param {string} key - Cl√© de traduction (ex: 'interface.tabs.enigmas')  
         * @param {string} [frenchText] - Texte fran√ßais optionnel (si absent, utilise une base fran√ßaise)
         * @returns {string} - Texte traduit ou fran√ßais
         */
        /**
         * üåç Fonction de traduction compatible avec i18n.js
         * Utilise window.i18n.t() pour la coh√©rence avec data-i18n
         */
        function getTranslatedText(key, frenchText = null) {
            // Si i18n n'est pas charg√©, retourner le fallback fran√ßais
            if (!window.i18n) {
                return frenchText || key;
            }

            const currentLang = window.i18n.getCurrentLanguage();
            const cacheKey = `${currentLang}:${key}`;
            
            // ‚ö° CACHE HIT - √©vite les recalculs pour 60fps
            if (translationCache.has(cacheKey)) {
                const cached = translationCache.get(cacheKey);
                return cached;
            }
            
            // Utiliser i18n.t() pour obtenir la traduction
            const translation = window.i18n.t(key);
            
            // Si traduction trouv√©e (i18n.t retourne la cl√© si pas de traduction)
            if (translation && translation !== key) {
                translationCache.set(cacheKey, translation);
                return translation;
            }
            
            // Si pas de traduction, utiliser le fallback fran√ßais
            const fallback = frenchText || key;
            translationCache.set(cacheKey, fallback);
            return fallback;
        }
        
        // üåç Fonction pour vider le cache lors du changement de langue
        function clearTranslationCache() {
            const cacheSize = translationCache.size;
            translationCache.clear();
            console.log(`üóëÔ∏è Cache des traductions vid√© (${cacheSize} entr√©es supprim√©es)`);
        }
        
        // Exposer globalement pour le s√©lecteur de langue
        window.clearTranslationCache = clearTranslationCache;

        // Voyage actuel selon la p√©riode
        let VOYAGE = [];

        // ===============================================
        // SYST√àME D'√âNIGMES COLLECTIBLES
        // ===============================================

        // Base de donn√©es des √©nigmes avec informations modulaires
        const ENIGMES_DATABASE = {
            humanite: {
                id: 'humanite',
                nom: () => getTranslatedText('enigmes.humanity.name', 'Humanit√©'),
                icone: 'ü§ù',
                description: () => getTranslatedText('enigmes.humanity.description', 'La force qui unit tous les c≈ìurs'),
                mystere: () => getTranslatedText('enigmes.humanity.mystery', 'Qu\'est-ce qui nous rend v√©ritablement humains ?'),
                revelation: () => getTranslatedText('enigmes.humanity.revelation', 'L\'humanit√© r√©side dans notre capacit√© √† ressentir de la compassion pour autrui, m√™me pour ceux qui nous sont diff√©rents.'),
                sagesse: () => getTranslatedText('enigmes.humanity.wisdom', 'Un p√®re, une m√®re, des enfants... Tous cherchant simplement √† vivre leur meilleure vie, comme nous.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            mur_peur: {
                id: 'mur_peur',
                nom: () => getTranslatedText('enigmes.wall_of_fear.name', 'Mur de Peur'),
                icone: 'üè∞',
                description: () => getTranslatedText('enigmes.wall_of_fear.description', 'L\'origine ancestrale de nos fronti√®res'),
                mystere: () => getTranslatedText('enigmes.wall_of_fear.mystery', 'Pourquoi ces vieux r√©flexes animaux demeurent-ils ?'),
                revelation: () => getTranslatedText('enigmes.wall_of_fear.revelation', 'Le mur et nos fronti√®res viennent de la peur et de la folie pass√©e de guerre de territoire, ou la peur de perdre du terrain, d\'√™tre envahi par des ennemis. Les forteresses √©taient alors logiques et obligatoires pour se prot√©ger, et √ßa depuis les grottes pr√©historiques simplement pour se prot√©ger des animaux. Mais aujourd\'hui pourquoi ces murs perdurent-ils ?'),
                sagesse: () => getTranslatedText('enigmes.wall_of_fear.wisdom', 'De la grotte pr√©historique au mur moderne, la peur ancestrale persiste. Mais sommes-nous toujours des animaux apeur√©s, ou pouvons-nous devenir humains ?'),
                collecte: false,
                phaseRequise: 16
            },
            paix: {
                id: 'paix',
                nom: () => getTranslatedText('enigmes.peace.name', 'Paix'),
                icone: 'üïäÔ∏è',
                description: () => getTranslatedText('enigmes.peace.description', 'L\'harmonie qui transcende les conflits'),
                mystere: () => getTranslatedText('enigmes.peace.mystery', 'Comment trouve-t-on la paix dans un monde de chaos ?'),
                revelation: () => getTranslatedText('enigmes.peace.revelation', 'La paix na√Æt lorsque nous choisissons d\'aimer plut√¥t que de ha√Ør, de comprendre plut√¥t que de juger.'),
                sagesse: () => getTranslatedText('enigmes.peace.wisdom', 'Au-del√† des nuages, il existe toujours une lumi√®re. Mais pour la voir, il faut d\'abord traverser la nuit.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            diversite: {
                id: 'diversite',
                nom: () => getTranslatedText('enigmes.diversity.name', 'Diversit√©'),
                icone: 'üåà',
                description: () => getTranslatedText('enigmes.diversity.description', 'La beaut√© de nos diff√©rences'),
                mystere: () => getTranslatedText('enigmes.diversity.mystery', 'Pourquoi craignons-nous ce qui est diff√©rent ?'),
                revelation: () => getTranslatedText('enigmes.diversity.revelation', 'La diversit√© est la richesse du monde. Chaque couleur, chaque culture apporte sa propre beaut√© √† l\'arc-en-ciel humain.'),
                sagesse: () => getTranslatedText('enigmes.diversity.wisdom', 'On m\'a dit tant de mal sur eux... Mais j\'ai pr√©f√©r√© aller voir de mes propres yeux.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            liberte: {
                id: 'liberte',
                nom: () => getTranslatedText('enigmes.freedom.name', 'Libert√©'),
                icone: 'üóΩ',
                description: () => getTranslatedText('enigmes.freedom.description', 'Le droit de vivre sans cha√Ænes'),
                mystere: () => getTranslatedText('enigmes.freedom.mystery', 'Qu\'est-ce que la vraie libert√© ?'),
                revelation: () => getTranslatedText('enigmes.freedom.revelation', 'La libert√© n\'est pas l\'absence de contraintes, mais la capacit√© de choisir l\'amour malgr√© la peur.'),
                sagesse: () => getTranslatedText('enigmes.freedom.wisdom', 'La cupidit√© et l\'avidit√©, comme des cha√Ænes invisibles, serrent le c≈ìur des hommes.'),
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            foi: {
                id: 'foi',
                nom: () => getTranslatedText('enigmes.faith.name', 'Foi'),
                icone: 'üôè',
                description: () => getTranslatedText('enigmes.faith.description', 'L\'espoir qui guide dans l\'obscurit√©'),
                mystere: () => getTranslatedText('enigmes.faith.mystery', 'Comment garder foi quand tout semble perdu ?'),
                revelation: () => getTranslatedText('enigmes.faith.revelation', 'Vouloir la libert√©, c\'est aussi l\'accorder aux autres. La libert√© nous sera alors √† tous b√©n√©fique et porteuse de paix.'),
                sagesse: () => getTranslatedText('enigmes.faith.wisdom', 'La foi n\'est pas l\'absence de doute, mais la d√©cision de continuer malgr√© l\'incertitude, en accordant aux autres ce que nous d√©sirons pour nous-m√™mes.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            respect: {
                id: 'respect',
                nom: () => getTranslatedText('enigmes.respect.name', 'Respect'),
                icone: 'ü§≤',
                description: () => getTranslatedText('enigmes.respect.description', 'La dignit√© accord√©e √† chaque √™tre'),
                mystere: () => getTranslatedText('enigmes.respect.mystery', 'Comment respecter ceux que nous ne comprenons pas ?'),
                revelation: () => getTranslatedText('enigmes.respect.revelation', 'Le respect na√Æt de la reconnaissance que chaque √™tre porte en lui une √©tincelle divine.'),
                sagesse: () => getTranslatedText('enigmes.respect.wisdom', 'Ils s\'enfermaient derri√®re des murs de fer et de peur... Mais l\'humanit√© existait encore.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            entraide: {
                id: 'entraide',
                nom: () => getTranslatedText('enigmes.mutual_aid.name', 'Entraide'),
                icone: 'üíû',
                description: () => getTranslatedText('enigmes.mutual_aid.description', 'La force de l\'union solidaire'),
                mystere: () => getTranslatedText('enigmes.mutual_aid.mystery', 'Pourquoi aider ceux qui ne peuvent rien nous donner ?'),
                revelation: () => getTranslatedText('enigmes.mutual_aid.revelation', 'Dans l\'entraide, nous d√©couvrons que donner nous enrichit plus que recevoir.'),
                sagesse: () => getTranslatedText('enigmes.mutual_aid.wisdom', 'L\'amour, plus fort que toutes les barri√®res, unit au-del√† des diff√©rences.'),
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            hopital: {
                id: 'hopital',
                nom: () => getTranslatedText('enigmes.healing.name', 'Gu√©rison'),
                icone: 'üè•',
                description: () => getTranslatedText('enigmes.healing.description', 'Le pouvoir de soigner les blessures'),
                mystere: () => getTranslatedText('enigmes.healing.mystery', 'Comment gu√©rit-on les blessures invisibles ?'),
                revelation: () => getTranslatedText('enigmes.healing.revelation', 'La v√©ritable gu√©rison commence par l\'acceptation et se poursuit par le pardon.'),
                sagesse: () => getTranslatedText('enigmes.healing.wisdom', 'Si la temp√™te gronde, c\'est pour rappeler qu\'au-del√† des nuages, il existe toujours une lumi√®re.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            restauration: {
                id: 'restauration',
                nom: () => getTranslatedText('enigmes.restoration.name', 'Restauration'),
                icone: 'üå±',
                description: () => getTranslatedText('enigmes.restoration.description', 'Le renouveau apr√®s la destruction'),
                mystere: () => getTranslatedText('enigmes.restoration.mystery', 'Comment reb√¢tir apr√®s la d√©vastation ?'),
                revelation: () => getTranslatedText('enigmes.restoration.revelation', 'Chaque fin contient en elle les graines d\'un nouveau commencement.'),
                sagesse: () => getTranslatedText('enigmes.restoration.wisdom', 'Une lumi√®re dans l\'obscurit√©... L\'espoir possible quand on choisit d\'aimer.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            avarice: {
                id: 'avarice',
                nom: () => getTranslatedText('enigmes.avarice.name', 'Avarice'),
                icone: 'üí∞',
                description: () => getTranslatedText('enigmes.avarice.description', 'Le mur de la cupidit√©'),
                mystere: () => getTranslatedText('enigmes.avarice.mystery', 'Qu\'est-ce qui dresse des murs entre les hommes ?'),
                revelation: () => getTranslatedText('enigmes.avarice.revelation', 'L\'avarice b√¢tit des murs l√† o√π l\'amour construirait des ponts.'),
                sagesse: () => getTranslatedText('enigmes.avarice.wisdom', 'Un mur dress√© dans la mer comme une cicatrice... Un mur qui n\'est pas fait de pierres, mais de lois, de papiers et de regards ferm√©s.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            mur_liberte: {
                id: 'mur_liberte',
                nom: () => getTranslatedText('enigmes.prison_freedom.name', 'Prison de Libert√©'),
                icone: '‚õìÔ∏è',
                description: () => getTranslatedText('enigmes.prison_freedom.description', 'Les cha√Ænes invisibles'),
                mystere: () => getTranslatedText('enigmes.prison_freedom.mystery', 'Qui m√©rite d\'√™tre libre ?'),
                revelation: () => getTranslatedText('enigmes.prison_freedom.revelation', 'La libert√© n\'est pas un privil√®ge √† distribuer, mais un droit universel √† honorer.'),
                sagesse: () => getTranslatedText('enigmes.prison_freedom.wisdom', 'Ce mur est la prison de la libert√© des hommes. Il s√©pare ceux qui peuvent courir sans cha√Ænes, et ceux qu\'on enferme dans des fronti√®res invisibles.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            refus: {
                id: 'refus',
                nom: () => getTranslatedText('enigmes.refusal.name', 'Refus'),
                icone: 'üö´',
                description: () => getTranslatedText('enigmes.refusal.description', 'Les barbel√©s du rejet'),
                mystere: () => getTranslatedText('enigmes.refusal.mystery', 'Pourquoi fermons-nous nos portes ?'),
                revelation: () => getTranslatedText('enigmes.refusal.revelation', 'Chaque refus est une blessure inflig√©e √† l\'humanit√© que nous partageons tous.'),
                sagesse: () => getTranslatedText('enigmes.refusal.wisdom', 'Des barbel√©s de fer et de peur... forg√©s par ceux qui ont oubli√© qu\'eux aussi furent un jour des voyageurs.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            privilege: {
                id: 'privilege',
                nom: () => getTranslatedText('enigmes.pride.name', 'Orgueil'),
                icone: 'üëë',
                description: () => getTranslatedText('enigmes.pride.description', 'L\'ego qui d√©forme notre regard'),
                mystere: () => getTranslatedText('enigmes.pride.mystery', 'Pourquoi voyons-nous les autres comme inf√©rieurs ?'),
                revelation: () => getTranslatedText('enigmes.pride.revelation', 'L\'orgueil et l\'ego nous font voir les gens plus petits ou pauvres diff√©remment, mais nous sommes tous √©gaux en humanit√©.'),
                sagesse: () => getTranslatedText('enigmes.pride.wisdom', 'Une porte dor√©e qui ne s\'ouvre que pour quelques-uns... Notre ego nous fait croire que nous la m√©ritons, et que les autres ne la m√©ritent pas.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            inegalites: {
                id: 'inegalites',
                nom: () => getTranslatedText('enigmes.inequality.name', 'In√©galit√©s'),
                icone: '‚öñÔ∏è',
                description: () => getTranslatedText('enigmes.inequality.description', 'La pyramide des destins'),
                mystere: () => getTranslatedText('enigmes.inequality.mystery', 'Pourquoi certains portent-ils le fardeau des autres ?'),
                revelation: () => getTranslatedText('enigmes.inequality.revelation', 'Les in√©galit√©s ne sont pas une fatalit√©, mais un syst√®me que nous perp√©tuons en silence.'),
                sagesse: () => getTranslatedText('enigmes.inequality.wisdom', 'Une pyramide de destins empil√©s... Ceux d\'en bas portent le poids de ceux d\'en haut, et nul ne demande si c\'est juste.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            espoir_mur: {
                id: 'espoir_mur',
                nom: () => getTranslatedText('enigmes.hope.name', 'Espoir'),
                icone: 'üåä',
                description: () => getTranslatedText('enigmes.hope.description', 'La libert√© qui ne peut √™tre enferm√©e'),
                mystere: () => getTranslatedText('enigmes.hope.mystery', 'Peut-on vraiment emprisonner la libert√© ?'),
                revelation: () => getTranslatedText('enigmes.hope.revelation', 'Que l\'espoir remplisse vos c≈ìurs, gardez avec pers√©v√©rance le cap, laissez le vent de Dieu vous pousser, et ne craignez pas l\'impossible.'),
                sagesse: () => getTranslatedText('enigmes.hope.wisdom', 'Dans le c≈ìur des vagues, la mer murmure une v√©rit√© : aucun mur n\'est √©ternel. Car l\'eau finit toujours par user la pierre, et la libert√©, t√¥t ou tard, reprendra son chemin.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            ange: {
                id: 'ange',
                nom: () => getTranslatedText('enigmes.lighthouse.name', 'Le Phare dans la Nuit'),
                icone: 'üóº',
                description: () => getTranslatedText('enigmes.lighthouse.description', 'La lumi√®re guide ceux qui sont perdus'),
                mystere: () => getTranslatedText('enigmes.lighthouse.mystery', 'Comment trouver son chemin dans l\'obscurit√© ?'),
                revelation: () => getTranslatedText('enigmes.lighthouse.revelation', 'La lumi√®re est plus forte que la nuit. M√™me une petite flamme peut dissiper les t√©n√®bres les plus profondes.'),
                sagesse: () => getTranslatedText('enigmes.lighthouse.wisdom', 'Dans les moments les plus sombres, soyez la lumi√®re que vous cherchez. La compassion √©claire m√™me les c≈ìurs les plus obscurcis.'),
                collecte: false,
                phaseRequise: 'lanterne'
            },
            lampe: {
                id: 'lampe',
                nom: () => getTranslatedText('enigmes.lamp.name', 'La Lampe Remplie d\'Huile'),
                icone: 'ü™î',
                description: () => getTranslatedText('enigmes.lamp.description', 'L\'amour qui √©claire nos ≈ìuvres'),
                mystere: () => getTranslatedText('enigmes.lamp.mystery', 'Quelle est la source de notre lumi√®re int√©rieure ?'),
                revelation: () => getTranslatedText('enigmes.lamp.revelation', 'L\'amour √©claire nos ≈ìuvres. Sans amour, on est l\'ombre de rien.'),
                sagesse: () => getTranslatedText('enigmes.lamp.wisdom', 'Nos actions ne prennent sens que lorsqu\'elles sont guid√©es par l\'amour. C\'est lui qui transforme le vide en pl√©nitude, l\'ombre en lumi√®re.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            coeur_final: {
                id: 'coeur_final',
                nom: () => getTranslatedText('enigmes.heart.name', 'Le C≈ìur de l\'Humanit√©'),
                icone: '‚ù§Ô∏è',
                description: () => getTranslatedText('enigmes.heart.description', 'L\'essence m√™me de notre humanit√© partag√©e'),
                mystere: () => getTranslatedText('enigmes.heart.mystery', 'Qu\'est-ce qui nous unit tous par-del√† nos diff√©rences ?'),
                revelation: () => getTranslatedText('enigmes.heart.revelation', 'Au c≈ìur de chaque √™tre humain bat le m√™me amour, les m√™mes espoirs, les m√™mes peurs. Nous sommes un.'),
                sagesse: () => getTranslatedText('enigmes.heart.wisdom', 'Le voyage s\'ach√®ve l√† o√π il a commenc√© : dans le c≈ìur. C\'est en reconnaissant notre humanit√© commune que nous trouvons la v√©ritable paix.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_humanite: {
                id: 'mur_humanite',
                nom: () => getTranslatedText('enigmes.humanity_no_borders.name', 'Humanit√© Sans Fronti√®res'),
                icone: 'üåç',
                description: () => getTranslatedText('enigmes.humanity_no_borders.description', 'L\'humanit√© au-del√† des murs'),
                mystere: () => getTranslatedText('enigmes.humanity_no_borders.mystery', 'Les fronti√®res d√©finissent-elles qui nous sommes ?'),
                revelation: () => getTranslatedText('enigmes.humanity_no_borders.revelation', 'L\'humanit√© ne conna√Æt pas de fronti√®res. Nous sommes tous des voyageurs sur la m√™me terre.'),
                sagesse: () => getTranslatedText('enigmes.humanity_no_borders.wisdom', 'Un p√®re, une m√®re, des enfants... cherchant simplement √† vivre, comme nous tous.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_maison: {
                id: 'mur_maison',
                nom: () => getTranslatedText('enigmes.right_to_happiness.name', 'Droit au Bonheur'),
                icone: 'üè†',
                description: () => getTranslatedText('enigmes.right_to_happiness.description', 'Un toit pour chaque famille'),
                mystere: () => getTranslatedText('enigmes.right_to_happiness.mystery', 'Qui m√©rite un abri et le bonheur ?'),
                revelation: () => getTranslatedText('enigmes.right_to_happiness.revelation', 'Chacun a droit au bonheur, un abris, un toit. Construisons des maisons et des ponts avec des murs utiles, des murs d\'amour pour des familles qui en ont besoin.'),
                sagesse: () => getTranslatedText('enigmes.right_to_happiness.wisdom', 'Les murs ne doivent pas s√©parer, mais prot√©ger. Les ponts ne doivent pas diviser, mais unir.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_vie: {
                id: 'mur_vie',
                nom: () => getTranslatedText('enigmes.precious_life.name', 'Vie Pr√©cieuse'),
                icone: 'üíö',
                description: () => getTranslatedText('enigmes.precious_life.description', 'La valeur de chaque existence'),
                mystere: () => getTranslatedText('enigmes.precious_life.mystery', 'Toutes les vies ont-elles la m√™me valeur ?'),
                revelation: () => getTranslatedText('enigmes.precious_life.revelation', 'Chaque vie est pr√©cieuse, qu\'elle soit n√©e ici ou ailleurs.'),
                sagesse: () => getTranslatedText('enigmes.precious_life.wisdom', 'La vie ne se mesure pas √† son origine, mais √† son essence.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            communautarisme: {
                id: 'communautarisme',
                nom: () => getTranslatedText('enigmes.communitarianism.name', 'Communautarisme'),
                icone: '‚öîÔ∏è',
                description: () => getTranslatedText('enigmes.communitarianism.description', 'Les dangers du sectarisme'),
                mystere: () => getTranslatedText('enigmes.communitarianism.mystery', 'Pourquoi nos divisions nous affaiblissent-elles ?'),
                revelation: () => getTranslatedText('enigmes.communitarianism.revelation', 'Important socialement mais dangereux dans les d√©rives de dictature. On retrouve le communautarisme un peu partout, de la politique et ses divisions, des religions aux sectes ath√©istes. Chacun m√®ne son combat, le combat de l\'homme avec sa vision, son c≈ìur. La communaut√© c\'est bien, mais d√©truire les id√©es des autres, sans tol√©rance et respect, n\'aide pas l\'humanit√© √† progresser.'),
                sagesse: () => getTranslatedText('enigmes.communitarianism.wisdom', 'Notre sectarisme politique et religieux d√©truit les ponts, d√©truit la paix. Il nous faut cet √©lan de porter √† bien le projet des autres, aider √† la r√©ussite, consolider et pas d√©truire h√¢tivement les id√©es des autres. Sans tol√©rance, point de progr√®s.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            }
        };

        // Gestionnaire de collection d'√©nigmes (version simplifi√©e pour canvas)
        class EnigmaCollector {
            constructor() {
                this.enigmesCollectees = new Set();
                this.chargerProgression();
            }

            // Charger la progression depuis localStorage
            chargerProgression() {
                const saved = localStorage.getItem('vdv_enigmes_collectees');
                if (saved) {
                    this.enigmesCollectees = new Set(JSON.parse(saved));
                }
            }

            // Sauvegarder la progression
            sauvegarderProgression() {
                localStorage.setItem('vdv_enigmes_collectees',
                    JSON.stringify([...this.enigmesCollectees]));
            }

            // V√©rifier si une √©nigme peut √™tre collect√©e
            peutCollecterEnigme(enigmeId) {
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) return false;

                // L'ange est collect√© uniquement via la chauve-souris (pas automatiquement)
                if (enigmeId === 'ange') return false;

                // V√©rifier si la phase actuelle correspond
                return phaseJeu === enigme.phaseRequise ||
                       (phaseJeu === 'petits_coeurs' && enigme.phaseRequise === 'coeurs');
            }

            // Collecter une √©nigme pendant le voyage
            collecterEnigme(enigmeId, forceCollection = false) {
                //
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) {
                    //
                    return false;
                }
                if (this.enigmesCollectees.has(enigmeId)) {
                    //
                    return false;
                }

                const peutCollecter = this.peutCollecterEnigme(enigmeId);
                //console.log(`üîç peutCollecterEnigme(${enigmeId}): ${peutCollecter}, phaseJeu: ${phaseJeu}, phaseRequise: ${enigme.phaseRequise}`);

                // Permettre la collection forc√©e (pour les √©nigmes sp√©ciales comme l'ange)
                if (forceCollection || peutCollecter) {
                    //
                    this.enigmesCollectees.add(enigmeId);
                    this.sauvegarderProgression();
                    this.afficherNotificationCollection(enigme);
                    //
                    return true;
                }
                //
                return false;
            }

            // Afficher notification de collection
            afficherNotificationCollection(enigme) {
                // D√©sactiver les notifications en phase 23
                const isPhase23 = narrationManager && narrationManager.currentPhase === 23;
                if (isPhase23) {
                    return; // Ne pas afficher de notification en phase 23
                }

                // Cr√©er une notification simple et discr√®te
                const notification = document.createElement('div');

                // Position sp√©ciale en phase 16 : en bas du bouton Continuer
                const isPhase16 = narrationManager && narrationManager.currentPhase === 16;
                const topPosition = isPhase16 ? '70%' : '80px'; // 70% pour phase 16, 80px sinon

                notification.style.cssText = `
                    position: fixed;
                    top: ${topPosition};
                    left: 50%;
                    transform: translateX(-50%);
                    background: transparent;
                    color: #ffffff;
                    padding: 8px 15px;
                    font-size: 16px;
                    font-weight: normal;
                    z-index: 10000;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
                    animation: enigmaNotif 3s ease forwards;
                `;
                notification.innerHTML = `${enigme.icone} ${typeof enigme.nom === 'function' ? enigme.nom() : enigme.nom}`;

                // Ajouter les keyframes CSS si pas d√©j√† pr√©sents
                if (!document.querySelector('#enigma-notif-style')) {
                    const style = document.createElement('style');
                    style.id = 'enigma-notif-style';
                    style.textContent = `
                        @keyframes enigmaNotif {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                            20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }

            // V√©rifier et collecter automatiquement selon la phase
            verifierCollectionAutomatique() {
                // Mapper les phases aux √©nigmes
                const phaseEnigmeMap = {
                    'coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'petits_coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'briques': ['paix', 'foi', 'hopital'],
                    'nuit_coeurs': ['liberte', 'entraide']
                };

                const enigmesPourPhase = phaseEnigmeMap[phaseJeu] || [];

                // Collecter automatiquement une √©nigme al√©atoire pour cette phase
                const enigmesNonCollectees = enigmesPourPhase.filter(id => !this.enigmesCollectees.has(id));

                if (enigmesNonCollectees.length > 0) {
                    const enigmeAleatoire = enigmesNonCollectees[Math.floor(Math.random() * enigmesNonCollectees.length)];

                    // Chance de 30% de collecter l'√©nigme pendant cette phase
                    if (Math.random() < 0.3) {
                        setTimeout(() => {
                            this.collecterEnigme(enigmeAleatoire);
                        }, Math.random() * 5000 + 2000); // Entre 2 et 7 secondes
                    }
                }
            }
        }

        // Initialiser le syst√®me d'√©nigmes
        const enigmaCollector = new EnigmaCollector();

        // ===============================================
        // SYST√àME CHAUVE-SOURIS & ANGE GARDIEN
        // ===============================================

        // R√©v√©ler la chauve-souris quand la lanterne touche les oiseaux
        function revelerChauveSouris(x, y) {
            if(chauveSouris.revelee) return; // D√©j√† r√©v√©l√©e

            chauveSouris.revelee = true;
            chauveSouris.active = true;
            chauveSouris.x = x;
            chauveSouris.y = y;
            chauveSouris.vx = (Math.random() - 0.5) * 2; // Mouvement erratique
            chauveSouris.vy = -1 - Math.random(); // Monte vers le haut
            chauveSouris.tempApparition = Date.now();
            chauveSouris.collectee = false;

            // Plus de message d'apparition - seulement √† la collection
        }

        // Mettre √† jour la chauve-souris
        function mettreAJourChauveSouris() {
            if(!chauveSouris.active) return;

            const tempsEcoule = Date.now() - chauveSouris.tempApparition;

            // Animation de vol erratique
            chauveSouris.x += chauveSouris.vx;
            chauveSouris.y += chauveSouris.vy;

            // Mouvement en zigzag
            chauveSouris.vx += (Math.random() - 0.5) * 0.2;
            chauveSouris.vy += Math.sin(Date.now() * 0.01) * 0.1;

            // Limiter la vitesse
            chauveSouris.vx = Math.max(-3, Math.min(3, chauveSouris.vx));
            chauveSouris.vy = Math.max(-2, Math.min(1, chauveSouris.vy));

            // V√©rifier collision avec la lanterne pour collecter
            if(!chauveSouris.collectee && balle.visible) {
                const distanceX = Math.abs(chauveSouris.x - balle.x);
                const distanceY = Math.abs(chauveSouris.y - balle.y);
                const distanceCollision = 50;

                if(distanceX < distanceCollision && distanceY < distanceCollision) {
                    collecterChauveSouris();
                }
            }

            // Faire dispara√Ætre apr√®s la dur√©e de vie ou si elle sort de l'√©cran
            if(tempsEcoule > chauveSouris.dureeVie ||
               chauveSouris.x < -100 || chauveSouris.x > C.W + 100 ||
               chauveSouris.y < -100 || chauveSouris.y > C.H + 100) {
                chauveSouris.active = false;
            }
        }

        // Collecter la chauve-souris
        function collecterChauveSouris() {
            if(chauveSouris.collectee) return;

            chauveSouris.collectee = true;
            chauveSouris.active = false;

            // Ajouter 1000 XP
            score += 1000;
            window.score = score; // Synchroniser avec le score global

            // Collecter l'ic√¥ne d'ange (collection forc√©e)
            if(enigmaCollector) {
                enigmaCollector.collecterEnigme('ange', true);
            }

            // Effet visuel spectaculaire
            for(let i = 0; i < 20; i++) {
                particules.push({
                    x: chauveSouris.x,
                    y: chauveSouris.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur: '#FFD700',
                    vie: Math.random() * 20 + 30, // 30-50 frames
                    taille: Math.random() * 6 + 4,
                    type: 'etoile'
                });
            }

            // Message de collection
            afficherMessageNarratifSimple(getTranslatedText('powerups.light_chases_night', 'üí° La lumi√®re chasse la nuit\n+1000 XP'), 4000);
        }

        // Dessiner la chauve-souris
        function dessinerChauveSouris() {
            if(!chauveSouris.active) return;

            ctx.save();
            ctx.translate(chauveSouris.x, chauveSouris.y);

            // Animation de battement d'ailes plus lente et fluide
            const battement = Math.sin(Date.now() * 0.008) * 0.2;
            ctx.rotate(battement);

            // Corps de la chauve-souris
            ctx.fillStyle = '#2C1810';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ailes
            ctx.fillStyle = '#1A0F08';
            ctx.beginPath();
            // Aile gauche
            ctx.ellipse(-12, -5, 10, 8, -0.5, 0, Math.PI * 2);
            // Aile droite
            ctx.ellipse(12, -5, 10, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Yeux rouges
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(-3, -3, 2, 0, Math.PI * 2);
            ctx.arc(3, -3, 2, 0, Math.PI * 2);
            ctx.fill();

            // Lueur dor√©e si proche de la collection
            if(!chauveSouris.collectee && balle.visible) {
                const distance = Math.sqrt(
                    Math.pow(chauveSouris.x - balle.x, 2) +
                    Math.pow(chauveSouris.y - balle.y, 2)
                );

                if(distance < 80) {
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ===============================================
        // ANIMATION IC√îNE VERS MENU √âNIGMES
        // ===============================================

        // D√©clencher l'animation de l'ic√¥ne vers le bouton du menu
        function lancerAnimationIconeVersMenu(icone) {
            if (animationIconeMenu.active) return; // √âviter les doublons

            // Position de d√©part (centre de l'ic√¥ne th√©matique)
            animationIconeMenu.startX = C.W / 2;
            animationIconeMenu.startY = C.H * 0.30;

            // Position cible (bouton menu √©nigmes - plus bas √† droite)
            animationIconeMenu.targetX = C.W - 65; // Position du bouton menu
            animationIconeMenu.targetY = 105; // Plus bas pour correspondre au bouton (80 + 25)

            // Initialiser l'animation
            animationIconeMenu.currentX = animationIconeMenu.startX;
            animationIconeMenu.currentY = animationIconeMenu.startY;
            animationIconeMenu.progress = 0;
            animationIconeMenu.startTime = Date.now();
            animationIconeMenu.icone = icone;
            animationIconeMenu.active = true;
        }

        // Mettre √† jour l'animation de l'ic√¥ne
        function mettreAJourAnimationIconeMenu() {
            if (!animationIconeMenu.active) return;

            const tempsEcoule = Date.now() - animationIconeMenu.startTime;
            const progression = Math.min(tempsEcoule / animationIconeMenu.duree, 1);

            // Appliquer l'easing
            const easedProgress = animationIconeMenu.easing(progression);

            // Calculer la position courante
            animationIconeMenu.currentX = animationIconeMenu.startX +
                (animationIconeMenu.targetX - animationIconeMenu.startX) * easedProgress;

            animationIconeMenu.currentY = animationIconeMenu.startY +
                (animationIconeMenu.targetY - animationIconeMenu.startY) * easedProgress;

            // Ajouter un arc parabolique pour plus de fluidit√©
            const arcHeight = 50;
            const arcY = Math.sin(progression * Math.PI) * arcHeight;
            animationIconeMenu.currentY -= arcY;

            // Terminer l'animation
            if (progression >= 1) {
                animationIconeMenu.active = false;

                // Effet visuel au moment de l'arriv√©e
                for(let i = 0; i < 10; i++) {
                    particules.push({
                        x: animationIconeMenu.targetX,
                        y: animationIconeMenu.targetY,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        couleur: '#64ffda',
                        vie: Math.random() * 25 + 35, // 35-60 frames
                        taille: Math.random() * 4 + 2,
                        type: 'rond'
                    });
                }
            }
        }

        // Dessiner l'ic√¥ne en animation
        function dessinerIconeEnAnimation() {
            if (!animationIconeMenu.active) return;

            ctx.save();
            ctx.translate(animationIconeMenu.currentX, animationIconeMenu.currentY);

            // Effet de rotation pendant le vol
            const rotation = (Date.now() - animationIconeMenu.startTime) * 0.01;
            ctx.rotate(rotation);

            // Taille qui grandit l√©g√®rement pendant le vol
            const scale = 1 + Math.sin(animationIconeMenu.progress * Math.PI) * 0.3;
            ctx.scale(scale, scale);

            // Dessiner l'ic√¥ne avec effet lumineux
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Lueur dor√©e
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#FFD700';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            // Deuxi√®me couche plus claire
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            ctx.restore();
        }

        // ===============================================
        // BOUTON MENU √âNIGMES DANS LE CANVAS
        // ===============================================

        // Bouton menu HOME supprim√©

        // Objet bouton menu √©nigmes
        let boutonMenuEnigmes = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            hover: false
        };

        // Objet bouton plein √©cran
        let boutonPleinEcran = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            hover: false,
            isFullscreen: false
        };

        // √âtat du menu √©nigmes dans le canvas
        let menuEnigmesCanvas = {
            visible: false,
            animation: 0, // 0 = ferm√©, 1 = ouvert
            animationStartTime: 0,
            animationDuration: 300,
            scrollY: 0,
            maxScrollY: 0,
            enigmaCards: [], // Position des cartes pour les clics
            closeButton: { x: 0, y: 0, width: 40, height: 40, hover: false },
            hoveredCard: null, // Carte actuellement survol√©e
            topIcons: [], // Positions des ic√¥nes en haut pour les clics
            centralIcon: { x: 0, y: 0, width: 60, height: 60, hover: false }, // Zone cliquable de l'ic√¥ne centrale
            expandedCard: null, // ID de la carte actuellement d√©pli√©e (syst√®me de liste d√©roulante)
            ongletActif: 'enigmes', // 'enigmes', 'classement', 'langues' ou 'info'
            onglets: {
                enigmes: { x: 0, y: 0, width: 0, height: 0, hover: false },
                classement: { x: 0, y: 0, width: 0, height: 0, hover: false },
                langues: { x: 0, y: 0, width: 0, height: 0, hover: false },
                info: { x: 0, y: 0, width: 0, height: 0, hover: false }
            }
        };

        // Initialiser le module InfoAuteur
        let infoAuteur = null;
        if (typeof InfoAuteur !== 'undefined') {
            infoAuteur = new InfoAuteur();
        }

        // Cr√©er un conteneur HTML pour l'onglet Info
        let infoContainer = null;
        // FONCTIONS D√âSACTIV√âES - Conteneur HTML Info non utilis√©
        // Le syst√®me utilise maintenant uniquement le canvas pour l'onglet Info
        /*
        function creerInfoContainer() {
            if (infoContainer) return;

            infoContainer = document.createElement('div');
            infoContainer.id = 'info-artist-container';
            
            // Calculer les dimensions du menu canvas
            const menuWidth = Math.min(800, C.W * 0.95);
            const menuHeight = C.H * 0.85;
            const menuX = (C.W - menuWidth) / 2;
            const menuY = C.H * 0.075;
            
            infoContainer.style.cssText = `
                position: fixed;
                top: ${menuY}px;
                left: ${menuX}px;
                width: ${menuWidth}px;
                height: ${menuHeight}px;
                background: linear-gradient(135deg, #ffffff, #f8fafc);
                overflow-y: auto;
                overflow-x: hidden;
                padding: 20px;
                z-index: 9999;
                display: none;
                font-family: Georgia, serif;
                color: #1e293b;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                pointer-events: auto;
            `;

            // Charger le contenu depuis emmanuel-artist-module.html
            fetch('modules/emmanuel-artist-module.html')
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const bodyContent = doc.body.innerHTML;
                    infoContainer.innerHTML = bodyContent;
                    
                    const style = document.createElement('style');
                    style.textContent = `
                        #info-artist-container h1 { font-size: 24px; margin-top: 10px; }
                        #info-artist-container h2 { font-size: 20px; margin-top: 15px; }
                        #info-artist-container p { font-size: 14px; line-height: 1.6; }
                        #info-artist-container img { max-width: 100%; height: auto; }
                        #info-artist-container a { color: #3b82f6; text-decoration: none; }
                        #info-artist-container a:hover { text-decoration: underline; }
                    `;
                    infoContainer.appendChild(style);
                })
                .catch(err => {
                    console.error('Erreur chargement emmanuel-artist-module.html:', err);
                    infoContainer.innerHTML = '<p style="text-align:center;color:#ef4444;padding:40px;">' + getTranslatedText('game.content_unavailable', 'Contenu non disponible') + '</p>';
                });

            document.body.appendChild(infoContainer);
        }

        function afficherInfoContainer(visible) {
            if (!infoContainer) creerInfoContainer();
            if (infoContainer) {
                infoContainer.style.display = visible ? 'block' : 'none';
                
                if (visible) {
                    const menuWidth = Math.min(800, C.W * 0.95);
                    const menuHeight = C.H * 0.85;
                    const menuX = (C.W - menuWidth) / 2;
                    const menuY = C.H * 0.075;
                    
                    infoContainer.style.width = menuWidth + 'px';
                    infoContainer.style.height = menuHeight + 'px';
                    infoContainer.style.left = menuX + 'px';
                    infoContainer.style.top = menuY + 'px';
                }
            }
        }
        */

        // Dessiner les ic√¥nes d'√©nigmes collect√©es en haut du header
        // D√âSACTIV√â : Les √©nigmes ne s'affichent que dans le menu, pas en haut
        function dessinerIconesCollecteesEnHaut(headerHeight) {
            // FONCTION D√âSACTIV√âE - Les √©nigmes collect√©es ne s'affichent QUE dans le menu üß©
            // La chauve-souris et l'ange sont g√©r√©s s√©par√©ment et toujours visibles
            return;

            // Afficher les ic√¥nes de droite √† gauche
            enigmesCollectees.forEach((enigme, index) => {
                const x = startX - (index + 1) * spacing;

                // Zone cliquable
                const iconData = {
                    x: x - iconSize / 2,
                    y: iconY - iconSize / 2,
                    width: iconSize,
                    height: iconSize,
                    enigme: enigme
                };
                menuEnigmesCanvas.topIcons.push(iconData);

                // Effet de survol
                const isHovered = menuEnigmesCanvas.topIcons.some(icon =>
                    icon.enigme.id === enigme.id && icon.hover);

                // Fond de l'ic√¥ne avec effet lumineux
                ctx.fillStyle = isHovered ? 'rgba(100, 255, 218, 0.3)' : 'rgba(100, 255, 218, 0.15)';
                ctx.beginPath();
                ctx.arc(x, iconY, iconSize / 2 + 2, 0, Math.PI * 2);
                ctx.fill();

                // Bordure
                ctx.strokeStyle = '#64ffda';
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.stroke();

                // Ic√¥ne de l'√©nigme
                ctx.font = `${iconSize * 0.7}px Arial`;
                ctx.fillStyle = '#64ffda';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enigme.icone, x, iconY);

                // Badge de notification si c'est la premi√®re fois affich√©
                if (index < 3) { // Badge seulement pour les 3 derni√®res collect√©es
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x + iconSize / 3, iconY - iconSize / 3, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();
        }

        // Dessiner le bouton menu √©nigmes dans le canvas
        function dessinerBoutonMenuEnigmes() {
            // Position dans le header √† droite
            const headerH = Math.max(C.H * 0.045, 32);
            boutonMenuEnigmes.x = C.W - 65;
            boutonMenuEnigmes.y = Math.max(headerH / 2 - 25, 5); // Centr√© dans le header

            ctx.save();

            // Effet de survol
            const scale = boutonMenuEnigmes.hover ? 1.1 : 1;
            const alpha = boutonMenuEnigmes.hover ? 1 : 0.8;

            ctx.globalAlpha = alpha;
            ctx.translate(boutonMenuEnigmes.x + boutonMenuEnigmes.width/2,
                         boutonMenuEnigmes.y + boutonMenuEnigmes.height/2);
            ctx.scale(scale, scale);

            // Arri√®re-plan du bouton
            const gradient = ctx.createLinearGradient(-25, -25, 25, 25);
            gradient.addColorStop(0, '#1a2d4a');
            gradient.addColorStop(1, '#0a1428');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Ic√¥ne du puzzle
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#64ffda';
            ctx.fillText('üß©', 0, 0);

            // Indicateur du nombre d'√©nigmes collect√©es
            if (enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;

                if (collected > 0) {
                    // Badge de notification
                    ctx.fillStyle = '#10d9c4';
                    ctx.beginPath();
                    ctx.arc(15, -15, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#0a1428';
                    ctx.fillText(collected, 15, -15);
                }
            }

            ctx.restore();
        }

        // Dessiner le bouton plein √©cran dans le canvas
        function dessinerBoutonPleinEcran() {
            // Position dans le header √† droite, √† gauche du bouton menu
            const headerH = Math.max(C.H * 0.045, 32);
            boutonPleinEcran.x = C.W - 120; // 55px √† gauche du bouton menu
            boutonPleinEcran.y = Math.max(headerH / 2 - 25, 5);

            ctx.save();

            // Effet de survol
            const scale = boutonPleinEcran.hover ? 1.1 : 1;
            const alpha = boutonPleinEcran.hover ? 1 : 0.8;

            ctx.globalAlpha = alpha;
            ctx.translate(boutonPleinEcran.x + boutonPleinEcran.width/2,
                         boutonPleinEcran.y + boutonPleinEcran.height/2);
            ctx.scale(scale, scale);

            // Arri√®re-plan du bouton
            const gradient = ctx.createLinearGradient(-25, -25, 25, 25);
            gradient.addColorStop(0, '#1a2d4a');
            gradient.addColorStop(1, '#0a1428');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = boutonPleinEcran.isFullscreen ? '#fbbf24' : '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Ic√¥ne plein √©cran ou minimiser
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = boutonPleinEcran.isFullscreen ? '#fbbf24' : '#64ffda';
            ctx.fillText(boutonPleinEcran.isFullscreen ? 'üóó' : '‚õ∂', 0, 0);

            ctx.restore();
        }

        // Fonction pour basculer le plein √©cran
        function toggleFullscreen() {
            const elem = document.documentElement;
            
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Entrer en plein √©cran
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) { // Firefox
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) { // IE/Edge
                    elem.msRequestFullscreen();
                }
                boutonPleinEcran.isFullscreen = true;
                
                // üîä Son de succ√®s
                if (AudioSystem && AudioSystem.playPowerUp) {
                    AudioSystem.playPowerUp();
                }
            } else {
                // Sortir du plein √©cran
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                boutonPleinEcran.isFullscreen = false;
                
                // üîä Son de clic
                if (AudioSystem && AudioSystem.playClick) {
                    AudioSystem.playClick();
                }
            }
        }

        // √âcouter les changements d'√©tat du plein √©cran
        document.addEventListener('fullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.fullscreenElement;
        });
        document.addEventListener('webkitfullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.webkitFullscreenElement;
        });
        document.addEventListener('mozfullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.mozFullScreenElement;
        });
        document.addEventListener('MSFullscreenChange', () => {
            boutonPleinEcran.isFullscreen = !!document.msFullscreenElement;
        });

        // Fonctions menu HOME supprim√©es

        // ========================================
        // MENU PRINCIPAL - Acc√®s √† tous les menus
        // ========================================

        function ouvrirMenuPrincipal() {
            // Cr√©er un menu avec toutes les options
            const options = [
                { nom: 'üß© √ânigmes', action: () => ouvrirMenuEnigmesCanvas() },
                { nom: 'üìú √ânigmes Compl√®tes', action: () => ouvrirEnigmesCompletes() },
                { nom: 'üéÆ Menu Jeux', action: () =>console.log('Menu jeux ouvert') },
                { nom: 'üìú Po√®me 1', action: () =>console.log('Po√®me 1 ouvert') },
                { nom: 'üìñ Po√®me 2', action: () =>console.log('Po√®me 2 ouvert') },
                { nom: 'üé® Info Artiste', action: () => ouvrirInfoArtiste() },
                { nom: 'üé¨ G√©n√©rique', action: () =>console.log('G√©n√©rique ouvert') },
                { nom: 'ü¶áüëº Ic√¥nes', action: () =>console.log('Menu ic√¥nes ouvert') }
            ];

            // Pour l'instant, ouvrir le menu √©nigmes (√† d√©velopper plus tard)
            ouvrirMenuEnigmesCanvas();
        }

        // Fonction pour ouvrir l'info artiste
        function ouvrirInfoArtiste() {
            // Version simplifi√©e pour √©viter les erreurs de syntaxe
            const infoArtistePage = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emmanuel Payet - Artiste</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            text-align: center;
        }
        h1 { color: #2c3e50; margin-bottom: 20px; }
        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="window.close()">√ó</button>
    <div class="container">
        <h1>Emmanuel Payet</h1>
        <p>Artiste Chretien - Createur - Inspirateur</p>
        <br>
        <div>
            <h3>Jeux & Deco</h3>
            <p>Decouvre mes creations visuelles et jeux interactifs</p>
            <a href="https://emmanuel.gallery" target="_blank">emmanuel.gallery</a>
        </div>
        <br>
        <div>
            <h3>Livres & Art</h3>
            <p>Mes oeuvres litteraires et artistiques</p>
            <a href="https://emmanuelpayet.art" target="_blank">emmanuelpayet.art</a>
        </div>
        <br>
        <div>
            <h3>Gospel Gratuit</h3>
            <p>Mes compositions gospel sur AudioMack</p>
            <a href="https://audiomack.com/emmanuelpayet888" target="_blank">AudioMack</a>
        </div>
    </div>
</body>
</html>`;

            // Ouvrir dans une nouvelle fen√™tre
            const newWindow = window.open('', '_blank', 'width=1000,height=800,scrollbars=yes,resizable=yes');
            newWindow.document.write(infoArtistePage);
            newWindow.document.close();
        }

        // Fonction pour ouvrir les √©nigmes compl√®tes avec le nouveau style
        function ouvrirEnigmesCompletes() {
            // Ouvrir le fichier existant directement avec la langue actuelle
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            const newWindow = window.open(`emmanuel-artist-module.html?lang=${currentLang}`, '_blank', 'width=1200,height=900,scrollbars=yes,resizable=yes');
        }

        // Ouvrir le menu √©nigmes dans le canvas
        function ouvrirMenuEnigmesCanvas() {
            if (menuEnigmesCanvas.visible) return;

            menuEnigmesCanvas.visible = true;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.animationStartTime = Date.now();
            menuEnigmesCanvas.showInfo = false;
            menuEnigmesCanvas.selectedEnigma = null;
            menuEnigmesCanvas.scrollY = 0;

            // G√©n√©rer les positions des cartes
            genererPositionsCartesEnigmes();
        }

        // Fermer le menu √©nigmes canvas
        function fermerMenuEnigmesCanvas() {
            menuEnigmesCanvas.visible = false;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.hoveredCard = null;
            menuEnigmesCanvas.expandedCard = null; // Refermer toutes les cartes d√©pli√©es
        }

        // G√©n√©rer les positions des cartes d'√©nigmes - FORMAT LISTE avec d√©roulants
        function genererPositionsCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards = [];

            // Calculer les dimensions du menu centr√©
            const menuWidth = Math.min(C.W - 40, 700);
            const menuHeight = Math.min(C.H - 60, 600);
            const menuX = (C.W - menuWidth) / 2;
            const menuY = (C.H - menuHeight) / 2;

            const startX = menuX + 20;
            const startY = menuY + 160; // Ajust√© pour laisser place aux onglets, titre et score
            const itemHeight = 80; // Hauteur de chaque ligne (agrandi)
            const spacing = 8;

            let currentY = startY;
            
            Object.values(ENIGMES_DATABASE).forEach(enigme => {
                menuEnigmesCanvas.enigmaCards.push({
                    id: enigme.id,
                    x: startX,
                    y: currentY,
                    width: menuWidth - 40,
                    height: itemHeight,
                    enigme: enigme,
                    hover: false
                });
                
                currentY += itemHeight + spacing;
                
                // NE PAS ajouter de hauteur pour le panneau d√©roulant
                // Le panneau s'affiche PAR-DESSUS sans d√©caler les autres cartes
            });

            // Calculer le scroll max
            const totalHeight = currentY - startY;
            menuEnigmesCanvas.maxScrollY = Math.max(0, totalHeight - (menuHeight - 180));
        }

        // Mettre √† jour l'animation du menu
        function mettreAJourMenuEnigmesCanvas() {
            if (!menuEnigmesCanvas.visible) return;

            const elapsed = Date.now() - menuEnigmesCanvas.animationStartTime;
            const progress = Math.min(elapsed / menuEnigmesCanvas.animationDuration, 1);

            // Easing out
            menuEnigmesCanvas.animation = 1 - Math.pow(1 - progress, 3);
        }

        // Dessiner le menu √©nigmes dans le canvas
        function dessinerMenuEnigmesCanvas() {
            // Cacher le menu pendant les phases 17-22 (murs)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle >= 17 && phaseActuelle <= 22) {
                return; // Ne pas afficher le menu pendant les phases de mur
            }

            if (!menuEnigmesCanvas.visible) {
                return;
            }

            ctx.save();

            // Arri√®re-plan avec transparence l√©g√®re
            ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * menuEnigmesCanvas.animation})`;
            ctx.fillRect(0, 0, C.W, C.H);

            // Container principal
            const containerAlpha = menuEnigmesCanvas.animation;
            ctx.globalAlpha = containerAlpha;

            // Arri√®re-plan du menu - CENTR√â et BLANC LUMINEUX
            const menuWidth = Math.min(C.W - 40, 800); // Augment√© pour 4 onglets
            const menuHeight = Math.min(C.H - 60, 600);
            const menuX = (C.W - menuWidth) / 2;
            const menuY = (C.H - menuHeight) / 2;

            // Fond blanc lumineux transparent
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.roundRect(menuX, menuY, menuWidth, menuHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Onglets modernes et √©l√©gants - style minimaliste - 4 onglets ADAPTATIFS
            const ongletHeight = 45;
            const ongletY = menuY + 10;
            const espacementOnglets = 8; // Espacement entre onglets
            const paddingTexteInactif = 30; // Padding pour onglets inactifs
            const paddingTexteActif = 50; // Padding pour onglet actif (plus large)
            
            // Mesurer la largeur n√©cessaire pour chaque onglet - TEXTE SANS IC√îNES
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            const texteEnigmes = getTranslatedText('interface.tabs.enigmas', '√ânigmes');
            const texteScores = getTranslatedText('interface.tabs.scores', 'Scores');
            const texteLangue = getTranslatedText('interface.tabs.language', 'Langue');
            const texteInfo = getTranslatedText('interface.tabs.info', 'Info');
            
            // D√©terminer quel onglet est actif pour lui donner plus de padding
            const ongletActif = menuEnigmesCanvas.ongletActif;
            const paddingEnigmes = (ongletActif === 'enigmes') ? paddingTexteActif : paddingTexteInactif;
            const paddingScores = (ongletActif === 'classement') ? paddingTexteActif : paddingTexteInactif;
            const paddingLangue = (ongletActif === 'langues') ? paddingTexteActif : paddingTexteInactif;
            const paddingInfo = (ongletActif === 'info') ? paddingTexteActif : paddingTexteInactif;
            
            const largeurEnigmes = ctx.measureText(texteEnigmes).width + paddingEnigmes * 2;
            const largeurScores = ctx.measureText(texteScores).width + paddingScores * 2;
            const largeurLangue = ctx.measureText(texteLangue).width + paddingLangue * 2;
            const largeurInfo = ctx.measureText(texteInfo).width + paddingInfo * 2;
            
            // Largeur totale n√©cessaire
            const largeurTotaleOnglets = largeurEnigmes + largeurScores + largeurLangue + largeurInfo + (espacementOnglets * 3);
            const largeurDisponible = menuWidth - 50; // Marges
            
            // Si les onglets sont trop larges, on les r√©duit proportionnellement
            let facteurReduction = 1;
            if (largeurTotaleOnglets > largeurDisponible) {
                facteurReduction = largeurDisponible / largeurTotaleOnglets;
            }
            
            const ongletWidthEnigmes = largeurEnigmes * facteurReduction;
            const ongletWidthScores = largeurScores * facteurReduction;
            const ongletWidthLangue = largeurLangue * facteurReduction;
            const ongletWidthInfo = largeurInfo * facteurReduction;

            // Calculer la largeur totale r√©elle apr√®s r√©duction
            const largeurTotaleReelle = ongletWidthEnigmes + ongletWidthScores + ongletWidthLangue + ongletWidthInfo + (espacementOnglets * 3);
            
            // Centrer les onglets horizontalement
            const offsetCentrage = (menuWidth - largeurTotaleReelle) / 2;

            // Onglet √ânigmes - CENTR√â
            const ongletEnigmesX = menuX + offsetCentrage;
            menuEnigmesCanvas.onglets.enigmes.x = ongletEnigmesX;
            menuEnigmesCanvas.onglets.enigmes.y = ongletY;
            menuEnigmesCanvas.onglets.enigmes.width = ongletWidthEnigmes;
            menuEnigmesCanvas.onglets.enigmes.height = ongletHeight;

            const enigmesActif = menuEnigmesCanvas.ongletActif === 'enigmes';

            // Design moderne et √©pur√©
            ctx.save();

            // Onglet √ânigmes - Style minimaliste
            if (enigmesActif) {
                // Onglet actif : fond blanc pur avec l√©g√®re √©l√©vation
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                // Onglet inactif : transparent avec bordure subtile
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletEnigmesX, ongletY, ongletWidthEnigmes, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure lat√©rale - seulement ligne du bas pour onglet inactif
            if (!enigmesActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletEnigmesX, ongletY + ongletHeight);
                ctx.lineTo(ongletEnigmesX + ongletWidthEnigmes, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte √©l√©gant - police adapt√©e - BOLD SANS IC√îNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = enigmesActif ? '#1e293b' : '#64748b';
            ctx.textAlign = 'center';
            ctx.fillText(texteEnigmes, ongletEnigmesX + ongletWidthEnigmes / 2, ongletY + 28);

            // Indicateur actif sous le texte - ajust√© dynamiquement
            if (enigmesActif) {
                ctx.fillStyle = '#3b82f6';
                const indicateurWidth = Math.min(40, ongletWidthEnigmes * 0.6);
                ctx.fillRect(ongletEnigmesX + ongletWidthEnigmes / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Classement
            const ongletClassementX = ongletEnigmesX + ongletWidthEnigmes + espacementOnglets;
            menuEnigmesCanvas.onglets.classement.x = ongletClassementX;
            menuEnigmesCanvas.onglets.classement.y = ongletY;
            menuEnigmesCanvas.onglets.classement.width = ongletWidthScores;
            menuEnigmesCanvas.onglets.classement.height = ongletHeight;

            const classementActif = menuEnigmesCanvas.ongletActif === 'classement';

            // Onglet Classement - Style minimaliste
            if (classementActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletClassementX, ongletY, ongletWidthScores, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure lat√©rale - seulement ligne du bas pour onglet inactif
            if (!classementActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletClassementX, ongletY + ongletHeight);
                ctx.lineTo(ongletClassementX + ongletWidthScores, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte √©l√©gant - BOLD SANS IC√îNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = classementActif ? '#1e293b' : '#64748b';
            ctx.fillText(texteScores, ongletClassementX + ongletWidthScores / 2, ongletY + 28);

            // Indicateur actif - ajust√© dynamiquement
            if (classementActif) {
                ctx.fillStyle = '#FFD700';
                const indicateurWidth = Math.min(50, ongletWidthScores * 0.6);
                ctx.fillRect(ongletClassementX + ongletWidthScores / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Langues
            const ongletLanguesX = ongletClassementX + ongletWidthScores + espacementOnglets;
            menuEnigmesCanvas.onglets.langues.x = ongletLanguesX;
            menuEnigmesCanvas.onglets.langues.y = ongletY;
            menuEnigmesCanvas.onglets.langues.width = ongletWidthLangue;
            menuEnigmesCanvas.onglets.langues.height = ongletHeight;

            const languesActif = menuEnigmesCanvas.ongletActif === 'langues';

            // Onglet Langues - Style minimaliste
            if (languesActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletLanguesX, ongletY, ongletWidthLangue, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure lat√©rale - seulement ligne du bas pour onglet inactif
            if (!languesActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletLanguesX, ongletY + ongletHeight);
                ctx.lineTo(ongletLanguesX + ongletWidthLangue, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte - BOLD SANS IC√îNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = languesActif ? '#1e293b' : '#64748b';
            const currentFlag = getCurrentLanguageFlag();
            ctx.fillText(`${currentFlag} ${texteLangue}`, ongletLanguesX + ongletWidthLangue / 2, ongletY + 28);

            // Indicateur actif - ajust√© dynamiquement
            if (languesActif) {
                ctx.fillStyle = '#10b981';
                const indicateurWidth = Math.min(50, ongletWidthLangue * 0.6);
                ctx.fillRect(ongletLanguesX + ongletWidthLangue / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Info
            const ongletInfoX = ongletLanguesX + ongletWidthLangue + espacementOnglets;
            menuEnigmesCanvas.onglets.info.x = ongletInfoX;
            menuEnigmesCanvas.onglets.info.y = ongletY;
            menuEnigmesCanvas.onglets.info.width = ongletWidthInfo;
            menuEnigmesCanvas.onglets.info.height = ongletHeight;

            const infoActif = menuEnigmesCanvas.ongletActif === 'info';

            // Onglet Info - Style minimaliste
            if (infoActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletInfoX, ongletY, ongletWidthInfo, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure lat√©rale - seulement ligne du bas pour onglet inactif
            if (!infoActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletInfoX, ongletY + ongletHeight);
                ctx.lineTo(ongletInfoX + ongletWidthInfo, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte √©l√©gant - BOLD SANS IC√îNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = infoActif ? '#1e293b' : '#64748b';
            ctx.fillText(texteInfo, ongletInfoX + ongletWidthInfo / 2, ongletY + 28);

            // Indicateur actif - ajust√© dynamiquement
            if (infoActif) {
                ctx.fillStyle = '#3b82f6';
                const indicateurWidth = Math.min(50, ongletWidthInfo * 0.6);
                ctx.fillRect(ongletInfoX + ongletWidthInfo / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            ctx.restore();

            // Titre moderne - plus petit et positionn√© sous les onglets - PLUS GROS
            if (enigmesActif) {
                ctx.font = '600 30px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.textAlign = 'center';
                ctx.fillText(getTranslatedText('interface.menus.voyage_enigmas', 'Voyage ‚Äî √ânigmes'), C.W / 2, menuY + 100);
            } else if (infoActif) {
                // Supprim√© le texte "√Ä propos"
            }

            // Statistiques (uniquement pour l'onglet √ânigmes) - PLUS GROSSES
            if (menuEnigmesCanvas.ongletActif === 'enigmes' && enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;
                const percent = Math.round((collected / total) * 100);

                ctx.font = '20px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                const progressText = getTranslatedText('interface.menus.collected_progress', `Collect√©es: ${collected}/${total} (${percent}%)`)
                    .replace('{collected}', collected)
                    .replace('{total}', total)
                    .replace('{percent}', percent);
                ctx.fillText(progressText, C.W / 2, menuY + 130);

                // Afficher le score - PLUS GROS
                const xp = pointsConnaissance || 0;
                const scoreJeu = window.score || score;
                ctx.font = '20px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#3b82f6';
                const scoreText = getTranslatedText('interface.menus.score_xp', `üïäÔ∏è ${scoreJeu} | ‚≠ê XP: ${xp}`)
                    .replace('{score}', scoreJeu)
                    .replace('{xp}', xp);
                ctx.fillText(scoreText, C.W / 2, menuY + 155);
            }

            // Bouton de fermeture EN BAS du menu
            const buttonWidth = 120;
            const buttonHeight = 40;
            menuEnigmesCanvas.closeButton.x = menuX + (menuWidth - buttonWidth) / 2;
            menuEnigmesCanvas.closeButton.y = menuY + menuHeight - buttonHeight + 15; // Encore plus bas (d√©passe du menu)
            menuEnigmesCanvas.closeButton.width = buttonWidth;
            menuEnigmesCanvas.closeButton.height = buttonHeight;

            // Rectangle arrondi pour le bouton
            ctx.fillStyle = menuEnigmesCanvas.closeButton.hover ? '#ff6b6b' : '#666';
            ctx.beginPath();
            ctx.roundRect(menuEnigmesCanvas.closeButton.x, menuEnigmesCanvas.closeButton.y, buttonWidth, buttonHeight, 8);
            ctx.fill();

            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(getTranslatedText('interface.buttons.close', 'Fermer'), menuEnigmesCanvas.closeButton.x + buttonWidth/2, menuEnigmesCanvas.closeButton.y + buttonHeight/2);

            // Afficher le contenu selon l'onglet actif
            if (menuEnigmesCanvas.ongletActif === 'enigmes') {
                // Zone de contenu avec clipping
                ctx.save();
                ctx.beginPath();
                ctx.rect(menuX + 10, menuY + 160, menuWidth - 20, menuHeight - 190);
                ctx.clip();

                // Dessiner les cartes d'√©nigmes
                dessinerCartesEnigmes();

                ctx.restore();

                // L'info-bulle popup est d√©sactiv√©e - utilisation du syst√®me de liste d√©roulante int√©gr√©
                // if (menuEnigmesCanvas.hoveredCard) {
                //     dessinerInfoBulleEnigme();
                // }
            } else if (menuEnigmesCanvas.ongletActif === 'info') {
                // Afficher l'ic√¥ne et le message √† 33 millions + projets d'Emmanuel
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 100;

                // Grande ic√¥ne centrale - ic√¥ne du jeu (PNG)
                const iconSize = 60;
                if (gameIcon.complete) {
                    ctx.drawImage(gameIcon, C.W / 2 - iconSize / 2, yPos - iconSize / 2, iconSize, iconSize);
                }
                yPos += 45;

                // Message humoristique - PLUS GROS
                ctx.font = 'bold 22px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#3b82f6';
                ctx.fillText(getTranslatedText('game.canvas.objective', 'Objectif : 33 millions ! üåç'), C.W / 2, yPos);
                yPos += 25;

                ctx.font = '18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.click_info', '(Clic pour en savoir plus)'), C.W / 2, yPos);
                yPos += 40;

                // Citation philosophique - PLUS GROSSE
                ctx.font = 'italic 17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#7c3aed';
                ctx.fillText(getTranslatedText('game.quotes.enigma_truth', 'Dans chaque √©nigme se cache une v√©rit√©,'), C.W / 2, yPos);
                yPos += 22;
                ctx.fillText(getTranslatedText('game.quotes.truth_humanity', 'dans chaque v√©rit√© se r√©v√®le notre humanit√©.'), C.W / 2, yPos);
                yPos += 30;

                ctx.font = '18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.author', 'üé® Emmanuel Payet'), C.W / 2, yPos);
                yPos += 20;

                ctx.font = '17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.dreamer', 'Dreamer Unisona'), C.W / 2, yPos);
                yPos += 35;

                // Section des projets - PLUS GROS
                ctx.font = 'bold 20px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.projects', 'üìÇ Projets'), C.W / 2, yPos);
                yPos += 25;

                // Cr√©er les boutons des projets s'ils n'existent pas
                if (!menuEnigmesCanvas.projectButtons) {
                    menuEnigmesCanvas.projectButtons = [];
                    
                    const projects = [
                        {
                            titleKey: 'game.projects.games_deco',
                            titleFallback: 'Jeux & D√©co',
                            link: 'https://emmanuel.gallery',
                            color: '#7c3aed'
                        },
                        {
                            titleKey: 'game.projects.unispourlapaix',
                            titleFallback: 'UnisPourLaPaix',
                            link: 'https://www.tiktok.com/@unispourlapaix',
                            color: '#059669'
                        },
                        {
                            titleKey: 'game.projects.free_gospel',
                            titleFallback: 'Free Gospel',
                            link: 'https://audiomack.com/emmanuelpayet888',
                            color: '#dc2626'
                        },
                        {
                            titleKey: 'game.projects.books_art',
                            titleFallback: 'Livres & Art',
                            link: 'https://emmanuelpayet.art',
                            color: '#0891b2'
                        },
                        {
                            titleKey: 'game.projects.good_time',
                            titleFallback: 'La Bonne Heure',
                            link: 'https://www.redbubble.com/fr/people/h777plx/shop',
                            color: '#8b5cf6'
                        }
                    ];

                    const buttonWidth = 200;
                    const buttonHeight = 35;
                    const spacing = 12;
                    const startX = C.W / 2 - buttonWidth / 2;

                    projects.forEach((project, index) => {
                        const x = startX;
                        const y = yPos + index * (buttonHeight + spacing);
                        
                        menuEnigmesCanvas.projectButtons.push({
                            x, y, width: buttonWidth, height: buttonHeight,
                            ...project
                        });
                    });
                }

                // Dessiner les boutons des projets (compacts)
                menuEnigmesCanvas.projectButtons.forEach((btn, index) => {
                    // Style du bouton simple et √©l√©gant
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = btn.color;
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 8);
                    ctx.fill();
                    ctx.stroke();

                    // Titre du projet centr√© - PLUS GROS
                    ctx.font = 'bold 17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = btn.color;
                    ctx.textAlign = 'center';
                    const projectTitle = getTranslatedText(btn.titleKey, btn.titleFallback);
                    ctx.fillText(projectTitle, btn.x + btn.width / 2, btn.y + btn.height / 2 + 4);
                });

                ctx.restore();
            } else if (menuEnigmesCanvas.ongletActif === 'classement') {
                // Afficher le classement des scores
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 100;

                // Afficher le meilleur score de l'utilisateur s'il existe - PLUS GROS
                if (userBestScore) {
                    ctx.font = 'bold 20px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(getTranslatedText('game.your_best', '‚ú® Votre meilleur'), C.W / 2, yPos);
                    yPos += 25;

                    // Fond
                    const donnees = userBestScore.donnees_extra;
                    let bgColor = 'rgba(59, 130, 246, 0.05)';
                    if (donnees && donnees.sagesse) {
                        const niveau = getNiveauSagesse(donnees.sagesse);
                        const hex = niveau.couleur.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);
                        bgColor = `rgba(${r}, ${g}, ${b}, 0.12)`;
                    }
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(menuX + 30, yPos - 20, menuWidth - 60, 45);

                    // Score - PLUS GROS
                    ctx.font = 'bold 28px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.fillText(userBestScore.score.toLocaleString(), C.W / 2, yPos);

                    // Niveau de sagesse et √©nigmes (compact) - PLUS GROS
                    if (donnees && donnees.sagesse) {
                        const niveau = getNiveauSagesse(donnees.sagesse);
                        ctx.font = '17px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#64748b';
                        const enigmesInfo = donnees.enigmes ? ` ‚Ä¢ ${donnees.enigmes}/18üß©` : '';
                        ctx.fillText(niveau.icone + ' ' + niveau.titre + ' ‚Ä¢ ' + donnees.sagesse + 'üíé' + enigmesInfo, C.W / 2, yPos + 18);
                    }

                    yPos += 55;
                }

                // Titre
                ctx.font = 'bold 22px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('ui.leaderboard_title', 'üèÜ Top 10 - Petit Bateau'), C.W / 2, yPos);
                yPos += 35;

                // V√©rifier si les donn√©es sont charg√©es
                if (loadingLeaderboard) {
                    ctx.font = '16px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(getTranslatedText('interface.system.loading', '‚è≥ Chargement...'), C.W / 2, yPos + 60);
                } else if (!leaderboardData || leaderboardData.length === 0) {
                    ctx.font = '16px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(getTranslatedText('interface.menus.no_score_recorded', 'Aucun score enregistr√©'), C.W / 2, yPos + 40);
                    yPos += 70;
                    ctx.font = '18px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#94a3b8';
                    ctx.fillText(getTranslatedText('game.quotes.be_first', 'Soyez le premier √† terminer le jeu !'), C.W / 2, yPos);
                } else {
                    // Afficher les scores
                    ctx.textAlign = 'left';
                    const startX = menuX + 40;
                    const lineHeight = 55; // Plus haut pour niveau de sagesse

                    leaderboardData.forEach((entry, index) => {
                        // Position et rang
                        let medal = '';
                        if (index === 0) medal = 'ü•á';
                        else if (index === 1) medal = 'ü•à';
                        else if (index === 2) medal = 'ü•â';
                        else medal = `${index + 1}.`;

                        // Fond color√© selon le niveau de sagesse
                        const donnees = entry.donnees_extra;
                        let bgColor = 'rgba(0, 0, 0, 0.02)';
                        if (donnees && donnees.sagesse) {
                            const niveau = getNiveauSagesse(donnees.sagesse);
                            // Convertir couleur hex en rgba avec opacit√©
                            const hex = niveau.couleur.replace('#', '');
                            const r = parseInt(hex.substr(0, 2), 16);
                            const g = parseInt(hex.substr(2, 2), 16);
                            const b = parseInt(hex.substr(4, 2), 16);
                            bgColor = `rgba(${r}, ${g}, ${b}, 0.08)`;
                        }
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(menuX + 30, yPos - 25, menuWidth - 60, lineHeight);

                        // M√©daille/Rang - PLUS GROS
                        ctx.font = 'bold 22px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText(medal, startX, yPos);

                        // Avatar (si pr√©sent) - PLUS GROS
                        const avatar = entry.users?.avatar;
                        let pseudoX = startX + 40;
                        if (avatar) {
                            ctx.font = '24px "Segoe UI", system-ui, sans-serif';
                            ctx.fillText(avatar, startX + 40, yPos);
                            pseudoX = startX + 68;
                        }

                        // Pseudo - PLUS GROS
                        ctx.font = '20px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#475569';
                        const pseudo = entry.users?.pseudo || 'Anonyme';
                        ctx.fillText(pseudo, pseudoX, yPos);

                        // Niveau de sagesse (ic√¥ne) sous le pseudo - PLUS GROS
                        if (donnees && donnees.sagesse) {
                            const niveau = getNiveauSagesse(donnees.sagesse);
                            ctx.font = '17px "Segoe UI", system-ui, sans-serif';
                            ctx.fillStyle = '#94a3b8';

                            // Afficher niveau + √©nigmes collect√©es (plus compact)
                            const enigmesInfo = donnees.enigmes ? `${donnees.enigmes}/18üß©` : '';
                            const infoText = enigmesInfo ? `${niveau.icone} ${niveau.titre} ‚Ä¢ ${enigmesInfo}` : `${niveau.icone} ${niveau.titre}`;
                            ctx.fillText(infoText, pseudoX, yPos + 16);

                            // Badges sp√©ciaux √† droite - PLUS GROS
                            const badges = getBadges(donnees, index === 0, donnees.enigmes);
                            let badgeX = menuX + menuWidth - 140;
                            badges.forEach(badge => {
                                ctx.font = '16px "Segoe UI", system-ui, sans-serif';
                                ctx.fillStyle = '#f39c12';
                                ctx.fillText(badge.icone, badgeX, yPos + 16);
                                badgeX += 20;
                            });
                        }

                        // Score - PLUS GROS
                        ctx.font = 'bold 22px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#3b82f6';
                        ctx.textAlign = 'right';
                        ctx.fillText(entry.score.toLocaleString(), menuX + menuWidth - 40, yPos);
                        ctx.textAlign = 'left';

                        yPos += lineHeight;
                    });
                }

                // Message de motivation
                yPos = menuY + menuHeight - 60;
                ctx.textAlign = 'center';
                ctx.font = '13px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#94a3b8';
                ctx.fillText(getTranslatedText('ui.complete_game_save_score'), C.W / 2, yPos);

                ctx.restore();
            } else if (menuEnigmesCanvas.ongletActif === 'langues') {
                // Nouvel design : boutons sur les bords reli√©s par des phrases d'amour
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 80;

                // Titre avec c≈ìur
                ctx.font = 'bold 24px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText(getTranslatedText('game.canvas.languages_heart', 'üíù Langues du C≈ìur üíù'), C.W / 2, yPos);
                yPos += 35;

                // Phrase d'introduction
                ctx.font = '16px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.languages_message', 'Chaque langue porte l\'amour et la paix du monde'), C.W / 2, yPos);
                yPos += 55;

                // Langue actuelle
                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                const currentFlag = getCurrentLanguageFlag();
                
                // D√©finir les 14 langues avec phrases d'amour
                const languagesWithLove = {
                    'fr': { name: 'Fran√ßais', love: 'L\'amour unit les c≈ìurs' },
                    'en': { name: 'English', love: 'Love brings us together' },
                    'es': { name: 'Espa√±ol', love: 'El amor nos une' },
                    'de': { name: 'Deutsch', love: 'Liebe verbindet uns' },
                    'it': { name: 'Italiano', love: 'L\'amore ci unisce' },
                    'pt': { name: 'Portugu√™s', love: 'O amor nos une' },
                    'ru': { name: '–†—É—Å—Å–∫–∏–π', love: '–õ—é–±–æ–≤—å –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –Ω–∞—Å' },
                    'zh': { name: '‰∏≠Êñá', love: 'Áà±Â∞ÜÊàë‰ª¨Âõ¢ÁªìÂú®‰∏ÄËµ∑' },
                    'ko': { name: 'ÌïúÍµ≠Ïñ¥', love: 'ÏÇ¨ÎûëÏù¥ Ïö∞Î¶¨Î•º ÌïòÎÇòÎ°ú' },
                    'jp': { name: 'Êó•Êú¨Ë™û', love: 'ÊÑõ„ÅåÁßÅ„Åü„Å°„ÇíÁµê„Å∂' },
                    'ar': { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', love: 'ÿßŸÑÿ≠ÿ® ŸäŸàÿ≠ÿØŸÜÿß' },
                    'he': { name: '◊¢◊ë◊®◊ô◊™', love: '◊ê◊î◊ë◊î ◊û◊ê◊ó◊ì◊™ ◊ê◊ï◊™◊†◊ï' },
                    'uk': { name: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞', love: '–õ—é–±–æ–≤ —î–¥–Ω–∞—î –Ω–∞—Å' },
                    'rc': { name: 'Kr√©ol R√©nyon√©', love: 'Lamour i r√®n nout k√®r ansanm' }
                };
                
                const currentLangData = languagesWithLove[currentLang] || languagesWithLove['fr'];

                // Afficher la langue actuelle au centre
                ctx.font = 'bold 18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText(`üíñ ${currentFlag} ${currentLangData.name} üíñ`, C.W / 2, yPos);
                yPos += 30;
                
                ctx.font = 'italic 15px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#e11d48';
                ctx.fillText(`"${currentLangData.love}"`, C.W / 2, yPos);
                yPos += 65;

                // Cr√©er un cercle d'amour avec les langues autour
                const centerX = C.W / 2;
                const centerY = yPos + 120;
                const radius = 120;
                const langEntries = Object.entries(languagesWithLove);

                // Cr√©er les zones cliquables en cercle
                if (!menuEnigmesCanvas.langueButtons || menuEnigmesCanvas.lastLangCheck !== currentLang) {
                    menuEnigmesCanvas.langueButtons = [];
                    menuEnigmesCanvas.lastLangCheck = currentLang;
                    
                    langEntries.forEach(([code, data], index) => {
                        const angle = (index / langEntries.length) * 2 * Math.PI - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius - 40;
                        const y = centerY + Math.sin(angle) * radius - 15;
                        const isActive = currentLang === code;

                        menuEnigmesCanvas.langueButtons.push({
                            x, y, width: 80, height: 30,
                            code, name: data.name, love: data.love, isActive, angle
                        });
                    });
                }

                // Dessiner les lignes d'amour qui relient les langues au centre
                ctx.strokeStyle = 'rgba(236, 72, 153, 0.3)';
                ctx.lineWidth = 2;
                menuEnigmesCanvas.langueButtons.forEach(btn => {
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(btn.x + btn.width / 2, btn.y + btn.height / 2);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Dessiner le c≈ìur central
                ctx.font = '48px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText('üíó', centerX, centerY + 15);

                // Texte central "Amour Universel" AU-DESSUS du c≈ìur
                ctx.font = 'bold 18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.love', 'Amour'), centerX, centerY - 30);
                ctx.fillText(getTranslatedText('game.canvas.universal', 'Universel'), centerX, centerY - 12);

                // Dessiner les boutons de langue
                const flags = {
                    'fr': 'üá´üá∑', 'en': 'üá¨üáß', 'jp': 'üáØüáµ', 'uk': 'üá∫üá¶',
                    'es': 'üá™üá∏', 'de': 'üá©üá™', 'it': 'üáÆüáπ', 'pt': 'üáµüáπ',
                    'ru': 'üá∑üá∫', 'zh': 'üá®üá≥', 'ko': 'üá∞üá∑', 'ar': 'üá∏üá¶', 'he': 'üáÆüá±',
                    'rc': 'üá∑üá™'
                };

                menuEnigmesCanvas.langueButtons.forEach(btn => {
                    // Mettre √† jour le statut actif
                    btn.isActive = currentLang === btn.code;
                    
                    // Style du bouton rond √©l√©gant moderne
                    const centerX = btn.x + btn.width / 2;
                    const centerY = btn.y + btn.height / 2;
                    const radius = 20; // Rayon l√©g√®rement augment√© pour les drapeaux plus grands
                    
                    // Gradient moderne blanc/gris pour le bouton
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    if (btn.isActive) {
                        gradient.addColorStop(0, '#ffffff'); // Blanc pur
                        gradient.addColorStop(0.7, '#f8fafc'); // Blanc tr√®s l√©g√®rement teint√©
                        gradient.addColorStop(1, '#e2e8f0'); // Gris tr√®s clair
                    } else {
                        gradient.addColorStop(0, '#f9fafb'); // Blanc cass√©
                        gradient.addColorStop(0.7, '#f3f4f6'); // Gris tr√®s clair
                        gradient.addColorStop(1, '#e5e7eb'); // Gris clair
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = btn.isActive ? '#3b82f6' : '#d1d5db'; // Bleu moderne ou gris
                    ctx.lineWidth = btn.isActive ? 3 : 2;

                    // Ombre moderne subtile
                    if (btn.isActive) {
                        ctx.shadowColor = 'rgba(59, 130, 246, 0.3)'; // Ombre bleue
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        ctx.shadowBlur = 8;
                    } else {
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 1;
                        ctx.shadowBlur = 3;
                    }

                    // Dessiner le cercle moderne
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // Effet de brillance moderne
                    if (btn.isActive) {
                        const highlightGradient = ctx.createRadialGradient(
                            centerX - 6, centerY - 6, 0, 
                            centerX - 6, centerY - 6, 12
                        );
                        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = highlightGradient;
                        ctx.beginPath();
                        ctx.arc(centerX - 4, centerY - 4, 8, 0, 2 * Math.PI);
                        ctx.fill();
                    }

                    // R√©initialiser l'ombre
                    ctx.shadowColor = 'transparent';
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.shadowBlur = 0;

                    // Drapeau ENCORE PLUS GRAND et parfaitement centr√© dans le cercle
                    const flag = flags[btn.code] || 'üåç';
                    ctx.font = '26px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Encore plus grand
                    ctx.fillStyle = btn.isActive ? '#1f2937' : '#4b5563'; // Gris fonc√© moderne
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Centrage parfait dans le cercle
                    ctx.fillText(`${flag}`, centerX, centerY);
                    
                    // Nom de la langue sous le cercle (externe)
                    ctx.font = 'bold 11px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Plus grand
                    ctx.fillStyle = btn.isActive ? '#1f2937' : '#6b7280';
                    ctx.textBaseline = 'top';
                    
                    // Contour blanc subtil pour une meilleure lisibilit√©
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeText(btn.name, centerX, centerY + radius + 6);
                    ctx.fillText(btn.name, centerX, centerY + radius + 6);

                    // Phrase d'amour qui flotte pr√®s du bouton avec style moderne
                    if (btn.isActive) {
                        const textX = centerX;
                        const textY = centerY - radius - 35;
                        
                        // Fond moderne blanc pour la phrase
                        ctx.font = 'italic 13px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Plus grand
                        const textMetrics = ctx.measureText(`"${btn.love}"`);
                        const textWidth = textMetrics.width + 24; // Plus d'espace
                        const textHeight = 28; // Plus haut
                        
                        // Gradient moderne blanc pour le fond de la phrase
                        const phraseGradient = ctx.createLinearGradient(
                            textX - textWidth/2, textY - textHeight/2,
                            textX + textWidth/2, textY + textHeight/2
                        );
                        phraseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                        phraseGradient.addColorStop(1, 'rgba(248, 250, 252, 0.95)');
                        
                        ctx.fillStyle = phraseGradient;
                        ctx.strokeStyle = '#3b82f6'; // Bordure bleue moderne
                        ctx.lineWidth = 2;
                        
                        // Ombre moderne pour la bulle
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        ctx.shadowBlur = 8;
                        
                        ctx.beginPath();
                        ctx.roundRect(textX - textWidth/2, textY - textHeight/2, textWidth, textHeight, 12);
                        ctx.fill();
                        ctx.stroke();
                        
                        // R√©initialiser l'ombre
                        ctx.shadowColor = 'transparent';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        ctx.shadowBlur = 0;
                        
                        // Effet de brillance moderne sur la bulle
                        const bubbleHighlight = ctx.createLinearGradient(
                            textX - textWidth/2, textY - textHeight/2,
                            textX - textWidth/3, textY - textHeight/3
                        );
                        bubbleHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                        bubbleHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = bubbleHighlight;
                        ctx.beginPath();
                        ctx.roundRect(textX - textWidth/2, textY - textHeight/2, textWidth/2, textHeight/2, 12);
                        ctx.fill();
                        
                        ctx.font = 'italic 13px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Police moderne coh√©rente
                        ctx.fillStyle = '#374151'; // Gris fonc√© moderne
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Contour blanc subtil pour la phrase
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeText(`"${btn.love}"`, textX, textY);
                        ctx.fillText(`"${btn.love}"`, textX, textY);
                    }
                });

                ctx.restore();
            }

            ctx.restore();
        }

        // Dessiner les cartes d'√©nigmes avec syst√®me de liste d√©roulante
        function dessinerCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards.forEach(card => {
                let y = card.y - menuEnigmesCanvas.scrollY;

                // Ne dessiner que les lignes visibles
                if (y + card.height < 80 || y > C.H - 40) return;

                const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                const isExpanded = menuEnigmesCanvas.expandedCard === card.id;

                ctx.save();

                // Arri√®re-plan de la ligne - style blanc lumineux
                if (isCollected) {
                    ctx.fillStyle = card.hover ? 'rgba(100, 200, 100, 0.15)' : 'rgba(100, 200, 100, 0.08)';
                    ctx.strokeStyle = '#4CAF50';
                } else {
                    ctx.fillStyle = card.hover ? 'rgba(200, 200, 200, 0.3)' : 'rgba(230, 230, 230, 0.5)';
                    ctx.strokeStyle = '#ccc';
                }

                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(card.x, y, card.width, card.height, 8);
                ctx.fill();
                ctx.stroke();

                // Ic√¥ne √† gauche - PLUS GRANDE
                ctx.font = '56px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = isCollected ? '#333' : '#aaa';
                ctx.fillText(card.enigme.icone, card.x + 15, y + card.height/2);

                // Nom au centre - PLUS GROS ET GRAS
                ctx.font = 'bold 26px Arial';
                ctx.fillStyle = isCollected ? '#222' : '#999';
                ctx.fillText(typeof card.enigme.nom === 'function' ? card.enigme.nom() : card.enigme.nom, card.x + 90, y + card.height/2 - 10);

                // Description en dessous (si collect√©e) - PLUS GROSSE
                if (isCollected) {
                    ctx.font = '18px Arial';
                    ctx.fillStyle = '#666';
                    const maxWidth = card.width - 140; // R√©duit pour laisser place √† la fl√®che
                    const description = typeof card.enigme.description === 'function' ? card.enigme.description() : card.enigme.description;

                    // Limiter la longueur
                    if (ctx.measureText(description).width > maxWidth) {
                        let truncated = description;
                        while (ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                            truncated = truncated.slice(0, -1);
                        }
                        ctx.fillText(truncated + '...', card.x + 90, y + card.height/2 + 18);
                    } else {
                        ctx.fillText(description, card.x + 90, y + card.height/2 + 18);
                    }

                    // Fl√®che d√©roulante √† droite (pour les cartes collect√©es) - PLUS GROSSE
                    const arrowX = card.x + card.width - 30;
                    const arrowY = y + card.height/2;
                    ctx.font = '28px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillText(isExpanded ? '‚ñ≤' : '‚ñº', arrowX, arrowY);
                }

                ctx.restore();
            });
            
            // Dessiner le panneau d√©roulant PAR-DESSUS toutes les cartes (apr√®s la boucle)
            const expandedCard = menuEnigmesCanvas.enigmaCards.find(card => card.id === menuEnigmesCanvas.expandedCard);
            if (expandedCard) {
                const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(expandedCard.id);
                if (isCollected) {
                    let y = expandedCard.y - menuEnigmesCanvas.scrollY + expandedCard.height + 5;
                    
                    const enigme = expandedCard.enigme;
                    const padding = 18;
                    const maxWidth = expandedCard.width - padding * 2;
                    
                    // Pr√©parer les textes - AJUST√â POUR MEILLEURE LISIBILIT√â
                    ctx.font = 'italic 17px Arial';
                    const mystereText = `üí≠ ${typeof enigme.mystere === 'function' ? enigme.mystere() : enigme.mystere}`;
                    const mystereLines = wrapText(ctx, mystereText, maxWidth);
                    
                    ctx.font = '17px Arial';
                    const revelationText = `‚ú® ${typeof enigme.revelation === 'function' ? enigme.revelation() : enigme.revelation}`;
                    const revelationLines = wrapText(ctx, revelationText, maxWidth);
                    
                    ctx.font = 'italic 15px Arial';
                    const sagesseText = `üìñ ${typeof enigme.sagesse === 'function' ? enigme.sagesse() : enigme.sagesse}`;
                    const sagesseLines = wrapText(ctx, sagesseText, maxWidth);
                    
                    // CALCULER LA HAUTEUR DYNAMIQUE en fonction du contenu
                    const lineHeight = 24;
                    const sectionSpacing = 14;
                    const calculatedHeight = padding * 2 + 20 + // padding + marge haut
                        mystereLines.length * lineHeight + sectionSpacing +
                        revelationLines.length * lineHeight + sectionSpacing +
                        sagesseLines.length * lineHeight;
                    
                    // Dessiner le fond du panneau d√©roulant avec HAUTEUR DYNAMIQUE
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    
                    // Ombre pour effet "par-dessus"
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetY = 3;
                    
                    ctx.beginPath();
                    ctx.roundRect(expandedCard.x, y, expandedCard.width, calculatedHeight, 8);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Pas besoin de clipping car la hauteur est calcul√©e dynamiquement
                    
                    // Dessiner le contenu
                    let currentY = y + padding + 20;
                    
                    // Myst√®re - AJUST√â
                    ctx.font = 'italic 17px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    mystereLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    currentY += sectionSpacing;
                    
                    // R√©v√©lation - AJUST√â
                    ctx.font = '17px Arial';
                    ctx.fillStyle = '#2d5016';
                    revelationLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    currentY += sectionSpacing;
                    
                    // Sagesse - AJUST√â
                    ctx.font = 'italic 15px Arial';
                    ctx.fillStyle = '#777';
                    sagesseLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    
                    // Plus besoin d'indicateur "..." car tout le texte est affich√©
                    
                    ctx.restore();
                }
            }
        }

        // Dessiner une info-bulle centr√©e avec texte complet de l'√©nigme
        function dessinerInfoBulleEnigme() {
            const card = menuEnigmesCanvas.hoveredCard;
            if (!card || !card.enigme) return;

            const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
            if (!isCollected) return; // Afficher seulement pour les √©nigmes collect√©es

            ctx.save();

            // Info-bulle CENTR√âE √† l'√©cran
            const maxWidth = Math.min(500, C.W - 60);
            const padding = 25;

            // Pr√©parer le contenu
            const enigme = card.enigme;

            ctx.font = 'bold 26px Arial';
            const titreLines = wrapText(ctx, `${enigme.icone} ${typeof enigme.nom === 'function' ? enigme.nom() : enigme.nom}`, maxWidth - padding * 2);

            ctx.font = 'italic 18px Arial';
            const mystereLines = wrapText(ctx, `üí≠ ${typeof enigme.mystere === 'function' ? enigme.mystere() : enigme.mystere}`, maxWidth - padding * 2);

            ctx.font = '18px Arial';
            const revelationLines = wrapText(ctx, `‚ú® ${typeof enigme.revelation === 'function' ? enigme.revelation() : enigme.revelation}`, maxWidth - padding * 2);

            ctx.font = 'italic 16px Arial';
            const sagesseLines = wrapText(ctx, `üìñ ${typeof enigme.sagesse === 'function' ? enigme.sagesse() : enigme.sagesse}`, maxWidth - padding * 2);

            // Calculer hauteur totale
            const lineHeight = 26;
            const sectionSpacing = 20;
            const totalHeight = padding * 2 +
                titreLines.length * 32 + sectionSpacing +
                mystereLines.length * lineHeight + sectionSpacing +
                revelationLines.length * lineHeight + sectionSpacing +
                sagesseLines.length * lineHeight;

            // Positionner au centre
            const tooltipX = (C.W - maxWidth) / 2;
            const tooltipY = (C.H - totalHeight) / 2;

            // Fond blanc lumineux
            ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(76, 175, 80, 0.5)';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.roundRect(tooltipX, tooltipY, maxWidth, totalHeight, 15);
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Dessiner le contenu
            let currentY = tooltipY + padding;

            // Titre
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            titreLines.forEach(line => {
                ctx.fillText(line, C.W / 2, currentY);
                currentY += 32;
            });
            currentY += sectionSpacing;

            // Myst√®re
            ctx.font = 'italic 18px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'left';
            mystereLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });
            currentY += sectionSpacing;

            // R√©v√©lation
            ctx.font = '18px Arial';
            ctx.fillStyle = '#2d5016';
            revelationLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });
            currentY += sectionSpacing;

            // Sagesse
            ctx.font = 'italic 16px Arial';
            ctx.fillStyle = '#888';
            sagesseLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });

            ctx.restore();
        }

        // V√©rifier le survol des ic√¥nes en haut ET de l'ic√¥ne centrale
        function verifierSurvolIconesHaut(x, y) {
            // V√©rifier le survol de l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                centralIcon.hover = true;
            } else {
                centralIcon.hover = false;
            }

            // V√©rifier le survol des ic√¥nes en haut
            if (!menuEnigmesCanvas.topIcons || menuEnigmesCanvas.topIcons.length === 0) return;

            for (let icon of menuEnigmesCanvas.topIcons) {
                if (x >= icon.x && x <= icon.x + icon.width &&
                    y >= icon.y && y <= icon.y + icon.height) {
                    icon.hover = true;
                } else {
                    icon.hover = false;
                }
            }
        }

        // V√©rifier le survol des cartes d'√©nigmes
        function verifierSurvolCartes(x, y) {
            if (!menuEnigmesCanvas.visible) {
                menuEnigmesCanvas.hoveredCard = null;
                return;
            }

            let cardTrouvee = null;

            for (let card of menuEnigmesCanvas.enigmaCards) {
                const cardY = card.y - menuEnigmesCanvas.scrollY;

                // V√©rifier si la carte est visible et survol√©e
                if (cardY + card.height >= 110 && cardY <= C.H - 40 &&
                    x >= card.x && x <= card.x + card.width &&
                    y >= cardY && y <= cardY + card.height) {

                    const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                    if (isCollected) {
                        cardTrouvee = card;
                        card.hover = true;
                    }
                } else {
                    card.hover = false;
                }
            }

            menuEnigmesCanvas.hoveredCard = cardTrouvee;
        }

        // Fonction utilitaire pour d√©couper le texte en lignes
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Fonction utilitaire pour afficher des messages sp√©ciaux - style bulle discr√®te
        function afficherMessageSpecial(texte, duree = 3000) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 60%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: normal;
                z-index: 10001;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.3);
                animation: messageSpecialAnim 4s ease forwards;
                text-align: center;
                border: 3px solid #FF8C00;
            `;
            messageDiv.innerHTML = texte;

            // Ajouter animation CSS si pas d√©j√† pr√©sente
            if (!document.querySelector('#message-special-style')) {
                const style = document.createElement('style');
                style.id = 'message-special-style';
                style.textContent = `
                    @keyframes messageSpecialAnim {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                        15%, 85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), duree);
        }

        // ===============================================
        // NOUVEAU SYST√àME DE NARRATION COMPLETE V2.0
        // ===============================================

        // Gestionnaire central de la narration
        class NarrationManager {
            constructor() {
                this.currentPhase = 1;
                this.isTransitioning = false;
                this.victoryTimers = new Map();
                this.phaseHistory = [];

                // Configuration des phases avec IDs uniques (textes traduits)
                // Note: les phases seront recharg√©es apr√®s le chargement de i18n
                this.phases = this.loadTranslatedPhases();
            }

            // Recharger les phases avec les nouvelles traductions
            reloadPhases() {
                this.phases = this.loadTranslatedPhases();
                console.log('‚úÖ Phases narratives recharg√©es avec traductions');
            }

            // Fonction helper pour charger les titres et textes traduits
            loadTranslatedPhases() {
                return [
                    {
                        id: 'VDV_NARR_P01_INTRO_LUMIERE',
                        phase: 1,
                        titre: getTranslatedText('narrative.voyage_titles.phase1', 'Voyage ‚Äî L\'aube des doutes'),
                        texte: getTranslatedText('narrative.phase1.text', "On m'a dit qu'ils √©taient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai pr√©f√©r√© aller voir\nde mes propres yeux..."),
                        mode: 'coeurs',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P02_REVELATION_FAMILLE',
                        phase: 2,
                        titre: getTranslatedText('narrative.voyage_titles.phase2', 'Voyage ‚Äî La lumi√®re'),
                        texte: getTranslatedText('narrative.phase2.text', 'Qui √©taient-ils vraiment ?...\nEt j\'ai vu...\nUn p√®re... une m√®re...\ndes enfants...\nTous cherchant simplement √† vivre\nleur meilleure vie...\nComme moi.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'neon',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P03_TRANSITION_OBSCURITE',
                        phase: 3,
                        titre: getTranslatedText('narrative.voyage_titles.phase3', 'Voyage ‚Äî L\'ombre des nuages'),
                        texte: getTranslatedText('narrative.phase3.text', 'Alors, la lune apparut.\nLe ciel s\'assombrit\ncomme une page br√ªl√©e\npar le temps.\nUn aileron fendit les vagues\nsombres...\nDes √©clairs z√©br√®rent\nles nuages gris.\n\nEt avec eux vinrent les maux...\nLes discordes...'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'shadow3d',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P04_CHAPITRE2_NUAGES',
                        phase: 4,
                        titre: getTranslatedText('narrative.voyage_titles.phase4', 'Voyage ‚Äî L\'ombre des nuages'),
                        texte: getTranslatedText('narrative.phase4.text', 'La haine...\nLa destruction...\nLe vol, le mensonge,\nLa manipulation...\nLa cupidit√© et l\'avidit√©,\nComme des cha√Ænes invisibles,\nSerrant le c≈ìur des hommes.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P05_MAUX_CHAINES',
                        phase: 5,
                        titre: getTranslatedText('narrative.voyage_titles.phase5', 'Voyage ‚Äî Le silence de l\'√¢me'),
                        texte: getTranslatedText('narrative.phase5.text', 'On m\'a dit de ne pas √©couter\nleurs cris...\nOn m\'a dit de ne pas laisser\nl\'orage me faire peur.\nCar l\'orage,\naussi bruyant qu\'il soit,\nne dure jamais\n√©ternellement.'),
                        mode: 'nuit_coeurs',
                        duree: 20000,
                        transition: 'fire',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P06_ORAGE_TEMPORAIRE',
                        phase: 6,
                        titre: getTranslatedText('narrative.voyage_titles.phase6', 'Voyage ‚Äî Le silence de l\'√¢me'),
                        texte: getTranslatedText('narrative.phase6.text', 'Et si la temp√™te gronde,\nc\'est peut-√™tre\npour rappeler √† l\'homme\nqu\'au-del√† des nuages,\nil existe toujours\nune lumi√®re.\nMais pour la voir,\nil faut d\'abord traverser\nla nuit...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P07_LUMIERE_NUAGES',
                        phase: 7,
                        titre: getTranslatedText('narrative.voyage_titles.phase7', 'Voyage ‚Äî L\'humanit√© des c≈ìurs'),
                        texte: getTranslatedText('narrative.phase7.text', 'On m\'a dit...\nque l\'humanit√© n\'existait plus,\nqu\'elle s\'√©tait perdue\ndans les guerres\net les rancunes.\nOn m\'a dit que les hommes\nn\'accueillaient\nplus personne,\nqu\'ils s\'enfermaient\nderri√®re des murs de fer\net de peur...'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'outline',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P08_CHAPITRE3_HUMANITE',
                        phase: 8,
                        titre: getTranslatedText('narrative.voyage_titles.phase8', 'Voyage ‚Äî L\'humanit√© des c≈ìurs'),
                        texte: getTranslatedText('narrative.phase8.text', 'Mais moi, j\'ai vu‚Ä¶\nUne main tendue √† un √©tranger.\nUn sourire partag√©\nmalgr√© la faim.\nUne porte ouverte\npour celui qui tremblait\ndans la nuit...'),
                        mode: 'nuit_coeurs',
                        duree: 20000,
                        transition: 'digital',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P09_MAIN_TENDUE',
                        phase: 9,
                        titre: getTranslatedText('narrative.voyage_titles.phase9', 'Voyage ‚Äî L\'humanit√© des c≈ìurs'),
                        texte: getTranslatedText('narrative.phase9.text', 'C\'est cela,\nl\'hospitalit√© :\nnon pas donner ce qu\'on a de trop,\nmais partager\nm√™me ce qui manque...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P10_HOSPITALITE',
                        phase: 10,
                        titre: getTranslatedText('narrative.voyage_titles.phase10', 'Voyage ‚Äî La sagesse des diff√©rences'),
                        texte: getTranslatedText('narrative.phase10.text', 'On m\'a dit que la libert√©\nn\'√©tait qu\'un mot,\nune illusion\nque les puissants\nvendaient aux faibles.\nMais j\'ai vu‚Ä¶\nUn enfant courir pieds nus\nsous la pluie,\nriant sans cha√Ænes,\net dans ses rires,\nj\'ai compris que la libert√©\nvit d\'abord dans l\'√¢me.'),
                        mode: 'coeurs',
                        duree: 40000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P11_LIBERTE_AME',
                        phase: 11,
                        titre: getTranslatedText('narrative.voyage_titles.phase11', 'Voyage ‚Äî La sagesse des diff√©rences'),
                        texte: getTranslatedText('narrative.phase11.text', 'On m\'a dit que les hommes\nn\'aidaient plus,\nque chacun ne vivait que pour soi.\nMais j\'ai vu‚Ä¶\nDes inconnus soulever ensemble\nune pierre trop lourde,\net dans cette force partag√©e,\nj\'ai vu l\'amour na√Ætre.'),
                        mode: 'nuit_coeurs',
                        duree: 30000,
                        transition: 'neon',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P12_AMOUR_PARTAGE',
                        phase: 12,
                        titre: getTranslatedText('narrative.voyage_titles.phase12', 'Voyage ‚Äî La sagesse des diff√©rences'),
                        texte: getTranslatedText('narrative.phase12.text', 'On m\'a dit que l\'amour\n√©tait fragile,\nmais j\'ai vu\nqu\'il est plus fort\nque la haine,\ncar il construit\nquand la haine\nd√©truit...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'fire',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P13_AMOUR_CONSTRUCTION',
                        phase: 13,
                        titre: getTranslatedText('narrative.voyage_titles.phase13', 'Voyage ‚Äî L\'unit√©'),
                        texte: getTranslatedText('narrative.phase13.text', 'On m\'a dit que la tol√©rance\n√©tait une faiblesse,\nmais j\'ai vu qu\'elle est\nune sagesse :\ncelle de reconna√Ætre\nque nous ne sommes pas tous\nsemblables...\nEt c\'est l√†\nle tr√©sor de la vie,\nla voie vers\nla paix.'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'shadow3d',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P14_TOLERANCE_SAGESSE',
                        phase: 14,
                        titre: getTranslatedText('narrative.voyage_titles.phase14', 'Voyage ‚Äî L\'unit√©'),
                        texte: getTranslatedText('narrative.phase14.text', 'La diversit√©‚Ä¶\nElle n\'est pas un danger,\nelle est un tr√©sor.\nComme les couleurs\nd\'un arc-en-ciel,\nc\'est leur diff√©rence\nqui fait na√Ætre la beaut√©.'),
                        mode: 'nuit_coeurs',
                        duree: 30000,
                        transition: 'typewriter',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P15_DIVERSITE_TRESOR',
                        phase: 15,
                        titre: getTranslatedText('narrative.voyage_titles.phase15', 'Voyage ‚Äî L\'unit√©'),
                        texte: getTranslatedText('narrative.phase15.text', 'Et dans ce m√©lange\nd\'humanit√©,\nj\'ai compris\nque nous sommes\nun seul peuple,\nli√© par la m√™me\nsoif de vivre,\nde cr√©er,\net d\'aimer.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P16_UNITE_HUMANITE',
                        phase: 16,
                        titre: getTranslatedText('narrative.voyage_titles.phase16', 'L\'Unit√© de l\'Humanit√©'),
                        texte: getTranslatedText('narrative.phase16.text', 'Le voyage commence,\net je vous souhaite bon vent.\n\nQue le vent vous porte toujours plus loin,\nl√† o√π le bonheur est libre.\n\nL√† o√π les fronti√®res deviennent\ndes promesses, des espoirs,\ndes projets de vie nouvelle.\n\nNe vous arr√™tez pas aux murs\nqui se dressent devant vous\neffroyables et froids,\nn\'abandonnez jamais,\nbrisez les murs,\nde peur, de honte, de ranc≈ìur, de haine,\npour √™tre comme un phare pour les autres.'),
                        mode: 'briques',
                        duree: 999999999,
                        transition: 'neon',
                        speed: 40
                    },
                    // === NOUVEAU CHAPITRE : LE MUR D'AVARICE ===
                    {
                        id: 'VDV_NARR_P17_MUR_VISION',
                        phase: 17,
                        titre: getTranslatedText('narrative.voyage_titles.phase17', 'Voyage ‚Äî Le Mur d\'avarice'),
                        texte: getTranslatedText('narrative.phase17.text', 'Au loin‚Ä¶ je vois un mur.\nUn mur dress√© dans la mer comme une cicatrice.\nUn mur qui n\'est pas fait de pierres,\nmais de lois, de papiers et de regards ferm√©s.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P18_MUR_PRISON',
                        phase: 18,
                        titre: getTranslatedText('narrative.voyage_titles.phase18', 'Voyage ‚Äî Prison de libert√©'),
                        texte: getTranslatedText('narrative.phase18.text', 'Ce mur est la prison de la libert√© des hommes.\nIl s√©pare ceux qui peuvent courir sans cha√Ænes,\net ceux qu\'on enferme dans des fronti√®res invisibles.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P19_MUR_PAUVRES',
                        phase: 19,
                        titre: getTranslatedText('narrative.voyage_titles.phase19', 'Voyage ‚Äî Barbel√©s de refus'),
                        texte: getTranslatedText('narrative.phase19.text', 'Pour les pauvres, il est barbel√© de refus,\nferm√© comme une porte rouill√©e.\nIls y frappent de leurs mains nues,\nleurs r√™ves bris√©s par le silence des gardiens.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'neon',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P20_MUR_RICHES',
                        phase: 20,
                        titre: getTranslatedText('narrative.voyage_titles.phase20', 'Voyage ‚Äî Porte d\'or'),
                        texte: getTranslatedText('narrative.phase20.text', 'Pour les riches, il est une porte d\'or.\nElle s\'ouvre sans effort,\net les laisse circuler comme le vent qui n\'a pas de patrie.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P21_MUR_QUESTION',
                        phase: 21,
                        titre: getTranslatedText('narrative.voyage_titles.phase21', 'Voyage ‚Äî Question de libert√©'),
                        texte: getTranslatedText('narrative.phase21.text', 'Alors je me demande‚Ä¶\nLa libert√© est-elle vraiment un droit,\nou est-elle devenue un privil√®ge vendu aux plus offrants ?'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P22_MUR_ESPOIR',
                        phase: 22,
                        titre: getTranslatedText('narrative.voyage_titles.phase22', 'Voyage ‚Äî L\'espoir des vagues'),
                        texte: getTranslatedText('narrative.phase22.text', 'Mais dans le c≈ìur des vagues,\nla mer murmure une v√©rit√© :\naucun mur n\'est √©ternel.\nCar l\'eau finit toujours par user la pierre,\net la libert√©, t√¥t ou tard,\nreprendra son chemin.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P23_CONCLUSION',
                        phase: 23,
                        titre: getTranslatedText('narrative.voyage_titles.phase23', 'R√©v√©lation'),
                        texte: getTranslatedText('narrative.phase23.text', 'üëÅÔ∏è Ainsi s\'ach√®ve ce voyage...\n\nTu as navigu√© √† travers les temp√™tes,\nbris√© les murs de l\'ignorance,\net d√©couvert que la v√©rit√©\nn\'est pas une fin,\nmais un chemin.\n\nChaque √©nigme r√©solue,\nchaque choix pos√©,\nt\'a rapproch√© de cette sagesse :\n\nüí´ Nous sommes tous\nles gardiens de la lumi√®re.\n\nLa diversit√© n\'est pas une menace,\nmais le plus beau des tr√©sors.\n\n‚õµ Le voyage continue...\nDans ton c≈ìur, dans tes choix,\ndans ta fa√ßon de voir le monde.\n\n--Emmanuel Payet'),
                        mode: 'final',
                        duree: 30000,
                        transition: 'neon',
                        speed: 42
                    }
                ];
            }

            // Obtenir la phase actuelle
            getCurrentPhase() {
                // Trouver la phase par son num√©ro au lieu d'utiliser l'index
                return this.phases.find(phase => phase.phase === this.currentPhase) || null;
            }

            // Obtenir la phase par ID
            getPhaseById(id) {
                return this.phases.find(phase => phase.id === id) || null;
            }

            // Avancer √† la prochaine phase
            nextPhase() {
                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    return false;
                }
                if (modeSecret) {console.log('üö´ Mode secret actif (fallback), nextPhase bloqu√©');
                    return false;
                }

                // Trouver la phase suivante par num√©ro
                const nextPhaseNumber = this.currentPhase + 1;
                const nextPhase = this.phases.find(phase => phase.phase === nextPhaseNumber);

                if (nextPhase) {
                    this.currentPhase = nextPhaseNumber;

                    // üéµ Musique : passer √† la suivante en phase 2
                    if (musicManager && nextPhaseNumber === 2) {
                        musicManager.playNext();
                    }

                    return true;
                } else {
                    return false; // Fin de la narration
                }
            }

            // R√©initialiser la narration
            reset() {
                // //console.log(`[DEBUG] reset() appel√© - retour currentPhase √† 1`);
                this.currentPhase = 1;
                this.phaseHistory = [];
                this.isTransitioning = false;
                this.victoryTimers.clear();
                this.hideStepIndicator();
            }

            // D√©marrer la narration
            start() {console.log(`[NARRATION] start() appel√© - d√©marrage de la narration`);
                this.reset();
                this.executeCurrentPhase(true); // true = afficher texte narratif
            }

            // Ex√©cuter la phase actuelle
            executeCurrentPhase(afficherTexte = false) {
                const phase = this.getCurrentPhase();
                if (!phase) {
                    this.finalizeNarration();
                    return;
                }

                // Afficher le titre du voyage au d√©but de la phase
                this.afficherTitreVoyage(true); // true = d√©but de phase
                this.phaseHistory.push(phase.id);

                this.isTransitioning = true;

                // üîä Jouer le son de vague selon la phase
                AudioSystem.playAmbience();

                // üîä Jouer son d'orage √† la phase 3
                if (phase.phase === 3) {
                    AudioSystem.playOrage();
                }

                // Mettre √† jour l'indicateur d'√©tape
                this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                // Afficher le texte narratif seulement au d√©marrage initial
                if (afficherTexte && phase && phase.texte) {
                    const texte = typeof phase.texte === 'function' ? phase.texte() : phase.texte;
                    this.afficherMessageAnime(texte, phase.transition, phase.speed);
                }

                // Pour les modes non-interactifs, programmer un nextPhase automatique
                // Modes interactifs : coeurs, briques, nuit_coeurs, etoiles, lanterne, mur
                if (phase.mode !== 'coeurs' && phase.mode !== 'briques' && phase.mode !== 'nuit_coeurs' && phase.mode !== 'etoiles' && phase.mode !== 'lanterne' && phase.mode !== 'mur') {
                    setTimeout(() => {
                        this.nextPhase();
                        this.executeCurrentPhase();
                    }, phase.duree);
                }

                // Configurer le mode de jeu
                this.configureGameMode(phase.mode);

                // Marquer la transition comme termin√©e apr√®s configuration
                this.isTransitioning = false;
            }

            // Afficher le titre du voyage
            afficherTitreVoyage(debutPhase = false) {
                const phase = this.currentPhase;
                let voyageNom = '';

                if (phase === 1) {
                    voyageNom = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageNom = 'La lumi√®re';
                } else if (phase >= 3 && phase <= 4) {
                    voyageNom = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageNom = 'Le silence de l\'√¢me';
                } else if (phase >= 7 && phase <= 9) {
                    voyageNom = 'L\'humanit√© des c≈ìurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageNom = 'La sagesse des diff√©rences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageNom = 'L\'unit√©';
                } else if (phase === 16) {
                    voyageNom = 'Animation finale';
                }

                if (voyageNom) {
                    // D√©lai de 15 secondes pour la phase 1 au d√©but, imm√©diat pour les autres cas
                    const delai = (phase === 1 && debutPhase) ? 15000 : 0;

                    setTimeout(() => {
                        titreVoyage.active = true;
                        titreVoyage.texte = voyageNom + '\nPhase ' + phase;
                        titreVoyage.fin = Date.now() + 5000; // 5 secondes
                    }, delai);
                }
            }

            // üìú MESSAGES NARRATIFS DES PHASES - Style simple centr√©
            afficherMessageAnime(texte, animation = 'emboss', speed = 45, onComplete) {
                // Utiliser afficherMessageNarratifSimple() pour toutes les phases
                // Utiliser la dur√©e de la phase actuelle
                const phase = this.getCurrentPhase();
                let duree = phase && phase.duree ? phase.duree : 12000;

                // Phase 16 : texte permanent (dur√©e infinie)
                if (this.currentPhase === 16) {
                    duree = 999999999; // Dur√©e tr√®s longue pour rester affich√©console.log('üìú Texte:', texte.substring(0, 50) + '...');
                    // Forcer l'effacement de l'ancien message
                    messageNarratifActif = null;
                    window.logP16Done = false; // Reset log
                }

                afficherMessageNarratifSimple(texte, duree);

                // Appeler onComplete apr√®s la dur√©e du message si fourni
                if (onComplete) {
                    setTimeout(onComplete, duree);
                }
            }

            // Mettre √† jour l'indicateur d'√©tape
            updateStepIndicator(phase, titre, mode) {
                const indicateur = document.getElementById('etapeIndicateur');
                if (!indicateur) return;

                // Ic√¥ne selon le mode
                let icone = '';
                switch(mode) {
                    case 'coeurs': icone = 'üíñ'; break;
                    case 'nuit_coeurs': icone = 'üåôüíñ'; break;
                    case 'briques': icone = 'üß±'; break;
                    case 'etoiles': icone = '‚≠ê'; break;
                    case 'mur': icone = 'üß±'; break;
                    case 'transition': icone = 'üåä'; break;
                    case 'final': icone = '‚ú®'; break;
                    default: icone = 'üìñ'; break;
                }

                // Mettre √† jour le contenu
                indicateur.innerHTML = `
                    <div>${icone} ${phase}/23</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">${titre}</div>
                `;

                // Afficher l'indicateur
                indicateur.classList.add('show');
            }

            // Cacher l'indicateur d'√©tape
            hideStepIndicator() {
                const indicateur = document.getElementById('etapeIndicateur');
                if (indicateur) {
                    indicateur.classList.remove('show');
                }
            }

            // Configurer le mode de jeu selon la phase
            configureGameMode(mode) {
                // Ne pas reconfigurer si on est d√©j√† dans le bon mode
                // SAUF pour les phases 17-22 (mode MUR) qui doivent recr√©er le mur √† chaque fois
                const phaseNecessiteReconfiguration = this.currentPhase >= 17 && this.currentPhase <= 22 && mode === 'mur';

                if (!phaseNecessiteReconfiguration && (phaseJeu === mode ||
                    (mode === 'coeurs' && phaseJeu === 'tir_coeurs_haut') ||
                    (mode === 'nuit_coeurs' && phaseJeu === 'tir_coeurs_nuit') ||
                    (mode === 'briques' && phaseJeu === 'lanterne') ||
                    (mode === 'etoiles' && phaseJeu === 'stars') ||
                    (mode === 'mur' && phaseJeu === 'mur') ||
                    (mode === 'transition' && phaseJeu === 'transition'))) {
                    //
                    return;
                }

                switch(mode) {
                    case 'coeurs':
                        this.setupCoeursMode();
                        break;
                    case 'nuit_coeurs':
                        this.setupNuitCoeursMode();
                        break;
                    case 'briques':
                        this.setupBriquesMode();
                        break;
                    case 'etoiles':
                        this.setupEtoilesMode();
                        break;
                    case 'mur':
                        this.setupMurMode();
                        break;
                    case 'transition':
                        this.setupTransitionMode();
                        break;
                    case 'final':
                        this.setupFinalMode();
                        break;
                }
            }

            // D√©terminer la p√©riode selon la phase (P3, P5, P11, P12 = nuit)
            getPeriodeFromPhase(phaseNumber) {
                return (phaseNumber === 3 || phaseNumber === 5 || phaseNumber === 11 || phaseNumber === 12) ? 'nuit' : 'jour';
            }

            // Configuration mode c≈ìurs
            async setupCoeursMode() {
                const phase = this.getCurrentPhase();

                // Attendre que les traductions soient charg√©es
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                // D√©sactiver la pluie (sauf si phase 5)
                if (this.currentPhase !== 5) {
                    desactiverPluie();
                }

                // D√©clencher la pluie d'averse en phase 3 (L'ombre des nuages)
                if (this.currentPhase === 3) {
                    setTimeout(() => {
                        if (typeof declencherPluieLumineuse === 'function') {
                            declencherPluieLumineuse();
                        }
                    }, 2000); // Apr√®s 2s pour laisser le temps au message narratif
                }

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);

                // V√©rification finale
                if (JOUR.length === 0 || NUIT.length === 0) {
                    console.error('‚ùå Tableaux toujours vides apr√®s attente !');
                    return;
                }

                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet nuit selon la p√©riode
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les √©toiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les √©clairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode nuit c≈ìurs (parties ambigu√´s)
            async setupNuitCoeursMode() {
                const phase = this.getCurrentPhase();

                // Attendre que les traductions soient charg√©es
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                // Activer la pluie UNIQUEMENT pour la phase 5
                if (this.currentPhase === 5) {
                    activerParticulesP5();
                } else {
                    desactiverPluie();
                }

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);

                // V√©rification finale
                if (JOUR.length === 0 || NUIT.length === 0) {
                    console.error('‚ùå Tableaux NUIT toujours vides apr√®s attente !');
                    return;
                }

                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet visuel de nuit - fond sombre sans affecter les √©toiles/lanterne
                document.body.style.backgroundColor = '#1a1a2e';
                document.body.style.filter = '';

                // Initialiser les √©clairs pour le mode nuit
                eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
            }

            // Configuration mode briques
            setupBriquesMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // D√©sactiver la pluie

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;

                // Phase 16 : FORCER mode tir de c≈ìurs
                if (this.currentPhase === 16) {
                    phaseJeu = 'tir_coeurs_haut';console.log('üìã Phase actuelle:', this.getCurrentPhase());

                    // D√©bloquer les √©nigmes "Lampe" et "Mur de Peur" au d√©but de la phase 16
                    // Notifications espac√©es de 3.5 secondes pour se lire l'une apr√®s l'autre
                    if (enigmaCollector) {
                        setTimeout(() => {
                            const result1 = enigmaCollector.collecterEnigme('lampe', true);
                            score += 1000;
                            window.score = score;
                        }, 1500);

                        setTimeout(() => {
                            const result2 = enigmaCollector.collecterEnigme('mur_peur', true);
                            score += 1000;
                            window.score = score;
                        }, 5000); // 3.5 secondes apr√®s la premi√®re (1.5s + 3.5s = 5s)
                    } else {
                        console.error('‚ùå enigmaCollector NON disponible !');
                    }
                }
                // En mode nuit, alterner entre briques et √©toiles apr√®s phase 3
                else if(periode === 'nuit') {
                    if(this.currentPhase <= 3) {
                        // Phase 3 et avant : toujours √©toiles
                        phaseJeu = 'stars';
                    } else {
                        // Apr√®s phase 3 : alterner entre les phases nocturnes restantes
                        // Phase 5 = √©toiles | Phase 11 = √©toiles | Phase 12 = briques
                        if(this.currentPhase === 12) {
                            phaseJeu = 'lanterne'; // Mode briques en mode nuit
                            balle.visible = true;
                            balle.enAttente = true;
                            balle.dx = 0;
                            balle.dy = 0;
                        } else {
                            phaseJeu = 'stars'; // Mode √©toiles tirables pour P5 et P11
                        }
                    }
                } else {
                    phaseJeu = 'lanterne'; // Mode classique casse-briques avec lanterne
                    balle.visible = true;
                    balle.enAttente = true;
                    balle.dx = 0;
                    balle.dy = 0;
                }

                jeu = true;
                initJeu();

                // Phase 16 : Mode texte narratif pur
                if (this.currentPhase === 16) {
                    // Vider tous les √©l√©ments de jeu - juste le texte
                    briques = [];
                    petitsCoeurs = [];
                    coeursBateau = [];
                    powerUps = [];
                    starsProjectiles = [];console.log('üìú Phase 16 : Mode texte narratif pur (sans gameplay)');
                    // Le bouton Suivant sera activ√© dans goToNextPhaseDirect apr√®s l'affichage du texte
                } else {
                    dedoublerCoeursEnBriques();
                }

                // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                // lanterne.active et lanterne.intensite conserv√©s

                // Effet nuit selon la p√©riode
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les √©toiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les √©clairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode √©toiles
            setupEtoilesMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // D√©sactiver la pluie

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'stars';
                jeu = true;
                initJeu();

                // Phases 17-22 : cr√©er un mur au lieu des briques normales
                if(this.currentPhase >= 17 && this.currentPhase <= 22) {
                    console.log(`üèîÔ∏è Phase ${this.currentPhase} - Cr√©ation mur (mode tir activ√© par setupMurMode)`);
                    creerMurDansLaMer();
                    // Note : Le mode tir MUR est activ√© par setupMurMode(), pas ici
                } else {
                    console.log(`üíé Phase ${this.currentPhase} - Appel dedoublerCoeursEnBriques()`);
                    dedoublerCoeursEnBriques();
                }
            }

            // Configuration mode mur - gameplay de destruction du mur
            setupMurMode() {
                const phaseNum = this.currentPhase; // Num√©ro de phase (17, 18, 19, etc.)
                desactiverPluie(); // D√©sactiver la pluie

                // Configuration du mode mur
                periode = 'jour'; // Le mur est en plein jour
                VOYAGE = JOUR;
                phaseJeu = 'mur'; // D√©finir AVANT initJeu() pour la logique de pr√©servation
                jeu = true;

                // Initialiser le jeu avec des briques en forme de mur
                initJeu(); // Maintenant phaseJeu='mur' est d√©j√† d√©fini, pr√©servera les munitions
                creerMurDansLaMer();
                
                // D√©finir les munitions pour phases 17-22 (syst√®me projectiles progressifs)
                // Phase 23 = fin narrative, pas de tir
                if (phaseNum >= 17 && phaseNum <= 22) {
                    munitions = 9999; // Munitions infinies pour d√©truire le mur (phases 17-22)
                    console.log(`üéØ setupMurMode() - Phase ${phaseNum} - Mode MUR avec projectiles | munitions=${munitions}`);
                } else {
                    console.log(`‚ö†Ô∏è setupMurMode() - Phase ${phaseNum} - Mode MUR sans tir (phase 23)`);
                }

                // üéÅ D√©bloquer une √©nigme unique pour chaque phase du mur (17-22)
                // Chaque √©nigme explore une facette des murs qui s√©parent l'humanit√©
                if (enigmaCollector) {
                    const enigmesParPhase = {
                        17: 'privilege',      // ÔøΩ Orgueil
                        18: 'mur_liberte',    // ‚õìÔ∏è Prison de Libert√©
                        19: 'refus',          // üö´ Les barbel√©s du rejet
                        20: 'avarice',        // ÔøΩüí∞ Le mur de la cupidit√© (billets qui explosent)
                        21: 'inegalites',     // La pyramide des destins
                        // 22: espoir_mur est SECRET - A decouvrir via le power-up arc-en-ciel cache !
                    };

                    const enigmeId = enigmesParPhase[phaseNum];
                    if (enigmeId) {
                        setTimeout(() => {
                            enigmaCollector.collecterEnigme(enigmeId, true);
                            score += 1000;
                            window.score = score;
                            console.log(`üîì √ânigme "${enigmeId}" d√©bloqu√©e en phase ${phaseNum} ! +1000 XP`);
                        }, 1500);
                    }
                }
            }

            // Configuration mode transition - texte + bouton continuer
            setupTransitionMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // D√©sactiver la pluie

                // Mode transition MAIS garder les animations (jeu = true pour que les animations continuent)
                jeu = true; // GARDER LES ANIMATIONS ACTIVES
                phaseJeu = 'transition';

                // Nettoyer les √©l√©ments de jeu
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];
                starsProjectiles = [];

                // Initialiser le bouton canvas
                if (!window.boutonContinuer) {
                    window.boutonContinuer = {
                        visible: true,
                        x: 0,
                        y: 0,
                        width: 200,
                        height: 60,
                        pulseTime: 0
                    };
                }
                window.boutonContinuer.visible = true;
                window.boutonContinuer.pulseTime = Date.now();
            }

            // Fonction vide pour compatibilit√© (le bouton est maintenant dans le canvas)
            showContinueButton() {
                // Le bouton est maintenant dessin√© dans le canvas
            }

            // Configuration mode final
            setupFinalMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // D√©sactiver la pluie

                // Arr√™ter le jeu et nettoyer
                jeu = false;
                phaseJeu = 'final';

                // Nettoyer tous les √©l√©ments de jeu
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                // Passer en mode jour pour la phase finale (fond clair)
                periode = 'jour';

                // Remettre le fond clair
                document.body.style.backgroundColor = '';

                setTimeout(() => {
                    this.finalizeNarration();
                }, phase.duree + 2000);
            }

            // Finaliser la narration
            finalizeNarration() {
                //
                phaseJeu = 'feux_artifice';
                jeu = false;

                // Forcer la mise √† jour des dimensions du canvas
                size = setupCanvas();
                C.W = size.width;
                C.H = size.height;
                C.PW = Math.max(size.width * 0.3, 100);
                C.PH = Math.max(size.height * 0.025, 15);
                C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                C.SP = Math.max(Math.min(size.width, size.height) * 0.002, 1.5);

                // Effacer le message narratif de la phase 23
                messageNarratifActif = null;

                // Cacher l'indicateur d'√©tape
                this.hideStepIndicator();

                // Vider les petits c≈ìurs et briques pour √©viter qu'ils r√©apparaissent
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];

                // D√©bloquer toutes les √©nigmes finales en une seule fois
                if (enigmaCollector) {
                    const enigmesFinales = ['mur_humanite', 'mur_maison', 'mur_vie', 'communautarisme', 'coeur_final'];

                    // D√©bloquer toutes les √©nigmes sans notification individuelle
                    enigmesFinales.forEach(enigmeId => {
                        enigmaCollector.collecterEnigme(enigmeId, true, true); // true = silencieux
                        score += 1000;
                        window.score = score;
                    });

                    // Notification d√©sactiv√©e
                    // setTimeout(() => {
                    //     afficherMessageNarratifSimple('üèÆ Lanterne allum√©e', 4000);
                    // }, 500);
                }

                // Activer l'√©couteur de clic imm√©diatement (√† 25s)
                // Chaque clic d√©clenche une formation diff√©rente
                let formationIndex = 0;
                const formations = ['heart', 'star', 'clock', 'star5', 'cross_christian', 'heart', 'double_heart']; // 7 formations (mur retir√©)
                const dronesNecessaires = {
                    'heart': 30,            // C≈ìur : forme continue
                    'star': 35,             // √âtoile am√©lior√©e : plus de drones pour plus de d√©tails
                    'clock': 60,            // Horloge : cadran + aiguilles anim√©es
                    'star5': 50,            // √âtoile 5 branches : forme classique remplie
                    'cross_christian': 30,  // Croix chr√©tienne r√©duite : forme sacr√©e plus petite
                    'double_heart': 60      // Double c≈ìur : finale romantique
                };

                const lancerDrones = (e = null) => {
                    // Emp√™cher le comportement par d√©faut et la propagation (si √©v√©nement)
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    // Effacer le message d'instruction au premier lancement
                    if (formationIndex === 0) {
                        messageNarratifActif = null;
                    }

                    if (droneModule) {
                        const formation = formations[formationIndex % formations.length];
                        const nbDrones = dronesNecessaires[formation] || 30;

                        // Position cible au centre-haut de l'√©cran
                        const x = C.W * 0.5;
                        const y = C.H * 0.4;

                        droneModule.options.droneCount = nbDrones;
                        droneModule.createDrones(); // Recr√©er les drones avec le bon nombre

                        // D√©placer les drones du bateau vers la position cible
                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        // Traitement sp√©cial pour le double c≈ìur : fusion puis explosion
                        if (formation === 'double_heart') {
                            setTimeout(() => {
                                // Phase 1 : Fusion des deux c≈ìurs (2 secondes)
                                droneModule.fuseDoubleHeart();
                                
                                // Phase 2 : Explosion finale en slow motion (2 secondes plus tard)
                                setTimeout(() => {
                                    droneModule.explodeSlowMotion(x, y); // Explosion sp√©ciale slow motion
                                }, 2000);
                            }, 1000);
                        } else if (formation === 'clock') {
                            // Traitement sp√©cial pour l'horloge : aiguilles anim√©es
                            setTimeout(() => {
                                // Phase 1 : Animer les aiguilles (3 secondes)
                                droneModule.animateClock();
                                
                                // Phase 2 : Explosion apr√®s l'animation
                                setTimeout(() => {
                                    droneModule.explode(x, y);
                                }, 3000);
                            }, 1000);
                        } else {
                            // Explosion normale pour les autres formations
                            setTimeout(() => {
                                droneModule.explode(x, y);
                            }, 1000);
                        }

                        formationIndex++;

                        // Apr√®s 8 formations, afficher le texte final
                        if (formationIndex === formations.length) {
                            // Faire dispara√Ætre les drones apr√®s la derni√®re explosion
                            // Double heart: fusion (2s) + explosion slow motion (dur√©e vie plus longue)
                            // Il faut attendre ~10 secondes pour que l'explosion slow motion se termine compl√®tement
                            setTimeout(() => {
                                if (droneModule) {
                                    droneModule.hide();
                                }
                            }, 10000); // 10 secondes pour laisser l'explosion slow motion se terminer
                            
                            // Afficher le texte final apr√®s un d√©lai
                            setTimeout(() => {
                                // Partie 1 : Le mur
                                afficherMessageNarratifSimple(getTranslatedText('narrative.walls_message', 
                                    'Ces murs sont les n√¥tres,\non les cr√©e par nos conflits,\npar la haine et le racisme,\nl\'intol√©rance des autres,\nla peur de l\'inconnu.\n\nC\'est nous, par nos silences et nos maux,\npar nos peurs murmur√©es,\npar nos mots jet√©s comme des pierres,\nqui les rendons plus solides.\n\nCe sont des murs d\'√©go√Øsme,\nconstruits avec ce qui aurait pu √™tre des toits,\ndes refuges, des foyers.'), 30000);

                                // Partie 2 : Le message d'espoir
                                setTimeout(() => {
                                    const xp = pointsConnaissance || 0;
                                    const scoreJeu = window.score || score;
                                    const scoreTotal = xp + scoreJeu; // XP + Score
                                    const scoreSagesse = Math.round(scoreTotal / 100); // Total / 100 = Sagesse

                                    // G√©n√©rer un ID unique hexad√©cimal pour chaque joueur
                                    const timestamp = Date.now().toString(16); // Timestamp en hex
                                    const random = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0'); // Random en hex
                                    const idUnique = `PB${timestamp}${random}`.toUpperCase();

                                    // Afficher le formulaire Supabase avec callback
                                    if (typeof afficherFormulaireFinDeJeu === 'function') {
                                        afficherFormulaireFinDeJeuAvecResume(xp, scoreJeu, scoreTotal, scoreSagesse, idUnique);
                                    } else {
                                        // Fallback : ancienne m√©thode avec prompts
                                        const nom = prompt(getTranslatedText('database_form.prompt_name')) || getTranslatedText('database_form.anonymous');
                                        const ville = prompt(getTranslatedText('database_form.prompt_city')) || getTranslatedText('database_form.unknown_city');
                                        const pays = prompt(getTranslatedText('database_form.prompt_country')) || getTranslatedText('database_form.unknown_country');

                                        afficherMessageNarratifSimple(getTranslatedText('narrative.final_message', 
                                            'L\'humanit√© n\'a pas besoin de murs pour se prot√©ger,\nmais de ponts pour se rencontrer.\n\nConstruisons avec amour, pas avec peur.\nUn monde uni vaut mieux qu\'un monde cloisonn√©.\n\n- Emmanuel.gallery') + 
                                            '\n\n[' + getTranslatedText('game.origin_journey', 'Origine : Le voyage d\'une vie') + ']\n\n' + nom + ' - ' + ville + ', ' + pays + '\n' + xp + ' XP + ' + scoreJeu + ' Score = ' + scoreTotal + '\n' + getTranslatedText('game.knowledge_given', 'Connaissance donn√©e') + '\n' + getTranslatedText('game.wisdom_score', 'Score de Sagesse') + ' : ' + scoreSagesse + '\nID: ' + idUnique + '\n\n[üåç ' + getTranslatedText('game.share_journey', 'Partager mon voyage') + ']\n\n[' + getTranslatedText('game.restart', 'Recommencer') + ']\n\n#PETITBATEAUROUGE #UnisPourLaPaix', 999999);
                                    }

                                    // Marquer le message comme contenant un bouton restart + lien + partage
                                    if (messageNarratifActif) {
                                        messageNarratifActif.avecRestart = true;
                                        messageNarratifActif.lienLivre = 'https://play.google.com/store/books/details?id=VW42EQAAQBAJ';
                                        messageNarratifActif.avecPartage = true;

                                        // 4 textes de partage diff√©rents
                                        const textesPartage = [
                                            `${getTranslatedText('game.share_texts.text1_title', "üåü J'ai voyag√© √† travers les fronti√®res de l'humanit√© !")}\n\n"${getTranslatedText('game.share_texts.text1_quote', "De l'obscurit√© vers la lumi√®re, j'ai appris que l'amour unit au-del√† des diff√©rences.")}"\n\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,

                                            `${getTranslatedText('game.share_texts.text2_title', 'üïäÔ∏è Un voyage vers la v√©rit√©...')}\n\n"${getTranslatedText('game.share_texts.text2_quote', "J'ai bris√© les murs de la peur pour construire des ponts d'amour.")}"\n\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,

                                            `${getTranslatedText('game.share_texts.text3_title', "üåç De mur en pont, j'ai d√©couvert l'humanit√©...")}\n\n"${getTranslatedText('game.share_texts.text3_quote', 'Au-del√† des fronti√®res, nos c≈ìurs battent √† l\'unisson.')}"\n\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,

                                            `${getTranslatedText('game.share_texts.text4_title', "üëÅÔ∏è J'ai vu la v√©rit√© au-del√† des pr√©jug√©s...")}\n\n"${getTranslatedText('game.share_texts.text4_quote', "Nous construisons des murs par peur, mais l'amour les transforme en refuges.")}"\n\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`
                                        ];

                                        // Choisir un texte al√©atoire
                                        messageNarratifActif.textePartage = textesPartage[Math.floor(Math.random() * textesPartage.length)];
                                    }

                                    // Red√©marrage automatique d√©sactiv√© - le joueur clique sur [Recommencer]
                                    // setTimeout(() => {
                                    //
                                    //     location.reload();
                                    // }, 40000);
                                }, 30000); // 30 secondes apr√®s la partie 1
                            }, 3000); // 3s apr√®s la derni√®re explosion
                        }
                    } else {
                        console.error('‚ùå droneModule non disponible pour les feux d\'artifice !');
                    }
                };

                // D√©marrer les feux d'artifice automatiques
                const lancerFeuxAutomatiques = () => {
                    if (formationIndex < formations.length) {
                        lancerDrones(); // Lancer sans √©v√©nement
                        
                        // Programmer le prochain lancement dans 4 secondes SEULEMENT si ce n'est pas le dernier
                        if (formationIndex < formations.length) {
                            setTimeout(lancerFeuxAutomatiques, 4000);
                        }
                    }
                };

                // D√©marrer le premier feu d'artifice apr√®s 2 secondes
                setTimeout(lancerFeuxAutomatiques, 2000);

                // Afficher un message d'attente √©l√©gant
                afficherMessageNarratifSimple(getTranslatedText('interface.system.fireworks_starting', 'Les feux d\'artifice commencent...'), 6000);
            }

            // G√©n√©rer un r√©sum√© √©l√©gant en 3 lignes
            generateElegantSummary() {
                const completedCount = Math.min(this.currentPhase, this.phases.length);
                const progressPercent = Math.round((completedCount / this.phases.length) * 100);

                return `
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05)); border-radius: 12px; border: 1px solid rgba(100,255,218,0.3);">
                        <div style="color: #64ffda; font-size: 16px; font-weight: 600; margin-bottom: 6px;">
                            ‚ú® ${completedCount}/16 ${getTranslatedText('game.chapters_progress', 'CHAPITRES')} (${progressPercent}%) ‚ú®
                        </div>
                        <div style="color: #ffffff; font-size: 14px; margin: 4px 0; opacity: 0.9;">
                            ${getTranslatedText('game.chapters_subtitle', 'üìö De "La Lumi√®re" √† "L\'Unit√© de l\'Humanit√©"')}
                        </div>
                        <div style="color: #cccccc; font-size: 12px; font-style: italic; opacity: 0.8;">
                            ${getTranslatedText('game.chapters_journey', 'Un voyage √† travers la v√©rit√© de l\'humanit√©')}
                        </div>
                    </div>
                `;
            }

            // Afficher le menu final
            showFinalMenu() {
                // Donner le bonus XP et permettre de rejouer
                giveXPBonus(200);
                
                // Afficher message de f√©licitations
                afficherMessageNarratifSimple(
                    getTranslatedText('end_form.congrats', 'üéâ F√©licitations !'),
                    getTranslatedText('end_form.journey_complete', 'Votre voyage est termin√©'),
                    () => {
                        this.restartKeepScore(); // Rejouer en gardant le score
                    }
                );
            }

            // Red√©marrer en gardant le score (pour rejouer apr√®s la fin)
            restartKeepScore() {
                cacherMessage();

                // Sauvegarder le score actuel AVANT toute r√©initialisation
                const savedScore = score;
                const savedBrises = brises;

                console.log(`üíæ Sauvegarde du score: ${savedScore}, brises: ${savedBrises}`);

                // R√©initialiser le jeu
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                vies = 3;
                jeu = false;

                // R√©initialiser les syst√®mes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les √©l√©ments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // Restaurer le score APR√àS toutes les initialisations
                score = savedScore;
                brises = savedBrises;

                console.log(`‚úÖ Score restaur√©: ${score}, brises: ${brises}`);

                // Red√©marrer la phase d'introduction
                phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
                
                // R√©initialiser l'animation du bateau
                animationBateau.active = true;
            }

            // Red√©marrer la narration (r√©initialisation compl√®te)
            restart() {
                cacherMessage();

                // R√©initialiser compl√®tement
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                score = 0;
                vies = 3;
                brises = 0;
                jeu = false;

                // R√©initialiser les syst√®mes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les √©l√©ments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // üé¨ RETOUR √Ä L'INTRO : Red√©marrer l'animation du bateau
                phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
                animationBateau.active = true;
                
                console.log('üîÑ Jeu compl√®tement r√©initialis√© - Retour √† l\'intro');
            }

            // Fonction appel√©e √† la fin d'une phase
            onPhaseComplete() {
                if (this.isTransitioning) return;

                // Cr√©er un timer de victoire unique
                const timerId = `victory_${Date.now()}_${Math.random()}`;

                this.victoryTimers.set(timerId, setTimeout(() => {
                    this.victoryTimers.delete(timerId);
                    // R√©initialiser les compteurs pour la prochaine phase
                    brises = 0;

                    if (this.nextPhase()) {
                        this.executeCurrentPhase();
                    } else {
                        this.finalizeNarration();
                    }
                }, 1500));
            }

            // M√©thode pour avancer directement √† la phase suivante sans narration
            goToNextPhase() {
                if (this.isTransitioning) return;

                //
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    //
                    this.executeCurrentPhase();
                } else {
                    this.finalizeNarration();
                }
            }

            // Progression directe sans narration - pour la fin des modes
            goToNextPhaseDirect() {
                if (this.isTransitioning) {
                    return;
                }

                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    return;
                }
                if (modeSecret) {console.log('üö´ Mode secret actif (fallback), changement de phase bloqu√©');
                    return;
                }

                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    const phase = this.getCurrentPhase();
                    if (phase) {
                        // Afficher le titre du voyage
                        this.afficherTitreVoyage();

                        // Mettre √† jour l'indicateur d'√©tape
                        this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                        //

                        // Configurer directement le mode de jeu
                        this.configureGameMode(phase.mode);

                        // Afficher le texte narratif APR√àS la configuration
                        if (phase.texte) {
                            setTimeout(() => {
                                const texte = typeof phase.texte === 'function' ? phase.texte() : phase.texte;
                                this.afficherMessageAnime(texte, phase.transition, phase.speed);

                                // Phase 16 : Activer le bouton Suivant apr√®s l'affichage du texte
                                if (this.currentPhase === 16) {
                                    if (!window.boutonSuivantP16) {
                                        window.boutonSuivantP16 = {
                                            visible: false,
                                            x: 0,
                                            y: 0,
                                            width: 150,
                                            height: 50,
                                            texte: getTranslatedText('ui.next_button')
                                        };
                                    }
                                    window.boutonSuivantP16.visible = true;
                                    window.logBoutonP16 = false; // Reset log
                                }
                            }, 200); // Petit d√©lai pour que le mode soit bien configur√©
                        }

                        // Marquer la transition comme termin√©e apr√®s tout
                        setTimeout(() => {
                            this.isTransitioning = false;
                        }, 100);
                    }
                } else {
                    this.finalizeNarration();
                }
            }

            // Alias pour compatibilit√© avec l'ancien code
            onLevelComplete() {
                this.onPhaseComplete();
            }
        }

        // Instance globale du gestionnaire de narration
        window.narrationManager = new NarrationManager();
        const narrationManager = window.narrationManager; // Alias local pour compatibilit√©

        // Si i18n est d√©j√† charg√© (apr√®s DOMContentLoaded), recharger les phases
        if (window.i18n && window.i18n.getCurrentLanguage) {
            setTimeout(() => {
                narrationManager.reloadPhases();
                console.log('üîÑ Phases narratives recharg√©es apr√®s cr√©ation de narrationManager');
            }, 100);
        }

        // ===============================================
        // COMPATIBILIT√â AVEC L'ANCIEN SYST√àME
        // ===============================================

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.08, // Augment√© de 0.03 √† 0.08 pour plus de fluidit√©
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au d√©but - les drones restent hors √©cran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors √©cran √† gauche
                        -100, // Commencer hors √©cran en haut
                        i
                    ));
                }
            }

            setFormation(formation) {
                this.currentFormation = formation;
                // Enregistrer le timestamp pour les animations temporelles
                this.formationStartTime = Date.now();
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                        
                        // Appliquer les propri√©t√©s sp√©ciales de la formation
                        if (positions[index].forceColor) {
                            drone.originalColor = drone.color; // Sauvegarder couleur originale
                            drone.color = positions[index].forceColor;
                            drone.hasSpecialColor = true;
                        } else if (drone.hasSpecialColor) {
                            // Restaurer couleur originale si plus de couleur forc√©e
                            drone.color = drone.originalColor || drone.getRandomColor();
                            drone.hasSpecialColor = false;
                        }
                        
                        // Transf√©rer autres propri√©t√©s sp√©ciales
                        drone.isStarInner = positions[index].isStarInner || false;
                        drone.isStarMid = positions[index].isStarMid || false;
                        drone.isStar5Outline = positions[index].isStar5Outline || false;
                        drone.isStar5Fill = positions[index].isStar5Fill || false;
                        drone.isCrossVertical = positions[index].isCrossVertical || false;
                        drone.isCrossHorizontal = positions[index].isCrossHorizontal || false;
                        drone.isBrokenBrick = positions[index].isBrokenBrick || false;
                        drone.isLeftSide = positions[index].isLeftSide || false;
                        drone.breakIntensity = positions[index].breakIntensity || 0;
                        drone.brickType = positions[index].brickType || 'normal';
                        drone.wallPhase = positions[index].wallPhase || 'uniform'; // Phase du mur
                        drone.isHeart = positions[index].isHeart || false; // C≈ìur dans le mur
                        drone.heartType = positions[index].heartType || 'none'; // Type de c≈ìur
                        drone.sizeEffect = positions[index].sizeEffect || 1.0; // Effet de taille pour la croix
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                // üéÜ Son d'explosion - UN SEUL par tir/explosion
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                // üéÜ Son de feux d'artifice - UN SEUL pour tout le groupe
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }

                this.drones.forEach(drone => {
                    drone.firework();
                });

                // Ne plus recr√©er les drones apr√®s l'explosion - fin du spectacle
                // Les drones disparaissent naturellement avec leur animation d'explosion
                // (Comment√© pour arr√™ter le cycle)
                // setTimeout(() => {
                //     this.createDrones();
                //     this.setFormation(this.currentFormation);
                // }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        // ‚≠ê √âtoile color√©e et homog√®ne avec 8 branches et d√©grad√© chaud
                        const starBranches = 8; // 8 branches au lieu de contour continu
                        const outlineCount = Math.floor(count * 0.45); // 45% pour le contour
                        const midCount = Math.floor(count * 0.35); // 35% pour la zone interm√©diaire
                        const coreCount = count - outlineCount - midCount; // 20% pour le c≈ìur
                        
                        // Palette de couleurs chaudes pour l'√©toile
                        const starColors = [
                            '#FFD700', // Or
                            '#FFA500', // Orange
                            '#FF8C00', // Orange fonc√©
                            '#FFFF00', // Jaune vif
                            '#FFB700', // Ambre
                            '#FFC125'  // Jaune dor√©
                        ];
                        
                        // 1. Contour : 8 branches √©toil√©es avec couleurs vari√©es et homog√®nes
                        for (let i = 0; i < outlineCount; i++) {
                            const branchIndex = Math.floor(i / (outlineCount / starBranches));
                            const posInBranch = (i % (outlineCount / starBranches)) / (outlineCount / starBranches);
                            const angle = (branchIndex / starBranches) * Math.PI * 2 - Math.PI / 2;
                            
                            // Rayon varie pour cr√©er des pointes
                            const maxRadius = size * 1.1;
                            const minRadius = size * 0.6;
                            const radius = minRadius + (maxRadius - minRadius) * (1 - posInBranch);
                            
                            // Couleur selon la branche pour homog√©n√©it√©
                            const colorIndex = branchIndex % starColors.length;
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarOutline: true,
                                forceColor: starColors[colorIndex] // Couleur vari√©e par branche
                            });
                        }
                        
                        // 2. Zone interm√©diaire : d√©grad√© orange-ambre homog√®ne
                        for (let i = 0; i < midCount; i++) {
                            const angle = (i / midCount) * Math.PI * 2;
                            const radius = size * 0.45;
                            
                            // Alterner entre orange et ambre pour homog√©n√©it√©
                            const midColor = i % 2 === 0 ? '#FFA500' : '#FFB700';
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarMid: true,
                                forceColor: midColor // Orange ou ambre altern√©
                            });
                        }
                        
                        // 3. C≈ìur : jaune vif tr√®s brillant et dense
                        for (let i = 0; i < coreCount; i++) {
                            const angle = (i / coreCount) * Math.PI * 2;
                            const radius = size * 0.2;
                            
                            // Alterner jaune vif et or pour brillance homog√®ne
                            const coreColor = i % 2 === 0 ? '#FFFF00' : '#FFD700';
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarInner: true,
                                forceColor: coreColor // Jaune ou or altern√©
                            });
                        }
                        break;

                    case 'clock':
                        // Horloge avec aiguilles : cercle + aiguille heures (points mobiles) + aiguille minutes (ligne fixe)
                        const clockRadius = size * 0.8;
                        const circleCount = Math.floor(count * 0.6); // 60% pour le cercle
                        const hourHandCount = Math.floor(count * 0.25); // 25% pour aiguille des heures
                        const minuteHandCount = count - circleCount - hourHandCount; // 15% pour aiguille des minutes
                        
                        // 1. Cercle de l'horloge
                        for (let i = 0; i < circleCount; i++) {
                            const angle = (i / circleCount) * Math.PI * 2;
                            positions.push({
                                x: centerX + Math.cos(angle) * clockRadius,
                                y: centerY + Math.sin(angle) * clockRadius,
                                isClockCircle: true
                            });
                        }
                        
                        // 2. Aiguille des heures (points) - initialement √† 12h
                        const hourHandLength = clockRadius * 0.5;
                        const hourAngle = -Math.PI / 2; // 12h
                        for (let i = 0; i < hourHandCount; i++) {
                            const progress = (i + 1) / hourHandCount; // Progression sur l'aiguille
                            positions.push({
                                x: centerX + Math.cos(hourAngle) * (progress * hourHandLength),
                                y: centerY + Math.sin(hourAngle) * (progress * hourHandLength),
                                isHourHand: true,
                                handProgress: progress
                            });
                        }
                        
                        // 3. Aiguille des minutes (ligne fixe) - pointant vers 12h
                        const minuteHandLength = clockRadius * 0.8;
                        const minuteAngle = -Math.PI / 2; // 12h fixe
                        for (let i = 0; i < minuteHandCount; i++) {
                            const progress = (i + 1) / minuteHandCount;
                            positions.push({
                                x: centerX + Math.cos(minuteAngle) * (progress * minuteHandLength),
                                y: centerY + Math.sin(minuteAngle) * (progress * minuteHandLength),
                                isMinuteHand: true,
                                isFixed: true // Reste fixe
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'double_heart':
                        // Double c≈ìur simplifi√© : un gros et un petit c≈ìur
                        const bigHeartCount = Math.floor(count * 0.7); // 70% pour le gros c≈ìur
                        const smallHeartCount = count - bigHeartCount; // 30% pour le petit c≈ìur
                        
                        // Gros c≈ìur (√† gauche)
                        for (let i = 0; i < bigHeartCount; i++) {
                            const t = (i / bigHeartCount) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX - size * 0.6 + x * size / 50, // Gros c≈ìur √† gauche
                                y: centerY + y * size / 50,
                                isBigHeart: true
                            });
                        }
                        
                        // Petit c≈ìur (√† droite)
                        for (let i = 0; i < smallHeartCount; i++) {
                            const t = (i / smallHeartCount) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + size * 0.6 + x * size / 80, // Petit c≈ìur √† droite
                                y: centerY + y * size / 80,
                                isSmallHeart: true
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;

                    case 'broken_brick':
                        // üß±üí• MUR AVEC C≈íUR √Ä L'INT√âRIEUR ‚Üí SE BRISE ‚Üí EXPLOSE !
                        const heartDrones = Math.floor(count * 0.2); // 20% pour le c≈ìur
                        const wallDrones = count - heartDrones; // 80% pour le mur
                        
                        const brickRows = Math.ceil(Math.sqrt(wallDrones / 2));
                        const bricksPerRow = Math.ceil(wallDrones / brickRows);
                        const brickWidth = (size * 2) / bricksPerRow;
                        const brickHeight = size / brickRows;
                        
                        // Ligne de rupture verticale au centre
                        const breakLineX = centerX;
                        
                        // Phases temporelles (contr√¥l√©es par l'√¢ge de la formation)
                        const timeElapsed = Date.now() - (this.formationStartTime || Date.now());
                        const phase1Duration = 2000; // 2s uniforme
                        const phase2Duration = 3000; // 3s bris√©
                        // phase3 = explosion (apr√®s 5s total)
                        
                        let wallPhase = 'uniform'; // uniform, breaking, exploded
                        if (timeElapsed > phase1Duration + phase2Duration) {
                            wallPhase = 'exploded';
                        } else if (timeElapsed > phase1Duration) {
                            wallPhase = 'breaking';
                        }
                        
                        // 1. CR√âER LE C≈íUR AU CENTRE ‚ù§Ô∏è
                        const heartSize = size * 0.4; // Taille du c≈ìur
                        for (let i = 0; i < heartDrones; i++) {
                            const angle = (i / heartDrones) * Math.PI * 2;
                            
                            // Forme de c≈ìur param√©trique
                            const t = angle;
                            const heartX = centerX + heartSize * (16 * Math.pow(Math.sin(t), 3)) / 16;
                            const heartY = centerY - heartSize * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
                            
                            let heartColor = '#FF1493'; // Rose profond
                            let heartType = 'heart_core';
                            
                            // Animation du c≈ìur selon la phase
                            if (wallPhase === 'uniform') {
                                // C≈ìur battant doucement
                                heartColor = '#FF69B4'; // Rose vif
                            } else if (wallPhase === 'breaking') {
                                // C≈ìur qui palpite (danger)
                                heartColor = '#FF0000'; // Rouge intense
                            } else {
                                // C≈ìur libre (apr√®s explosion du mur)
                                heartColor = '#FFD700'; // Or brillant (libert√©)
                                heartType = 'heart_free';
                            }
                            
                            positions.push({
                                x: heartX,
                                y: heartY,
                                isHeart: true,
                                heartType: heartType,
                                forceColor: heartColor
                            });
                        }
                        
                        // 2. CR√âER LE MUR AUTOUR
                        for (let row = 0; row < brickRows && positions.length < count; row++) {
                            const rowOffset = (row % 2) * (brickWidth / 2); // D√©calage pour effet briques
                            const bricksInRow = row < brickRows - 1 ? bricksPerRow : wallDrones - (positions.length - heartDrones);
                            
                            for (let col = 0; col < bricksInRow && positions.length < count; col++) {
                                const originalBrickX = centerX - size + rowOffset + col * brickWidth;
                                const originalBrickY = centerY - size / 2 + row * brickHeight;
                                
                                // √âviter de placer des briques trop pr√®s du c≈ìur
                                const distanceToCenter = Math.sqrt(
                                    Math.pow(originalBrickX - centerX, 2) + 
                                    Math.pow(originalBrickY - centerY, 2)
                                );
                                if (distanceToCenter < heartSize * 1.2) {
                                    continue; // Laisser l'espace pour le c≈ìur
                                }
                                
                                // Position initiale uniforme
                                let finalX = originalBrickX;
                                let finalY = originalBrickY;
                                let brickType = 'normal';
                                let color = '#C0C0C0'; // Gris argent uniforme par d√©faut
                                
                                // D√©terminer de quel c√¥t√© de la rupture se trouve cette brique
                                const isLeftSide = originalBrickX < breakLineX;
                                const distanceToBreak = Math.abs(originalBrickX - breakLineX);
                                const maxDistance = size;
                                const breakIntensity = Math.max(0, 1 - (distanceToBreak / maxDistance));
                                
                                if (wallPhase === 'uniform') {
                                    // PHASE 1: Mur uniforme gris argent
                                    color = '#C0C0C0'; // Gris argent uniforme
                                    brickType = 'normal';
                                    
                                } else if (wallPhase === 'breaking') {
                                    // PHASE 2: Mur se brise en deux
                                    const separationDistance = size * 0.4; // Plus de s√©paration
                                    
                                    if (isLeftSide) {
                                        finalX -= separationDistance * breakIntensity;
                                    } else {
                                        finalX += separationDistance * breakIntensity;
                                    }
                                    
                                    // L√©ger d√©calage vertical pour effet d'effondrement
                                    const verticalShift = breakIntensity * (Math.random() - 0.5) * 15;
                                    finalY += verticalShift;
                                    
                                    // Couleurs selon la position
                                    if (distanceToBreak < brickWidth) {
                                        brickType = 'crack_edge';
                                        color = '#A9A9A9'; // Gris sombre (ligne de rupture)
                                    } else if (breakIntensity > 0.5) {
                                        brickType = 'crack_near';
                                        color = '#B8B8B8'; // Gris moyen
                                    } else {
                                        brickType = 'normal';
                                        color = '#C0C0C0'; // Gris argent maintenu
                                    }
                                    
                                } else if (wallPhase === 'exploded') {
                                    // PHASE 3: Explosion compl√®te
                                    const explosionRadius = size * 1.5;
                                    const randomAngle = Math.random() * Math.PI * 2;
                                    const randomDistance = Math.random() * explosionRadius;
                                    
                                    finalX += Math.cos(randomAngle) * randomDistance;
                                    finalY += Math.sin(randomAngle) * randomDistance;
                                    
                                    // Couleurs de d√©bris
                                    const debrisColors = ['#A9A9A9', '#808080', '#696969', '#778899'];
                                    color = debrisColors[Math.floor(Math.random() * debrisColors.length)];
                                    brickType = 'debris';
                                }
                                
                                positions.push({
                                    x: finalX,
                                    y: finalY,
                                    isBrokenBrick: true,
                                    isLeftSide: isLeftSide,
                                    breakIntensity: breakIntensity,
                                    brickType: brickType,
                                    wallPhase: wallPhase,
                                    forceColor: color
                                });
                            }
                        }
                        break;

                    case 'circle':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            positions.push({
                                x: centerX + Math.cos(angle) * size,
                                y: centerY + Math.sin(angle) * size
                            });
                        }
                        break;

                    case 'lantern':
                        // Forme de lanterne (rectangle avec haut/bas arrondis)
                        const lanternHeight = size * 1.5;
                        const lanternWidth = size * 0.8;
                        const pointsPerSide = Math.floor(count / 4);

                        // Haut arrondi
                        for (let i = 0; i < pointsPerSide; i++) {
                            const angle = Math.PI + (i / pointsPerSide) * Math.PI;
                            positions.push({
                                x: centerX + Math.cos(angle) * (lanternWidth / 2),
                                y: centerY - lanternHeight / 2 + Math.sin(angle) * (lanternWidth / 4)
                            });
                        }
                        // C√¥t√© droit
                        for (let i = 0; i < pointsPerSide; i++) {
                            positions.push({
                                x: centerX + lanternWidth / 2,
                                y: centerY - lanternHeight / 2 + (i / pointsPerSide) * lanternHeight
                            });
                        }
                        // Bas arrondi
                        for (let i = 0; i < pointsPerSide; i++) {
                            const angle = (i / pointsPerSide) * Math.PI;
                            positions.push({
                                x: centerX + Math.cos(angle) * (lanternWidth / 2),
                                y: centerY + lanternHeight / 2 + Math.sin(angle) * (lanternWidth / 4)
                            });
                        }
                        // C√¥t√© gauche
                        for (let i = 0; i < count - pointsPerSide * 3; i++) {
                            positions.push({
                                x: centerX - lanternWidth / 2,
                                y: centerY + lanternHeight / 2 - (i / pointsPerSide) * lanternHeight
                            });
                        }
                        break;

                    case 'paix':
                        // Mot PEACE en formation simple
                        const spacing = size / 4;
                        const letterPositions = [
                            // P
                            [0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [2, 0], [2, 1],
                            // E
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 0], [5, 2], [6, 0],
                            // A
                            [8, 0], [8, 1], [8, 2], [8, 3], [9, 0], [9, 2], [10, 0], [10, 1], [10, 2], [10, 3],
                            // C
                            [12, 0], [12, 1], [12, 2], [12, 3], [13, 0], [14, 0],
                            // E
                            [16, 0], [16, 1], [16, 2], [16, 3], [17, 0], [17, 2], [18, 0]
                        ];
                        letterPositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size * 1.5 + pos[0] * spacing,
                                    y: centerY - size * 0.4 + pos[1] * spacing
                                });
                            }
                        });
                        break;

                    case 'respect':
                        // Mot RESPECT (simplifi√©)
                        const spacingR = size / 5;
                        const respPositions = [
                            // R
                            [0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [2, 0], [2, 1], [2, 3],
                            // E
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 0], [5, 2], [5, 3], [6, 0], [6, 2], [6, 3],
                            // S
                            [8, 0], [8, 1], [8, 2], [8, 3], [9, 0], [9, 2], [10, 0], [10, 2], [10, 3]
                        ];
                        respPositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size + pos[0] * spacingR,
                                    y: centerY - size * 0.3 + pos[1] * spacingR
                                });
                            }
                        });
                        break;

                    case 'unite':
                        // Mot UNIT√â (simplifi√©)
                        const spacingU = size / 5;
                        const unitePositions = [
                            // U
                            [0, 0], [0, 1], [0, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3],
                            // N
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 1], [6, 0], [6, 1], [6, 2], [6, 3],
                            // I
                            [8, 0], [8, 1], [8, 2], [8, 3],
                            // T
                            [10, 0], [11, 0], [11, 1], [11, 2], [11, 3], [12, 0]
                        ];
                        unitePositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size * 0.8 + pos[0] * spacingU,
                                    y: centerY - size * 0.3 + pos[1] * spacingU
                                });
                            }
                        });
                        break;

                    case 'star5':
                        // ‚≠ê √âTOILE 5 BRANCHES REMPLIE ! (√âtoile classique)
                        const star5Outline = Math.floor(count * 0.4); // 40% pour le contour
                        const star5Fill = count - star5Outline; // 60% pour le remplissage
                        
                        // Points de l'√©toile 5 branches
                        const outerRadius = size * 0.8;
                        const innerRadius = size * 0.35;
                        const starPoints = [];
                        
                        // Calculer les 10 points (5 externes + 5 internes)
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI) / 5 - Math.PI / 2; // Commencer par le haut
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            starPoints.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius
                            });
                        }
                        
                        // 1. Contour de l'√©toile (tracer les bords)
                        for (let i = 0; i < star5Outline; i++) {
                            const progress = i / star5Outline;
                            const totalPerimeter = starPoints.length;
                            const segmentIndex = Math.floor(progress * totalPerimeter);
                            const segmentProgress = (progress * totalPerimeter) % 1;
                            
                            const currentPoint = starPoints[segmentIndex];
                            const nextPoint = starPoints[(segmentIndex + 1) % starPoints.length];
                            
                            positions.push({
                                x: currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress,
                                y: currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress,
                                isStar5Outline: true,
                                forceColor: '#FFD700' // Or pour le contour
                            });
                        }
                        
                        // 2. Remplissage de l'√©toile (zone int√©rieure)
                        for (let i = 0; i < star5Fill; i++) {
                            // M√©thode de remplissage par √©chantillonnage al√©atoire dans l'√©toile
                            let x, y, inside = false;
                            let attempts = 0;
                            
                            while (!inside && attempts < 50) {
                                // Point al√©atoire dans le rectangle englobant
                                x = centerX + (Math.random() - 0.5) * size * 1.6;
                                y = centerY + (Math.random() - 0.5) * size * 1.6;
                                
                                // Test si le point est √† l'int√©rieur de l'√©toile
                                inside = isPointInStar(x, y, centerX, centerY, outerRadius, innerRadius);
                                attempts++;
                            }
                            
                            if (inside) {
                                positions.push({
                                    x: x,
                                    y: y,
                                    isStar5Fill: true,
                                    forceColor: '#FF6B6B' // Rouge-rose pour le remplissage
                                });
                            }
                        }
                        
                        // Fonction pour tester si un point est dans l'√©toile
                        function isPointInStar(px, py, cx, cy, outerR, innerR) {
                            const dx = px - cx;
                            const dy = py - cy;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) + Math.PI / 2; // Ajuster pour commencer par le haut
                            const normalizedAngle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                            
                            // Quel segment de l'√©toile (chaque segment = 2œÄ/5)
                            const segmentAngle = (2 * Math.PI) / 5;
                            const segmentIndex = Math.floor(normalizedAngle / segmentAngle);
                            const angleInSegment = normalizedAngle % segmentAngle;
                            
                            // Interpoler entre rayon interne et externe selon la position dans le segment
                            const t = angleInSegment / segmentAngle;
                            const effectiveRadius = t <= 0.5 ? 
                                innerR + (outerR - innerR) * (t * 2) : 
                                outerR + (innerR - outerR) * ((t - 0.5) * 2);
                            
                            return distance <= effectiveRadius;
                        }
                        break;

                    case 'cross_christian':
                        // ‚úùÔ∏è CROIX CHR√âTIENNE PLUS PETITE ET √âL√âGANTE
                        const crossVertical = Math.floor(count * 0.6); // 60% pour la barre verticale
                        const crossHorizontal = count - crossVertical; // 40% pour la barre horizontale
                        
                        // Dimensions r√©duites de la croix (taille normale, pas 3x)
                        const crossHeight = size * 1.4; // R√©duit de 3.6 √† 1.4
                        const crossWidth = size * 1.0; // R√©duit de 2.4 √† 1.0
                        const beamThickness = size * 0.2; // R√©duit de 0.45 √† 0.2
                        
                        // Palette arc-en-ciel douce pour effet √©l√©gant
                        const rainbowColors = [
                            '#FF6B6B', // Rouge doux
                            '#FFB347', // Orange p√™che
                            '#FFD700', // Or
                            '#98FB98', // Vert p√¢le
                            '#87CEEB', // Bleu ciel
                            '#9370DB', // Violet moyen
                            '#FF69B4'  // Rose
                        ];
                        
                        // 1. Barre verticale (pied + partie haute) - Arc-en-ciel doux
                        for (let i = 0; i < crossVertical; i++) {
                            const progress = i / (crossVertical - 1 || 1);
                            const y = centerY - crossHeight / 2 + progress * crossHeight;
                            
                            // Effet taille subtil : l√©g√®rement plus gros au centre
                            const distanceFromCenter = Math.abs(progress - 0.5) * 2;
                            const sizeMultiplier = 1.2 - distanceFromCenter * 0.3; // 1.2 au centre, 0.9 aux bords
                            
                            // Couleur arc-en-ciel selon la position verticale
                            const colorIndex = Math.floor(progress * (rainbowColors.length - 1));
                            const rainbowColor = rainbowColors[colorIndex];
                            
                            // R√©partir sur l'√©paisseur de la poutre verticale
                            const offsetX = ((i % 3) - 1) * (beamThickness / 3);
                            
                            positions.push({
                                x: centerX + offsetX,
                                y: y,
                                isCrossVertical: true,
                                sizeEffect: sizeMultiplier,
                                forceColor: rainbowColor
                            });
                        }
                        
                        // 2. Barre horizontale (bras de la croix) - Arc-en-ciel doux
                        for (let i = 0; i < crossHorizontal; i++) {
                            const progress = i / (crossHorizontal - 1 || 1);
                            const x = centerX - crossWidth / 2 + progress * crossWidth;
                            
                            // Position √† 1/3 du haut (proportion classique croix latine)
                            const horizontalY = centerY - crossHeight / 6;
                            
                            // Effet taille subtil
                            const distanceFromCenter = Math.abs(progress - 0.5) * 2;
                            const sizeMultiplier = 1.2 - distanceFromCenter * 0.3;
                            
                            // Couleur arc-en-ciel selon la position horizontale
                            const colorIndex = Math.floor(progress * (rainbowColors.length - 1));
                            const rainbowColor = rainbowColors[colorIndex];
                            
                            // R√©partir sur l'√©paisseur de la poutre horizontale
                            const offsetY = ((i % 3) - 1) * (beamThickness / 3);
                            
                            positions.push({
                                x: x,
                                y: horizontalY + offsetY,
                                isCrossHorizontal: true,
                                sizeEffect: sizeMultiplier,
                                forceColor: rainbowColor
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // Animation s√©par√©e pour mise √† jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options);
                });
                
                // Mise √† jour automatique des formations temporelles
                if (this.currentFormation === 'broken_brick' && this.formationStartTime) {
                    this.updateTemporalFormation();
                }
            }
            
            updateTemporalFormation() {
                // Met √† jour les positions pour les formations temporelles (comme broken_brick)
                const positions = this.getFormationPositions(this.currentFormation, this.drones.length, this.options.size);
                
                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        // Mettre √† jour la cible progressivement
                        drone.setTarget(positions[index].x, positions[index].y);
                        
                        // Mettre √† jour les propri√©t√©s temporelles
                        if (positions[index].forceColor && positions[index].forceColor !== drone.color) {
                            drone.color = positions[index].forceColor;
                        }
                        drone.brickType = positions[index].brickType || 'normal';
                        drone.wallPhase = positions[index].wallPhase || 'uniform';
                        drone.heartType = positions[index].heartType || 'none'; // Mise √† jour du type de c≈ìur
                    }
                });
            }

            render() {
                // Rendu s√©par√© √† appeler depuis la boucle de jeu
                if (!window.droneRenderLogged) {
                    if (this.drones[0]) {console.log('üé® Drone 0 pos:', Math.round(this.drones[0].x), Math.round(this.drones[0].y), 'life:', this.drones[0].life.toFixed(2));
                    }
                    window.droneRenderLogged = true;
                }
                this.drones.forEach(drone => {
                    // Ne dessiner que les drones vivants
                    if (drone.life > 0) {
                        drone.draw(this.ctx, this.options);
                    }
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }

            hide() {
                // Faire dispara√Ætre tous les drones progressivement
                this.drones.forEach((drone, index) => {
                    setTimeout(() => {
                        drone.life = 0; // Forcer la disparition
                        drone.exploding = true;
                        drone.explosionLife = 1; // D√©j√† termin√©
                    }, index * 50); // D√©calage de 50ms entre chaque drone
                });
                
                // Effacer compl√®tement apr√®s 5 secondes
                setTimeout(() => {
                    this.drones = [];
                }, 5000);
            }

            fuseDoubleHeart() {
                // Fusion simple : tous les drones vont vers le centre puis explosent
                const centerX = this.targetX;
                const centerY = this.targetY;
                
                // Animer tous les drones vers le centre
                this.drones.forEach((drone, index) => {
                    // Mouvement vers le centre avec un l√©ger d√©calage circulaire
                    const angle = (index / this.drones.length) * Math.PI * 2;
                    const smallRadius = 20; // Petit cercle au centre
                    
                    drone.setTarget(
                        centerX + Math.cos(angle) * smallRadius,
                        centerY + Math.sin(angle) * smallRadius
                    );
                    drone.speed = 0.12; // Vitesse rapide pour convergence
                    drone.fusionMode = true; // Mode fusion activ√©
                });
                
                console.log('üíï Fusion simple des doubles c≈ìurs vers le centre...');
            }

            animateClock() {
                // Animation horloge : aiguille des heures qui bouge, minutes fixe
                const centerX = this.targetX;
                const centerY = this.targetY;
                const clockRadius = this.options.size * 0.8;
                const totalDuration = 3000; // 3 secondes
                const startTime = Date.now();
                
                // Marquer tous les drones pour l'animation
                this.drones.forEach(drone => {
                    drone.clockAnimation = true;
                    drone.animationStartTime = startTime;
                });
                
                // Animation de l'aiguille des heures
                const animateHourHand = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    // L'aiguille des heures fait un tour complet (12h)
                    const hourAngle = -Math.PI / 2 + (progress * Math.PI * 2);
                    const hourHandLength = clockRadius * 0.5;
                    
                    this.drones.forEach((drone, index) => {
                        const originalPos = this.getFormationPositions('clock', this.drones.length, this.options.size)[index];
                        
                        if (originalPos && originalPos.isHourHand) {
                            // Recalculer la position de l'aiguille des heures
                            const newX = centerX + Math.cos(hourAngle) * (originalPos.handProgress * hourHandLength);
                            const newY = centerY + Math.sin(hourAngle) * (originalPos.handProgress * hourHandLength);
                            
                            drone.setTarget(newX, newY);
                            drone.speed = 0.15; // Vitesse rapide pour suivre
                            drone.clockGlow = true;
                        }
                        // Les autres drones (cercle et aiguille minutes) ne bougent pas
                    });
                    
                    // Continuer l'animation si pas termin√©e
                    if (progress < 1) {
                        setTimeout(animateHourHand, 50); // 50ms
                    }
                };
                
                // D√©marrer l'animation
                animateHourHand();
                console.log('üïê Animation horloge : aiguille des heures en mouvement...');
            }

            explodeSlowMotion(x, y) {
                // Explosion finale en slow motion - plus lente et spectaculaire
                const explosionRadius = 150; // Plus large que normale (120)
                
                // Son d'explosion finale spectaculaire üí•
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }
                
                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explodeSlowMotion(x, y, explosionRadius);
                    }
                });

                // Temps de reset plus long pour l'effet slow motion
                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 4000); // 4 secondes au lieu de 2
                
                console.log('üí• Explosion finale en slow motion...');
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
                this.inSlowMotion = false; // Mode slow motion pour finale
                this.speed = 0.08; // Vitesse augment√©e de 0.03 √† 0.08 pour mouvement plus fluide
                this.glowing = false; // Effet lumineux pour la fusion
                this.fusionMode = false; // Mode fusion activ√©
                this.clockAnimation = false; // Animation horloge
                this.clockGlow = false; // Effet sp√©cial horloge
                this.animationStartTime = 0; // Temps de d√©but d'animation
                this.lightUpDelay = 0; // D√©lai avant allumage (horloge)
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            explodeSlowMotion(explosionX, explosionY, radius) {
                // Explosion en slow motion - plus lente et spectaculaire
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 12; // Force r√©duite (18 ‚Üí 12)

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 4; // Gravit√© r√©duite (6 ‚Üí 4)
                    this.inExplosion = true;
                    this.inSlowMotion = true; // Mode slow motion
                    this.life = 1.0;

                    // Couleurs dor√©es/roses pour la finale romantique
                    const finaleColors = ['#FFD700', '#FF69B4', '#FFA500', '#FF1493', '#FFFF00'];
                    this.color = finaleColors[Math.floor(Math.random() * finaleColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
                // Le son est jou√© au niveau du module, pas ici
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options) {
                if (this.inExplosion) {
                    // Appliquer slow motion si activ√©
                    const motionFactor = this.inSlowMotion ? 0.4 : 1.0; // 40% de vitesse en slow motion
                    
                    this.x += this.explosionVelX * motionFactor;
                    this.y += this.explosionVelY * motionFactor;
                    this.explosionVelY += 0.3 * motionFactor; // Gravit√© aussi ralentie
                    
                    // Vie qui diminue plus lentement en slow motion
                    const lifeDecay = this.inSlowMotion ? 0.008 : 0.015;
                    this.life -= lifeDecay;
                    if (this.life <= 0) this.life = 0;
                } else {
                    // Mouvement fluide et relaxant (sauf horloge qui garde sa rapidit√©)
                    let currentSpeed = this.clockAnimation ? 0.12 : 0.08; // Horloge rapide, autres fluides
                    
                    if (this.fusionMode) {
                        currentSpeed = 0.08; // Fusion fluide
                    }
                    
                    // Interpolation douce avec easing
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Ralentir √† l'approche de la cible (easing)
                    const easingFactor = Math.min(1, distance / 100);
                    this.x += dx * currentSpeed * easingFactor;
                    this.y += dy * currentSpeed * easingFactor;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    // Tra√Æn√©es plus longues et lumineuses (18 au lieu de 12)
                    if (this.trail.length > 18) this.trail.shift();
                }

                // Effets de brillance selon le mode - plus doux
                if (this.fusionMode) {
                    this.brightness = 0.8 + Math.sin(Date.now() * 0.01 + this.id) * 0.3; // Pulsation plus lente
                } else if (this.clockAnimation) {
                    // Effet horloge : s'allumer progressivement selon le d√©lai
                    const elapsed = Date.now() - this.animationStartTime;
                    if (elapsed >= this.lightUpDelay) {
                        this.clockGlow = true;
                        this.brightness = 1.0; // Pleine brillance quand allum√©
                    } else {
                        this.brightness = 0.3; // Faible brillance en attente
                    }
                } else {
                    // Pulsation douce et relaxante
                    this.brightness = 0.7 + Math.sin(Date.now() * 0.005 + this.id) * 0.2;
                }
            }

            draw(ctx, options) {
                if (this.life <= 0) return;

                // Tra√Æn√©es lumineuses √©l√©gantes et visibles
                if (options.showTrails && this.trail.length > 1) {
                    // Tra√Æn√©e avec d√©grad√© progressif et glow pour effet lumineux
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = (i / this.trail.length) * 0.7; // Opacit√© plus forte (0.4 ‚Üí 0.7)
                        const width = (i / this.trail.length) * 4; // Largeur plus √©paisse (3 ‚Üí 4)
                        
                        // Effet glow sur la tra√Æn√©e
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = this.color;
                        
                        ctx.strokeStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        ctx.lineWidth = width;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.stroke();
                        
                        // R√©initialiser le shadow
                        ctx.shadowBlur = 0;
                    }
                }

                // Effet visuel simplifi√© selon le mode - GLOW PLUS PETIT ET TAILLES VARI√âES
                let glowSize = 5; // R√©duit de 8 √† 5 (glow plus petit)
                let coreSize = 1.5 * this.life; // R√©duit de 2 √† 1.5
                let intensityMultiplier = 1.0;
                
                if (this.fusionMode) {
                    // En mode fusion : plus brillant mais glow r√©duit
                    glowSize = 8; // R√©duit de 12 √† 8
                    coreSize = 2.2 * this.life; // R√©duit de 3 √† 2.2
                    intensityMultiplier = 1.5; // Plus brillant
                } else if (this.inSlowMotion) {
                    // En mode slow motion : tr√®s brillant mais glow r√©duit
                    glowSize = 10; // R√©duit de 15 √† 10
                    coreSize = 3 * this.life; // R√©duit de 4 √† 3
                    intensityMultiplier = 2.0; // Tr√®s brillant
                } else if (this.clockGlow) {
                    // En mode horloge : brillance moyenne, glow r√©duit
                    glowSize = 7; // R√©duit de 10 √† 7
                    coreSize = 1.8 * this.life; // R√©duit de 2.5 √† 1.8
                    intensityMultiplier = 1.2; // L√©g√®rement plus brillant
                } else if (this.isStar5Outline) {
                    // Contour √©toile 5 branches : color√© et homog√®ne
                    glowSize = 9; // R√©duit de 12 √† 9
                    coreSize = 2.5 * this.life; // R√©duit de 3 √† 2.5
                    intensityMultiplier = 1.8; // Tr√®s brillant et color√©
                } else if (this.isStar5Fill) {
                    // Remplissage √©toile 5 branches : homog√®ne
                    glowSize = 7; // R√©duit de 9 √† 7
                    coreSize = 2 * this.life; // R√©duit de 2.3 √† 2
                    intensityMultiplier = 1.3; // Plus brillant pour homog√©n√©it√©
                } else if (this.isStarMid) {
                    // Zone interm√©diaire √©toile : color√©e et homog√®ne
                    glowSize = 8; // R√©duit de 11 √† 8
                    coreSize = 2.3 * this.life; // R√©duit de 2.8 √† 2.3
                    intensityMultiplier = 1.5; // Plus brillant pour homog√©n√©it√©
                } else if (this.isCrossVertical) {
                    // Barre verticale croix : pulse comme un c≈ìur avec tailles vari√©es
                    const heartPulse = Math.sin(Date.now() * 0.003) * 0.2 + 1; // Pulsation cardiaque
                    const sizeVariation = 0.8 + Math.random() * 0.6; // Taille vari√©e (0.8-1.4)
                    const sizeMultiplier = (this.sizeEffect || 1.2) * sizeVariation;
                    glowSize = 7 * sizeMultiplier * heartPulse; // R√©duit de 10 √† 7 + pulse
                    coreSize = 2 * this.life * sizeMultiplier * heartPulse; // R√©duit de 2.5 √† 2 + pulse
                    intensityMultiplier = 1.7 * heartPulse; // Brillant + pulsation
                } else if (this.isCrossHorizontal) {
                    // Barre horizontale croix : pulse comme un c≈ìur avec tailles vari√©es
                    const heartPulse = Math.sin(Date.now() * 0.003) * 0.2 + 1; // Pulsation cardiaque
                    const sizeVariation = 0.8 + Math.random() * 0.6; // Taille vari√©e (0.8-1.4)
                    const sizeMultiplier = (this.sizeEffect || 1.2) * sizeVariation;
                    glowSize = 7 * sizeMultiplier * heartPulse; // R√©duit de 10 √† 7 + pulse
                    coreSize = 2 * this.life * sizeMultiplier * heartPulse; // R√©duit de 2.5 √† 2 + pulse
                    intensityMultiplier = 1.6 * heartPulse; // Brillant + pulsation
                } else if (this.isHeart) {
                    // ‚ù§Ô∏è C≈íUR dans le mur : effets selon le type
                    if (this.heartType === 'heart_free') {
                        // C≈ìur lib√©r√© : tr√®s brillant et grand
                        glowSize = 18;
                        coreSize = 4 * this.life;
                        intensityMultiplier = 2.2; // Tr√®s brillant (libert√©)
                    } else if (this.heartType === 'heart_core') {
                        // C≈ìur prot√©g√© : brillance pulsante
                        const pulsation = Math.sin(Date.now() * 0.005) * 0.3 + 1; // Battement
                        glowSize = 12 * pulsation;
                        coreSize = 3 * this.life * pulsation;
                        intensityMultiplier = 1.6 * pulsation; // Pulsation cardiaque
                    } else {
                        // C≈ìur normal : brillance moyenne
                        glowSize = 10;
                        coreSize = 2.5 * this.life;
                        intensityMultiplier = 1.3; // Brillance chaleureuse
                    }
                } else if (this.isBrokenBrick) {
                    // Briques bris√©es : brillance selon le type et la phase
                    if (this.brickType === 'debris') {
                        // Phase explosion : d√©bris dispers√©s
                        glowSize = 6;
                        coreSize = 1.5 * this.life;
                        intensityMultiplier = 0.7; // Moins brillant (d√©bris)
                    } else if (this.brickType === 'crack_edge') {
                        // Briques sur la ligne de rupture : tr√®s brillantes
                        glowSize = 14;
                        coreSize = 3.2 * this.life;
                        intensityMultiplier = 1.8; // Tr√®s brillant (zone de rupture)
                    } else if (this.brickType === 'crack_near') {
                        // Briques proches de la rupture : moyennement brillantes
                        glowSize = 11;
                        coreSize = 2.5 * this.life;
                        intensityMultiplier = 1.3; // Moyennement brillant (endommag√©)
                    } else {
                        // Briques normales (uniform ou breaking) : brillance selon la phase
                        if (this.wallPhase === 'uniform') {
                            // Phase uniforme : brillance argentine
                            glowSize = 9;
                            coreSize = 2.2 * this.life;
                            intensityMultiplier = 1.1; // Brillance m√©tallique
                        } else {
                            // Phase breaking : brillance normale
                            glowSize = 8;
                            coreSize = 2 * this.life;
                            intensityMultiplier = 0.9; // L√©g√®rement moins brillant
                        }
                    }
                }
                
                // Gradient simple avec intensit√© modifi√©e
                const adjustedBrightness = this.brightness * intensityMultiplier;
                
                // Convertir la couleur hex en rgba pour l'opacit√©
                const hex = this.color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${adjustedBrightness * this.life})`);
                gradient.addColorStop(0.8, `rgba(${r}, ${g}, ${b}, 0.19)`); // 30 en hex = 0.19 en alpha
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // C≈ìur du drone avec intensit√©
                ctx.fillStyle = this.color;
                ctx.globalAlpha = adjustedBrightness * this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Restaurer l'opacit√© normale
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // INITIALISATION SUPABASE
        // ===============================================
        let supabaseScores = null;
        let leaderboardData = null;
        let loadingLeaderboard = false;
        let userBestScore = null; // Meilleur score de l'utilisateur connect√©

        // Initialiser Supabase au d√©marrage
        setTimeout(async () => {
            if (typeof SupabaseScores !== 'undefined') {
                supabaseScores = new SupabaseScores();

                // Attendre que le client soit pr√™t (augmentation du d√©lai)
                setTimeout(async () => {
                    // V√©rifier que le client est bien initialis√©
                    if (supabaseScores && supabaseScores.client) {
                        await supabaseScores.setCurrentGame('Petit Bateau');

                        // Charger le classement initial
                        await chargerClassement();
                    } else {
                        console.warn('‚è≥ Client Supabase pas encore pr√™t, nouvelle tentative...');
                        setTimeout(async () => {
                            if (supabaseScores && supabaseScores.client) {
                                await supabaseScores.setCurrentGame('Petit Bateau');
                                await chargerClassement();
                            }
                        }, 2000);
                    }
                }, 3000);
            }
        }, 1000);

        // Fonction pour charger le classement
        async function chargerClassement() {
            if (!supabaseScores) return;

            loadingLeaderboard = true;
            try {
                leaderboardData = await supabaseScores.getLeaderboard(10);
            } catch (error) {
                console.error('‚ùå Erreur chargement classement:', error);
                leaderboardData = [];
            }
            loadingLeaderboard = false;
        }

        // Syst√®me de niveaux de sagesse (15 niveaux th√©matiques)
        function getNiveauSagesse(scoreSagesse) {
            if (scoreSagesse >= 300) return { titre: getTranslatedText('levels.robe_blanche.name', 'Robe Blanche'), icone: 'üëº', couleur: '#ffffff', seuil: 300, prochain: null };
            if (scoreSagesse >= 250) return { titre: getTranslatedText('levels.saint_navigator.name', 'Saint Navigateur'), icone: '‚õ™', couleur: '#e8f4f8', seuil: 250, prochain: 300 };
            if (scoreSagesse >= 200) return { titre: getTranslatedText('levels.prophet.name', 'Proph√®te des Mers'), icone: 'üôè', couleur: '#ffd700', seuil: 200, prochain: 250 };
            if (scoreSagesse >= 175) return { titre: getTranslatedText('levels.illuminated.name', 'Illumin√©'), icone: 'üí´', couleur: '#f1c40f', seuil: 175, prochain: 200 };
            if (scoreSagesse >= 150) return { titre: getTranslatedText('levels.disciple.name', 'Disciple de la Lumi√®re'), icone: '‚ú®', couleur: '#e67e22', seuil: 150, prochain: 175 };
            if (scoreSagesse >= 125) return { titre: getTranslatedText('levels.contemplative.name', 'Contemplatif'), icone: 'üßò', couleur: '#9b59b6', seuil: 125, prochain: 150 };
            if (scoreSagesse >= 100) return { titre: getTranslatedText('levels.guardian.name', 'Gardien de la Lumi√®re'), icone: 'üïØÔ∏è', couleur: '#8e44ad', seuil: 100, prochain: 125 };
            if (scoreSagesse >= 80) return { titre: getTranslatedText('levels.meditating.name', 'M√©ditant'), icone: 'üïäÔ∏è', couleur: '#3498db', seuil: 80, prochain: 100 };
            if (scoreSagesse >= 60) return { titre: getTranslatedText('levels.captain.name', 'Capitaine'), icone: '‚õµ', couleur: '#2980b9', seuil: 60, prochain: 80 };
            if (scoreSagesse >= 45) return { titre: getTranslatedText('levels.navigator.name', 'Navigateur'), icone: 'üß≠', couleur: '#16a085', seuil: 45, prochain: 60 };
            if (scoreSagesse >= 30) return { titre: getTranslatedText('levels.enlightened_sailor.name', 'Marin √âclair√©'), icone: '‚öì', couleur: '#27ae60', seuil: 30, prochain: 45 };
            if (scoreSagesse >= 20) return { titre: getTranslatedText('levels.initiate.name', 'Initi√©'), icone: 'üîç', couleur: '#2ecc71', seuil: 20, prochain: 30 };
            if (scoreSagesse >= 10) return { titre: getTranslatedText('levels.apprentice.name', 'Apprenti'), icone: 'üåä', couleur: '#7f8c8d', seuil: 10, prochain: 20 };
            if (scoreSagesse >= 5) return { titre: getTranslatedText('levels.cabin_boy.name', 'Mousse'), icone: 'üßô', couleur: '#95a5a6', seuil: 5, prochain: 10 };
            return { titre: getTranslatedText('levels.pilgrim.name', 'P√®lerin'), icone: '‚õµ', couleur: '#bdc3c7', seuil: 0, prochain: 5 };
        }

        // Fonction pour obtenir les badges sp√©ciaux
        function getBadges(donnees, isTopPlayer, enigmesCollectees) {
            const badges = [];

            // Badge Top 1
            if (isTopPlayer) {
                badges.push({ icone: 'üëë', titre: getTranslatedText('badges.champion.name', 'Champion') });
            }

            // Badge Perfectionniste (si toutes les √©nigmes collect√©es)
            if (enigmesCollectees && enigmesCollectees >= 18) { // Nombre total d'√©nigmes
                badges.push({ icone: 'üíé', titre: getTranslatedText('badges.perfectionist.name', 'Perfectionniste') });
            }

            // Badge Contemplatif (si beaucoup de temps pass√©)
            if (donnees && donnees.temps_jeu && donnees.temps_jeu > 3600) { // Plus d'1h
                badges.push({ icone: '‚è≥', titre: getTranslatedText('badges.contemplative.name', 'Contemplatif') });
            }

            return badges;
        }

        // Variable pour savoir si le formulaire a √©t√© affich√©
        let formulaireFinAffiche = false;

        // Fonction pour afficher le formulaire avec r√©sum√© (appel√©e apr√®s feux d'artifice)
        function afficherFormulaireFinDeJeuAvecResume(xp, scoreJeu, scoreTotal, scoreSagesse, idUnique) {
            if (formulaireFinAffiche) return;
            formulaireFinAffiche = true;

            // R√©cup√©rer les dimensions du canvas avec fallback
            let canvasWidth, canvasHeight, canvasLeft, canvasTop;
            
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const canvasRect = canvas.getBoundingClientRect();
                canvasWidth = canvasRect.width;
                canvasHeight = canvasRect.height;
                canvasLeft = canvasRect.left;
                canvasTop = canvasRect.top;
            } else {
                // Fallback si le canvas n'est pas disponible
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                canvasLeft = 0;
                canvasTop = 0;
            }

            const html = `
                <div id="formulaire-fin-overlay" style="position: fixed; top: ${canvasTop}px; left: ${canvasLeft}px; width: ${canvasWidth}px; height: ${canvasHeight}px; background: rgba(0,0,0,0.9); z-index: 20000; display: flex; align-items: center; justify-content: center; overflow-y: auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 15px; max-width: 90%; width: 600px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); margin: 20px; color: white;">
                        <h2 style="margin: 0 0 15px 0; text-align: center; color: white; font-family: 'Segoe UI', sans-serif; font-size: 28px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">${getTranslatedText('ui.journey_completed_title')}</h2>

                        <!-- R√©sum√© des scores -->
                        <div style="background: rgba(0,0,0,0.3); padding: 25px; border-radius: 15px; margin-bottom: 20px; color: white; border: 2px solid rgba(255,255,255,0.2);">
                            <div style="text-align: center; font-size: 16px; opacity: 0.95; margin-bottom: 15px; font-weight: 600;">${getTranslatedText('ui.your_progress')}</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                <div style="text-align: center; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                                    <div style="font-size: 32px; font-weight: bold;">üí°</div>
                                    <div style="font-size: 28px; font-weight: bold; margin-top: 5px;">${xp}</div>
                                    <div style="font-size: 12px; opacity: 0.9; margin-top: 3px;">${getTranslatedText('game.xp_label', 'XP')}</div>
                                </div>
                                <div style="text-align: center; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                                    <div style="font-size: 32px; font-weight: bold;">üéØ</div>
                                    <div style="font-size: 28px; font-weight: bold; margin-top: 5px;">${scoreJeu}</div>
                                    <div style="font-size: 12px; opacity: 0.9; margin-top: 3px;">${getTranslatedText('game.score_label', 'Score')}</div>
                                </div>
                            </div>
                            <div style="text-align: center; padding: 20px; background: rgba(255,255,255,0.15); border-radius: 10px; margin-bottom: 15px;">
                                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">${getTranslatedText('end_form.total_label', 'Total')}</div>
                                <div style="font-size: 42px; font-weight: bold;">${scoreTotal}</div>
                            </div>
                            <div style="text-align: center; margin-top: 15px; padding: 15px; background: rgba(255,215,0,0.2); border-radius: 10px; border: 2px solid rgba(255,215,0,0.3);">
                                <div style="font-size: 36px; margin-bottom: 5px;">üíé</div>
                                <div style="font-size: 32px; font-weight: bold; color: #FFD700;">${scoreSagesse}</div>
                                <div style="font-size: 13px; opacity: 0.95; margin-top: 3px;">${getTranslatedText('end_form.wisdom_score', 'Score de Sagesse')}</div>
                            </div>
                            <div style="text-align: center; margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-size: 28px;">${(() => { const n = getNiveauSagesse(scoreSagesse); return n.icone; })()}</div>
                                <div style="font-size: 18px; font-weight: 600; margin-top: 5px;">${(() => { const n = getNiveauSagesse(scoreSagesse); return n.titre; })()}</div>
                                <div style="font-size: 11px; opacity: 0.85; margin-top: 3px;">${getTranslatedText('game.wisdom_level', 'Niveau de sagesse')}</div>
                                ${(() => {
                                    const n = getNiveauSagesse(scoreSagesse);
                                    if (n.prochain) {
                                        const prog = scoreSagesse - n.seuil;
                                        const total = n.prochain - n.seuil;
                                        const pct = Math.round((prog / total) * 100);
                                        return '<div style="margin-top: 8px;">' +
                                            '<div style="font-size: 10px; opacity: 0.8; margin-bottom: 3px;">' + scoreSagesse + '/' + n.prochain + ' ' + getTranslatedText('game.next_level', 'vers le prochain niveau') + '</div>' +
                                            '<div style="width: 100%; height: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow: hidden;">' +
                                                '<div style="width: ' + pct + '%; height: 100%; background: rgba(255,215,0,0.9); transition: width 0.3s;"></div>' +
                                            '</div>' +
                                        '</div>';
                                    }
                                    return '';
                                })()}
                            </div>
                            <div style="text-align: center; margin-top: 12px; font-size: 11px; opacity: 0.7; font-family: monospace;">ID: ${idUnique}</div>
                        </div>

                        <p style="text-align: center; color: rgba(255,255,255,0.8); margin-bottom: 20px; font-size: 15px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${getTranslatedText('ui.save_score_ranking')}</p>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 5px; color: white; font-size: 14px; font-weight: 600;" data-i18n="ui.form.email_label">Email * :</label>
                            <input type="email" id="fin-email" data-i18n-placeholder="ui.form.email_placeholder" placeholder="Votre adresse email" style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 16px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 5px; color: white; font-size: 14px; font-weight: 600;" data-i18n="ui.form.pseudo_label">Pseudo * :</label>
                            <input type="text" id="fin-pseudo" data-i18n-placeholder="ui.form.pseudo_placeholder" placeholder="Votre pseudo" style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 16px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 8px; color: white; font-size: 14px; font-weight: 600;" data-i18n="ui.form.avatar_label">Avatar :</label>
                            <div id="avatar-selector" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px; max-height: 200px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.2);">
                                <div class="avatar-option" data-avatar="‚úùÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚úùÔ∏è</div>
                                <div class="avatar-option" data-avatar="‚Ä†" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚Ä†</div>
                                <div class="avatar-option" data-avatar="‚úö" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚úö</div>
                                <div class="avatar-option" data-avatar="‚úü" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚úü</div>
                                <div class="avatar-option" data-avatar="‚úû" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚úû</div>
                                <div class="avatar-option" data-avatar="+" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">+</div>
                                <div class="avatar-option" data-avatar="‚ûï" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚ûï</div>
                                <div class="avatar-option" data-avatar="‚õ™" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚õ™</div>
                                <div class="avatar-option" data-avatar="üïå" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üïå</div>
                                <div class="avatar-option" data-avatar="‚ù§Ô∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚ù§Ô∏è</div>
                                <div class="avatar-option" data-avatar="ü¶Ñ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶Ñ</div>
                                <div class="avatar-option" data-avatar="üåà" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåà</div>
                                <div class="avatar-option" data-avatar="üëº" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üëº</div>
                                <div class="avatar-option" data-avatar="ü¶â" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶â</div>
                                <div class="avatar-option" data-avatar="ü¶Ö" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶Ö</div>
                                <div class="avatar-option" data-avatar="üå∏" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üå∏</div>
                                <div class="avatar-option" data-avatar="‚òÅÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚òÅÔ∏è</div>
                                <div class="avatar-option" data-avatar="ü¶á" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶á</div>
                                <div class="avatar-option" data-avatar="üïäÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üïäÔ∏è</div>
                                <div class="avatar-option" data-avatar="‚õ∞Ô∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚õ∞Ô∏è</div>
                                <div class="avatar-option" data-avatar="üê±" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üê±</div>
                                <div class="avatar-option" data-avatar="üê∂" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üê∂</div>
                                <div class="avatar-option" data-avatar="ü¶ä" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶ä</div>
                                <div class="avatar-option" data-avatar="üêº" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üêº</div>
                                <div class="avatar-option" data-avatar="ü¶Å" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶Å</div>
                                <div class="avatar-option" data-avatar="üêØ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üêØ</div>
                                <div class="avatar-option" data-avatar="üêâ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üêâ</div>
                                <div class="avatar-option" data-avatar="üê≤" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üê≤</div>
                                <div class="avatar-option" data-avatar="üåπ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåπ</div>
                                <div class="avatar-option" data-avatar="üñ§" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üñ§</div>
                                <div class="avatar-option" data-avatar="üêô" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üêô</div>
                                <div class="avatar-option" data-avatar="ü¶ã" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">ü¶ã</div>
                                <div class="avatar-option" data-avatar="üêù" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üêù</div>
                                <div class="avatar-option" data-avatar="üê¢" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üê¢</div>
                                <div class="avatar-option" data-avatar="üê†" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üê†</div>
                                <div class="avatar-option" data-avatar="üåü" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåü</div>
                                <div class="avatar-option" data-avatar="‚≠ê" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚≠ê</div>
                                <div class="avatar-option" data-avatar="üí´" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üí´</div>
                                <div class="avatar-option" data-avatar="‚ú®" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚ú®</div>
                                <div class="avatar-option" data-avatar="üåô" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåô</div>
                                <div class="avatar-option" data-avatar="‚òÄÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚òÄÔ∏è</div>
                                <div class="avatar-option" data-avatar="üåä" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåä</div>
                                <div class="avatar-option" data-avatar="‚õµ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚õµ</div>
                                <div class="avatar-option" data-avatar="üö¢" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üö¢</div>
                                <div class="avatar-option" data-avatar="üõü" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üõü</div>
                                <div class="avatar-option" data-avatar="‚öì" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚öì</div>
                                <div class="avatar-option" data-avatar="üß≠" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üß≠</div>
                                <div class="avatar-option" data-avatar="üèùÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üèùÔ∏è</div>
                                <div class="avatar-option" data-avatar="‚òÆÔ∏è" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">‚òÆÔ∏è</div>
                                <div class="avatar-option" data-avatar="üíö" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üíö</div>
                                <div class="avatar-option" data-avatar="üíô" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üíô</div>
                                <div class="avatar-option" data-avatar="üíõ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üíõ</div>
                                <div class="avatar-option" data-avatar="üíú" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üíú</div>
                                <div class="avatar-option" data-avatar="üçÄ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üçÄ</div>
                                <div class="avatar-option" data-avatar="üåª" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üåª</div>
                                <div class="avatar-option" data-avatar="üéà" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üéà</div>
                                <div class="avatar-option" data-avatar="üé®" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üé®</div>
                                <div class="avatar-option" data-avatar="üìñ" style="font-size: 28px; text-align: center; cursor: pointer; padding: 6px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent;">üìñ</div>
                            </div>
                            <input type="hidden" id="fin-avatar" value="">
                        </div>

                        <details style="margin: 15px 0; cursor: pointer; pointer-events: auto; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);">
                            <summary style="color: rgba(255,255,255,0.9); font-size: 14px; user-select: none; pointer-events: auto; cursor: pointer; font-weight: 600;" data-i18n="ui.form.optional_info">Informations optionnelles</summary>
                            <div style="margin-top: 15px;">
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: rgba(255,255,255,0.9); font-size: 13px;" data-i18n="ui.form.city_label">Ville :</label>
                                    <input type="text" id="fin-ville" data-i18n-placeholder="ui.form.city_placeholder" placeholder="Votre ville" style="width: 100%; padding: 10px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: rgba(255,255,255,0.9); font-size: 13px;" data-i18n="ui.form.country_label">Pays :</label>
                                    <input type="text" id="fin-pays" data-i18n-placeholder="ui.form.country_placeholder" placeholder="Votre pays" style="width: 100%; padding: 10px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: rgba(255,255,255,0.9); font-size: 13px;" data-i18n="ui.form.age_label">√Çge :</label>
                                    <input type="number" id="fin-age" data-i18n-placeholder="ui.form.age_placeholder" placeholder="Votre √¢ge" style="width: 100%; padding: 10px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;" min="1" max="150">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: rgba(255,255,255,0.9); font-size: 13px;" data-i18n="ui.form.gender_label">Genre :</label>
                                    <select id="fin-genre" style="width: 100%; padding: 10px; border: 2px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto;">
                                        <option value="" data-i18n="ui.form.gender_not_specified">Non sp√©cifi√©</option>
                                        <option value="Homme">Homme</option>
                                        <option value="Femme">Femme</option>
                                        <option value="Autre">Autre</option>
                                    </select>
                                </div>
                            </div>
                        </details>

                        <div style="margin-top: 25px; display: flex; gap: 10px;">
                            <button id="fin-enregistrer" data-i18n="ui.buttons.save" style="flex: 1; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: 700; box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4); transition: all 0.2s;">
                                üíæ Enregistrer
                            </button>
                            <button id="fin-passer" data-i18n="ui.buttons.skip" style="flex: 1; padding: 14px; background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.4); border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                                Passer
                            </button>
                        </div>

                        <div id="fin-message" style="margin-top: 15px; text-align: center; font-size: 14px; color: white; font-weight: 600;"></div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);

            // üåç Appliquer les traductions aux nouveaux √©l√©ments DOM
            if (window.i18n && typeof window.i18n.updateDOM === 'function') {
                window.i18n.updateDOM();
            }

            // ‚ùå D√âSACTIV√â : Ne pas permettre de fermer en cliquant sur le fond
            // L'utilisateur doit cliquer sur "Enregistrer" ou "Passer" pour continuer
            // (sinon il ne pourrait pas rouvrir le formulaire)

            // Gestion de la s√©lection d'avatar
            const avatarOptions = document.querySelectorAll('.avatar-option');
            avatarOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Retirer la s√©lection des autres
                    avatarOptions.forEach(opt => {
                        opt.style.background = 'transparent';
                        opt.style.borderColor = 'transparent';
                        opt.style.transform = 'scale(1)';
                    });

                    // S√©lectionner celui-ci
                    option.style.background = '#3b82f6';
                    option.style.borderColor = '#2563eb';
                    option.style.transform = 'scale(1.1)';

                    // Enregistrer la valeur
                    document.getElementById('fin-avatar').value = option.getAttribute('data-avatar');
                });

                // Effet hover
                option.addEventListener('mouseenter', () => {
                    if (!option.style.background || option.style.background === 'transparent') {
                        option.style.background = '#e2e8f0';
                    }
                });

                option.addEventListener('mouseleave', () => {
                    if (option.style.borderColor !== 'rgb(37, 99, 235)') { // Pas s√©lectionn√©
                        option.style.background = 'transparent';
                    }
                });
            });

            // Fonction pour afficher le message final (closure pour acc√©der aux variables du parent)
            function afficherMessageFinal(nom, ville, pays) {
                document.getElementById('formulaire-fin-overlay').remove();

                // Les variables xp, scoreJeu, scoreTotal, scoreSagesse, idUnique sont accessibles via closure
                afficherMessageNarratifSimple(getTranslatedText('narrative.final_message', 
                    'L\'humanit√© n\'a pas besoin de murs pour se prot√©ger,\nmais de ponts pour se rencontrer.\n\nConstruisons avec amour, pas avec peur.\nUn monde uni vaut mieux qu\'un monde cloisonn√©.\n\n- Emmanuel.gallery') + 
                    '\n\n[' + getTranslatedText('game.origin_journey', 'Origine : Le voyage d\'une vie') + ']\n\n' + nom + ' - ' + ville + ', ' + pays + '\n' + xp + ' XP + ' + scoreJeu + ' Score = ' + scoreTotal + '\n' + getTranslatedText('game.knowledge_given', 'Connaissance donn√©e') + '\n' + getTranslatedText('game.wisdom_score', 'Score de Sagesse') + ' : ' + scoreSagesse + '\nID: ' + idUnique + '\n\n[üåç ' + getTranslatedText('game.share_journey', 'Partager mon voyage') + ']\n\n[' + getTranslatedText('game.restart', 'Recommencer') + ']\n\n#PETITBATEAUROUGE #UnisPourLaPaix', 999999);

                // Marquer le message comme contenant un bouton restart + lien + partage
                setTimeout(() => {
                    if (messageNarratifActif) {
                        messageNarratifActif.avecRestart = true;
                        messageNarratifActif.lienLivre = 'https://play.google.com/store/books/details?id=VW42EQAAQBAJ';
                        messageNarratifActif.avecPartage = true;

                        // 4 textes de partage diff√©rents
                        const textesPartage = [
                            `${getTranslatedText('game.share_texts.text1_title', "üåü J'ai voyag√© √† travers les fronti√®res de l'humanit√© !")}\n\n"${getTranslatedText('game.share_texts.text1_quote', "De l'obscurit√© vers la lumi√®re, j'ai appris que l'amour unit au-del√† des diff√©rences.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,
                            `${getTranslatedText('game.share_texts.text2_title', 'üïäÔ∏è Un voyage vers la v√©rit√©...')}\n\n"${getTranslatedText('game.share_texts.text2_quote', "J'ai bris√© les murs de la peur pour construire des ponts d'amour.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,
                            `${getTranslatedText('game.share_texts.text3_title', "üåç De mur en pont, j'ai d√©couvert l'humanit√©...")}\n\n"${getTranslatedText('game.share_texts.text3_quote', 'Au-del√† des fronti√®res, nos c≈ìurs battent √† l\'unisson.')}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`,
                            `${getTranslatedText('game.share_texts.text4_title', "üëÅÔ∏è J'ai vu la v√©rit√© au-del√† des pr√©jug√©s...")}\n\n"${getTranslatedText('game.share_texts.text4_quote', "Nous construisons des murs par peur, mais l'amour les transforme en refuges.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', 'üíé Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', 'üéØ Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez √† ‚õµ PETIT BATEAU üëÅÔ∏è')}`
                        ];

                        const texteChoisi = textesPartage[Math.floor(Math.random() * textesPartage.length)];
                        messageNarratifActif.textePartage = texteChoisi;
                    }
                }, 100);
            }

            // Gestionnaire d'enregistrement
            document.getElementById('fin-enregistrer').onclick = async () => {
                console.log('üîò Bouton Enregistrer cliqu√©');
                const emailInput = document.getElementById('fin-email');
                const pseudoInput = document.getElementById('fin-pseudo');
                
                console.log('üìß Email input:', emailInput, emailInput ? emailInput.value : 'NOT FOUND');
                console.log('üë§ Pseudo input:', pseudoInput, pseudoInput ? pseudoInput.value : 'NOT FOUND');
                
                const email = emailInput ? emailInput.value.trim() : '';
                const pseudo = pseudoInput ? pseudoInput.value.trim() : '';

                if (!email || !pseudo) {
                    console.log('‚ùå Email ou pseudo manquant');
                    document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è ' + getTranslatedText('database_form.email_pseudo_required', 'Email et pseudo requis') + '</span>';
                    return;
                }

                if (!email.includes('@')) {
                    console.log('‚ùå Email invalide');
                    document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è ' + getTranslatedText('database_form.invalid_email', 'Email invalide') + '</span>';
                    return;
                }

                document.getElementById('fin-message').innerHTML = '<span style="color: #3b82f6;">' + getTranslatedText('interface.system.saving', 'üíæ Enregistrement...') + '</span>';

                try {
                    console.log('üíæ D√©but enregistrement...');
                    const ville = document.getElementById('fin-ville').value.trim() || 'Inconnue';
                    const pays = document.getElementById('fin-pays').value.trim() || 'Inconnu';
                    const age = parseInt(document.getElementById('fin-age').value) || null;
                    const genre = document.getElementById('fin-genre').value || null;
                    const avatar = document.getElementById('fin-avatar').value || null;

                    console.log('üë§ Cr√©ation/r√©cup√©ration utilisateur...', { email, pseudo, ville, pays, age, genre, avatar });
                    await supabaseScores.getOrCreateUser(email, pseudo, { ville, pays, age, genre, avatar });

                    // Calculer le niveau de sagesse
                    const niveauSagesse = getNiveauSagesse(scoreSagesse);

                    await supabaseScores.saveScore(scoreTotal, {
                        niveau_atteint: 23,
                        temps_jeu: Math.floor(Date.now() / 1000),
                        donnees_extra: {
                            xp,
                            score: scoreJeu,
                            sagesse: scoreSagesse,
                            niveau: niveauSagesse.titre,
                            niveau_icone: niveauSagesse.icone,
                            enigmes: enigmaCollector ? enigmaCollector.enigmesCollectees.size : 0,
                            id: idUnique
                        }
                    });

                    document.getElementById('fin-message').innerHTML = '<span style="color: #10b981;">‚úÖ ' + getTranslatedText('database_form.score_saved', 'Score enregistr√© !') + '</span>';

                    // R√©cup√©rer le meilleur score de l'utilisateur
                    userBestScore = await supabaseScores.getBestScore();

                    await chargerClassement();

                    setTimeout(() => {
                        afficherMenuFinal();
                    }, 1500);

                } catch (error) {
                    console.error('‚ùå Erreur sauvegarde:', error);
                    document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">‚ùå ' + getTranslatedText('interface.system.error', 'Erreur') + ' : ' + error.message + '</span>';
                }
            };

            // Gestionnaire passer
            document.getElementById('fin-passer').onclick = () => {
                afficherMenuFinal();
            };
        }

        // Fonction pour afficher le formulaire de fin de jeu (phase 23 - version simple)
        function afficherFormulaireFinDeJeu() {
            if (formulaireFinAffiche) return; // Ne pas afficher plusieurs fois
            formulaireFinAffiche = true;

            const html = `
                <div id="formulaire-fin-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 20000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 40px; border-radius: 20px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                        <h2 style="margin: 0 0 20px 0; text-align: center; color: #1e293b; font-family: 'Segoe UI', sans-serif;">üéâ ${getTranslatedText('ui.congratulations')}</h2>
                        <p style="text-align: center; color: #64748b; margin-bottom: 30px;">${getTranslatedText('ui.journey_completed')}</p>

                        <div style="text-align: center; margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px;">
                            <div style="font-size: 36px; font-weight: bold; color: white;">${score || 0}</div>
                            <div style="font-size: 14px; color: rgba(255,255,255,0.9);">points</div>
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.email_label">Email * :</label>
                            <input type="email" id="fin-simple-email" data-i18n-placeholder="ui.form.email_placeholder" placeholder="Votre adresse email" style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.pseudo_label">Pseudo * :</label>
                            <input type="text" id="fin-simple-pseudo" data-i18n-placeholder="ui.form.pseudo_placeholder" placeholder="Votre pseudo" style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 8px; color: #475569; font-size: 14px;" data-i18n="ui.form.avatar_label">Avatar :</label>
                            <div id="avatar-selector-simple" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; padding: 8px; background: #f8fafc; border-radius: 8px; max-height: 200px; overflow-y: auto;">
                                <div class="avatar-option-simple" data-avatar="‚úùÔ∏è" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">‚úùÔ∏è</div>
                                <div class="avatar-option-simple" data-avatar="‚ù§Ô∏è" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">‚ù§Ô∏è</div>
                                <div class="avatar-option-simple" data-avatar="üåà" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">üåà</div>
                                <div class="avatar-option-simple" data-avatar="‚õµ" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">‚õµ</div>
                                <div class="avatar-option-simple" data-avatar="üïäÔ∏è" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">üïäÔ∏è</div>
                                <div class="avatar-option-simple" data-avatar="‚õ™" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">‚õ™</div>
                            </div>
                            <input type="hidden" id="fin-simple-avatar" value="">
                        </div>

                        <details style="margin: 15px 0; cursor: pointer; pointer-events: auto;">
                            <summary style="color: #64748b; font-size: 14px; user-select: none; pointer-events: auto; cursor: pointer;" data-i18n="ui.form.optional_info">Informations optionnelles</summary>
                            <div style="margin-top: 15px;">
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.city_label">Ville :</label>
                                    <input type="text" id="fin-simple-ville" data-i18n-placeholder="ui.form.city_placeholder" placeholder="Votre ville" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.country_label">Pays :</label>
                                    <input type="text" id="fin-simple-pays" data-i18n-placeholder="ui.form.country_placeholder" placeholder="Votre pays" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.age_label">√Çge :</label>
                                    <input type="number" id="fin-simple-age" data-i18n-placeholder="ui.form.age_placeholder" placeholder="Votre √¢ge" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto; user-select: text;" min="1" max="150">
                                </div>
                                <div style="margin: 10px 0;">
                                    <label style="display: block; margin-bottom: 5px; color: #475569; font-size: 14px;" data-i18n="ui.form.gender_label">Genre :</label>
                                    <select id="fin-simple-genre" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; pointer-events: auto; touch-action: auto;">
                                        <option value="" data-i18n="ui.form.gender_not_specified">Non sp√©cifi√©</option>
                                        <option value="Homme">Homme</option>
                                        <option value="Femme">Femme</option>
                                        <option value="Autre">Autre</option>
                                    </select>
                                </div>
                            </div>
                        </details>

                        <div style="margin-top: 25px; display: flex; gap: 10px;">
                            <button id="fin-simple-enregistrer" data-i18n="ui.buttons.save" style="flex: 1; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                                üíæ Enregistrer
                            </button>
                            <button id="fin-simple-passer" data-i18n="ui.buttons.skip" style="flex: 1; padding: 14px; background: #94a3b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">
                                Passer
                            </button>
                        </div>

                        <div id="fin-simple-message" style="margin-top: 15px; text-align: center; font-size: 14px;"></div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);

            // üåç Appliquer les traductions aux nouveaux √©l√©ments DOM
            if (window.i18n && typeof window.i18n.updateDOM === 'function') {
                window.i18n.updateDOM();
            }

            // ‚ùå D√âSACTIV√â : Ne pas permettre de fermer en cliquant sur le fond
            // L'utilisateur doit cliquer sur "Enregistrer" ou "Passer" pour continuer

            // Gestion de la s√©lection d'avatar
            const avatarOptionsSimple = document.querySelectorAll('.avatar-option-simple');
            avatarOptionsSimple.forEach(option => {
                option.addEventListener('click', () => {
                    // Retirer la s√©lection des autres
                    avatarOptionsSimple.forEach(opt => {
                        opt.style.background = 'transparent';
                        opt.style.borderColor = 'transparent';
                        opt.style.transform = 'scale(1)';
                    });

                    // S√©lectionner celui-ci
                    option.style.background = '#3b82f6';
                    option.style.borderColor = '#2563eb';
                    option.style.transform = 'scale(1.1)';

                    // Enregistrer la valeur
                    document.getElementById('fin-simple-avatar').value = option.getAttribute('data-avatar');
                });
            });

            // Gestionnaire d'enregistrement
            document.getElementById('fin-simple-enregistrer').onclick = async () => {
                const email = document.getElementById('fin-simple-email').value.trim();
                const pseudo = document.getElementById('fin-simple-pseudo').value.trim();

                if (!email || !pseudo) {
                    document.getElementById('fin-simple-message').innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è ' + getTranslatedText('database_form.email_pseudo_required', 'Email et pseudo requis') + '</span>';
                    return;
                }

                // Validation email
                if (!email.includes('@')) {
                    document.getElementById('fin-simple-message').innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è ' + getTranslatedText('database_form.invalid_email', 'Email invalide') + '</span>';
                    return;
                }

                document.getElementById('fin-simple-message').innerHTML = '<span style="color: #3b82f6;">' + getTranslatedText('interface.system.saving', 'üíæ Enregistrement...') + '</span>';

                try {
                    // Cr√©er ou r√©cup√©rer l'utilisateur
                    const ville = document.getElementById('fin-simple-ville').value.trim() || null;
                    const pays = document.getElementById('fin-simple-pays').value.trim() || null;
                    const age = parseInt(document.getElementById('fin-simple-age').value) || null;
                    const genre = document.getElementById('fin-simple-genre').value || null;
                    const avatar = document.getElementById('fin-simple-avatar').value || null;

                    await supabaseScores.getOrCreateUser(email, pseudo, { ville, pays, age, genre, avatar });

                    // Sauvegarder le score
                    const phaseAtteinte = narrationManager ? narrationManager.currentPhase : 23;
                    const tempsJeu = Math.floor(Date.now() / 1000); // Timestamp simple

                    // Calculer le score de sagesse (score / 100)
                    const scoreSagesse = Math.round((score || 0) / 100);
                    const niveauSagesse = getNiveauSagesse(scoreSagesse);

                    await supabaseScores.saveScore(score || 0, {
                        niveau_atteint: phaseAtteinte,
                        temps_jeu: tempsJeu,
                        donnees_extra: {
                            sagesse: scoreSagesse,
                            niveau: niveauSagesse.titre,
                            niveau_icone: niveauSagesse.icone,
                            enigmes: enigmaCollector ? enigmaCollector.enigmesCollectees.size : 0
                        }
                    });

                    document.getElementById('fin-simple-message').innerHTML = '<span style="color: #10b981;">‚úÖ ' + getTranslatedText('database_form.score_saved', 'Score enregistr√© !') + '</span>';

                    // R√©cup√©rer le meilleur score de l'utilisateur
                    userBestScore = await supabaseScores.getBestScore();

                    // Recharger le classement
                    await chargerClassement();

                    // Fermer apr√®s 2 secondes
                    setTimeout(() => {
                        document.getElementById('formulaire-fin-overlay').remove();
                    }, 2000);

                } catch (error) {
                    console.error('‚ùå Erreur sauvegarde:', error);
                    document.getElementById('fin-simple-message').innerHTML = '<span style="color: #ef4444;">‚ùå ' + getTranslatedText('interface.system.error', 'Erreur') + ' : ' + error.message + '</span>';
                }
            };

            // Gestionnaire passer
            document.getElementById('fin-simple-passer').onclick = () => {
                document.getElementById('formulaire-fin-overlay').remove();
            };
        }

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapt√© pour int√©gration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentIndex = 0;
                this.timeoutId = null;
                this.text = '';
                this.options = {};
            }

            // Configuration des couleurs
            setColors(element, textColor = '#ffffff', effectColor = '#64ffda') {
                element.style.setProperty('--ta-text-color', textColor);
                element.style.setProperty('--ta-effect-color', effectColor);
                element.style.color = textColor;
            }

            // Arr√™te l'animation
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
            }

            // Reset
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.text = '';
            }

            // Animation machine √† √©crire avec support HTML complet
            typewriter(element, text, speed = 50, onComplete = null) {console.log('TextAnimationModule.typewriter appel√© avec:', {text: text.substring(0, 50), speed, element});
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';
                this.isRunning = true;

                this._typewriterStep(element);
            }

            _typewriterStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    // Gestion des balises HTML et des \n
                    let currentChar = this.text.charAt(this.currentIndex);

                    // Si on trouve une balise HTML, on l'ajoute enti√®rement
                    if (currentChar === '<') {
                        let tagEnd = this.text.indexOf('>', this.currentIndex);
                        if (tagEnd !== -1) {
                            let fullTag = this.text.substring(this.currentIndex, tagEnd + 1);
                            element.innerHTML += fullTag;
                            this.currentIndex = tagEnd + 1;
                        } else {
                            element.innerHTML += currentChar;
                            this.currentIndex++;
                        }
                    } else if (currentChar === '\n') {
                        // G√©rer les sauts de ligne
                        element.innerHTML += '<br>';
                        this.currentIndex++;
                    } else {
                        element.innerHTML += currentChar;
                        this.currentIndex++;
                    }

                    this.timeoutId = setTimeout(() => this._typewriterStep(element), this.options.speed);
                } else {
                    element.style.borderRight = 'none';
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                }
            }

            // Animation fade avec support HTML
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                element.innerHTML = text.replace(/\n/g, '<br>');
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 50);

                setTimeout(() => {
                    element.style.transition = '';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Animation digital avec support HTML
            digital(element, text, speed = 50, onComplete = null) {
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                this.isRunning = true;

                this._digitalStep(element);
            }

            _digitalStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    let displayText = '';
                    let textOnly = this.text.replace(/<[^>]*>/g, '').replace(/\n/g, ' '); // Texte sans balises
                    let currentTextIndex = 0;

                    // Reconstitue le texte avec balises jusqu'√† la position actuelle
                    for (let i = 0; i < this.text.length && currentTextIndex < this.currentIndex; i++) {
                        if (this.text.charAt(i) === '<') {
                            let tagEnd = this.text.indexOf('>', i);
                            if (tagEnd !== -1) {
                                displayText += this.text.substring(i, tagEnd + 1);
                                i = tagEnd;
                            }
                        } else if (this.text.charAt(i) === '\n') {
                            displayText += '<br>';
                            currentTextIndex++;
                        } else {
                            displayText += this.text.charAt(i);
                            currentTextIndex++;
                        }
                    }

                    // Ajoute un caract√®re al√©atoire si on n'est pas √† la fin
                    if (this.currentIndex < textOnly.length) {
                        const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }

                    element.innerHTML = displayText;

                    setTimeout(() => {
                        this.currentIndex++;
                        if (this.currentIndex < textOnly.length) {
                            this.timeoutId = setTimeout(() => this._digitalStep(element), this.options.speed);
                        } else {
                            element.innerHTML = this.text.replace(/\n/g, '<br>');
                            this.isRunning = false;
                            if (this.options.onComplete) this.options.onComplete();
                        }
                    }, this.options.speed / 2);
                }
            }

            // Animation glitch avec support HTML
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();

                // Effet de glitch en pr√©servant le HTML
                let textOnly = text.replace(/<[^>]*>/g, '').replace(/\n/g, ' ');
                let glitchText = '';
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';

                // Reconstitue le texte avec des caract√®res glitch
                for (let i = 0; i < text.length; i++) {
                    if (text.charAt(i) === '<') {
                        let tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            glitchText += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text.charAt(i) === '\n') {
                        glitchText += '<br>';
                    } else {
                        if (Math.random() < 0.1 && text.charAt(i) !== ' ') {
                            glitchText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        } else {
                            glitchText += text.charAt(i);
                        }
                    }
                }

                element.innerHTML = glitchText;
                element.style.animation = 'ta-glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas d√©j√† pr√©sentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes ta-glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.innerHTML = text.replace(/\n/g, '<br>');
                    element.style.animation = 'none';
                    if (onComplete) onComplete();
                }, duration);
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé¨ NOUVELLE CLASSE TEXTANIMATOR OPTIMIS√âE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class TextAnimator {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('TextAnimator: Element non trouv√©:', elementId);
                    return;
                }
                this.reset();
            }

            // √âtat et m√©thodes utilitaires optimis√©es
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.element.innerHTML = '';
                // Garder les classes originales du message
                const originalClasses = this.element.className;
                this.element.className = originalClasses.replace(/ta-\w+/g, '').trim();
            }

            stop() {
                this.isRunning = false;
                if (this.timeoutId) clearTimeout(this.timeoutId);
            }

            setColors(textColor = '#ffffff', effectColor = '#64ffda') {
                this.element.style.setProperty('--ta-text-color', textColor);
                this.element.style.setProperty('--ta-effect-color', effectColor);
                this.element.style.color = textColor;
            }

            applyEffect(effect = 'none') {
                const effects = ['shadow3d', 'neon', 'emboss', 'outline', 'fire', 'ice'];
                effects.forEach(e => this.element.classList.remove(`ta-effect-${e}`));
                if (effect !== 'none') this.element.classList.add(`ta-effect-${effect}`);
            }

            // Animation machine √† √©crire optimis√©e
            typewriter(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-typewriter');
                this.isRunning = true;
                this._typewriterStep();
            }

            _typewriterStep() {
                if (!this.isRunning || this.currentIndex >= this.text.length) {
                    this.element.classList.remove('ta-typewriter');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                const char = this.text.charAt(this.currentIndex);
                if (char === '<') {
                    const tagEnd = this.text.indexOf('>', this.currentIndex);
                    if (tagEnd !== -1) {
                        this.element.innerHTML += this.text.substring(this.currentIndex, tagEnd + 1);
                        this.currentIndex = tagEnd + 1;
                    } else {
                        this.element.innerHTML += char;
                        this.currentIndex++;
                    }
                } else if (char === '\n') {
                    this.element.innerHTML += '<br>';
                    this.currentIndex++;
                } else {
                    this.element.innerHTML += char;
                    this.currentIndex++;
                }

                this.timeoutId = setTimeout(() => this._typewriterStep(), this.options.speed);
            }

            // Animation code digital optimis√©e
            digital(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-digital');
                this.isRunning = true;
                this._digitalStep();
            }

            _digitalStep() {
                if (!this.isRunning) return;

                const textOnly = this.text.replace(/<[^>]*>/g, '');
                if (this.currentIndex >= textOnly.length) {
                    this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                let displayText = this._buildHtmlText(this.currentIndex);
                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                displayText += digitalChars[Math.floor(Math.random() * digitalChars.length)];

                this.element.innerHTML = displayText;

                setTimeout(() => {
                    this.currentIndex++;
                    if (this.currentIndex < textOnly.length) {
                        this.timeoutId = setTimeout(() => this._digitalStep(), this.options.speed);
                    } else {
                        this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                        this.isRunning = false;
                        if (this.options.onComplete) this.options.onComplete();
                    }
                }, this.options.speed / 2);
            }

            // Animation fade
            fade(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-fade-in');
                this.element.innerHTML = text.replace(/\n/g, '<br>');

                setTimeout(() => {
                    this.element.classList.remove('ta-fade-in');
                    if (this.options.onComplete) this.options.onComplete();
                }, 1000);
            }

            // Animation glitch optimis√©e
            glitch(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-glitch');

                const glitchText = this._createGlitchText(text);
                this.element.innerHTML = glitchText;

                this.timeoutId = setTimeout(() => {
                    this.element.innerHTML = text.replace(/\n/g, '<br>');
                    this.element.classList.remove('ta-glitch');
                    if (this.options.onComplete) this.options.onComplete();
                }, this.options.speed * 5);
            }

            // M√©thodes utilitaires optimis√©es
            setupAnimation(text, options) {
                this.text = text;
                this.options = {
                    speed: options.speed || 50,
                    textColor: options.textColor || '#ffffff',
                    effectColor: options.effectColor || '#64ffda',
                    effect: options.effect || 'none',
                    onComplete: options.onComplete
                };
                this.reset();
                this.setColors(this.options.textColor, this.options.effectColor);
                this.applyEffect(this.options.effect);
            }

            _buildHtmlText(index) {
                let result = '';
                let textIndex = 0;
                for (let i = 0; i < this.text.length && textIndex < index; i++) {
                    if (this.text[i] === '<') {
                        const tagEnd = this.text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += this.text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (this.text[i] === '\n') {
                        result += '<br>';
                        textIndex++;
                    } else {
                        result += this.text[i];
                        textIndex++;
                    }
                }
                return result;
            }

            _createGlitchText(text) {
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '<') {
                        const tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text[i] === '\n') {
                        result += '<br>';
                    } else if (Math.random() < 0.1 && text[i] !== ' ') {
                        result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        result += text[i];
                    }
                }
                return result;
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // üîä Syst√®me Audio - Sons synth√©tiques calmes et feutr√©s
        window.AudioSystem = {
            ctx: null,
            masterVolume: 0.3,
            muted: false,
            initialized: false,

            init() {
                if (!this.initialized) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                }
            },

            ensureInit() {
                if (!this.initialized) {
                    this.init();
                }
            },

            // Son de clic doux (UI)
            playClick() {
                this.ensureInit();
                if (this.muted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.frequency.value = 800;
                gain.gain.value = this.masterVolume * 0.1;

                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son de collecte doux - Tock d'amour pour power-ups
            playCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Tock d'amour chaleureux et doux (pas de tinks aigus!)
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(550, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(380, this.ctx.currentTime + 0.25);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.22, this.ctx.currentTime + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.25);
            },

            // Son "Chuchotement" - Murmure feutr√© pour les c≈ìurs du haut
            playPof() {
                this.ensureInit();
                if (this.muted) return;

                // Chuchotement - Murmure doux et apaisant
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.25, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Cr√©er un chuchotement avec bruit modul√©
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const envelope = Math.sin(t * 20) * Math.exp(-t * 6);
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.6;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1200;
                filter.Q.value = 2;

                const gain = this.ctx.createGain();
                gain.gain.value = this.masterVolume * 0.15;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de bulle qui pop (briques qui cassent)
            playExplosion() {
                this.ensureInit();
                if (this.muted) return;

                // Son de "pop" de bulle - fr√©quence qui descend rapidement
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 1200;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Descente rapide de fr√©quence pour effet "pop"
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.08);

                // Volume qui chute rapidement
                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son "plouf" tr√®s doux pour explosion finale des c≈ìurs
            playExplosionCoeurs() {
                this.ensureInit();
                if (this.muted) return;

                // "Plouf" ultra doux - comme un soupir apaisant
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 300; // Tr√®s filtr√© et grave

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Descente ultra douce et lente
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(120, this.ctx.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.8);

                // Volume ultra doux et tr√®s progressif
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.06, this.ctx.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.05, this.ctx.currentTime + 0.4);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.9);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.9);
            },

            // Son de rebond l√©ger et feutr√© (balle/lanterne)
            playBounce() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 600; // Filtre pour son plus doux

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Petit "boing" doux
                osc.frequency.setValueAtTime(250, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(180, this.ctx.currentTime + 0.05);

                gain.gain.setValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            // Vague douce - Ambiance calme
            playVagueDouce() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 3, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const wave = Math.sin(t * Math.PI / 3) * 0.7 + 0.3;
                    data[i] = (Math.random() * 2 - 1) * wave * 0.6;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 1.5);
                filter.frequency.linearRampToValueAtTime(250, this.ctx.currentTime + 3);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.6, this.ctx.currentTime + 0.8);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.5, this.ctx.currentTime + 2.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Vague puissante - Ambiance intense
            playVaguePuissante() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 4, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const wave = Math.pow(Math.sin(t * Math.PI / 4), 2);
                    data[i] = (Math.random() * 2 - 1) * wave * 0.8;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(500, this.ctx.currentTime + 2);
                filter.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 4);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.7, this.ctx.currentTime + 1.5);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.6, this.ctx.currentTime + 3);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();

                // R√©sonance grave
                const osc = this.ctx.createOscillator();
                const gainOsc = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(40, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(70, this.ctx.currentTime + 2);
                osc.frequency.linearRampToValueAtTime(35, this.ctx.currentTime + 4);

                gainOsc.gain.setValueAtTime(0, this.ctx.currentTime);
                gainOsc.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 1.2);
                gainOsc.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                osc.connect(gainOsc);
                gainOsc.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 4);
            },

            // Ambiance sonore - Joue vague selon la phase
            playAmbience() {
                this.ensureInit();
                if (this.muted) {
                    return;
                }

                // Alterner entre vague douce et puissante selon la phase
                // Phases paires = douce, impaires = puissante
                const phaseActuelle = (typeof narrationManager !== 'undefined' && narrationManager)
                    ? narrationManager.currentPhase
                    : 0;

                if (phaseActuelle % 2 === 0) {
                    this.playVagueDouce();
                } else {
                    this.playVaguePuissante();
                }
            },

            // Son de gong asiatique (bouton "Passer" NON!)
            playNegative() {
                this.ensureInit();
                if (this.muted) return;

                // Gong asiatique - plusieurs fr√©quences harmoniques
                const frequencies = [220, 330, 440, 660]; // Harmoniques du gong

                frequencies.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();

                    osc.type = 'sine';
                    filter.type = 'lowpass';
                    filter.frequency.value = 800;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);

                    // Fr√©quence l√©g√®rement variable pour effet m√©tallique
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(freq * 0.98, this.ctx.currentTime + 0.5);

                    // Volume avec attaque et longue r√©sonance
                    const volume = this.masterVolume * (0.15 - index * 0.03); // Harmoniques plus faibles
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(volume, this.ctx.currentTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2.0);

                    osc.start();
                    osc.stop(this.ctx.currentTime + 2.0);
                });
            },

            // Son "feuuuux" - souffle qui s'√©teint (pour le corbeau)
            playCrow() {
                this.ensureInit();
                if (this.muted) return;

                // "feuuuux" - souffle long qui s'√©teint progressivement
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.5, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit qui d√©cro√Æt tr√®s progressivement
                for (let i = 0; i < buffer.length; i++) {
                    const progress = i / buffer.length;
                    // Fade exponentiel pour extinction naturelle
                    const fade = Math.exp(-progress * 4);
                    // Variation pour son organique
                    const variation = Math.sin(i / 500) * 0.2;
                    data[i] = (Math.random() * 2 - 1) * fade * (0.6 + variation);
                }

                noise.buffer = buffer;

                // Filtre qui ferme progressivement (extinction)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 1.5);

                const gain = this.ctx.createGain();

                // Volume : monte, tient, puis s'√©teint doucement
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.1, this.ctx.currentTime + 0.08);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.4);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de vol du corbeau - battements d'ailes
            playCrowFly() {
                this.ensureInit();
                if (this.muted) return;

                // Cr√©er 3 battements d'ailes rapides
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const noise = this.ctx.createBufferSource();
                        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);

                        // Bruit de battement - attaque rapide puis decay
                        for (let j = 0; j < buffer.length; j++) {
                            const t = j / buffer.length;
                            const envelope = Math.exp(-t * 8);
                            data[j] = (Math.random() * 2 - 1) * envelope * 0.7;
                        }

                        noise.buffer = buffer;

                        const filter = this.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 400 + Math.random() * 200;

                        const gain = this.ctx.createGain();
                        gain.gain.value = this.masterVolume * (0.12 - i * 0.02);

                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.ctx.destination);

                        noise.start();
                    }, i * 120);
                }
            },

            // Son de rire mal√©fique du corbeau
            playCrowLaugh() {
                this.ensureInit();
                if (this.muted) return;

                // Rire en 3 phases descendantes "ah-ah-ahhh"
                const frequencies = [600, 500, 400];
                const durations = [0.15, 0.15, 0.3];

                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        const filter = this.ctx.createBiquadFilter();

                        // M√©lange de square et sine pour son plus rauque
                        osc.type = 'square';
                        filter.type = 'lowpass';
                        filter.frequency.value = 800;

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.ctx.destination);

                        // Fr√©quence qui tremble (vibrato) pour effet rire
                        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(freq * 0.9, this.ctx.currentTime + durations[i]);

                        // Volume avec attaque rapide
                        const vol = this.masterVolume * (0.08 - i * 0.01);
                        gain.gain.setValueAtTime(0, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + durations[i]);

                        osc.start();
                        osc.stop(this.ctx.currentTime + durations[i]);
                    }, i * 180);
                });
            },

            // Son d'explosion du corbeau
            playCrowExplosion() {
                this.ensureInit();
                if (this.muted) return;

                // Pff long - expiration apr√®s explosion du drone

                // Souffle long et feutr√©
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / buffer.length;
                    const envelope = Math.exp(-t * 2); // Descente lente
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.3;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 1);
                filter.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 2);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.18, this.ctx.currentTime + 1.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de voile - Vent dans la toile (mouvement du bateau)
            playVoile() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.4, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit avec flutter (effet de toile qui ondule)
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const flutter = Math.sin(t * 12) * 0.3 + 0.7;
                    data[i] = (Math.random() * 2 - 1) * flutter * 0.5;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(700, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(1000, this.ctx.currentTime + 0.2);
                filter.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.4);
                filter.Q.value = 3;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son d'orage - Tonnerre avec grondement
            playOrage() {
                this.ensureInit();
                if (this.muted) return;

                // Grondement grave du tonnerre
                const thunder = this.ctx.createOscillator();
                const thunderGain = this.ctx.createGain();

                thunder.frequency.setValueAtTime(80, this.ctx.currentTime);
                thunder.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 10);
                thunder.type = 'sawtooth';

                thunderGain.gain.setValueAtTime(0, this.ctx.currentTime);
                thunderGain.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 0.1);
                thunderGain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime + 8);
                thunderGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);

                thunder.connect(thunderGain);
                thunderGain.connect(this.ctx.destination);

                thunder.start();
                thunder.stop(this.ctx.currentTime + 10);

                // Pluie d'orage en fond
                const rain = this.ctx.createBufferSource();
                const rainBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 10, this.ctx.sampleRate);
                const rainData = rainBuffer.getChannelData(0);

                for (let i = 0; i < rainBuffer.length; i++) {
                    if (Math.random() < 0.45) {
                        rainData[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                }

                rain.buffer = rainBuffer;

                const rainFilter = this.ctx.createBiquadFilter();
                rainFilter.type = 'bandpass';
                rainFilter.frequency.value = 4000;
                rainFilter.Q.value = 1;

                const rainGain = this.ctx.createGain();
                rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.5);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 9);
                rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);

                rain.connect(rainFilter);
                rainFilter.connect(rainGain);
                rainGain.connect(this.ctx.destination);

                rain.start();
            },

            // Son de casse brique - Tac doux 1
            playBrickBreakToc() {
                this.ensureInit();
                if (this.muted) return;

                // Tac court et sec mais doux
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 700;

                gain.gain.setValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            // Son de casse brique - Tac doux 2
            playBrickBreakGlass() {
                this.ensureInit();
                if (this.muted) return;

                // Tac medium
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 600;

                gain.gain.setValueAtTime(this.masterVolume * 0.23, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.09);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.09);
            },

            // Son de casse brique - Tac doux 3
            playBrickBreakCrack() {
                this.ensureInit();
                if (this.muted) return;

                // Tac grave
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 500;

                gain.gain.setValueAtTime(this.masterVolume * 0.21, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son de pi√®ce - tintement l√©ger et d√©licat (pour phases 17 & 20)
            playCoin() {
                this.ensureInit();
                if (this.muted) return;

                // Tintement l√©ger - deux notes cristallines
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();
                
                // Note principale - aigu√´ et l√©g√®re
                osc1.type = 'sine';
                osc1.frequency.value = 1760; // A6 - aigu
                
                // Harmonique subtile - octave au-dessus
                osc2.type = 'sine';
                osc2.frequency.value = 3520; // A7 - tr√®s aigu
                
                // Volume l√©ger et qui dispara√Æt vite
                gain1.gain.setValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                
                gain2.gain.setValueAtTime(this.masterVolume * 0.06, this.ctx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);
                
                // Connexions
                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);
                
                osc2.connect(gain2);
                gain2.connect(this.ctx.destination);
                
                // D√©marrage
                osc1.start();
                osc2.start();
                osc1.stop(this.ctx.currentTime + 0.15);
                osc2.stop(this.ctx.currentTime + 0.12);
            },

            // Son "poque" - impact sur le mur (sans le d√©truire)
            playWallHit() {
                this.ensureInit();
                if (this.muted) return;

                // Petit coup sec - "poque"
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.06);

                gain.gain.setValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.06);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.06);
            },

            // Son de mur qui casse (impact lourd pour briques du mur)
            playWallBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Impact sourd et lourd
                const osc = this.ctx.createOscillator();
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit d'impact
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / buffer.length * 8);
                }
                noise.buffer = buffer;

                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();

                // Composante grave
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.15);

                gain1.gain.setValueAtTime(this.masterVolume * 0.35, this.ctx.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);

                // Composante bruit
                gain2.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);

                osc.connect(gain1);
                gain1.connect(this.ctx.destination);

                noise.connect(gain2);
                gain2.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
                noise.start();
            },

            // Son de tir de projectile (whoosh)
            playShoot() {
                this.ensureInit();
                if (this.muted) return;

                // Whoosh rapide
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.12, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / buffer.length;
                    const envelope = Math.sin(t * Math.PI) * 0.8;
                    data[i] = (Math.random() * 2 - 1) * envelope;
                }
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 800;
                filter.Q.value = 2;

                const gain = this.ctx.createGain();
                gain.gain.value = this.masterVolume * 0.12;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de cloche magique (d√©couverte du power-up espoir) üîî‚ú®
            playChime() {
                this.ensureInit();
                if (this.muted) return;

                // Carillon magique avec 3 notes harmonieuses
                const notes = [880, 1100, 1320]; // A5, C#6, E6 (accord majeur)
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine'; // Son de cloche pure
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.08); // Notes d√©cal√©es
                    const endTime = startTime + 1.5; // R√©sonance longue
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Phase 18 : Son de vent/souffle l√©ger (LIBERT√â) üí®
            playWindBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Souffle a√©rien
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const envelope = Math.exp(-i / buffer.length * 5);
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.4;
                }
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800; // Aigu et l√©ger

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Phase 19 : Tac grave sec (REFUS) üß± - Coup sourd et percutant
            playHammerBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Tac grave et sec - coup de brique
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const noise = this.ctx.createBufferSource();

                // Bruit de cassure grave
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.08, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / buffer.length * 25);
                }
                noise.buffer = buffer;

                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();
                const noiseGain = this.ctx.createGain();

                // Composante grave principale (le tac profond)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(150, this.ctx.currentTime); // Plus grave
                osc1.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.1);

                // Harmonique m√©dium (d√©finition du coup)
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(400, this.ctx.currentTime); // Moins aigu
                osc2.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.06);

                // Attaque rapide, d√©clin court (tac sec)
                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.35, this.ctx.currentTime + 0.005);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                gain2.gain.setValueAtTime(0, this.ctx.currentTime);
                gain2.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.003);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.06);

                noiseGain.gain.setValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc1.connect(gain1);
                osc2.connect(gain2);
                noise.connect(noiseGain);
                gain1.connect(this.ctx.destination);
                gain2.connect(this.ctx.destination);
                noiseGain.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                noise.start();
                osc1.stop(this.ctx.currentTime + 0.1);
                osc2.stop(this.ctx.currentTime + 0.06);
                noise.stop(this.ctx.currentTime + 0.08);
            },

            // Phase 21 : Son cristallin/verre (IN√âGALIT√âS) ‚ú®
            playCrystalBreak() {
                this.ensureInit();
                if (this.muted) return;

                // √âclat cristallin
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const osc3 = this.ctx.createOscillator();

                const gain = this.ctx.createGain();

                // Accord cristallin (notes aigu√´s)
                osc1.type = 'sine';
                osc1.frequency.value = 1760; // A6
                osc2.type = 'sine';
                osc2.frequency.value = 2217; // C#7
                osc3.type = 'sine';
                osc3.frequency.value = 2637; // E7

                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                osc1.connect(gain);
                osc2.connect(gain);
                osc3.connect(gain);
                gain.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                osc3.start();
                osc1.stop(this.ctx.currentTime + 0.4);
                osc2.stop(this.ctx.currentTime + 0.4);
                osc3.stop(this.ctx.currentTime + 0.4);
            },

            // Phase 22 : Son doux/c≈ìur (ESPOIR) üíì
            playHeartBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Battement de c≈ìur chaleureux
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(220, this.ctx.currentTime); // Note douce
                osc.frequency.exponentialRampToValueAtTime(180, this.ctx.currentTime + 0.2);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.35);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.35);
            },

            // Phase 22 : Toc grave profond (brique espoir) üéØ
            playDeepKnock() {
                this.ensureInit();
                if (this.muted) return;

                // Toc grave et r√©sonnant
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();

                // Composante tr√®s grave (le "toc" profond)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(80, this.ctx.currentTime); // Tr√®s grave
                osc1.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.15);

                // Harmonique pour le "claquement"
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(160, this.ctx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);

                // Enveloppe grave (attaque rapide, d√©clin lent)
                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.4, this.ctx.currentTime + 0.01);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                gain2.gain.setValueAtTime(0, this.ctx.currentTime);
                gain2.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 0.005);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);

                osc1.connect(gain1);
                osc2.connect(gain2);
                gain1.connect(this.ctx.destination);
                gain2.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                osc1.stop(this.ctx.currentTime + 0.3);
                osc2.stop(this.ctx.currentTime + 0.15);
            },

            // Sons de collecte de power-ups th√©matiques üéÅ

            // Son sombre/lourd (power-ups n√©gatifs : cha√Ænes, barbel√©s, c≈ìur noir)
            playDarkCollect() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(110, this.ctx.currentTime); // Tr√®s grave
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            },

            // Son lumineux/joyeux (c≈ìurs color√©s positifs : vert, jaune, bleu)
            playJoyfulCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Arp√®ge joyeux
                const notes = [523, 659, 784]; // C5, E5, G5 (accord majeur)
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.05);
                    const endTime = startTime + 0.3;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.15, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Son doux/apaisant (c≈ìurs empathiques : rose, violet, rouge)
            playSoftCollect() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, this.ctx.currentTime); // A4
                osc.frequency.exponentialRampToValueAtTime(330, this.ctx.currentTime + 0.4);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.18, this.ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.4);
            },

            // Son p√©tillant (sourire, libert√© retrouv√©e)
            playSparkleCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Notes p√©tillantes ascendantes
                const notes = [880, 1100, 1320, 1568]; // A5, C#6, E6, G6
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.04);
                    const endTime = startTime + 0.2;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Son de pluie douce en boucle - tr√®s longue et extra douce
            startRainLoop() {
                this.ensureInit();
                if (this.muted || this.rainLoopActive) return;

                // Cr√©er buffer de pluie 2x plus long (16 secondes en boucle)
                const duration = 16;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Pluie tr√®s douce avec modulation lente
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    const modulation = Math.sin(t * Math.PI * 2) * 0.4 + 0.6; // Variation plus lente
                    if (Math.random() < 0.1) { // Encore moins dense pour plus de douceur
                        data[i] = (Math.random() * 2 - 1) * 0.18 * modulation; // Volume r√©duit
                    }
                }

                this.rainSource = this.ctx.createBufferSource();
                this.rainSource.buffer = buffer;
                this.rainSource.loop = true;

                // Triple filtrage pour effet ultra-doux
                const filter1 = this.ctx.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.value = 2000; // Encore plus grave
                filter1.Q.value = 0.4;

                const filter2 = this.ctx.createBiquadFilter();
                filter2.type = 'highpass';
                filter2.frequency.value = 1000;
                filter2.Q.value = 0.3;

                const filter3 = this.ctx.createBiquadFilter();
                filter3.type = 'lowpass';
                filter3.frequency.value = 1800; // Deuxi√®me lowpass pour adoucir
                filter3.Q.value = 0.5;

                this.rainGain = this.ctx.createGain();
                this.rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime + 3); // Volume plus faible

                this.rainSource.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(filter3);
                filter3.connect(this.rainGain);
                this.rainGain.connect(this.ctx.destination);

                this.rainSource.start();
                this.rainLoopActive = true;console.log('[AUDIO] Pluie tr√®s douce et longue (16s) d√©marr√©e en boucle');
            },

            stopRainLoop() {
                if (!this.rainLoopActive || !this.rainGain || !this.rainSource) return;

                this.rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4); // Fade out 4 secondes
                setTimeout(() => {
                    if (this.rainSource) {
                        this.rainSource.stop();
                        this.rainSource = null;
                        this.rainGain = null;
                        this.rainLoopActive = false;console.log('[AUDIO] Pluie douce arr√™t√©e (fade out 4s)');
                    }
                }, 4000);
            },

            // Son d'averse (pluie forte ponctuelle - plus douce et fade out long)
            playAverse() {
                this.ensureInit();
                if (this.muted) return;

                // Pluie moins dense et plus douce
                const rain = this.ctx.createBufferSource();
                const rainBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 8, this.ctx.sampleRate);
                const rainData = rainBuffer.getChannelData(0);

                for (let i = 0; i < rainBuffer.length; i++) {
                    const t = i / rainBuffer.length;
                    const modulation = Math.sin(t * Math.PI * 2) * 0.3 + 0.7;
                    if (Math.random() < 0.3) { // Moins dense
                        rainData[i] = (Math.random() * 2 - 1) * 0.2 * modulation;
                    }
                }

                rain.buffer = rainBuffer;

                const rainFilter = this.ctx.createBiquadFilter();
                rainFilter.type = 'bandpass';
                rainFilter.frequency.value = 3000;
                rainFilter.Q.value = 1;

                const rainGain = this.ctx.createGain();
                rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.5); // Mont√©e plus lente
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 4); // Volume r√©duit
                rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8); // Fade out 4s

                rain.connect(rainFilter);
                rainFilter.connect(rainGain);
                rainGain.connect(this.ctx.destination);

                rain.start();
            },

            // Son d'√©tincelle magique l√©g√®re (corbeau/power-up)
            playSparkle() {
                this.ensureInit();
                if (this.muted) return;

                // √âtincelle principale - mont√©e rapide
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();

                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(2400, this.ctx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(3600, this.ctx.currentTime + 0.08);
                osc1.frequency.exponentialRampToValueAtTime(1800, this.ctx.currentTime + 0.2);

                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 0.04);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);

                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);

                osc1.start();
                osc1.stop(this.ctx.currentTime + 0.2);

                // 2 micro-√©tincelles en cascade
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const sparkle = this.ctx.createOscillator();
                        const sparkleGain = this.ctx.createGain();

                        sparkle.type = 'sine';
                        sparkle.frequency.value = 3000 + Math.random() * 800;

                        sparkleGain.gain.setValueAtTime(0, this.ctx.currentTime);
                        sparkleGain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.02);
                        sparkleGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);

                        sparkle.connect(sparkleGain);
                        sparkleGain.connect(this.ctx.destination);

                        sparkle.start();
                        sparkle.stop(this.ctx.currentTime + 0.12);
                    }, 80 + i * 50);
                }
            },

            // Son de feu d'artifice R√âALISTE üéÜ - WOUUUCHE... PAF!
            playFirework() {
                this.ensureInit();
                if (this.muted) return;

                const now = this.ctx.currentTime;

                // 1. WOUUUCHE - Sifflement de fus√©e qui monte (bruit blanc modul√©)
                const riseNoise = this.ctx.createBufferSource();
                const riseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.7, this.ctx.sampleRate);
                const riseData = riseBuffer.getChannelData(0);
                
                // Bruit blanc avec enveloppe montante
                for (let i = 0; i < riseBuffer.length; i++) {
                    const t = i / riseBuffer.length;
                    const envelope = Math.pow(t, 0.5) * Math.exp(-t * 1.5); // Monte puis diminue
                    riseData[i] = (Math.random() * 2 - 1) * envelope * 0.8;
                }
                riseNoise.buffer = riseBuffer;
                
                // Filtre qui monte pour le sifflement
                const riseFilter = this.ctx.createBiquadFilter();
                riseFilter.type = 'bandpass';
                riseFilter.frequency.setValueAtTime(300, now);
                riseFilter.frequency.exponentialRampToValueAtTime(1200, now + 0.6);
                riseFilter.Q.value = 8; // Filtre √©troit pour le sifflement
                
                const riseGain = this.ctx.createGain();
                riseGain.gain.setValueAtTime(0, now);
                riseGain.gain.linearRampToValueAtTime(this.masterVolume * 0.8, now + 0.1); // Plus fort : 0.3 ‚Üí 0.8
                riseGain.gain.linearRampToValueAtTime(this.masterVolume * 0.9, now + 0.5); // Plus fort : 0.35 ‚Üí 0.9
                riseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
                
                riseNoise.connect(riseFilter);
                riseFilter.connect(riseGain);
                riseGain.connect(this.ctx.destination);
                
                riseNoise.start(now);
                riseNoise.stop(now + 0.7);

                // 2. PAF! - Explosion massive et grave
                setTimeout(() => {
                    // Choc initial tr√®s grave (sub-bass)
                    const subBass = this.ctx.createOscillator();
                    const subGain = this.ctx.createGain();
                    
                    subBass.type = 'sine';
                    subBass.frequency.setValueAtTime(50, this.ctx.currentTime);
                    subBass.frequency.exponentialRampToValueAtTime(25, this.ctx.currentTime + 0.15);
                    
                    subGain.gain.setValueAtTime(0, this.ctx.currentTime);
                    subGain.gain.linearRampToValueAtTime(this.masterVolume * 1.2, this.ctx.currentTime + 0.01); // Plus fort : 0.7 ‚Üí 1.2 (attaque ultra rapide)
                    subGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                    
                    subBass.connect(subGain);
                    subGain.connect(this.ctx.destination);
                    
                    subBass.start();
                    subBass.stop(this.ctx.currentTime + 0.5);

                    // Explosion (bruit blanc grave)
                    const boom = this.ctx.createBufferSource();
                    const boomBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.8, this.ctx.sampleRate);
                    const boomData = boomBuffer.getChannelData(0);
                    
                    for (let i = 0; i < boomBuffer.length; i++) {
                        const t = i / boomBuffer.length;
                        const envelope = Math.exp(-t * 5); // D√©clin rapide
                        boomData[i] = (Math.random() * 2 - 1) * envelope;
                    }
                    boom.buffer = boomBuffer;
                    
                    const boomFilter = this.ctx.createBiquadFilter();
                    boomFilter.type = 'lowpass';
                    boomFilter.frequency.setValueAtTime(300, this.ctx.currentTime);
                    boomFilter.frequency.exponentialRampToValueAtTime(150, this.ctx.currentTime + 0.3);
                    
                    const boomGain = this.ctx.createGain();
                    boomGain.gain.setValueAtTime(this.masterVolume * 1.0, this.ctx.currentTime); // Plus fort : 0.5 ‚Üí 1.0
                    boomGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
                    
                    boom.connect(boomFilter);
                    boomFilter.connect(boomGain);
                    boomGain.connect(this.ctx.destination);
                    
                    boom.start();
                    
                    // R√©sonance post-explosion
                    const rumble = this.ctx.createOscillator();
                    const rumbleGain = this.ctx.createGain();
                    
                    rumble.type = 'sine';
                    rumble.frequency.setValueAtTime(40, this.ctx.currentTime + 0.1);
                    rumble.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.6);
                    
                    rumbleGain.gain.setValueAtTime(0, this.ctx.currentTime + 0.1);
                    rumbleGain.gain.linearRampToValueAtTime(this.masterVolume * 0.5, this.ctx.currentTime + 0.15); // Plus fort : 0.2 ‚Üí 0.5
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.7);
                    
                    rumble.connect(rumbleGain);
                    rumbleGain.connect(this.ctx.destination);
                    
                    rumble.start(this.ctx.currentTime + 0.1);
                    rumble.stop(this.ctx.currentTime + 0.7);
                }, 700);
            },

            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            }
        };

        // L'audio s'initialise automatiquement au premier son jou√©

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;

        // S√©lecteur de langue au d√©marrage - BLOQUE LE JEU
        // Si langue d√©j√† choisie (dans localStorage), on skip le s√©lecteur
        const langueDejaChoisie = localStorage.getItem('petit_bateau_lang') !== null;

        let languageSelector = {
            active: false, // D√âSACTIV√â - Le nouveau syst√®me dans l'onglet langues le remplace
            menuOpen: false, 
            languageChosen: true, // True pour d√©marrer directement le jeu
            iconButton: {
                x: C.W - 60, 
                y: C.H - 60,
                radius: 25,
                hover: false
            },
            buttons: [
                { code: 'fr', drapeau: 'üá´üá∑', nom: 'Fran√ßais' },
                { code: 'en', drapeau: 'üá¨üáß', nom: 'English' },
                { code: 'es', drapeau: 'üá™üá∏', nom: 'Espa√±ol' },
                { code: 'jp', drapeau: 'üáØüáµ', nom: 'Êó•Êú¨Ë™û' },
                { code: 'uk', drapeau: 'üá∫üá¶', nom: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞' }
            ]
        };

        // üåç MINI-JEU "BRISER LES FRONTI√àRES" - Syst√®me ind√©pendant
        let briqueLangue = {
            active: false,
            game: null
        };

        // Rendre score accessible globalement pour les modules
        window.score = score;
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (value) => { score = value; }
        });
        let titreVoyage = { active: false, texte: '', fin: 0 }; // Affichage titre voyage
        let raquette = {}, balle = {}, briques = [], particules = [];
        let starsProjectiles = []; // Projectiles √©toiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles √©toiles (phase briques) - commence √† 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let laserState = { lastFired: 0, active: false, startTime: 0, duration: 1000 }; // √âtat du laser phase 23
        let coeursBateau = []; // C≈ìurs lanc√©s par le bateau
        let derniereCreeRafale = 0; // Temps de la derni√®re rafale
        let petitsCoeurs = []; // Petits c≈ìurs d√©coratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause apr√®s explosion
        let textesVolants = []; // Textes qui montent au ciel
        let gouttesPlui = []; // Gouttes de pluie pour phase 5
        let pluieActive = false; // √âtat de la pluie
        let corbeau = { actif: false, x: 0, y: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000, direction: 1 }; // Corbeau secret (10s pour test)

        // Syst√®me de chauve-souris r√©v√©l√©e par la lanterne
        let chauveSouris = {
            revelee: false,
            x: 0, y: 0,
            vx: 0, vy: 0,
            active: false,
            tempApparition: 0,
            dureeVie: 5000, // 5 secondes
            collectee: false
        };

        // Animation de l'ic√¥ne vers le menu √©nigmes
        let animationIconeMenu = {
            active: false,
            startX: 0, startY: 0,
            targetX: 0, targetY: 0,
            currentX: 0, currentY: 0,
            progress: 0,
            duree: 1500, // 1.5 secondes
            startTime: 0,
            icone: '',
            easing: function(t) {
                // Easing out cubic pour un effet naturel
                return 1 - Math.pow(1 - t, 3);
            }
        };
        let soleil = { clignotement: false, tempsClignotement: 0 }; // √âtat du soleil
        let multiplicateurPuissance = 1; // Cheat code x10 puissance
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition
        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let secretModeModule = null; // Module mode secret
        let musicManager = null; // Gestionnaire de musique gospel
        // let kawaiiObjectsModule = null; // SUPPRIM√â - utilisation via module secret seulement
        let modeNarration = true; // Mode narration actif au d√©but
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Syst√®me de messages narratifs
        let periode = 'jour'; // P√©riode actuelle : 'jour' ou 'nuit'
        let transitionPeriode = { active: false, progression: 0 };
        let phaseIntro = { active: langueDejaChoisie, etape: 'arrivee_bateau', tempsDebut: langueDejaChoisie ? Date.now() : 0 }; // Phase d'introduction
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de c≈ìurs vers les petits c≈ìurs du haut (phase d'√©veil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'√©toiles vers les briques en mode nuit (phase de r√©v√©lation)
         * 4. 'feux_artifice' : C√©l√©bration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: langueDejaChoisie, // Actif si langue d√©j√† choisie
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: langueDejaChoisie ? Date.now() : 0,
            dureeArret: 20000 // 20 secondes d'arr√™t
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.0006, 0.4); // Vitesse r√©duite 10x

            // Les objets kawaii seront activ√©s apr√®s l'animation d'intro
            // activerObjetsKawaii(); // Trop t√¥t, on attend la fin de l'intro

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 38,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Initialiser les gestionnaires d'√©v√©nements des oiseaux CSS
            setupBirdClickHandlers();

            // Initialiser le module mode secret
            initSecretModeModule();

            // Initialiser le gestionnaire de musique
            initMusicManager();

            // Les objets kawaii sont maintenant g√©r√©s par le module secret seulement

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors √©cran √† gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = Date.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            
            // Conserver les munitions pour phases mur 17-21 (mode tir MUR)
            // Phase 22 utilise balle normale donc munitions = 0
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const estPhaseMur17_21 = phaseActuelle >= 17 && phaseActuelle <= 21 && phaseJeu === 'mur';
            const munitionsAvant = munitions;
            if (!estPhaseMur17_21) {
                munitions = 0; // Commencer sans munitions (sauf phases mur 17-21)
                console.log(`üî´ initJeu() - Phase ${phaseActuelle} (${phaseJeu}): munitions ${munitionsAvant} ‚Üí 0 (normal)`);
            } else {
                console.log(`üî´ initJeu() - Phase ${phaseActuelle} (${phaseJeu}): munitions ${munitionsAvant} ‚Üí CONSERV√âES (mode mur 17-21)`);
            }
            // Si phase 17-21, garder les munitions (ne pas r√©initialiser √† 0)
            
            rechargement = 0;

            briques = [];

            // Cr√©er les briques si on est en phase stars (nuit) - FORC√â
            if(phaseJeu === 'stars') {
                // FORCER l'arr√™t de tous les syst√®mes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                // Introduction termin√©e

                // Les objets kawaii sont r√©serv√©s au mode secret seulement
                // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                // FORCER la cr√©ation des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Cr√©er
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les c≈ìurs
            const zoneW = C.W - 40;

            // Positions dispers√©es et tailles diff√©rentes pour chaque c≈ìur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront cr√©√©es √† partir des petits c≈ìurs du haut
            // Initialisation vide, elles appara√Ætront lors du d√©doublement des c≈ìurs
            briques = [];
            particules = [];
            powerUps = [];
            // Garder l'√©tat de la lanterne pendant initJeu() - ne pas la remettre √† z√©ro
            // lanterne conserve son √©tat pr√©c√©dent
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propri√©t√©s selon la phase
            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au d√©but
                    dy: 0, // Immobile au d√©but
                    visible: true, // Visible en phase lanterne/mur
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles √©toiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Cr√©er les 10 petits c≈ìurs d√©coratifs en haut (seulement en mode coeurs)
            if(phaseJeu !== 'lanterne' && phaseJeu !== 'stars') {
                creerPetitsCoeurs();
            }

            // Cacher les c≈ìurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'√©toile principale - utiliser les projectiles stars

            // R√©initialiser la phase d'intro (activ√©e apr√®s l'animation du bateau)
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (!animationBateau.active) return;

            const tempsActuel = Date.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arriv√©e depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arriv√©e fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arriv√© au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // Intro d√©j√† g√©r√©e par gererPhaseIntro()
                        // narrationManager.start();
                    }
                    break;

                case 'arret':
                    // Bateau arr√™t√©, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de d√©part vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'√©cran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation termin√©e, d√©marrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        // Introduction termin√©e // Phase de jeu

                        // Les objets kawaii sont r√©serv√©s au mode secret seulement
                        // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                        // Repositionner le bateau normalement et d√©marrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;
                        jeu = true; // Activer le jeu
                        phaseJeu = 'tir_coeurs_haut'; // Commencer par la premi√®re phase

                        // R√©v√©ler les petits c≈ìurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre √† jour l'√©toile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            if (!phaseIntro.active) {
                // Intro termin√©e - comportement normal
                return;
            }

            const tempsEcoule = Date.now() - phaseIntro.tempsDebut;
            // Log d√©sactiv√© : gererPhaseIntro

            if (phaseIntro.etape === 'arrivee_bateau') {
                // Phase d'introduction: D√©marrer l'intro tr√®s rapidement
                if (tempsEcoule >= 200) { // R√©duire √† 0.2 seconde
                    // D√©marrer le syst√®me narratif avec la premi√®re phase (une seule fois)
                    if (narrationManager && !window.narrationStarted) {
                        window.narrationStarted = true; // Marquer comme d√©j√† d√©marr√©

                        // Attendre les traductions avant de d√©marrer
                        (async () => {
                            if (window.translationsReady) {
                                await window.translationsReady;
                            }

                            // Forcer l'affichage de l'intro imm√©diatement
                            if (narrationManager.narrativeData && narrationManager.narrativeData.phases) {
                                narrationManager.start();
                            } else {

                            // Utiliser notre syst√®me simple unifi√©
                            afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.intro_full', "On m'a dit qu'ils √©taient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai pr√©f√©r√© aller voir\nde mes propres yeux..."), 12000);

                            // Activer le bouton passer pendant l'intro
                            boutonPasser.actif = true;

                            // D√©sactiver le bouton apr√®s l'intro
                            setTimeout(() => {
                                boutonPasser.actif = false;
                            }, 12000);
                            }
                        })(); // Fin fonction async
                    }
                    phaseIntro.etape = 'rafales';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'rafales') {
                // Phase 1: R√©duire l'attente pour un flux plus rapide
                if (tempsEcoule >= 1000) { // R√©duire de 2s √† 1s
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                if (tempsEcoule >= 1000) {
                    phaseIntro.active = false;
                    jeu = true; // D√©marrer le jeu

                    // üé¨ D√âMARRER LA NARRATION APR√àS L'INTRO
                    if (narrationManager && narrationManager.currentPhase === 0) {
                        (async () => {
                            if (window.translationsReady) {
                                await window.translationsReady;
                            }
                            narrationManager.start();
                        })();
                    }

                    // üéµ Pr√©parer le d√©marrage de la musique au prochain clic
                    if (musicManager && !musicManager.isPlaying) {
                        window.musicReadyToStart = true;
                    }

                    // Ne pas forcer le mode - conserver le mode d√©j√† configur√© par narrationManager
                    // Message g√©r√© par le nouveau syst√®me narratif
                }
            }
        }

        // Interface int√©gr√©e compl√®te
        function dessinerInterface() {
            ctx.save();

            // Header optimis√© tr√®s compact - bleu roi
            const headerH = Math.max(C.H * 0.045, 32);
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.fillRect(0, 0, C.W, headerH);

            // Lignes ondul√©es en fond transparent blanc
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const waveY = headerH * (0.2 + i * 0.3);
                const waveLength = C.W / 8;
                for(let x = 0; x <= C.W; x += 10) {
                    const y = waveY + Math.sin((x / waveLength) * Math.PI * 2) * 3;
                    if(x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();

            // Bordure header
            ctx.strokeStyle = '#3b82f6'; // Bordure bleu plus clair
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre centr√© en hauteur
            const titleY = headerH / 2 + 4; // Centr√© verticalement dans le header
            const iconSize = Math.max(C.H * 0.008, 8); // Tr√®s petits bateaux

            ctx.save();
            // Titre moderne et plus gros
            ctx.fillStyle = '#ffffff';
            ctx.font = `800 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = '2px';
            
            const titleText = getTranslatedText('ui.game_title', 'PETIT BATEAU');
            ctx.fillText(titleText, C.W/2, titleY);

            // Calculer la largeur du texte pour positionner les bateaux
            const titleWidth = ctx.measureText(titleText).width;
            const boatPadding = 15; // Espace entre le texte et les bateaux
            
            // Tr√®s petits bateaux discrets - positionn√©s selon la largeur du texte
            const leftBoatX = C.W/2 - titleWidth/2 - boatPadding;
            const rightBoatX = C.W/2 + titleWidth/2 + boatPadding;
            drawBoatIcon(ctx, leftBoatX, titleY - iconSize, iconSize, 'red');
            drawBoatIcon(ctx, rightBoatX, titleY - iconSize, iconSize, 'blue');

            // Menu HOME supprim√©

            ctx.restore();

            // Afficher le titre du voyage si actif
            if (titreVoyage.active && Date.now() < titreVoyage.fin) {
                const voyageY = Math.max(C.H * 0.10, 70); // Tr√®s l√©g√®rement plus bas
                ctx.save();

                // Style moderne avec blanc et ombres
                ctx.fillStyle = '#ffffff';
                ctx.font = `700 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', system-ui, sans-serif`;
                ctx.textAlign = 'center';

                // Ombres multiples pour effet profondeur
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 8;

                // S√©parer le nom du voyage et la phase
                const lignes = titreVoyage.texte.split('\n');
                const voyageNom = lignes[0];
                const phaseTexte = lignes[1] || '';

                const voyageLabel = getTranslatedText('game.phase_display.voyage', 'Voyage');

                // Premi√®re ombre (arri√®re) pour le titre voyage
                ctx.fillText(`üó∫Ô∏è ${voyageLabel} ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Deuxi√®me couche avec ombre plus subtile pour le titre
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 4;
                ctx.fillText(`üó∫Ô∏è ${voyageLabel} ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Sous-titre phase masqu√© - d√©j√† affich√© dans le header
                // if (phaseTexte) {
                //     ctx.font = `600 ${Math.max(C.H * 0.018, 16)}px 'Segoe UI', system-ui, sans-serif`;
                //     ctx.fillStyle = '#ffffff';
                //     ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                //     ctx.shadowOffsetX = 2;
                //     ctx.shadowOffsetY = 2;
                //     ctx.shadowBlur = 6;
                //     ctx.fillText(phaseTexte, C.W/2, voyageY + Math.max(C.H * 0.035, 28));
                // }

                ctx.restore();
            } else if (titreVoyage.active && Date.now() >= titreVoyage.fin) {
                titreVoyage.active = false; // D√©sactiver apr√®s 4 secondes
            }

            // Stats ligne avec fond blanc plus pr√®s du header
            const statsY = Math.max(C.H * 0.045, 30); // Beaucoup plus pr√®s du header
            const padding = 8;
            const bgHeight = Math.max(C.H * 0.025, 20);

            // Fond blanc pour toute la barre de stats
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, statsY - bgHeight/2, C.W, bgHeight);

            // Bordure subtile
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, statsY - bgHeight/2, C.W, bgHeight);

            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points XP avec indicateur de langue - centr√© verticalement dans la barre
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const languageFlag = getCurrentLanguageFlag();
            
            // Effet de survol simple et s√ªr sur le drapeau
            if (flagHoverAnimation > 0) {
                // Interpolation pour l'animation
                const alpha = flagHoverAnimation;
                
                const x = 8, y = statsY - 16, w = 134, h = 32;
                const radius = 6;
                
                // Rectangle de fond simple avec transparence anim√©e
                ctx.fillStyle = `rgba(74, 144, 226, ${alpha * 0.2})`;
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                ctx.fill();
                
                // Bordure subtile
                ctx.strokeStyle = `rgba(74, 144, 226, ${alpha * 0.4})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Texte avec transition de couleur simple
                const r = Math.round(44 + (74 - 44) * alpha);  // Vers un bleu fonc√©
                const g = Math.round(62 + (144 - 62) * alpha);
                const b = Math.round(80 + (226 - 80) * alpha);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            } else {
                // √âtat normal
                ctx.fillStyle = '#2c3e50';
            }
            
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`${languageFlag} | ‚≠ê XP: ${pointsConnaissance}`, 15, statsY);
            } else {
                ctx.fillText(`${languageFlag} | üïäÔ∏è ${score}`, 15, statsY);
            }
            
            // IMPORTANT : R√©initialiser imm√©diatement l'ombre apr√®s le texte du drapeau
            ctx.shadowColor = 'transparent';
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;

            // Progression avec voyage et phase
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            ctx.fillStyle = '#2c3e50'; // S'assurer que la couleur est correcte pour la phase
            let phaseInfo = '';
            if (narrationManager && narrationManager.currentPhase) {
                const phase = narrationManager.currentPhase; // Phase 1 = intro simple
                let voyageIcon = '';
                let voyageName = '';

                if (phase === 1) {
                    voyageIcon = 'üåÖ'; voyageName = getTranslatedText('game.voyage_names.dawn_of_doubts', 'L\'aube des doutes');
                } else if (phase === 2) {
                    voyageIcon = '‚òÄÔ∏è'; voyageName = getTranslatedText('game.voyage_names.light', 'La lumi√®re');
                } else if (phase >= 3 && phase <= 4) {
                    voyageIcon = '‚òÅÔ∏è'; voyageName = getTranslatedText('game.voyage_names.shadow_of_clouds', 'L\'ombre des nuages');
                } else if (phase >= 5 && phase <= 6) {
                    voyageIcon = 'ü§´'; voyageName = getTranslatedText('game.voyage_names.silence_of_soul', 'Le silence de l\'√¢me');
                } else if (phase >= 7 && phase <= 9) {
                    voyageIcon = '‚ù§Ô∏è'; voyageName = getTranslatedText('game.voyage_names.humanity_of_hearts', 'L\'humanit√© des c≈ìurs');
                } else if (phase >= 10 && phase <= 12) {
                    voyageIcon = 'üß†'; voyageName = getTranslatedText('game.voyage_names.wisdom_of_differences', 'La sagesse des diff√©rences');
                } else if (phase >= 13 && phase <= 15) {
                    voyageIcon = 'üåç'; voyageName = getTranslatedText('game.voyage_names.unity', 'L\'unit√©');
                } else if (phase === 16) {
                    voyageIcon = 'üéÜ'; voyageName = getTranslatedText('game.voyage_names.unity_of_humanity', 'L\'Unit√© de l\'Humanit√©');
                } else if (phase >= 17 && phase <= 22) {
                    voyageIcon = 'üß±'; voyageName = getTranslatedText('game.voyage_names.wall_of_greed', 'Le Mur d\'avarice');
                } else {
                    voyageIcon = 'üó∫Ô∏è'; voyageName = getTranslatedText('game.voyage_names.default', 'Voyage');
                }

                const phaseLabel = getTranslatedText('game.phase_display.phase_counter', 'Phase');
                phaseInfo = `üó∫Ô∏è ${phaseLabel} ${phase}/23`;
            } else {
                phaseInfo = `üß± ${brises}/${VOYAGE.length}`;
            }
            ctx.fillText(phaseInfo, C.W/2, statsY);

            // Vies
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const coeurs = vies > 0 ? '‚ù§Ô∏è'.repeat(vies) : 'üíî';
            ctx.fillText(coeurs, C.W - 15, statsY);

            // Affichage des commandes mode passe d√©sactiv√©
            /*
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                'üîë MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir √©toiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();
            */

            ctx.restore();
        }

        // Tirer un projectile √©toile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars, feux_artifice ET lanterne (pour Poxerstart)
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice' && phaseJeu !== 'lanterne') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation √©toile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de d√©placement pour la tra√Æn√©e
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Tra√Æn√©e d'√©toile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // Gradient de la tra√Æn√©e
                const gradientTrainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                // Tra√Æn√©e dor√©e normale
                gradientTrainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                gradientTrainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradientTrainee.addColorStop(1, projectile.couleur || '#FFD700');

                // Dessiner la tra√Æn√©e
                ctx.fillStyle = gradientTrainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'√©toile elle-m√™me
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // √âtoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // Halo lumineux
                    const gradientHalo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                    gradientHalo.addColorStop(0, projectile.couleur || '#FFD700');
                    gradientHalo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradientHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = gradientHalo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // √âtoile centrale brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, projectile.couleur || '#FFD700');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0.8)');

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // √âtoile √† 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre √† jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    //
                                    // Phases 17-22 : un mot sur deux s'envole (visible)
                                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                    if(phaseActuelle >= 17 && phaseActuelle <= 22) {
                                        // Un mot sur deux est visible (les autres invisibles)
                                        const estVisible = (Math.random() < 0.5); // 50% de chance
                                        ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2, !estVisible); // false = visible
                                    }

                                    // üîä Son d'explosion douce
                                    AudioSystem.playExplosion();
                                    // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // V√©rifier la condition de fin apr√®s destruction de brique
                                    const briquesRestantes = briques.filter(b => b.visible).length;console.log(`üîç V√©rif briques restantes (√©toile): ${briquesRestantes}`);
                                    if(briquesRestantes === 0) {
                                        // üåà EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collect√© !
                                        const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                        if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                            // V√©rifier si le power-up existe et n'est PAS collect√©
                                            const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                            if (espoirPresent) {
                                                console.log('üåà Phase 22 : Mur d√©truit mais power-up ESPOIR pas encore collect√© (√©toile) !');
                                                console.log('   ‚Üí La phase ne se termine pas automatiquement.');
                                                return; // ‚Üê Sortir sans transition ET sans animation
                                            }
                                        }

                                        console.log('üéØ Toutes les briques d√©truites (√©toile)! Animation d\'explosion...');

                                        // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                        animerExplosionIconeCollector(() => {
                                            narrationManager.goToNextPhaseDirect();
                                        });
                                    }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // Collision avec les petits c≈ìurs
                petitsCoeurs.forEach((petitCoeur, j) => {
                    if(!petitCoeur.visible) return;

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // C≈ìur touch√© !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        if (petitCoeur.etape && petitCoeur.etape.nom) {
                            if (petitCoeur.etape && petitCoeur.etape.nom) {
                                ajouterTexteVolant(`+${typeof petitCoeur.etape.nom === 'function' ? petitCoeur.etape.nom() : petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);
                            }
                        }

                        // üîä Son "pof" doux pour les petits c≈ìurs
                        AudioSystem.playPof();

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                        const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                        //
                        if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {

                            // üîä Son "pof" doux pour l'explosion finale
                            AudioSystem.playExplosionCoeurs();

                            // üéÜ ANIMATION D'EXPLOSION PUIS PASSAGE AU MODE LANTERNE
                            animerExplosionIconeCollector(() => {
                                // Passer au mode lanterne (casse-briques)
                                phaseJeu = 'lanterne';
                                balle.visible = true;
                                balle.enAttente = true;
                                balle.dx = 0;
                                balle.dy = 0;
                                
                                // Message de transition
                                afficherMessagePowerupSimple(getTranslatedText('game.messages.lantern_mode_start', 'üèÆ Mode Lanterne activ√© !'));
                                
                                narrationManager.goToNextPhaseDirect();
                                // Ne plus cr√©er de c≈ìurs d√©coratifs - ils r√©apparaissent √† la fin
                            });
                        }
                        return;
                    }
                });
            }
        }

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // Dessiner la lanterne √©teinte comme balle du jeu UNIQUEMENT pendant la phase casse-briques
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0; // Position de la balle
            const posY = balle.y || 0; // Position de la balle
            const temps = Date.now() * 0.001;

            // V√©rification de s√©curit√© pour √©viter les valeurs non finies
            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // EFFET TRA√éN√âE VERTE (power-up vitesse)
            if(balle.traineeVerte && balle.vitesseActive) {
                // Tra√Æn√©e verte dynamique
                for(let i = 0; i < 5; i++) {
                    const alpha = (5 - i) / 5 * 0.6;
                    const size = C.BS * (1 - i * 0.15);
                    const offsetX = (balle.dx || 0) * -i * 2;
                    const offsetY = (balle.dy || 0) * -i * 2;

                    const grad = ctx.createRadialGradient(
                        posX + offsetX, posY + offsetY, 0,
                        posX + offsetX, posY + offsetY, size
                    );
                    grad.addColorStop(0, `rgba(0, 255, 0, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 255, 50, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(0, 255, 0, 0)`);

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(posX + offsetX, posY + offsetY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 1. HALO DE BOUGIE SIMPLE (seulement si lanterne active)
            if(lanterne.active) {
                // Halo simple statique
                const haloSize = C.BS * 1.5;
                const haloIntensity = 0.4;

                // Halo principal simple avec v√©rification
                if (isFinite(haloSize) && haloSize > 0) {
                    const haloGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, haloSize);
                haloGrad.addColorStop(0, `rgba(255, 220, 150, ${haloIntensity})`);
                haloGrad.addColorStop(0.3, `rgba(255, 180, 100, ${haloIntensity * 0.7})`);
                haloGrad.addColorStop(0.7, `rgba(255, 140, 60, ${haloIntensity * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');

                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. LANTERNE CYLINDRIQUE CLASSIQUE

            // Dimensions de la lanterne avec multiplicateur de taille si actif
            const multiplTaille = balle.multiplicateurTaille || 1;
            const rayon = C.BS * 0.4 * multiplTaille;        // Rayon du cylindre
            const corpsH = C.BS * 1.2 * multiplTaille;       // Hauteur du corps cylindrique
            const domeH = C.BS * 0.1 * multiplTaille;        // Hauteur du d√¥me
            const baseH = C.BS * 0.1 * multiplTaille;        // Hauteur de la base

            // LUEUR DOUCE AUTOUR DE LA LANTERNE
            if(lanterne.active) {
                // Halo de lueur douce adapt√© √† la taille
                const lueurSize = rayon * 1.25;
                if (isFinite(rayon) && isFinite(lueurSize) && rayon > 0 && lueurSize > 0) {
                    const lueurGrad = ctx.createRadialGradient(posX, posY, rayon, posX, posY, lueurSize);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.2)');
                lueurGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
                ctx.fillStyle = lueurGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, lueurSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Armature m√©tallique de la lanterne
            const armatureColor = lanterne.active ? '#B8860B' : '#654321';
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;

            // BASE RONDE plus petite
            const baseY = posY + corpsH/2;
            ctx.fillStyle = armatureColor;
            ctx.beginPath();
            ctx.ellipse(posX, baseY, rayon * 1.05, baseH, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // CORPS CYLINDRIQUE
            const corpsTop = posY - corpsH/2;
            const corpsBottom = posY + corpsH/2;

            // Vitres cylindriques
            if(lanterne.active) {
                // Vitres dor√©es lumineuses
                if (isFinite(rayon) && rayon > 0) {
                    const vitreGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, rayon);
                    vitreGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    vitreGrad.addColorStop(0.7, 'rgba(255, 200, 0, 0.6)');
                    vitreGrad.addColorStop(1, 'rgba(255, 180, 0, 0.4)');
                    ctx.fillStyle = vitreGrad;
                } else {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                }
            } else {
                // Vitres √©teintes
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.ellipse(posX, posY, rayon, corpsH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Contour du cylindre
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Barreaux en forme de croix
            ctx.beginPath();
            // Barre verticale
            ctx.moveTo(posX, corpsTop);
            ctx.lineTo(posX, corpsBottom);
            // Barre horizontale
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // D√îME SUP√âRIEUR
            const domeTop = corpsTop - domeH;
            ctx.fillStyle = armatureColor;
            ctx.strokeStyle = '#CD7F32';
            ctx.lineWidth = 2;

            // D√¥me en forme d'ellipse plus petit
            ctx.beginPath();
            ctx.ellipse(posX, domeTop + domeH/2, rayon * 0.9, domeH/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 3. FLAMME AVEC ANIMATIONS TR√àS LENTES
            if(lanterne.active) {
                // Flamme avec mouvement encore plus lent et doux
                const flammeX = posX + Math.sin(temps * 0.1) * 1 * multiplTaille; // Encore plus lent
                const flammeY = posY - C.BS * 0.3 * multiplTaille;
                const flammeH = C.BS * 0.6 * multiplTaille;
                const flammeW = C.BS * 0.3 * multiplTaille;

                // Flamme principale avec danse tr√®s douce
                if (isFinite(flammeX) && isFinite(flammeY) && isFinite(flammeH) && flammeH > 0) {
                    const flammeGrad = ctx.createRadialGradient(flammeX, flammeY, 0, flammeX, flammeY, flammeH);
                flammeGrad.addColorStop(0, '#FFFF99');
                flammeGrad.addColorStop(0.3, '#FFD700');
                flammeGrad.addColorStop(0.6, '#FFA500');
                flammeGrad.addColorStop(1, '#FF6347');

                    ctx.fillStyle = flammeGrad;
                    ctx.beginPath();
                    // Forme de flamme avec variations encore plus lentes
                    ctx.ellipse(flammeX, flammeY, flammeW * (0.6 + Math.sin(temps * 0.12) * 0.05), flammeH * (0.8 + Math.cos(temps * 0.1) * 0.05), Math.sin(temps * 0.06) * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    // C≈ìur de la flamme plus lumineux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(flammeX, flammeY, flammeW * 0.3, flammeH * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // M√®che de la bougie
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1 * multiplTaille, posY, 2 * multiplTaille, C.BS * 0.2 * multiplTaille);
            } else {
                // M√®che √©teinte
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY - 2, 2, 4);

                // C≈ìur d'humanit√© au repos
                const coeurSize = C.BS * 0.4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(posX, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX, posY, posX - coeurSize*0.5, posY, posX - coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX - coeurSize*0.5, posY + coeurSize*0.7, posX, posY + coeurSize*0.7, posX, posY + coeurSize);
                ctx.bezierCurveTo(posX, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX + coeurSize*0.5, posY, posX, posY, posX, posY + coeurSize*0.3);
                ctx.fill();
            }

            // 4. SYST√àME DE SUSPENSION SIMPLE
            const cordeLength = C.BS * 1;
            ctx.strokeStyle = lanterne.active ? '#8B4513' : '#4a4a4a';
            ctx.lineWidth = 2;

            // Cordes depuis le d√¥me adapt√©es √† la taille
            ctx.beginPath();
            ctx.moveTo(posX - rayon*0.6, domeTop); // Gauche du d√¥me
            ctx.lineTo(posX - rayon*0.2, posY - cordeLength);
            ctx.moveTo(posX + rayon*0.6, domeTop); // Droite du d√¥me
            ctx.lineTo(posX + rayon*0.2, posY - cordeLength);
            ctx.stroke();

            // Corde centrale
            ctx.beginPath();
            ctx.moveTo(posX, domeTop); // Centre du d√¥me
            ctx.lineTo(posX, posY - cordeLength);
            ctx.stroke();

            ctx.restore();
        }

        // Fonction pour dessiner les ic√¥nes de bateaux miniatures
        function drawBoatIcon(ctx, x, y, size, color) {
            ctx.save();

            // Couleurs selon le type
            let coqueColors, borderColor;
            if (color === 'red') {
                coqueColors = ['#ff6b6b', '#e74c3c', '#c0392b'];
                borderColor = '#a93226';
            } else {
                coqueColors = ['#74b9ff', '#0984e3', '#2d3436'];
                borderColor = '#2d3436';
            }

            // Coque simplifi√©e
            const coqueW = size * 1.5;
            const coqueH = size * 0.8;

            const coqueGrad = ctx.createLinearGradient(x, y, x, y + coqueH);
            coqueGrad.addColorStop(0, coqueColors[0]);
            coqueGrad.addColorStop(0.5, coqueColors[1]);
            coqueGrad.addColorStop(1, coqueColors[2]);

            ctx.fillStyle = coqueGrad;
            ctx.beginPath();
            ctx.ellipse(x, y + coqueH/2, coqueW/2, coqueH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bordure
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // M√¢t
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + coqueH/2);
            ctx.lineTo(x, y - size);
            ctx.stroke();

            // Voile triangulaire
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size/2, y);
            ctx.lineTo(x + size/3, y - size/3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#ced4da';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau √©l√©gant g√©om√©trique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // EFFET POXERSTART (aura rose pulsante)
            if(raquette.poxerstart && Date.now() < raquette.poxerstartFin) {
                const tempsRestant = (raquette.poxerstartFin - Date.now()) / 7000; // 0 √† 1
                const pulsation = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                const alpha = tempsRestant * pulsation * 0.6;

                // Aura rose autour du bateau
                const grad = ctx.createRadialGradient(
                    raquette.x + C.PW/2, raquette.y + C.PH/2, 0,
                    raquette.x + C.PW/2, raquette.y + C.PH/2, C.PW * 1.5
                );
                grad.addColorStop(0, `rgba(255, 105, 180, ${alpha})`);
                grad.addColorStop(0.7, `rgba(255, 105, 180, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 105, 180, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(
                    raquette.x - C.PW * 0.5, raquette.y - C.PH * 0.5,
                    C.PW * 2, C.PH * 2
                );

                // √âtoiles qui scintillent autour
                for(let i = 0; i < 3; i++) {
                    const angle = Date.now() * 0.005 + i * Math.PI * 2 / 3;
                    const rayon = C.PW * 0.8;
                    const x = raquette.x + C.PW/2 + Math.cos(angle) * rayon;
                    const y = raquette.y + C.PH/2 + Math.sin(angle) * rayon * 0.5;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', x, y);
                }
            } else if(raquette.poxerstart) {
                // Nettoyer l'effet quand fini
                raquette.poxerstart = false;
            }

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec √©trave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient bleu pour la coque
                // Protection contre les valeurs NaN
                const isValid = isFinite(raquette.x) && isFinite(raquette.y) && isFinite(C.PH);

                if (isValid) {
                    const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                    coqueGrad.addColorStop(0, '#74b9ff'); // Bleu clair
                    coqueGrad.addColorStop(0.5, '#0984e3'); // Bleu moyen
                    coqueGrad.addColorStop(1, '#2d3436'); // Bleu fonc√©
                    ctx.fillStyle = coqueGrad;
                } else {
                    ctx.fillStyle = '#0984e3'; // Couleur de secours
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                if (isValid) {
                    const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                    refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                    refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = refletGrad;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                if (isFinite(matX) && isFinite(matY) && isValid) {
                    const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                    voileGrad.addColorStop(0, '#ffffff');
                    voileGrad.addColorStop(0.6, '#f8f9fa');
                    voileGrad.addColorStop(1, '#e9ecef');
                    ctx.fillStyle = voileGrad;
                } else {
                    ctx.fillStyle = '#f8f9fa';
                }
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Protection contre les valeurs NaN
                const isValid = isFinite(raquette.x) && isFinite(raquette.y) && isFinite(C.PH);

                // Coque du bateau - forme en V tr√®s grosse qui touche le m√¢t
                const coquePoints = [
                    [raquette.x, raquette.y + C.PH * 0.3],               // Arri√®re gauche (pont plus haut)
                    [raquette.x + C.PW * 0.02, raquette.y + C.PH * 1.3], // Fond gauche (descend en V)
                    [raquette.x + C.PW * 0.5, raquette.y + C.PH * 1.5],  // Point le plus bas du V (quille)
                    [raquette.x + C.PW * 0.98, raquette.y + C.PH * 1.3], // Fond droit (remonte du V)
                    [raquette.x + C.PW, raquette.y + C.PH * 0.3]         // Arri√®re droite (pont plus haut)
                ];

                // Gradient rouge pour la coque
                if (isValid) {
                    const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                    coqueGrad.addColorStop(0, '#ff6b6b');
                    coqueGrad.addColorStop(0.5, '#e74c3c');
                    coqueGrad.addColorStop(1, '#c0392b');
                    ctx.fillStyle = coqueGrad;
                } else {
                    ctx.fillStyle = '#e74c3c';
                }

                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                if (isValid) {
                    const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                    refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                    refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = refletGrad;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // üåä √âcume en avant-plan du bateau
        function dessinerEcume() {
            if (modeSecret || !raquette.vitesse || Math.abs(raquette.vitesse) < 0.5) return;

            const nbBulles = 5;

            for (let i = 0; i < nbBulles; i++) {
                const offsetX = (Math.random() - 0.5) * C.PW * 0.8;
                const offsetY = Math.random() * 5;
                const taille = 2 + Math.random() * 3;
                const alpha = 0.3 + Math.random() * 0.4;

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(
                    raquette.x + C.PW/2 + offsetX,
                    raquette.y + C.PH + offsetY,
                    taille,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        // Vraies briques avec c≈ìurs √† l'int√©rieur pour le casse-brique
        function dessinerPrejuges() {
            // Mot-cl√© qui se r√©v√®le en cassant les briques (phases 17-22)
            if(narrationManager && narrationManager.currentPhase >= 17 && narrationManager.currentPhase <= 22) {
                // Mots-cl√©s pour chaque phase
                const motsEnigmes = {
                    17: 'AVARICE',
                    18: 'LIBERT√â',
                    19: 'REFUS',
                    20: 'ORGUEIL',
                    21: 'IN√âGALIT√âS',
                    22: 'ESPOIR'
                };

                const phaseActuelle = narrationManager.currentPhase;
                const motComplet = motsEnigmes[phaseActuelle] || '√âNIGME';

                // Calculer progression : nombre de briques d√©truites / total
                const totalBriques = briques.length;
                const briquesDetruites = briques.filter(b => !b.visible).length;
                const progression = totalBriques > 0 ? briquesDetruites / totalBriques : 0;

                // Nombre de lettres √† r√©v√©ler
                const nbLettresAR√©v√©ler = Math.floor(progression * motComplet.length);

                // Texte r√©v√©l√© progressivement
                let texteR√©v√©l√© = '';
                for(let i = 0; i < motComplet.length; i++) {
                    if(i < nbLettresAR√©v√©ler) {
                        texteR√©v√©l√© += motComplet[i]; // Lettre r√©v√©l√©e
                    } else {
                        texteR√©v√©l√© += '_'; // Lettre cach√©e
                    }
                }

                ctx.save();
                ctx.globalAlpha = 0.2; // Transparence
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 70px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Ombre fine
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 3;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillText(texteR√©v√©l√©, C.W / 2, C.H * 0.45); // D√©plac√© plus bas (45% au lieu de 32%)
                ctx.restore();
            }

            briques.forEach((brique, index) => {
                if(!brique.visible) return;

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec √©tat de d√©g√¢ts
                ctx.save();

                // Style diff√©rent pour les briques de mur (phases 17-22)
                const estBriqueMur = brique.type === 'mur';

                if (estBriqueMur) {
                    // STYLE MUR : Simple, trait blanc √©pais, couleur mate
                    ctx.fillStyle = couleur;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 4; // Trait blanc √©pais

                    // Rectangle simple
                    ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                    ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);

                    // L√©ger effet ponc√© (transparence sur les bords)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(brique.x + 2, brique.y + 2, brique.w - 4, brique.h * 0.3);
                } else {
                    // STYLE NORMAL : Briques classiques avec effets 3D
                    // Couleur selon la vie restante
                    let couleurBrique = couleur;
                    if (brique.vieMax === 2) {
                        // Phase lanterne : 2 vies maximum
                        if (brique.vie === 1) {
                            // Brique endommag√©e (1er coup re√ßu sur 2)
                            couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.6)`;
                        }
                    } else {
                        // Phase stars : 3 vies maximum
                        if (brique.vie === 2) {
                            // Brique l√©g√®rement endommag√©e (1er coup re√ßu sur 3)
                            couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.8)`;
                        } else if (brique.vie === 1) {
                            // Brique tr√®s endommag√©e (2√®me coup re√ßu sur 3)
                            couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.5)`;
                        }
                    }

                    ctx.fillStyle = couleurBrique;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;

                    // Clignotement si r√©cemment touch√©e
                    if (brique.clignotement > 0) {
                        ctx.fillStyle = '#FFFFFF';
                        brique.clignotement--;
                    }

                    // Rectangle de brique
                    ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                    ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);

                    // Effet 3D de brique
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.3); // Highlight du haut

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(brique.x, brique.y + brique.h * 0.8, brique.w, brique.h * 0.2); // Ombre du bas
                }

                // Dessiner les fissures zigzag blanches selon les d√©g√¢ts (pas pour les murs)
                if (!estBriqueMur && ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2))) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    // Premi√®re fissure zigzag apr√®s le 1er coup
                    ctx.beginPath();
                    const startX1 = brique.x + brique.w * 0.3;
                    const endX1 = brique.x + brique.w * 0.2;
                    const segments = 4; // Nombre de segments zigzag
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX1 + (endX1 - startX1) * progress + (i % 2 === 0 ? 0 : brique.w * 0.05) * Math.sin(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                if (!estBriqueMur && brique.vie <= 1) {
                    // Deuxi√®me fissure zigzag apr√®s le 2√®me coup
                    ctx.beginPath();
                    const startX2 = brique.x + brique.w * 0.7;
                    const endX2 = brique.x + brique.w * 0.8;
                    const segments = 4;
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX2 + (endX2 - startX2) * progress + (i % 2 === 1 ? 0 : brique.w * 0.04) * Math.cos(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le c≈ìur √† l'int√©rieur de la brique (pas pour les murs ni les drapeaux)
                if (!estBriqueMur && brique.type !== 'drapeau') {
                    dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);
                }

                // Dessiner le drapeau pour les briques drapeaux
                if (brique.type === 'drapeau' && brique.drapeau) {
                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(brique.drapeau, centreX, centreY);
                    ctx.shadowBlur = 0;
                }

                // En phase stars (nuit), afficher les mots pour guider le joueur
                // Sauf pour les phases 17-22 (montagnes) o√π le texte est invisible
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const afficherTexte = phaseActuelle < 17 || phaseActuelle > 22;

                if(phaseJeu === 'stars' && brique.etape && (typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom) && afficherTexte) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Contour noir pour la lisibilit√©
                    const nomBrique = typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom;
                    ctx.strokeText(nomBrique, centreX, centreY + brique.h * 0.3);
                    // Texte blanc par-dessus
                    ctx.fillText(nomBrique, centreX, centreY + brique.h * 0.3);
                }

                // En phase lanterne, le texte reste cach√© - il n'appara√Æt que lors de l'explosion
                // Le myst√®re reste entier jusqu'√† la lib√©ration du c≈ìur !
            });
        }

        // Messages simples centr√©s pour powerups et narratifs
        let messagePowerupActif = null;
        let messageNarratifActif = null;

        // Syst√®me d'√©clairs pour le mode nuit
        let eclairNuit = {
            actif: false,
            flashBlanc: false,
            intensite: 0,
            duree: 0,
            tempsProchainEclair: 0,
            delaiMinimum: 8000,  // 8 secondes minimum entre les √©clairs
            delaiMaximum: 20000  // 20 secondes maximum entre les √©clairs
        };

        // Bouton simple "Passer" avec juste texte et ombre
        let boutonPasser = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 150, // Ajust√© pour le texte encore plus gros
            hauteur: 50,  // Ajust√© pour le texte encore plus gros
            getTexte: () => getTranslatedText('ui.skip_button', 'Passer'),
            hover: false,
            pulse: 0 // Animation de pulsation
        };

        // Bouton simple "Continuer" pour phase 16
        let boutonContinuer = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 150,
            hauteur: 40,
            texte: () => getTranslatedText('ui.continue_button', 'Continuer'),
            hover: false
        };

        function afficherMessagePowerupSimple(texte) {
            messagePowerupActif = {
                texte: texte,
                temps: Date.now() + 4000, // 4 secondes (augment√© de 2s)
                alpha: 1.0
            };
        }

        // Afficher une modal avec les d√©tails philosophiques d'Emmanuel pour une √©nigme
        function afficherModalEnigme(enigme) {
            // R√©cup√©rer les traductions ou utiliser les textes fran√ßais
            const nom = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.description`, enigme.nom);
            const mystere = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.mystery`, enigme.mystere);
            const revelation = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.revelation`, enigme.revelation);
            const sagesse = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.wisdom`, enigme.sagesse);

            // Cr√©er la modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 20000;
                backdrop-filter: blur(5px);
                animation: modalFadeIn 0.3s ease-out;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                border: 3px solid #4a90e2;
                border-radius: 20px;
                padding: 30px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                animation: modalSlideIn 0.3s ease-out;
            `;

            modalContent.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 20px;">${enigme.icone}</div>
                <h2 style="color: #4a90e2; margin-bottom: 25px; font-size: 28px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${nom}</h2>
                
                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #ff6b6b;">
                    <h3 style="color: #ff6b6b; margin-bottom: 15px; font-size: 20px;">ü§î ${getTranslatedText('interface.labels.mystery', 'Myst√®re')}</h3>
                    <p style="font-size: 18px; line-height: 1.6; font-style: italic;">"${mystere}"</p>
                </div>

                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #4ecdc4;">
                    <h3 style="color: #4ecdc4; margin-bottom: 15px; font-size: 20px;">üí° ${getTranslatedText('interface.labels.revelation', 'R√©v√©lation')}</h3>
                    <p style="font-size: 18px; line-height: 1.6;">${revelation}</p>
                </div>

                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 30px; border-left: 4px solid #feca57;">
                    <h3 style="color: #feca57; margin-bottom: 15px; font-size: 20px;">‚ú® ${getTranslatedText('interface.labels.wisdom', 'Sagesse')}</h3>
                    <p style="font-size: 18px; line-height: 1.6; font-style: italic; color: #feca57;">"${sagesse}"</p>
                </div>

                <button id="closeEnigmaModal" style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 25px;
                    font-size: 18px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">${getTranslatedText('interface.buttons.close', 'Fermer')}</button>
            `;

            modal.appendChild(modalContent);

            // Ajouter les styles CSS pour les animations
            if (!document.querySelector('#enigma-modal-styles')) {
                const style = document.createElement('style');
                style.id = 'enigma-modal-styles';
                style.textContent = `
                    @keyframes modalFadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes modalSlideIn {
                        from { transform: translateY(-50px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }

            // Gestionnaire de fermeture
            const closeModal = () => {
                modal.style.animation = 'modalFadeIn 0.2s ease-in reverse';
                modalContent.style.animation = 'modalSlideIn 0.2s ease-in reverse';
                setTimeout(() => modal.remove(), 200);
                AudioSystem.playClick();
            };

            // Events de fermeture
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            modalContent.querySelector('#closeEnigmaModal').addEventListener('click', closeModal);

            // Ajouter √† la page
            document.body.appendChild(modal);
            AudioSystem.playClick();
        }

        function afficherMessageNarratifSimple(texte, duree = 12000) {
            messageNarratifActif = {
                texte: texte,
                temps: Date.now() + duree,
                tempsDebut: Date.now(),
                alpha: 1.0
            };
        }

        // Fonctions pour les √©clairs en mode nuit
        function initierEclairNuit() {
            if (periode !== 'nuit') return;

            const maintenant = Date.now();
            if (maintenant >= eclairNuit.tempsProchainEclair) {
                // D√©clencher un √©clair
                eclairNuit.actif = true;
                eclairNuit.flashBlanc = true;
                eclairNuit.intensite = 1.0;
                eclairNuit.duree = maintenant + 150; // Flash blanc de 150ms

                // Programmer le prochain √©clair
                const delai = eclairNuit.delaiMinimum + Math.random() * (eclairNuit.delaiMaximum - eclairNuit.delaiMinimum);
                eclairNuit.tempsProchainEclair = maintenant + delai;
            }
        }

        function mettreAJourEclairNuit() {
            if (!eclairNuit.actif) return;

            const maintenant = Date.now();

            if (eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase de flash blanc - intensit√© maximale
                eclairNuit.intensite = 1.0;
            } else if (eclairNuit.flashBlanc && maintenant > eclairNuit.duree) {
                // Fin du flash blanc, commencer l'√©clair bleu
                eclairNuit.flashBlanc = false;
                eclairNuit.duree = maintenant + 300; // √âclair bleu de 300ms
                eclairNuit.intensite = 0.7;
            } else if (!eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase d'√©clair bleu qui s'estompe
                const progression = (eclairNuit.duree - maintenant) / 300;
                eclairNuit.intensite = 0.7 * progression;
            } else {
                // Fin de l'√©clair
                eclairNuit.actif = false;
                eclairNuit.intensite = 0;
            }
        }

        function dessinerEclairNuit() {
            if (!eclairNuit.actif || periode !== 'nuit') return;

            ctx.save();

            if (eclairNuit.flashBlanc) {
                // Flash blanc aveuglant
                ctx.fillStyle = `rgba(255, 255, 255, ${eclairNuit.intensite * 0.8})`;
                ctx.fillRect(0, 0, C.W, C.H);
            } else {
                // √âclair bleu-√©lectrique
                ctx.fillStyle = `rgba(173, 216, 230, ${eclairNuit.intensite * 0.4})`;
                ctx.fillRect(0, 0, C.W, C.H);

                // Dessiner quelques √©clairs en zigzag
                ctx.strokeStyle = `rgba(255, 255, 255, ${eclairNuit.intensite})`;
                ctx.lineWidth = 2;
                ctx.beginPath();

                // √âclair principal diagonal
                const startX = Math.random() * C.W;
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H * 0.3);
                ctx.lineTo(startX + (Math.random() - 0.5) * 150, C.H * 0.6);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H);

                ctx.stroke();
            }

            ctx.restore();
        }

        // Fonction pour dessiner le message powerup simple sous les titres narratifs
        function dessinerMessagePowerupSimple() {
            if (!messagePowerupActif) return;

            const maintenant = Date.now();
            if (maintenant > messagePowerupActif.temps) {
                messagePowerupActif = null;
                return;
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messagePowerupActif.temps - maintenant;
            if (tempsRestant < 500) {
                messagePowerupActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messagePowerupActif.alpha;

            // Position plus haute pour meilleure visibilit√©
            const posY = C.H * 0.25; // 25% de la hauteur (plus haut que le centre)

            // Texte avec ombre fine
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Ombre fine pour lisibilit√©
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.fillText(messagePowerupActif.texte, C.W/2, posY);

            ctx.restore();
        }

        // Fonction pour dessiner le message narratif discret (en bas, sans fond)
        function dessinerMessageNarratifSimple() {
            if (!messageNarratifActif) return;

            const maintenant = Date.now();
            if (maintenant > messageNarratifActif.temps) {
                messageNarratifActif = null;
                return;
            }

            // Log pour phase 16
            if (narrationManager && narrationManager.currentPhase === 16) {
                if (!window.logP16Done) {console.log('üñºÔ∏è Dessin message narratif P16:', messageNarratifActif.texte.substring(0, 30));
                    window.logP16Done = true;
                }
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messageNarratifActif.temps - maintenant;
            if (tempsRestant < 500) {
                messageNarratifActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messageNarratifActif.alpha;

            // Position selon la phase
            let posY = C.H * 0.70; // 70% de la hauteur par d√©faut - pr√®s du bateau

            // Intro : Texte au centre pendant l'animation du bateau
            if(narrationManager && narrationManager.currentPhase === 1) {
                posY = C.H * 0.40; // 40% de la hauteur - centr√© pour l'intro
            }

            // Phase 16 : Texte au milieu
            if(narrationManager && narrationManager.currentPhase === 16) {
                posY = C.H * 0.45; // 45% de la hauteur - au milieu
            }

            // Texte centr√© fixe pour la phase finale
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                posY = C.H * 0.50; // Texte toujours centr√©, sans d√©filement
            }

            // Dessiner l'ic√¥ne lanterne si demand√©e
            if (messageNarratifActif.avecIcone) {
                const iconX = C.W / 2 - 60;
                const iconY = posY - 40;

                // Corps de la lanterne (orange lumineux)
                const grad = ctx.createRadialGradient(iconX, iconY, 0, iconX, iconY, 20);
                grad.addColorStop(0, '#FFD700');
                grad.addColorStop(0.5, '#FF8C00');
                grad.addColorStop(1, '#FF6B00');
                ctx.fillStyle = grad;
                ctx.fillRect(iconX - 12, iconY - 15, 24, 30);

                // Lueur de la flamme
                const lueurGrad = ctx.createRadialGradient(iconX, iconY, 0, iconX, iconY, 35);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 140, 0, 0.4)');
                lueurGrad.addColorStop(1, 'rgba(255, 107, 0, 0)');
                ctx.fillStyle = lueurGrad;
                ctx.beginPath();
                ctx.arc(iconX, iconY, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            // Diviser le texte en lignes pour les longs messages
            const lignes = messageNarratifActif.texte.split('\n');

            // Pas de fond - style discret mais bien visible
            // Texte blanc bold avec ombre noire marqu√©e
            ctx.fillStyle = '#FFFFFF';

            // Texte selon la phase
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                ctx.font = 'bold 20px Arial'; // Texte simple pour phase finale
            } else if(narrationManager && narrationManager.currentPhase === 16) {
                ctx.font = 'bold 24px Arial'; // Texte PLUS GROS pour phase 16
            } else {
                ctx.font = 'bold 20px Arial'; // Texte normal
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Ombre selon la phase
            if(narrationManager && narrationManager.currentPhase === 16) {
                // Phase 16 : Ombre tr√®s fine
                ctx.shadowColor = '#000000';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
            } else {
                // Autres phases : Ombre subtile
                ctx.shadowColor = '#000000';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
            }

            // Traiter chaque ligne pour un formatage optimal
            const hauteurLigne = 26;
            // Phase 16 : Marges r√©duites pour texte sur toute la largeur
            const margeHorizontale = (narrationManager && narrationManager.currentPhase === 16) ? 20 : 40;
            const largeurMax = C.W - (margeHorizontale * 2);

            let lignesFinales = [];

            // Pr√©-traiter toutes les lignes pour g√©rer le retour √† la ligne intelligent
            lignes.forEach(ligne => {
                const largeurTexte = ctx.measureText(ligne).width;

                if (largeurTexte > largeurMax) {
                    // Diviser intelligemment la ligne trop longue
                    const mots = ligne.split(' ');
                    let ligneActuelle = '';

                    for (let mot of mots) {
                        const testLigne = ligneActuelle + (ligneActuelle ? ' ' : '') + mot;
                        const testLargeur = ctx.measureText(testLigne).width;

                        if (testLargeur > largeurMax && ligneActuelle !== '') {
                            lignesFinales.push(ligneActuelle);
                            ligneActuelle = mot;
                        } else {
                            ligneActuelle = testLigne;
                        }
                    }

                    if (ligneActuelle) {
                        lignesFinales.push(ligneActuelle);
                    }
                } else {
                    lignesFinales.push(ligne);
                }
            });

            // Calculer la position de d√©part pour centrer verticalement le bloc de texte
            const hauteurTotale = lignesFinales.length * hauteurLigne;
            const yDebut = posY - hauteurTotale / 2;

            // Dessiner toutes les lignes finales
            lignesFinales.forEach((ligne, index) => {
                const y = yDebut + (index + 1) * hauteurLigne;

                // D√©tecter [Origine : Le voyage d'une vie] et le rendre cliquable
                if (ligne.includes('[Origine :')) {
                    const largeurLien = ctx.measureText('Origine du voyage').width;

                    // Dessiner le lien cliquable
                    const btnX = C.W/2 - largeurLien/2 - 10;
                    const btnY = y - 18;
                    const btnW = largeurLien + 20;
                    const btnH = 30;

                    // Stocker la zone cliquable du lien
                    if (messageNarratifActif.lienLivre) {
                        messageNarratifActif.lienZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du lien (bleu clair)
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du lien
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('game.canvas.voyage_origin', 'Origine du voyage'), C.W/2, y);
                }
                // D√©tecter [Recommencer] et le rendre cliquable
                else if (ligne.includes('[Recommencer]')) {
                    const texteAvant = ligne.substring(0, ligne.indexOf('[Recommencer]'));
                    const largeurAvant = ctx.measureText(texteAvant).width;
                    const largeurBouton = ctx.measureText('Recommencer').width;

                    // Dessiner le texte avant
                    if (texteAvant) {
                        ctx.fillText(texteAvant, C.W/2 - largeurBouton/2 - 20, y);
                    }

                    // Dessiner le bouton Recommencer
                    const btnX = C.W/2 - largeurBouton/2 - 10;
                    const btnY = y - 18;
                    const btnW = largeurBouton + 20;
                    const btnH = 30;

                    // Stocker la zone cliquable
                    if (messageNarratifActif.avecRestart) {
                        messageNarratifActif.restartZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du bouton
                    ctx.fillStyle = 'rgba(30, 58, 138, 0.8)'; // Bleu roi
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du bouton
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('interface.buttons.restart', 'Recommencer'), C.W/2, y);
                }
                // D√©tecter [üåç Partager mon voyage] et le rendre cliquable
                else if (ligne.includes('[üåç Partager mon voyage]')) {
                    const largeurPartage = ctx.measureText('üåç Partager mon voyage').width;

                    // Dessiner le bouton de partage
                    const btnX = C.W/2 - largeurPartage/2 - 15;
                    const btnY = y - 20;
                    const btnW = largeurPartage + 30;
                    const btnH = 35;

                    // Stocker la zone cliquable
                    if (messageNarratifActif.avecPartage) {
                        messageNarratifActif.partageZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du bouton (vert uni)
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.9)'; // Vert √©meraude
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure dor√©e
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du bouton
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('interface.buttons.share_journey', 'üåç Partager mon voyage'), C.W/2, y);
                } else {
                    ctx.fillText(ligne, C.W/2, y);
                }
            });

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Continuer" dans le canvas (Phase 16)
        function dessinerBoutonContinuer() {
            if (!window.boutonContinuer || !window.boutonContinuer.visible) return;
            if (!narrationManager || narrationManager.currentPhase !== 16) return;

            const btn = window.boutonContinuer;

            // Position centr√©e, milieu-bas de l'√©cran - PLUS PETIT
            btn.width = 200;
            btn.height = 50;
            btn.x = (C.W - btn.width) / 2;
            btn.y = C.H * 0.60; // 60% de la hauteur (milieu-bas, bien visible)

            ctx.save();

            // Animation de pulsation
            const temps = (Date.now() - btn.pulseTime) * 0.002;
            const scale = 1 + Math.sin(temps) * 0.05;

            ctx.translate(btn.x + btn.width/2, btn.y + btn.height/2);
            ctx.scale(scale, scale);
            ctx.translate(-(btn.x + btn.width/2), -(btn.y + btn.height/2));

            // Ombre
            ctx.shadowColor = 'rgba(30, 58, 138, 0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 6;

            // Fond bleu roi
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.beginPath();
            ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 25);
            ctx.fill();

            // Bordure rouge
            ctx.strokeStyle = '#ef4444'; // Rouge vif
            ctx.lineWidth = 3;
            ctx.stroke();

            // Texte
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(getTranslatedText('game.canvas.continue_button', '‚ûú Continuer'), btn.x + btn.width/2, btn.y + btn.height/2);

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Passer" simple
        function dessinerBoutonPasser() {
            if (!boutonPasser.actif) return;

            // Animation de pulsation
            boutonPasser.pulse += 0.03; // 5x plus lent (0.15 / 5 = 0.03)
            const scale = 1 + Math.sin(boutonPasser.pulse) * 0.15; // Pulsation entre 0.85 et 1.15
            const alpha = 0.8 + Math.sin(boutonPasser.pulse) * 0.2; // Alpha entre 0.6 et 1.0

            // Position en bas du texte d'intro
            boutonPasser.x = C.W/2 - boutonPasser.largeur/2;
            boutonPasser.y = C.H * 0.55; // Positionn√© sous le texte d'intro (40% + espace)

            ctx.save();

            // Appliquer la transformation de pulsation
            const centerX = boutonPasser.x + boutonPasser.largeur/2;
            const centerY = boutonPasser.y + boutonPasser.hauteur/2;
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            // Juste du texte avec ombre - pas de fond ni bordure
            ctx.globalAlpha = alpha;
            ctx.fillStyle = boutonPasser.hover ? '#ff6666' : '#ff0000';
            ctx.font = 'bold 32px "Orbitron", "Exo 2", "Rajdhani", monospace'; // Police futuriste encore plus grosse
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre fine et moderne
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;

            ctx.fillText(boutonPasser.getTexte(), centerX, centerY);

            ctx.restore();
        }

        // Fonction pour v√©rifier si on clique sur le bouton Passer
        function verifierClicBoutonPasser(x, y) {
            if (!boutonPasser.actif) return false;

            return x >= boutonPasser.x && x <= boutonPasser.x + boutonPasser.largeur &&
                   y >= boutonPasser.y && y <= boutonPasser.y + boutonPasser.hauteur;
        }

        // Fonction pour dessiner le bouton "Suivant" simple pour phase 16
        function dessinerBoutonSuivantP16() {
            if (!window.boutonSuivantP16 || !window.boutonSuivantP16.visible) {
                return;
            }
            if (narrationManager && narrationManager.currentPhase !== 16) {
                return;
            }

            const btn = window.boutonSuivantP16;
            // Centrer le texte
            const centerX = C.W / 2;
            const centerY = C.H * 0.83; // Un peu plus bas (83% de la hauteur)

            // Mettre √† jour la position pour le clic (zone autour du texte)
            btn.x = centerX - btn.width / 2;
            btn.y = centerY - btn.height / 2;

            ctx.save();

            // Texte blanc en gras avec ombre
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre plus visible
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.shadowBlur = 4;

            ctx.fillText(getTranslatedText('game.canvas.next_button', '‚ûú Suivant'), centerX, centerY);

            ctx.restore();
        }

        // Power-Up Bleu √âtincelant
        function creerPowerUp(x, y, typeSpecifique = null) {
            // Si un type sp√©cifique est fourni, l'utiliser, sinon choisir al√©atoirement
            let typeFinal;
            if (typeSpecifique) {
                // Si c'est un tableau (phase 17 avec plusieurs types possibles), choisir al√©atoirement
                if (Array.isArray(typeSpecifique)) {
                    typeFinal = typeSpecifique[Math.floor(Math.random() * typeSpecifique.length)];
                } else {
                    typeFinal = typeSpecifique;
                }
            } else {
                // allume_lanterne n'appara√Æt pas al√©atoirement - seulement via creerPowerUpLanterne()
                const types = ['etoile_montante', 'poxerstart', 'vitesse', 'bonus_points'];
                typeFinal = types[Math.floor(Math.random() * types.length)];
            }

            const nouveauPowerUp = {
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: typeFinal,
                temps: 0,
                etincelles: []
            };

            powerUps.push(nouveauPowerUp);console.log(`üéØ Power-up cr√©√©: ${typeFinal} √† (${x}, ${y}), total: ${powerUps.length}`);
        }

        function dessinerPowerUps() {
            if(powerUps.length > 0) {
                //
            }
            powerUps.forEach(power => {
                // üîî V√©rifier AVANT tout si le power-up rainbow_hope doit √™tre d√©couvert (Phase 22)
                if (power.type === 'rainbow_hope' && !power.decouvert) {
                    // Compter combien de briques autour du power-up ont √©t√© d√©truites
                    let briquesAutourDetruites = 0;
                    let totalBriquesAutour = 0;
                    
                    briques.forEach(brique => {
                        // V√©rifier si la brique est proche du power-up (dans un rayon de 80px)
                        const dx = (brique.x + brique.w/2) - (power.x + power.w/2);
                        const dy = (brique.y + brique.h/2) - (power.y + power.h/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 80) {
                            totalBriquesAutour++;
                            if (!brique.visible) {
                                briquesAutourDetruites++;
                            }
                        }
                    });
                    
                    // Si au moins 50% des briques autour sont d√©truites, le power-up est d√©couvert !
                    if (totalBriquesAutour > 0 && (briquesAutourDetruites / totalBriquesAutour) >= 0.5) {
                        power.decouvert = true;
                        AudioSystem.playChime(); // üîî Son de cloche magique !
                        console.log('üîî‚ú® Power-up ESPOIR d√©couvert ! Son de cloche jou√©.');
                        
                        // Explosion de particules arc-en-ciel pour marquer la d√©couverte
                        const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                        for (let c = 0; c < 7; c++) {
                            setTimeout(() => {
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, rainbowColors[c], 8);
                            }, c * 30);
                        }
                    } else {
                        // Pas encore d√©couvert, ne pas dessiner
                        return;
                    }
                }
                
                ctx.save();

                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);

                // Couleur selon le type
                let couleur1, couleur2, couleur3;
                switch(power.type) {
                    case 'etoile_montante':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Dor√©
                        break;
                    case 'poxerstart':
                        couleur1 = '#FF69B4'; couleur2 = '#FF1493'; couleur3 = '#DC143C'; // Rose/Rouge
                        break;
                    case 'vitesse':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert
                        break;
                    case 'bonus_points':
                        couleur1 = '#9400D3'; couleur2 = '#8A2BE2'; couleur3 = '#7B68EE'; // Violet
                        break;
                    case 'allume_lanterne':
                        couleur1 = '#FFA500'; couleur2 = '#FF8C00'; couleur3 = '#FF6347'; // Orange/Rouge (feu)
                        break;
                    case 'red_cross':
                        couleur1 = '#FF0000'; couleur2 = '#CC0000'; couleur3 = '#990000'; // Rouge vif
                        break;
                    case 'broken_heart':
                        couleur1 = '#8B0000'; couleur2 = '#660000'; couleur3 = '#440000'; // Rouge sombre
                        break;
                    case 'gray_heart':
                        couleur1 = '#A9A9A9'; couleur2 = '#808080'; couleur3 = '#696969'; // Gris (crise)
                        break;
                    case 'black_heart':
                        couleur1 = '#2C2C2C'; couleur2 = '#1C1C1C'; couleur3 = '#0C0C0C'; // Noir
                        break;
                    case 'chain':
                        couleur1 = '#708090'; couleur2 = '#556B76'; couleur3 = '#3D4E5C'; // Gris acier (cha√Ænes)
                        break;
                    case 'barbed_wire':
                        couleur1 = '#C0C0C0'; couleur2 = '#A8A8A8'; couleur3 = '#808080'; // Argent/M√©tal
                        break;
                    case 'red_heart':
                        couleur1 = '#FF0000'; couleur2 = '#DC143C'; couleur3 = '#B22222'; // Rouge vif (amour)
                        break;
                    case 'open_hands':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Or (g√©n√©rosit√©)
                        break;
                    case 'green_heart':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert (nature/espoir)
                        break;
                    case 'yellow_heart':
                        couleur1 = '#FFFF00'; couleur2 = '#FFD700'; couleur3 = '#FFA500'; // Jaune (joie)
                        break;
                    case 'blue_heart':
                        couleur1 = '#0000FF'; couleur2 = '#4169E1'; couleur3 = '#1E90FF'; // Bleu (paix)
                        break;
                    case 'purple_heart':
                        couleur1 = '#9400D3'; couleur2 = '#8B00FF'; couleur3 = '#6A0DAD'; // Violet (spiritualit√©)
                        break;
                    case 'vibrant_heart':
                        couleur1 = '#FF1493'; couleur2 = '#FF69B4'; couleur3 = '#FF85C1'; // Rose vibrant (espoir)
                        break;
                    case 'smile':
                        couleur1 = '#FFD700'; couleur2 = '#FFED4E'; couleur3 = '#FFF68F'; // Jaune lumineux (joie)
                        break;
                    case 'rainbow_hope':
                        // Arc-en-ciel anim√© pour le power-up Espoir (Phase 22)
                        const rainbowIndex = Math.floor((power.temps / 5) % 7);
                        const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                        couleur1 = rainbowColors[rainbowIndex];
                        couleur2 = rainbowColors[(rainbowIndex + 1) % 7];
                        couleur3 = rainbowColors[(rainbowIndex + 2) % 7];
                        break;
                    default:
                        couleur1 = '#00aaff'; couleur2 = '#0099dd'; couleur3 = '#0088cc'; // Bleu
                }

                // D√©grad√© selon le type
                const grad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                grad.addColorStop(0, couleur1);
                grad.addColorStop(0.5, couleur2);
                grad.addColorStop(1, couleur3);

                ctx.fillStyle = grad;
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // Bordure scintillante
                ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                ctx.lineWidth = 3;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.strokeRect(power.x, power.y, power.w, power.h);
                ctx.shadowBlur = 0;

                // Ic√¥ne selon le type
                if (power.type === 'red_cross') {
                    // Dessiner une croix rouge ‚ùå
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = power.w * 0.15;
                    ctx.lineCap = 'round';
                    
                    const centerX = power.x + power.w/2;
                    const centerY = power.y + power.h/2;
                    const crossSize = power.w * 0.4;
                    
                    // Ligne diagonale \
                    ctx.beginPath();
                    ctx.moveTo(centerX - crossSize, centerY - crossSize);
                    ctx.lineTo(centerX + crossSize, centerY + crossSize);
                    ctx.stroke();
                    
                    // Ligne diagonale /
                    ctx.beginPath();
                    ctx.moveTo(centerX + crossSize, centerY - crossSize);
                    ctx.lineTo(centerX - crossSize, centerY + crossSize);
                    ctx.stroke();
                } else if (power.type === 'broken_heart') {
                    // Dessiner un c≈ìur bris√© üíî
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíî', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'gray_heart') {
                    // Dessiner un c≈ìur gris (crise) ü§ç
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('ü§ç', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'black_heart') {
                    // Dessiner un c≈ìur noir üñ§
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üñ§', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'chain') {
                    // Dessiner des cha√Ænes üîó
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üîó', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'barbed_wire') {
                    // Dessiner des barbel√©s üöß
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üöß', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'red_heart') {
                    // Dessiner un c≈ìur rouge ‚ù§Ô∏è
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ù§Ô∏è', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'open_hands') {
                    // Dessiner des mains tendues ü§≤
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('ü§≤', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'green_heart') {
                    // Dessiner un c≈ìur vert üíö
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíö', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'yellow_heart') {
                    // Dessiner un c≈ìur jaune üíõ
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíõ', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'blue_heart') {
                    // Dessiner un c≈ìur bleu üíô
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíô', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'purple_heart') {
                    // Dessiner un c≈ìur violet üíú
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíú', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'vibrant_heart') {
                    // Dessiner un c≈ìur vibrant üíó
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üíó', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'smile') {
                    // Dessiner un sourire üòä
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üòä', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'allume_lanterne') {
                    // Ic√¥ne lanterne üèÆ
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.6}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üèÆ', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'rainbow_hope') {
                    // üåà Power-up Espoir arc-en-ciel (Phase 22)
                    // Animation de rotation des couleurs
                    const colorIndex = Math.floor((power.temps / 5) % power.colors.length);
                    const currentColor = power.colors[colorIndex];
                    
                    // Aura arc-en-ciel pulsante
                    ctx.shadowBlur = 30 + Math.sin(power.temps * 0.1) * 10;
                    ctx.shadowColor = currentColor;
                    
                    // Dessin de l'emoji arc-en-ciel avec pulsation
                    const scale = 1 + Math.sin(power.temps * 0.08) * 0.15;
                    ctx.save();
                    ctx.translate(power.x + power.w/2, power.y + power.h/2);
                    ctx.scale(scale, scale);
                    ctx.font = `${power.h * 1.2}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(power.emoji, 0, 0);
                    ctx.restore();
                    
                    ctx.shadowBlur = 0;
                }

                // √âtincelles autour
                for(let i = 0; i < 3; i++) {
                    const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = power.w * 0.8;
                    const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                    const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                    ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // üåà EXCEPTION : Ne pas incr√©menter le temps pour le power-up Espoir (ne doit jamais expirer)
                if (power.type !== 'rainbow_hope') {
                    power.temps += 1;
                }
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                if(powerUps.length > 0) {
                    //console.log(`üîç V√©rif collision balle(${balle.x.toFixed(1)}, ${balle.y.toFixed(1)}) avec ${powerUps.length} power-ups`);
                }
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Effets selon le type de power-up
                    switch(power.type) {
                        case 'etoile_montante':
                            // Cr√©er une √©toile qui monte au ciel + 1000 XP
                            creerEtoileMontante(power.x + power.w/2, power.y + power.h/2);
                            score += 1000;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 8);

                            // üîä Son de collecte power-up
                            AudioSystem.playCollect();

                            // Message simple avec traduction
                            const message = getTranslatedText('powerups.star_rising', '‚≠ê √âtoile montante +1000 XP');
                            afficherMessagePowerupSimple(message);
                            break;

                        case 'poxerstart':
                            // Active le mode tir √©toiles POXERSTART pendant 7 secondes
                            // Syst√®me s√©par√© du mode tir MUR (phases 17-22)
                            if(!window.modeTirStars || !window.modeTirStars.actif) {
                                const finTirStars = Date.now() + 7000;
                                window.modeTirStars = { actif: true, fin: finTirStars };
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 8);
                                console.log('üåü Mode tir √©toiles POXERSTART activ√© (7s)');

                                // üîä Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple avec traduction
                                const message = getTranslatedText('powerups.poxerstart', 'üåü Poxerstart activ√© - 7 secondes');
                                afficherMessagePowerupSimple(message);

                                // Indicateur visuel sur la raquette
                                raquette.poxerstart = true;
                                raquette.poxerstartFin = finTirStars;
                            } else {
                                console.log('‚ö†Ô∏è Poxerstart d√©j√† actif');
                            }
                            break;

                        case 'vitesse':
                            // Balle plus rapide pendant 8 secondes (ne pas cumuler)
                            if(!balle.vitesseActive) {
                                balle.multiplicateurVitesse = 1.8; // Fixe √† 1.8x pour √©viter l'accumulation
                                balle.vitesseActive = true;
                                balle.vitesseFinTime = Date.now() + 8000; // 8s

                                // Effet visuel de tra√Æn√©e verte
                                balle.traineeVerte = true;

                                setTimeout(() => {
                                    balle.multiplicateurVitesse = 1; // Reset √† 1 au lieu de diviser
                                    balle.vitesseActive = false;
                                    balle.traineeVerte = false;
                                }, 8000);

                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 15);console.log('üí® Mode vitesse TURBO activ√© (8s) - 1.8x plus rapide!');

                                // üîä Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple
                                afficherMessagePowerupSimple(getTranslatedText('powerups.turbo_speed', 'üí® Vitesse turbo activ√©e !'));
                            } else {
                            }
                            break;

                        case 'red_cross':
                            // Croix rouge : Fronti√®res (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF0000', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('‚ùå üó∫Ô∏è üìè');
                            break;

                        case 'broken_heart':
                            // C≈ìur bris√© : Refus et espoir bris√© (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#8B0000', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('üíî üö´ üò¢');
                            break;

                        case 'gray_heart':
                            // C≈ìur gris : Libert√© vs Prison (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#A9A9A9', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('ü§ç üïäÔ∏è ‚õìÔ∏è');
                            break;

                        case 'black_heart':
                            // C≈ìur noir : Enfermement (tr√®s sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#2C2C2C', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('üñ§ üåë üîí');
                            break;

                        case 'chain':
                            // Cha√Ænes : Pauvret√© emprisonne (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#708090', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('üîó üí∏ üö´');
                            break;

                        case 'barbed_wire':
                            // Barbel√©s : Fronti√®res blessent (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#C0C0C0', 15);
                            AudioSystem.playDarkCollect(); // üîä Son sombre
                            afficherMessagePowerupSimple('üöß ü©∏ ‚úã');
                            break;

                        case 'green_heart':
                            // C≈ìur vert : Nature, vie, espoir (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 15);
                            AudioSystem.playJoyfulCollect(); // üîä Son joyeux
                            afficherMessagePowerupSimple('üíö üå± üåç');
                            break;

                        case 'yellow_heart':
                            // C≈ìur jaune : Joie, lumi√®re, amiti√© (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFFF00', 15);
                            AudioSystem.playJoyfulCollect(); // üîä Son joyeux
                            afficherMessagePowerupSimple('üíõ ‚òÄÔ∏è üòä');
                            break;

                        case 'blue_heart':
                            // C≈ìur bleu : Paix, confiance, s√©r√©nit√© (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#0000FF', 15);
                            AudioSystem.playJoyfulCollect(); // üîä Son joyeux
                            afficherMessagePowerupSimple('üíô üïäÔ∏è üåä');
                            break;

                        case 'purple_heart':
                            // C≈ìur violet : Spiritualit√©, sagesse, unit√© (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 15);
                            AudioSystem.playSoftCollect(); // üîä Son doux
                            afficherMessagePowerupSimple('üíú üîÆ ‚ú®');
                            break;

                        case 'vibrant_heart':
                            // C≈ìur vibrant : Espoir qui bat (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF1493', 15);
                            AudioSystem.playSoftCollect(); // üîä Son doux
                            afficherMessagePowerupSimple('üíó üåä üí™');
                            break;

                        case 'smile':
                            // Sourire : Joie et libert√© retrouv√©e (p√©tillant)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 15);
                            AudioSystem.playSparkleCollect(); // üîä Son p√©tillant
                            afficherMessagePowerupSimple('üòä ‚òÄÔ∏è üïäÔ∏è');
                            break;

                        case 'red_heart':
                            // C≈ìur rouge : Compassion refus√©e (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF0000', 15);
                            AudioSystem.playSoftCollect(); // üîä Son doux
                            afficherMessagePowerupSimple('‚ù§Ô∏è üíî ÔøΩ');
                            break;

                        case 'open_hands':
                            // Mains transaction : Argent et privil√®ges (pi√®ce)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 15);
                            AudioSystem.playCoin(); // üîä Son de pi√®ce (argent)
                            afficherMessagePowerupSimple('ü§≤ üí∞ ÔøΩ');
                            break;

                        case 'bonus_points':
                            // Points bonus (toujours cumulable) - augment√© !
                            score += 500; // 500 au lieu de 200
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 10);

                            // üîä Son de collecte power-up
                            AudioSystem.playCollect();

                            // Message simple
                            afficherMessagePowerupSimple(getTranslatedText('powerups.bonus_points', 'üíé Bonus points +500'));
                            break;

                        case 'allume_lanterne':
                            // Allumer la lanterne si elle est √©teinte
                            if(!lanterne.active) {
                                lanterne.active = true;
                                lanterne.intensite = 1.0;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 12);

                                // üîä Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple
                                afficherMessagePowerupSimple(getTranslatedText('powerups.lantern_lit', 'üèÆ Lanterne allum√©e !'));
                            } else {
                                // Si d√©j√† allum√©e, donner des points bonus
                                score += 300;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 8);

                                // üîä Son de collecte power-up
                                AudioSystem.playCollect();

                                afficherMessagePowerupSimple(getTranslatedText('powerups.lantern_bonus', 'üèÆ Lanterne +300 bonus'));
                            }
                            break;

                        case 'coeur':
                        default:
                            // C≈ìurs et autres types : +100 XP
                            score += 100;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 8);

                            // üîä Son de collecte
                            AudioSystem.playCollect();

                            // Message
                            afficherMessagePowerupSimple(getTranslatedText('powerups.heart_collected', '‚ù§Ô∏è C≈ìur collect√© !'));
                            break;
                    }

                    // Toujours supprimer le power-up apr√®s contact (m√™me si effet ignor√©)
                    powerUps.splice(i, 1);
                    }
                }
            }

            // V√©rifier l'expiration des power-ups (4 secondes = 240 frames √† 60fps)
            for(let i = powerUps.length - 1; i >= 0; i--) {
                const power = powerUps[i];
                
                // üåà EXCEPTION : Le power-up Espoir (Phase 22) ne doit JAMAIS expirer !
                if (power.type === 'rainbow_hope') {
                    continue; // Skip l'expiration pour ce power-up sp√©cial
                }
                
                // Si le power-up a v√©cu plus de 4 secondes (240 frames)
                if(power.temps > 240) {
                    // Explosion visuelle
                    ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 20);
                    
                    // Donner 100 XP
                    score += 100;
                    
                    // Message d'expiration
                    afficherMessagePowerupSimple('üí´ +100 XP');
                    
                    // Supprimer le power-up
                    powerUps.splice(i, 1);
                    console.log(`‚è±Ô∏è Power-up expir√© apr√®s 4s - +100 XP`);
                }
            }
        }

        // Fonction sp√©ciale pour cr√©er le power-up lanterne sur la premi√®re brique en bas
        function creerPowerUpLanterne() {
            // Trouver la brique la plus en bas (plus grand Y)
            let briqueLoPlus = null;
            let yMax = -1;

            briques.forEach(brique => {
                if(brique.visible && brique.y > yMax) {
                    yMax = brique.y;
                    briqueLoPlus = brique;
                }
            });

            // Si on a trouv√© une brique en bas, y placer le power-up lanterne
            if(briqueLoPlus) {
                const powerUpLanterne = {
                    x: briqueLoPlus.x + briqueLoPlus.w/2 - C.BS * 0.75,
                    y: briqueLoPlus.y + briqueLoPlus.h/2 - C.BS * 0.75,
                    w: C.BS * 1.5,
                    h: C.BS * 1.5,
                    type: 'allume_lanterne',
                    temps: 0,
                    etincelles: [],
                    special: true // Marquer comme power-up sp√©cial
                };

                powerUps.push(powerUpLanterne);
            }
        }

        // Cr√©er une √©toile qui monte vers le ciel
        function creerEtoileMontante(x, y) {
            // Cr√©er l'√©toile montante
            const etoile = {
                x: x,
                y: y,
                taille: 30,
                vitesseY: -3,
                temps: 0,
                alpha: 1,
                particules: []
            };

            // Animation de l'√©toile qui monte
            const animer = () => {
                etoile.y += etoile.vitesseY;
                etoile.temps += 1;
                etoile.alpha = Math.max(0, 1 - etoile.temps / 120); // Dispara√Æt en 2 secondes √† 60fps

                // Dessiner l'√©toile
                ctx.save();
                ctx.globalAlpha = etoile.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.font = `${etoile.taille}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê', etoile.x, etoile.y);

                // Effet de tra√Æn√©e dor√©e
                for(let i = 0; i < 3; i++) {
                    const particuleX = etoile.x + (Math.random() - 0.5) * 20;
                    const particuleY = etoile.y + i * 15;
                    ctx.globalAlpha = etoile.alpha * (1 - i * 0.3);
                    ctx.fillStyle = `hsl(45, 100%, ${70 - i * 10}%)`;
                    ctx.font = `${etoile.taille * (1 - i * 0.2)}px serif`;
                    ctx.fillText('‚ú®', particuleX, particuleY);
                }
                ctx.restore();

                // Continuer l'animation si l'√©toile est encore visible
                if(etoile.alpha > 0 && etoile.y > -50) {
                    requestAnimationFrame(animer);
                }
            };

            requestAnimationFrame(animer);
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise √† jour pendant l'animation
            if(lanterne.active && phaseJeu === 'lanterne') {
                // Effet de pulsation encore plus douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.001);

                // Cr√©er quelques particules dor√©es plus rarement (seulement en mode lanterne)
                if(Math.random() < 0.02) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Cr√©er une rafale de 1-3 c≈ìurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // √âventail 40¬∞
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // D√©part l√©g√®rement dispers√©
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, tr√®s grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // D√©lai entre chaque c≈ìur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            const tempsActuel = Date.now();

            // Plus de c≈ìurs automatiques pendant l'intro
            // Pendant le jeu normal : plus de d√©clenchement automatique
            // Les rafales se d√©clenchent seulement sur clic/touche

            // Mettre √† jour les c≈ìurs de lumi√®re
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Mont√©e rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Animation de flottement gauche-droite
                if(coeur.vitesseFlottement !== undefined) {
                    coeur.flottemment += coeur.vitesseFlottement;
                    // Ajouter un mouvement oscillant horizontal
                    coeur.x += Math.sin(coeur.flottemment) * 0.5;
                }

                // Animation de scintillement
                coeur.scintillement += 0.2;
                coeur.luminosite = 0.7 + 0.3 * Math.sin(coeur.scintillement);

                // Supprimer si sort de l'√©cran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits c≈ìurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // V√©rifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // C≈ìur touch√© !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            if (petitCoeur.etape && petitCoeur.etape.nom) {
                                ajouterTexteVolant(`+${typeof petitCoeur.etape.nom === 'function' ? petitCoeur.etape.nom() : petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);
                            }

                            // üîä Son "pof" doux pour les petits c≈ìurs
                            AudioSystem.playPof();

                            // Supprimer le c≈ìur du bateau
                            coeursBateau.splice(i, 1);

                            // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // üîä Son "pof" doux pour l'explosion finale
                                AudioSystem.playExplosionCoeurs();

                                // üéÜ ANIMATION D'EXPLOSION PUIS PASSAGE AU MODE LANTERNE
                                animerExplosionIconeCollector(() => {
                                    // Passer au mode lanterne (casse-briques)
                                    phaseJeu = 'lanterne';
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    
                                    // Message de transition
                                    afficherMessagePowerupSimple(getTranslatedText('game.messages.lantern_mode_start', 'üèÆ Mode Lanterne activ√© !'));
                                    
                                    narrationManager.goToNextPhaseDirect();
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                                    // lanterne.active et lanterne.intensite conserv√©s
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    // Message g√©r√© par le nouveau syst√®me narratif

                                    // Cr√©er quelques c≈ìurs d√©coratifs qui flottent (diff√©rents de ceux du haut)
                                    setTimeout(() => {
                                        // Cr√©er des c≈ìurs d√©coratifs flottants au lieu de recr√©er les c≈ìurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

    
                                        // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                });
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                // Bloquer compl√®tement les collisions pendant le mode secret
                if (secretModeModule && secretModeModule.isActive) {
                    return; // Pas de collision avec les briques en mode secret
                }
                if (modeSecret) {
                    return; // Pas de collision avec les briques en mode secret (fallback)
                }

                // V√©rifier d'abord s'il reste plus d'une brique pour √©viter le passage automatique
                const briquesRestantes = briques.filter(b => b.visible).length;

                briques.forEach(brique => {
                    if(!brique.visible) return;

                    // Si il ne reste qu'une brique, les c≈ìurs ne peuvent plus la casser
                    if(briquesRestantes <= 1 && (phaseJeu === 'lanterne' || phaseJeu === 'stars')) {
                        return; // Arr√™ter les collisions pour √©viter la transition automatique
                    }

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // D√©lai anti-collision multiple (500ms)
                        const tempsActuel = Date.now();
                        if(brique.dernierCoup && tempsActuel - brique.dernierCoup < 500) {
                            return; // Ignorer si collision trop r√©cente
                        }

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Supprimer le c≈ìur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // üîä Son de casse brique (al√©atoire entre 3 sons)
                            const sonAleatoire = Math.random();
                            if (sonAleatoire < 0.33) {
                                AudioSystem.playBrickBreakToc();
                            } else if (sonAleatoire < 0.66) {
                                AudioSystem.playBrickBreakGlass();
                            } else {
                                AudioSystem.playBrickBreakCrack();
                            }

                            // Explosion en 3 petits c≈ìurs seulement
                            for(let j = 0; j < 3; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du c≈ìur qui grossit et monte au ciel
                            // En mode lanterne : afficher seulement 1 texte sur 4 pour √©viter la surcharge
                            if (phaseJeu !== 'lanterne' || Math.random() < 0.25) {
                                ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                            }

                            // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        // V√©rifier la condition de fin selon le mode de jeu
                        if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                            // Mode briques : v√©rifier si presque toutes les briques sont d√©truites (garder la derni√®re)
                            const briquesRestantes = briques.filter(b => b.visible).length;console.log(`üîç V√©rif briques restantes (collectePowerup): ${briquesRestantes}, phase: ${phaseJeu}`);
                            // Ne pas d√©clencher automatiquement si il reste seulement 1 brique
                            // Le joueur doit d√©cider quand passer √† la phase suivante
                            if(briquesRestantes === 0) {
                                // üåà EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collect√© !
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                    // V√©rifier si le power-up existe et n'est PAS collect√©
                                    const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                    if (espoirPresent) {
                                        console.log('üåà Phase 22 : Mur d√©truit mais power-up ESPOIR pas encore collect√© (collectePowerup) !');
                                        console.log('   ‚Üí La phase ne se termine pas automatiquement.');
                                        return; // ‚Üê Sortir sans transition ET sans animation
                                    }
                                }

                                console.log('üéÜ TOUTES LES BRIQUES D√âTRUITES (collectePowerup)! Animation d\'explosion !');

                                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    narrationManager.goToNextPhaseDirect();
                                });
                            }
                        } else if(brises >= VOYAGE.length) {
                            // Mode c≈ìurs : progression classique bas√©e sur VOYAGE

                            // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante apr√®s animation
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                            });
                        }
                    }
                });
            }
        }

        // üéÜ ANIMATION D'EXPLOSION DE L'IC√îNE COLLECTOR ET COLLECTION AUTOMATIQUE D'√âNIGME
        function animerExplosionIconeCollector(callback = null) {

            // Position de l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;

            // Si l'ic√¥ne n'est pas encore positionn√©e, utiliser le centre de l'√©cran
            let explosionX, explosionY;
            if (centralIcon.x === 0 && centralIcon.y === 0) {
                explosionX = C.W / 2;
                explosionY = C.H / 2;
            } else {
                explosionX = centralIcon.x + centralIcon.width / 2;
                explosionY = centralIcon.y + centralIcon.height / 2;
            }

            // Animation d'explosion avec particules dor√©es
            if (typeof ajouterParticules === 'function') {
                ajouterParticules(explosionX, explosionY, '#FFD700', 15); // Explosion dor√©e
                ajouterParticules(explosionX, explosionY, '#FFA500', 10); // Explosion orange
                ajouterParticules(explosionX, explosionY, '#FFFF00', 8); // Explosion jaune
                ajouterParticules(explosionX, explosionY, '#FF4500', 5); // Explosion rouge-orange
            }

            // üåßÔ∏è Pluie de c√©l√©bration lors des transitions de phase
            setTimeout(() => {
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }, 1000); // D√©clencher apr√®s 1 seconde d'explosion

            // Collection automatique d'√©nigme bas√©e sur la phase actuelle
            if (enigmaCollector) {
                let enigmeAColleter = null;

                // D√©terminer quelle √©nigme collecter selon la phase
                // V√©rifier si on est dans les phases de mur (17-22)
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const estPhaseMur = phaseActuelle >= 17 && phaseActuelle <= 22;

                if (estPhaseMur) {
                    // Phases 17-22 : Collecter les √©nigmes du mur
                    const enigmesMur = ['avarice', 'mur_liberte', 'refus', 'privilege', 'inegalites', 'espoir_mur'];
                    enigmeAColleter = enigmesMur.find(id => !enigmaCollector.enigmesCollectees.has(id));
                } else {
                    switch(phaseJeu) {
                        case 'tir_coeurs_haut':
                        case 'petits_coeurs':
                        case 'coeurs':
                            // Phase c≈ìurs - collecter une √©nigme de type "coeurs"
                            const enigmesCoeurs = ['humanite', 'diversite', 'respect', 'restauration'];
                            enigmeAColleter = enigmesCoeurs.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        case 'lanterne':
                            // Phase lanterne - collecter les √©nigmes de type "briques"
                            const enigmesBriques = ['paix', 'foi', 'hopital'];
                            enigmeAColleter = enigmesBriques.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        case 'stars':
                        case 'nuit_coeurs':
                            // Phase nuit c≈ìurs - collecter les √©nigmes correspondantes
                            const enigmesNuit = ['liberte', 'entraide'];
                            enigmeAColleter = enigmesNuit.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        default:
                            // Fallback - collecter n'importe quelle √©nigme disponible
                            const toutesEnigmes = Object.keys(ENIGMES_DATABASE).filter(id => id !== 'ange');
                            enigmeAColleter = toutesEnigmes.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;
                    }
                }

                // Collecter l'√©nigme avec animation
                if (enigmeAColleter) {
                    //console.log(`üß© TENTATIVE COLLECTION: ${enigmeAColleter} (phase: ${phaseJeu})`);
                    setTimeout(() => {
                        const success = enigmaCollector.collecterEnigme(enigmeAColleter, true);
                        //
                        if (success) {
                            //
                            // Message simple d'explosion - utilise la notification au lieu du gros afficherMessage
                            const enigme = ENIGMES_DATABASE[enigmeAColleter];
                            // La notification sera affich√©e par afficherNotificationCollection() automatiquement
                        } else {
                            //
                        }
                    }, 200);
                }
            }

            // Animation d'explosion plus visible avec flash et zoom dramatique
            let animationFrame = 0;
            const maxFrames = 300; // 5 secondes √† 60 FPS - animation encore plus lente

            // Cr√©er un flash blanc sur tout l'√©cran
            const createFlash = () => {
                const flashDiv = document.createElement('div');
                flashDiv.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: white;
                    z-index: 9999;
                    opacity: 0.8;
                    pointer-events: none;
                `;
                document.body.appendChild(flashDiv);

                // Fade out du flash
                let opacity = 0.8;
                const fadeFlash = () => {
                    opacity -= 0.05;
                    flashDiv.style.opacity = opacity;
                    if (opacity <= 0) {
                        document.body.removeChild(flashDiv);
                    } else {
                        requestAnimationFrame(fadeFlash);
                    }
                };
                requestAnimationFrame(fadeFlash);
            };

            // Flash imm√©diat
            createFlash();

            const animer = () => {
                if (animationFrame < maxFrames) {
                    animationFrame++;

                    // Effet de zoom plus dramatique
                    const progress = animationFrame / maxFrames;
                    let zoom;
                    if (progress < 0.2) {
                        // Implosion rapide
                        zoom = 1 - progress * 2;
                    } else if (progress < 0.6) {
                        // Explosion dramatique
                        zoom = 0.6 + (progress - 0.2) * 5;
                    } else {
                        // Retour normal avec oscillation
                        const oscillation = Math.sin((progress - 0.6) * Math.PI * 4) * 0.2;
                        zoom = 1.2 - (progress - 0.6) * 0.5 + oscillation;
                    }

                    // Sauvegarder l'√©tat original de l'ic√¥ne
                    if (animationFrame === 1) {
                        menuEnigmesCanvas.centralIcon.originalSize = menuEnigmesCanvas.centralIcon.width;
                    }

                    // Modifier la taille de l'ic√¥ne
                    const newSize = Math.max(5, menuEnigmesCanvas.centralIcon.originalSize * zoom); // Minimum 5px
                    menuEnigmesCanvas.centralIcon.width = newSize;
                    menuEnigmesCanvas.centralIcon.height = newSize;

                    // Debug d√©sactiv√© pour r√©duire les logs

                    requestAnimationFrame(animer);
                } else {
                    // Restaurer la taille originale
                    if (menuEnigmesCanvas.centralIcon.originalSize) {
                        menuEnigmesCanvas.centralIcon.width = menuEnigmesCanvas.centralIcon.originalSize;
                        menuEnigmesCanvas.centralIcon.height = menuEnigmesCanvas.centralIcon.originalSize;
                        delete menuEnigmesCanvas.centralIcon.originalSize;
                    }

                    // Ex√©cuter le callback apr√®s l'animation avec un d√©lai pour les textes narratifs
                    if (callback && typeof callback === 'function') {
                        setTimeout(() => {
                            callback();
                        }, 500); // D√©lai de 500ms pour permettre aux textes narratifs de s'afficher
                    }
                }
            };

            animer();
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';

                // Forme √©toile/diamant pour les c≈ìurs du bateau
                ctx.save();
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                const t = coeur.taille;

                ctx.translate(coeur.x, coeur.y);

                // C≈ìur en polygone pour le bateau
                ctx.beginPath();

                // Lobe gauche
                ctx.moveTo(-t * 0.25, 0);
                ctx.lineTo(-t * 0.15, -t * 0.15);
                ctx.lineTo(-t * 0.05, -t * 0.1);
                ctx.lineTo(-t * 0.02, 0);

                // Lobe droit
                ctx.lineTo(t * 0.02, 0);
                ctx.lineTo(t * 0.05, -t * 0.1);
                ctx.lineTo(t * 0.15, -t * 0.15);
                ctx.lineTo(t * 0.25, 0);

                // Descente vers la pointe
                ctx.lineTo(t * 0.1, t * 0.15);
                ctx.lineTo(0, t * 0.3);
                ctx.lineTo(-t * 0.1, t * 0.15);

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            });
        }

        // Petits c≈ìurs d√©coratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];

            // V√©rifier que VOYAGE est initialis√©
            if (!VOYAGE || VOYAGE.length === 0) {console.log('‚è≥ creerPetitsCoeurs() - Attente initialisation tableaux (VOYAGE:', VOYAGE.length, 'JOUR:', JOUR.length, 'NUIT:', NUIT.length, ')');
                return;
            }

            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Cr√©er un visage rond avec les c≈ìurs - PLUS GRAND
            const centreX = C.W / 2;
            // Position diff√©rente en mode mur : juste sous le header (10%)
            const centreY = (phaseJeu === 'mur') ? C.H * 0.10 : C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.22; // Rayon du visage agrandi (0.22 au lieu de 0.15)

            for(let i = 0; i < 40; i++) { // 40 c≈ìurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles vari√©es

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // R√©partir sur 360¬∞
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut √™tre cass√©
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une √©tape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.02,
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02,
                });
            }
        }

        // üß± Mots philosophiques pour les phases mur (17-22)
        const MOTS_MUR = {
            17: ['cupidit√©', 'avarice', '√©go√Øsme', 'richesse', 'accumulation', 'profit', 'mat√©riel', 'possession', 'avidit√©', 'convoitise'],
            18: ['racisme', 'g√©nocide', 'esclavage', 'manipulation', 'abus', 'oppression', 'haine', 'violence', 'discrimination', 'cruaut√©'],
            19: ['refus', 'rejet', 'exclusion', 'fermeture', 'd√©ni', 'blocage', 'opposition', 'r√©sistance', 'n√©gation', 'abandon'],
            20: ['orgueil', 'ego', 'arrogance', 'fiert√©', 'vanit√©', 'sup√©riorit√©', 'm√©pris', 'hautain', 'dominance', 'pr√©tention'],
            21: ['in√©galit√©', 'injustice', 'privil√®ge', 'pauvret√©', 'richesse', '√©cart', 'discrimination', 'd√©s√©quilibre', 'oppression', 'exploitation'],
            22: ['espoir', 'r√™ve', 'promesse', 'avenir', 'libert√©', 'bonheur', 'paix', 'unit√©', 'horizon', 'lumi√®re']
        };

        // üß± Cr√©er un mur vertical dans la mer - UN SEUL BLOC avec dessin pixel art dedans
        function creerMurDansLaMer() {
            // Cacher/supprimer tous les petits c≈ìurs et √©l√©ments pr√©c√©dents
            petitsCoeurs = [];
            coeursBateau = [];

            // Configuration selon la phase actuelle
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 17;

            // Obtenir les mots philosophiques pour cette phase
            const motsPhase = MOTS_MUR[phaseActuelle] || MOTS_MUR[17];
            let forme = 'mur';
            let couleurMur = '#888888';

            switch(phaseActuelle) {
                case 17: forme = 'montagne'; couleurMur = '#6B5B5B'; break;
                case 18: forme = 'prison'; couleurMur = '#3A3A3A'; break;
                case 19: forme = 'barbeles'; couleurMur = '#8B4513'; break;
                case 20: forme = 'porte'; couleurMur = '#DAA520'; break;
                case 21: forme = 'pyramide'; couleurMur = '#696969'; break;
                case 22: forme = 'fissure'; couleurMur = '#7B8A9E'; break;
            }

            // UN SEUL BLOC : du header (15%) au centre (50%)
            const zoneHauteur = C.H * 0.35; // 35% de hauteur (de 15% √† 50%)
            const zoneDebut = C.H * 0.15; // Commence apr√®s le header

            // Grille pixel art avec briques RECTANGULAIRES (format r√©el 2:1)
            const nbColonnes = 13; // 13 colonnes pour tenir dans les bords
            const nbLignes = 12; // 12 lignes
            const largeurBrique = C.W * 0.8 / nbColonnes; // Rectangle
            const hauteurBrique = largeurBrique / 2; // Hauteur = moiti√© de la largeur (ratio 2:1)
            const startX = C.W * 0.1; // Commence √† 10% (centr√©)
            const startY = zoneDebut;

            // Cr√©er les briques - BLOC PLEIN avec motif pixel art color√© dedans
            let briqueIndex = 0;
            const totalBriques = nbColonnes * nbLignes; // 40√ó30 = 1200

            for(let ligne = 0; ligne < nbLignes; ligne++) {
                for(let col = 0; col < nbColonnes; col++) {
                    // TOUJOURS dessiner un bloc (mur plein)
                    const centre = Math.floor(nbColonnes / 2);
                    const hauteurDepuisBas = nbLignes - ligne - 1;

                    // D√©terminer la couleur selon la forme et la position
                    let couleurBrique = couleurMur; // Couleur de base
                    let estMotif = false; // Pour savoir si c'est un motif sp√©cial

                    if(forme === 'montagne') {
                        // Montagne triangulaire avec neige (grille 13√ó12)
                        const largeur = Math.floor(hauteurDepuisBas * 0.65);
                        const dansTriangle = (col >= centre - largeur && col <= centre + largeur);

                        if(dansTriangle) {
                            // Gradient vertical dans la montagne
                            if(ligne <= 2) couleurBrique = '#FFFFFF'; // Neige
                            else if(ligne <= 5) couleurBrique = '#B0B0B0';
                            else if(ligne <= 8) couleurBrique = '#808080';
                            else couleurBrique = '#6B5B5B';
                        } else {
                            couleurBrique = '#1a1a2e'; // Ciel sombre autour
                        }

                    } else if(forme === 'prison') {
                        // Barreaux noirs sur fond gris (grille 13√ó12)
                        if(col % 3 === 0) {
                            couleurBrique = '#1A1A1A'; // Barreaux noirs
                            estMotif = true;
                        } else {
                            couleurBrique = '#505050'; // Mur gris
                        }

                    } else if(forme === 'barbeles') {
                        // Lignes de barbel√©s (grille 13√ó12)
                        const lignes = [2, 5, 8, 11];
                        if(lignes.includes(ligne)) {
                            couleurBrique = '#A0522D'; // Fil rouille
                            estMotif = true;
                        } else if(lignes.includes(ligne - 1) && col % 2 === 0) {
                            couleurBrique = '#5A3010'; // Pics
                            estMotif = true;
                        } else if(lignes.includes(ligne + 1) && col % 2 === 1) {
                            couleurBrique = '#5A3010'; // Pics
                            estMotif = true;
                        } else {
                            couleurBrique = '#2a2a2a'; // Fond sombre
                        }

                    } else if(forme === 'porte') {
                        // Mur dor√© avec porte noire et colonnes oranges (grille 13√ó12)
                        const dansPorte = (col >= centre - 2 && col <= centre + 2) && (ligne >= 5);
                        const colonneOrange = (col >= 5 && col <= 7); // Colonnes 5, 6, 7

                        if(dansPorte) {
                            couleurBrique = '#1a1a1a'; // Porte (passage noir)
                        } else if(colonneOrange) {
                            couleurBrique = '#FF8C00'; // Orange vif
                        } else if(col <= centre - 3 || col >= centre + 3) {
                            couleurBrique = '#FFD700'; // Or brillant
                        } else {
                            couleurBrique = '#DAA520'; // Or normal
                        }

                    } else if(forme === 'pyramide') {
                        // Escalier avec gradient social (grille 13√ó12)
                        const marche = Math.floor(col * 0.7);
                        const dansEscalier = (ligne >= nbLignes - marche - 1);

                        if(dansEscalier) {
                            // Gradient vertical
                            if(ligne <= 3) couleurBrique = '#D3D3D3'; // Riches
                            else if(ligne <= 6) couleurBrique = '#A0A0A0';
                            else if(ligne <= 9) couleurBrique = '#808080';
                            else couleurBrique = '#696969'; // Pauvres
                        } else {
                            couleurBrique = '#1a1a1a'; // Vide noir
                        }

                    } else if(forme === 'fissure') {
                        // Mur avec fissure noire (grille 13√ó12)
                        const estFissure = (col === centre) && (ligne >= 3);
                        if(estFissure) {
                            couleurBrique = '#000000'; // Fissure noire
                        } else {
                            // Gradient d'usure
                            if(ligne <= 4) couleurBrique = '#9BA5B0';
                            else if(ligne <= 8) couleurBrique = '#8595A5';
                            else couleurBrique = '#7B8A9E';
                        }
                    }

                    // Utiliser les mots philosophiques pour les briques du mur
                    const motPhilo = motsPhase[briqueIndex % motsPhase.length];
                    const etape = {
                        nom: motPhilo,
                        msg: motPhilo // Message simple
                    };

                    // POSE EN QUINCONCE : d√©calage d'une demi-brique pour lignes impaires
                    const decalage = (ligne % 2 === 1) ? largeurBrique / 2 : 0;

                    briques.push({
                        x: startX + col * largeurBrique + decalage,
                        y: startY + ligne * hauteurBrique,
                        largeur: largeurBrique,
                        hauteur: hauteurBrique,
                        w: largeurBrique,
                        h: hauteurBrique,
                        couleur: couleurBrique,
                        visible: true,
                        etape: etape,
                        vie: 1,
                        scintillement: Math.random() * Math.PI * 2,
                        type: 'mur'
                    });

                    briqueIndex++;
                }
            }

            // üåà Phase 22 UNIQUEMENT : Cr√©er un power-up ESPOIR cach√© derri√®re le mur
            if (phaseActuelle === 22) {
                // Positionner au centre, dans la 3e ligne du mur (ligne index 2) - plus profond !
                const ligneCache = 2; // Troisi√®me ligne (index 2) - plus cach√© !
                const yPowerUp = startY + (ligneCache * hauteurBrique) + (hauteurBrique / 2) - 15; // -15 pour centrer (30/2)
                
                const powerUpEspoir = {
                    x: C.W / 2 - 15, // Centre horizontal (d√©cal√© de la moiti√© de la largeur - 30/2)
                    y: yPowerUp, // Dans la 3e ligne du mur, au centre vertical de la brique
                    w: 30, // ‚Üê Plus discret ! (r√©duit de 60)
                    h: 30, // ‚Üê Plus discret ! (r√©duit de 60)
                    type: 'rainbow_hope', // Type sp√©cial arc-en-ciel
                    emoji: 'üåà',
                    visible: true,
                    temps: 0,
                    collected: false,
                    decouvert: false, // ‚Üê Nouveau : pour d√©tecter la premi√®re d√©couverte
                    colorIndex: 0,
                    colors: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3']
                };
                
                // Ajouter aux power-ups globaux
                if (!powerUps) powerUps = [];
                powerUps.push(powerUpEspoir);
                
                console.log('üåà Power-up ESPOIR cr√©√© dans le mur en phase 22 (ligne 2, centre) !');
                console.log('   Position:', powerUpEspoir.x.toFixed(1), powerUpEspoir.y.toFixed(1));
                console.log('   StartY du mur:', startY.toFixed(1));
                console.log('   Hauteur brique:', hauteurBrique.toFixed(1));
                console.log('   Type:', powerUpEspoir.type);
                console.log('   Total power-ups:', powerUps.length);
            }
        }

        // G√©n√©rer des positions en forme de c≈ìur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du c≈ìur

            // G√©n√©rer des positions selon l'√©quation param√©trique d'un c≈ìur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Param√®tre de 0 √† 2œÄ

                // √âquation param√©trique d'un c≈ìur : x = 16sin¬≥(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise √† l'√©chelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function creerBriquesDrapeaux() {
            // Nettoyer les √©l√©ments pr√©c√©dents
            petitsCoeurs = [];
            coeursBateau = [];

            // Taille des briques
            const largeurBrique = 80;
            const hauteurBrique = 40;
            const rows = 5;
            const cols = Math.floor(C.W / largeurBrique);
            const startX = (C.W - (cols * largeurBrique)) / 2;
            const startY = 80;

            // Drapeaux disponibles
            const drapeaux = languageSelector.buttons;

            // Cr√©er les briques drapeaux
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const drapeau = drapeaux[Math.floor(Math.random() * drapeaux.length)];

                    briques.push({
                        x: startX + col * largeurBrique,
                        y: startY + row * hauteurBrique,
                        w: largeurBrique - 5,
                        h: hauteurBrique - 5,
                        largeur: largeurBrique - 5,
                        hauteur: hauteurBrique - 5,
                        visible: true,
                        drapeau: drapeau.drapeau,
                        langCode: drapeau.code,
                        langNom: drapeau.nom,
                        couleur: 'rgba(255, 255, 255, 0.2)',
                        vie: 1,
                        type: 'drapeau'
                    });
                }
            }
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits c≈ìurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les c≈ìurs r√©siduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le c≈ìur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // G√©n√©rer les positions en forme de c≈ìur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Cr√©er les briques selon la disposition en c≈ìur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: 2,     // 2 vies pour toutes les briques
                    vie: 2,        // Vie actuelle
                    clignotement: 0, // Animation quand touch√©e
                    // Animation de d√©doublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }

            // Placer automatiquement le power-up lanterne sur la premi√®re brique en bas
            // Mais seulement en phase lanterne et si la lanterne n'est pas d√©j√† allum√©e
            if(phaseJeu === 'lanterne' && !lanterne.active) {
                setTimeout(() => {
                    creerPowerUpLanterne();
                }, 500); // Petit d√©lai pour laisser les briques se placer
            }
        }

        function libererVaguesAmour() {
            // Ne lib√©rer des vagues d'amour que si le jeu est actif
            if (!jeu || phaseIntro.active) return;

            const tempsActuel = Date.now();

            // Mode √©toile c≈ìur activ√© par power-up
            if(window.modeEtoileCoeur && window.modeEtoileCoeur.actif) {
                if(Date.now() > window.modeEtoileCoeur.fin) {
                    window.modeEtoileCoeur.actif = false;
                } else if(tempsActuel - derniereCreeRafale >= 200) { // Plus fr√©quent pendant le power-up
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
            // Mode normal
            else if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : lib√©rer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : lib√©rer l'amour seulement pour la derni√®re brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        function mettreAJourPetitsCoeurs() {
            petitsCoeurs.forEach((coeur, index) => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;

            });
        }

        // Fonction pour dessiner des c≈ìurs avec 20 triangles (pour les briques)
        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            const temps = Date.now() * 0.003;
            const pulsation = 1 + Math.sin(temps) * 0.15; // Pulsation douce

            // Appliquer la pulsation
            ctx.scale(pulsation, pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            const triangleSize = t * 0.08;

            // C≈ìur super mignon pour les briques qui pulse
            ctx.beginPath();

            // Lobe gauche (forme arrondie avec segments)
            ctx.moveTo(-t * 0.3, -t * 0.02);
            ctx.lineTo(-t * 0.22, -t * 0.18);
            ctx.lineTo(-t * 0.12, -t * 0.2);
            ctx.lineTo(-t * 0.05, -t * 0.1);
            ctx.lineTo(-t * 0.02, -t * 0.02);

            // Lobe droit (forme arrondie avec segments)
            ctx.lineTo(t * 0.02, -t * 0.02);
            ctx.lineTo(t * 0.05, -t * 0.1);
            ctx.lineTo(t * 0.12, -t * 0.2);
            ctx.lineTo(t * 0.22, -t * 0.18);
            ctx.lineTo(t * 0.3, -t * 0.02);

            // Descente vers la pointe avec courbe
            ctx.lineTo(t * 0.18, t * 0.15);
            ctx.lineTo(t * 0.08, t * 0.3);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.08, t * 0.3);
            ctx.lineTo(-t * 0.18, t * 0.15);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // D√©tails mignons - petits c≈ìurs √† l'int√©rieur
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Petit c≈ìur gauche
            ctx.beginPath();
            ctx.moveTo(-t * 0.15, -t * 0.05);
            ctx.lineTo(-t * 0.12, -t * 0.08);
            ctx.lineTo(-t * 0.09, -t * 0.05);
            ctx.lineTo(-t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Petit c≈ìur droit
            ctx.beginPath();
            ctx.moveTo(t * 0.09, -t * 0.05);
            ctx.lineTo(t * 0.12, -t * 0.08);
            ctx.lineTo(t * 0.15, -t * 0.05);
            ctx.lineTo(t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Point lumineux central
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, t * 0.05, t * 0.02, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // C≈ìur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // C√¥t√©s qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits c≈ìurs pendant l'animation du bateau, la phase lanterne, stars, final ou feux d'artifice
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'final' || phaseJeu === 'feux_artifice') return;

            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // Calculs d'animation
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le c≈ìur polygonal
                dessinerCoeurPolygonal(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });

            // Dessiner l'ic√¥ne th√©matique au centre du cercle de c≈ìurs
            dessinerIconeThematique();
        }

        // Ic√¥ne centrale pour Phase 23 uniquement (en haut au centre)
        function dessinerIconeCentraleP23() {
            // Position haute et centr√©e horizontalement
            const centerX = C.W / 2;
            const centerY = 60; // En haut

            // Mettre √† jour la zone cliquable de l'ic√¥ne centrale
            const iconSize = 60;
            menuEnigmesCanvas.centralIcon.x = centerX - iconSize / 2;
            menuEnigmesCanvas.centralIcon.y = centerY - iconSize / 2;
            menuEnigmesCanvas.centralIcon.width = iconSize;
            menuEnigmesCanvas.centralIcon.height = iconSize;

            // Animation de pulsation
            const temps = Date.now() * 0.003;
            const pulsationBase = menuEnigmesCanvas.centralIcon.hover ? 0.25 : 0.15;
            const pulsation = 1 + Math.sin(temps) * pulsationBase;
            const rotation = Math.sin(temps * 0.5) * 0.08;

            ctx.save();

            // Effet de bordure cliquable si survol√©e
            if (menuEnigmesCanvas.centralIcon.hover) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(pulsation, pulsation);

                // Bordure lumineuse blanche
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            ctx.scale(pulsation, pulsation);

            // Ic√¥ne c≈ìur pour Phase 23 (finale)
            ctx.font = '50px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚ù§Ô∏è', 0, 0);

            ctx.restore();
        }

        // Ic√¥nes th√©matiques au centre du cercle de c≈ìurs
        function dessinerIconeThematique() {
            // Ne pas afficher l'ic√¥ne si l'animation est en cours
            if (animationIconeMenu.active) return;

            // Position haute et centr√©e horizontalement
            const centerX = C.W / 2;
            const centerY = C.H * 0.30; // Encore un petit peu plus bas (30% au lieu de 28%)

            // Mettre √† jour la zone cliquable de l'ic√¥ne centrale
            const iconSize = 60;
            menuEnigmesCanvas.centralIcon.x = centerX - iconSize / 2;
            menuEnigmesCanvas.centralIcon.y = centerY - iconSize / 2;
            menuEnigmesCanvas.centralIcon.width = iconSize;
            menuEnigmesCanvas.centralIcon.height = iconSize;

            // Animation de pulsation PLUS FORTE (augment√©e si survol√©e)
            const temps = Date.now() * 0.003; // Fr√©quence l√©g√®rement augment√©e
            const pulsationBase = menuEnigmesCanvas.centralIcon.hover ? 0.25 : 0.15; // Plus forte si survol√©e
            const pulsation = 1 + Math.sin(temps) * pulsationBase;
            const rotation = Math.sin(temps * 0.5) * 0.08; // Rotation plus visible (0.08 au lieu de 0.05)

            ctx.save();

            // Effet de bordure cliquable si survol√©e
            if (menuEnigmesCanvas.centralIcon.hover) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(pulsation, pulsation);

                // Bordure lumineuse blanche
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            ctx.scale(pulsation, pulsation);

            // Mapping des ic√¥nes selon les phases
            const iconesThematiques = {
                'humanite': 'ü§ù',        // Humanit√©
                'paix': 'üïäÔ∏è',           // Paix
                'diversite': 'üåà',       // Diversit√©
                'liberte': 'üóΩ',         // Libert√©
                'foi': 'üôè',             // Foi
                'respect': 'ü§≤',         // Respect
                'entraide': 'üíû',        // Entraide
                'hopital': 'üè•',         // H√¥pital
                'restauration': 'üå±',    // Restauration
                // Phases par d√©faut avec des ic√¥nes g√©n√©riques
                'coeurs': 'üíñ',          // Phase c≈ìurs g√©n√©rique
                'liberation': 'üïäÔ∏è',     // Phase lib√©ration
                'guerison': '‚ú®',        // Phase gu√©rison
                'renaissance': 'üå∏',     // Phase renaissance
                'transformation': 'ü¶ã', // Phase transformation
                'elevation': 'üåü',      // Phase √©l√©vation
                'illumination': 'üí´'     // Phase illumination
            };

            // D√©terminer quelle ic√¥ne afficher selon la phase actuelle
            let icone = iconesThematiques[phaseJeu] || 'üíñ'; // C≈ìur par d√©faut

            // Plus d'animation - l'ic√¥ne reste affich√©e et les ic√¥nes en haut servent de menu
            detecterFinNiveau(); // D√©tecter quand m√™me la fin pour autres logiques

            // Debug d√©sactiv√© pour r√©duire le spam de logs

            // Affichage de l'ic√¥ne avec style - PLUS PETITE
            ctx.font = '28px Arial'; // R√©duit de 48px √† 28px
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Effet de lueur douce - R√©duit
            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowBlur = 10; // R√©duit de 20 √† 10
            ctx.fillStyle = '#ffffff';
            ctx.fillText(icone, 0, 0);

            // Deuxi√®me couche sans ombre pour plus de clart√©
            ctx.shadowBlur = 0;
            ctx.fillText(icone, 0, 0);

            ctx.restore();
        }

        // D√©tecter quand un niveau est termin√©
        function detecterFinNiveau() {
            let niveauTermine = false;

            // Pour les phases de c≈ìurs : quand tous les c≈ìurs sont cass√©s
            if (phaseJeu === 'petits_coeurs') {
                const coeursVisibles = petitsCoeurs.filter(coeur => coeur.visible).length;
                niveauTermine = coeursVisibles === 0;
            }

            // Pour les phases de briques : quand toutes les briques sont cass√©es
            else if (phaseJeu === 'briques' || phaseJeu === 'lanterne') {
                const briquesVisibles = briques.filter(brique => brique.visible).length;
                niveauTermine = briquesVisibles === 0;
            }

            // Pour les autres phases bas√©es sur la variable brises
            else if (phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'coeurs' || phaseJeu === 'stars' || phaseJeu === 'nuit_coeurs') {
                niveauTermine = brises >= VOYAGE.length;
            }

            // üéÜ Si le niveau est termin√©, d√©clencher l'animation d'explosion
            if (niveauTermine && !window.niveauTermineDejaDeclenche) {

                // √âviter les d√©clenchements multiples
                window.niveauTermineDejaDeclenche = true;

                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante apr√®s animation
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                        // R√©initialiser le flag pour le prochain niveau
                        window.niveauTermineDejaDeclenche = false;
                    }, 500);
                });
            }

            return niveauTermine;
        }

        // Syst√®me de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // Limite stricte pour √©viter les bugs de performance
            const maxParticules = 120; // R√©duit de 200 √† 120
            if(particules.length + nombre > maxParticules) {
                const aSupprimer = (particules.length + nombre) - maxParticules;
                particules.splice(0, aSupprimer); // Supprimer les plus anciennes
            }

            // Ralentir 3x dans les phases lanterne et stars
            const vitesseFactor = (phaseJeu === 'lanterne' || phaseJeu === 'stars') ? 1.33 : 4;

            for(let i = 0; i < nombre; i++) {
                // 10% √©toiles, 30% ronds, 60% traits lumineux
                const rand = Math.random();
                let typeParticule;
                if(rand < 0.1) typeParticule = 'etoile';
                else if(rand < 0.4) typeParticule = 'rond';
                else typeParticule = 'trait_lumineux';

                // Direction plus al√©atoire pour les ronds
                const angleAleatoire = Math.random() * Math.PI * 2;
                const vitesseAleatoire = Math.random() * vitesseFactor * 1.5;

                particules.push({
                    x, y,
                    vx: typeParticule === 'rond' ? Math.cos(angleAleatoire) * vitesseAleatoire : (Math.random() - 0.5) * vitesseFactor,
                    vy: typeParticule === 'rond' ? Math.sin(angleAleatoire) * vitesseAleatoire : (Math.random() - 0.5) * vitesseFactor,
                    couleur,
                    vie: Math.random() * 40 + 20, // R√©duit : 20-60 au lieu de 30-90
                    taille: Math.random() * 6 + 2, // Plus grosses
                    type: typeParticule,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    longueur: Math.random() * 30 + 15, // Pour les traits lumineux
                    angle: Math.random() * Math.PI * 2 // Angle du trait
                });
            }
        }

        // ‚ú® PLUIE R√äVEUSE - Traits blancs lumineux avec tra√Æn√©es fines
        function declencherPluieLumineuse() {
            // üîä Son d'averse (pluie forte courte)
            AudioSystem.playAverse();

            for(let i = 0; i < 50; i++) { // R√©duit de 80 √† 50
                setTimeout(() => {
                    // Cr√©er des traits blancs oniriques
                    particules.push({
                        x: Math.random() * C.W,
                        y: -30,
                        vx: 0, // Pas de d√©rive horizontale
                        vy: Math.random() * 2 + 4, // Chute verticale pure
                        couleur: ['#FFFFFF', '#F8F8FF', '#FFFACD'][Math.floor(Math.random() * 3)], // Blancs nuanc√©s
                        vie: 100, // R√©duit de 120 √† 100
                        taille: 2, // Plus √©pais pour √™tre visible
                        type: 'trait_lumineux',
                        longueur: Math.random() * 35 + 30, // Tra√Æn√©es plus longues
                        angle: Math.PI / 2, // Parfaitement vertical
                        rotation: 0,
                        rotationSpeed: 0,
                        opacity: Math.random() * 0.4 + 0.6 // Plus opaque
                    });
                }, i * 80); // Plus espac√© dans le temps
            }
        }

        // üåßÔ∏è DEUX TYPES DE PLUIE :
        // 1. declencherPluieLumineuse() - Pluie d'AVERSE (80 traits lumineux blancs, gros, rapide, ponctuel)
        // 2. Pluie DOUCE ci-dessous - Pluie continue l√©g√®re (gouttes bleues fines, permanente en phase 5)

        function activerParticulesP5() {
            // Activer la pluie douce continue pour la phase 5
            pluieActive = true;

            // üîä D√©marrer le son de pluie en boucle
            AudioSystem.startRainLoop();
        }

        function desactiverPluie() {
            pluieActive = false;
            gouttesPlui = [];

            // üîä Arr√™ter le son de pluie
            AudioSystem.stopRainLoop();
        }

        // Cr√©er des gouttes de pluie douce (continue)
        function creerGouttesPluie() {
            if (!pluieActive) return;

            // Cr√©er 2-3 gouttes par frame pour un effet continu mais l√©ger
            const nbGouttes = Math.random() < 0.7 ? 2 : 3;

            for (let i = 0; i < nbGouttes; i++) {
                gouttesPlui.push({
                    x: Math.random() * C.W,
                    y: -10,
                    vitesse: 3 + Math.random() * 2, // Vitesse entre 3 et 5
                    longueur: 8 + Math.random() * 8, // Longueur entre 8 et 16
                    alpha: 0.3 + Math.random() * 0.3 // Transparence variable
                });
            }

            // Limiter le nombre de gouttes pour les performances
            if (gouttesPlui.length > 150) {
                gouttesPlui = gouttesPlui.slice(-150);
            }
        }

        // Mettre √† jour les gouttes de pluie
        function mettreAJourPluie() {
            if (!pluieActive) return;

            for (let i = gouttesPlui.length - 1; i >= 0; i--) {
                const goutte = gouttesPlui[i];
                goutte.y += goutte.vitesse;

                // Retirer les gouttes qui sortent de l'√©cran
                if (goutte.y > C.H + 20) {
                    gouttesPlui.splice(i, 1);
                }
            }
        }

        // Dessiner les gouttes de pluie
        function dessinerPluie() {
            if (!pluieActive || gouttesPlui.length === 0) return;

            ctx.save();
            ctx.strokeStyle = '#A0C4E0'; // Bleu clair
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';

            for (const goutte of gouttesPlui) {
                ctx.globalAlpha = goutte.alpha;
                ctx.beginPath();
                ctx.moveTo(goutte.x, goutte.y);
                ctx.lineTo(goutte.x, goutte.y + goutte.longueur);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Particules en forme de petits c≈ìurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 2, // Dispersion horizontale r√©duite
                    vy: -(Math.random() * 3 + 2),  // Vitesse verticale r√©duite
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            // Permettre la pluie √©motionnelle m√™me pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIM√â - autoriser les particules

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                // üåü Rotation pour les √©toiles
                if(p.rotation !== undefined) {
                    p.rotation += p.rotationSpeed;
                }

                if(p.type === 'coeur') {
                    // C≈ìurs : pas de gravit√©, continuent vers le haut
                    p.vy *= 0.99; // L√©g√®re d√©c√©l√©ration
                } else if(p.type === 'etoile') {
                    // √âtoiles : mouvement flottant avec scintillement
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.vy += Math.sin(Date.now() * 0.005 + i) * 0.1; // Mouvement ondulant
                } else if(p.type === 'trait_lumineux') {
                    // ‚ú® Traits r√™veurs : chute verticale pure
                    p.vy += 0.05; // Gravit√© tr√®s l√©g√®re
                    // Pas d'oscillation horizontale - pluie droite
                    // Angle reste vertical
                    p.angle = Math.PI / 2;
                } else {
                    // Particules normales : gravit√©
                    p.vy += 0.15;
                }

                // Syst√®me de vie normalis√©
                p.vie -= (p.type === 'coeur' ? 0.8 : 0.6); // C≈ìurs durent plus longtemps

                // Supprimer les particules qui sortent de l'√©cran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            // Permettre la pluie √©motionnelle m√™me pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIM√â - autoriser les particules

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = Math.max(0.1, p.vie * 0.8); // Minimum d'opacit√© pour voir les particules
                ctx.fillStyle = p.couleur;

                // Appliquer l'effet de lueur AVANT le dessin
                if(p.type !== 'trait_lumineux') {
                    ctx.shadowColor = p.couleur;
                    ctx.shadowBlur = p.taille * 1.5;
                }

                if(p.type === 'coeur') {
                    // Dessiner petit c≈ìur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du c≈ìur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du c≈ìur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du c≈ìur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else if(p.type === 'etoile') {
                    // üåü √âtoile simple sans rotation
                    ctx.translate(p.x, p.y);
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angleExt = (i * 2 * Math.PI) / 5;
                        const angleInt = ((i + 0.5) * 2 * Math.PI) / 5;
                        const xExt = Math.cos(angleExt) * p.taille;
                        const yExt = Math.sin(angleExt) * p.taille;
                        const xInt = Math.cos(angleInt) * p.taille * 0.5;
                        const yInt = Math.sin(angleInt) * p.taille * 0.5;

                        if(i === 0) ctx.moveTo(xExt, yExt);
                        else ctx.lineTo(xExt, yExt);
                        ctx.lineTo(xInt, yInt);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if(p.type === 'trait_lumineux') {
                    // ‚ú® Trait lumineux fin et simple
                    ctx.lineWidth = Math.max(1, p.taille * 0.3); // Plus fin
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = p.couleur;

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(
                        p.x - Math.cos(p.angle) * p.longueur * 0.5, // Plus court
                        p.y - Math.sin(p.angle) * p.longueur * 0.5
                    );
                    ctx.stroke();
                } else if(p.type === 'emoji') {
                    // üí∞ Particule emoji (billets de banque phase 20)
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.font = `${p.taille}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 0; // Pas de flou pour les emojis
                    ctx.fillText(p.emoji, 0, 0);
                    p.rotation += p.rotationSpeed; // Rotation continue
                } else {
                    // Particule ronde simple
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions - D√âSACTIV√â (interface simplifi√©e)
        function afficherMunitions() {
            // Fonction d√©sactiv√©e - plus d'affichage de munitions en mode √©toiles
            return;
        }

        // Dessiner les projectiles √©toiles
        function dessinerProjectiles() {
            // Dessiner les projectiles √©toiles pendant la phase stars, lanterne ET mur (phases 17-23)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur';

            // üîç DEBUG Phase 22
            if(phaseActuelle === 22) {
                console.log(`üîç dessinerProjectiles() DEBUG - phaseJeu=${phaseJeu}, isWallPhase=${isWallPhase}, projectiles.length=${projectiles.length}`);
            }

            if(phaseJeu !== 'stars' && phaseJeu !== 'lanterne' && !isWallPhase) {
                if(phaseActuelle === 22) console.log(`‚ùå dessinerProjectiles() BLOQU√â par return - phaseJeu=${phaseJeu}`);
                return;
            }

            if(projectiles.length > 0) {
                console.log(`üé® dessinerProjectiles() - ${projectiles.length} projectiles √† dessiner (phase ${phaseActuelle}, phaseJeu=${phaseJeu})`);
            }

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;

                // Utiliser la config du projectile si disponible
                const config = projectile.config || getProjectileConfig(18); // Par d√©faut: √©toiles
                const rayonEtoile = config.size / 2 || 8;

                // üîç DEBUG Phase 22 - V√©rifier la config (premier projectile seulement)
                if(phaseActuelle === 22 && projectiles.indexOf(projectile) === 0) {
                    console.log(`üîç Projectile config:`, {
                        type: config.type,
                        emoji: config.emoji,
                        size: config.size,
                        trailType: config.trailType,
                        colors: config.color
                    });
                }

                // ‚ú® PAILLETTES MAGIQUES AUTOUR DU PROJECTILE ‚ú®
                const sparkleCount = 8;
                const sparkleTime = Date.now() * 0.005;
                for (let s = 0; s < sparkleCount; s++) {
                    const angle = (s / sparkleCount) * Math.PI * 2 + sparkleTime;
                    const distance = rayonEtoile * 2 + Math.sin(sparkleTime + s) * 5;
                    const sparkleX = posX + Math.cos(angle) * distance;
                    const sparkleY = posY + Math.sin(angle) * distance;
                    const sparkleSize = 2 + Math.sin(sparkleTime * 2 + s) * 1;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.6 + Math.sin(sparkleTime * 3 + s) * 0.3;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#FFFFFF';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Dessiner la tra√Æn√©e lumineuse si configur√©e
                if (config.trail && projectile.dx && projectile.dy) {
                    const trailLength = config.trailLength || 15;
                    
                    // Phase 22 : Tra√Æn√©e de paillettes arc-en-ciel ‚ú®
                    if (config.trailType === 'sparkle') {
                        const sparkleCount = Math.floor(trailLength / 2); // Plus de paillettes (25/2 ‚âà 12)
                        for (let s = 0; s < sparkleCount; s++) {
                            const sparkleRatio = s / sparkleCount;
                            const sparkleX = posX - projectile.dx * (sparkleRatio * trailLength / config.speed);
                            const sparkleY = posY - projectile.dy * (sparkleRatio * trailLength / config.speed);

                            // Couleur arc-en-ciel cyclique - chaque paillette a sa propre couleur
                            const colorIndex = (s + Math.floor(Date.now() / 150)) % config.color.length;
                            const sparkleColor = config.color[colorIndex];

                            // Dessiner une √©toile scintillante plus grande et plus visible
                            ctx.save();
                            ctx.globalAlpha = 0.9 - sparkleRatio * 0.6; // Plus opaque au d√©but
                            ctx.shadowBlur = 20; // Glow encore plus intense
                            ctx.shadowColor = sparkleColor;
                            ctx.fillStyle = sparkleColor;

                            ctx.translate(sparkleX, sparkleY);
                            ctx.rotate((Date.now() * 0.008) + s); // Rotation plus rapide

                            // √âtoile √† 4 branches plus grande
                            const sparkleSize = 8 - sparkleRatio * 4; // Taille variable (8px ‚Üí 4px)
                            ctx.beginPath();
                            for (let p = 0; p < 4; p++) {
                                const angle = (p * Math.PI) / 2;
                                const x = Math.cos(angle) * sparkleSize;
                                const y = Math.sin(angle) * sparkleSize;
                                if (p === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();

                            // Ajouter un second glow pour plus d'√©clat
                            ctx.shadowBlur = 30;
                            ctx.globalAlpha = 0.6 - sparkleRatio * 0.4;
                            ctx.fill();

                            ctx.restore();
                        }
                    } else {
                        // ‚ú® Tra√Æn√©e am√©lior√©e avec BLUR et d√©grad√©
                        const trailSteps = 20;
                        for (let t = 0; t < trailSteps; t++) {
                            const ratio = t / trailSteps;
                            const trailX = posX - projectile.dx * (ratio * trailLength / config.speed);
                            const trailY = posY - projectile.dy * (ratio * trailLength / config.speed);
                            
                            const currentColor = Array.isArray(config.color) ? config.color[projectile.colorIndex || 0] : config.color[0];
                            
                            ctx.save();
                            ctx.globalAlpha = (1 - ratio) * 0.7;
                            ctx.shadowBlur = 15 * (1 - ratio);
                            ctx.shadowColor = currentColor;
                            ctx.fillStyle = currentColor;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, rayonEtoile * (1 - ratio * 0.5), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }

                // Calcul pour l'effet de rotation scintillante
                const rotation = config.rotation ? (projectile.rotation || 0) : Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner le projectile avec effet de lueur (couleur selon le type)
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const currentColor = Array.isArray(config.color) ? config.color[projectile.colorIndex || 0] : config.color[0];
                    
                    // Si un emoji est configur√©, dessiner UNIQUEMENT l'emoji avec un glow
                    if (config.emoji) {
                        // üíñ C≈íUR G√âOM√âTRIQUE BRILLANT (si c'est un emoji c≈ìur)
                        if (config.emoji === 'üíñ' || config.emoji === 'üíõ' || config.emoji === 'üíö' || config.emoji === 'üíô' || config.emoji === 'üíú' || config.emoji === '‚ù§Ô∏è') {
                            // Dessiner un c≈ìur g√©om√©trique vectoriel au lieu de l'emoji
                            const size = rayonEtoile * 2;
                            
                            // Multi-couches de blur pour effet magique
                            for (let layer = 3; layer >= 0; layer--) {
                                ctx.save();
                                ctx.globalAlpha = 0.3 + (layer * 0.15);
                                ctx.shadowBlur = 30 - (layer * 7);
                                ctx.shadowColor = currentColor;
                                ctx.fillStyle = currentColor;
                                
                                // C≈ìur g√©om√©trique avec courbes de B√©zier
                                const scale = 1 + (layer * 0.05);
                                ctx.scale(scale, scale);
                                ctx.beginPath();
                                ctx.moveTo(0, size * 0.3);
                                // Lobe gauche
                                ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                                // Lobe droit
                                ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                                ctx.closePath();
                                ctx.fill();
                                
                                ctx.restore();
                            }
                            
                            // Contour brillant
                            ctx.save();
                            ctx.strokeStyle = '#FFFFFF';
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#FFFFFF';
                            ctx.beginPath();
                            ctx.moveTo(0, size * 0.3);
                            ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                            ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                            ctx.closePath();
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            // Autre emoji : glow intense derri√®re l'emoji pour le rendre bien visible
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = currentColor;
                            
                            ctx.font = `${rayonEtoile * 3}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const emoji = Array.isArray(config.emoji) ? config.emoji[projectile.colorIndex % config.emoji.length] : config.emoji;
                            ctx.fillText(emoji, 0, 0);
                            
                            ctx.shadowBlur = 0;
                        }
                    } else {
                        // Pas d'emoji : dessiner un C≈íUR G√âOM√âTRIQUE par d√©faut avec blur intense
                        const size = rayonEtoile * 2;
                        
                        // Multi-couches de blur pour effet magique maximum
                        for (let layer = 4; layer >= 0; layer--) {
                            ctx.save();
                            ctx.globalAlpha = 0.25 + (layer * 0.12);
                            ctx.shadowBlur = 40 - (layer * 8);
                            ctx.shadowColor = currentColor;
                            ctx.fillStyle = currentColor;
                            
                            const scale = 1 + (layer * 0.08);
                            ctx.scale(scale, scale);
                            ctx.beginPath();
                            ctx.moveTo(0, size * 0.3);
                            ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                            ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.restore();
                        }
                        
                        // √âclat central blanc brillant
                        ctx.save();
                        ctx.globalAlpha = 0.8;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.scale(0.3, 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, size * 0.3);
                        ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                        ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                }

                ctx.restore();
            });
        }

        // Configuration des projectiles par phase
        function getProjectileConfig(phase) {
            const configs = {
                17: {
                    type: 'coin',
                    emoji: 'ü™ô',
                    color: ['#FFD700', '#FFA500'],
                    size: 20,
                    trail: true,
                    trailLength: 15,
                    particles: false,
                    cadence: 15,
                    speed: 2.5,
                    powerup: ['red_cross', 'broken_heart'] // Deux types al√©atoires
                },
                18: {
                    type: 'cloud',
                    emoji: '‚òÅÔ∏è',
                    color: ['#B0B0B0', '#808080'],
                    size: 22,
                    trail: true,
                    trailLength: 18,
                    particles: false,
                    cadence: 15,
                    speed: 2.8,
                    powerup: ['gray_heart', 'black_heart'] // Deux types al√©atoires
                },
                19: {
                    type: 'hammer',
                    emoji: '‚öíÔ∏è',
                    color: ['#708090', '#556B2F', '#8B4513'],
                    size: 20,
                    trail: true,
                    trailLength: 16,
                    particles: false,
                    cadence: 12,
                    speed: 3.2,
                    powerup: ['chain', 'barbed_wire'] // Prison/Barbel√©s
                },
                20: {
                    type: 'money',
                    emoji: 'üíµ',
                    color: ['#85BB65', '#2E7D32', '#1B5E20'],
                    size: 28,
                    trail: true,
                    trailLength: 45,
                    colorChange: false,
                    particles: true,
                    particleCount: 12,
                    particleEmoji: 'üí∞',
                    cadence: 12,
                    speed: 3.5,
                    powerup: ['red_heart', 'open_hands'] // Solidarit√©/Compassion
                },
                21: {
                    type: 'star',
                    emoji: '‚≠ê',
                    color: ['#FFD700', '#FFFF00', '#FFA500'],
                    size: 22,
                    trail: true,
                    trailLength: 20,
                    particles: false,
                    cadence: 8,
                    speed: 3.8,
                    doubleShot: false,
                    powerup: ['green_heart', 'yellow_heart', 'blue_heart', 'purple_heart'] // Diversit√©
                },
                22: {
                    type: 'big_heart',
                    emoji: 'üíñ',
                    color: ['#FF1493'], // Rose vif - couleur fixe
                    size: 26,
                    trail: true,
                    trailLength: 25,
                    particles: true,
                    particleCount: 8,
                    cadence: 10,
                    speed: 3.0,
                    powerup: ['vibrant_heart', 'smile'] // Espoir
                },
                23: {
                    type: 'rotating_hearts',
                    emoji: ['üíñ', 'üíõ', 'üíö', 'üíô', 'üíú'],
                    color: ['#FF1493', '#FFD700', '#00FF00', '#1E90FF', '#9370DB'],
                    size: 20,
                    trail: true,
                    trailLength: 20,
                    particles: true,
                    particleCount: 12,
                    rotation: true,
                    cadence: 15,
                    speed: 9,
                    laser: true,
                    laserInterval: 20000,
                    powerup: null
                }
            };
            
            return configs[phase] || configs[18]; // Par d√©faut : √©toiles
        }

        // Tirer un projectile √©toile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne ou mur (phases 17-22, pas 23 = fin)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur';
            
            console.log(`üéØ tirerProjectile() - Phase ${phaseActuelle}, phaseJeu=${phaseJeu}, isWallPhase=${isWallPhase}, munitions=${munitions}, rechargement=${rechargement}`);
            
            if (rechargement > 0) {
                // Rechargement normal - ne pas afficher de log (trop de spam)
                return;
            }
            
            if (phaseJeu !== 'lanterne' && !isWallPhase) {
                console.log(`‚õî tirerProjectile() - BLOQU√â : Mauvaise phase (phaseJeu=${phaseJeu}, phase=${phaseActuelle})`);
                return;
            }

            // Obtenir la configuration pour la phase actuelle (n√©cessaire pour rechargement)
            const config = getProjectileConfig(phaseActuelle);

            // Tant qu'il y a des munitions, tirer des √©toiles
            if (munitions > 0) {
                console.log(`üöÄ tirerProjectile() - TIR! Config type=${config.type}, emoji=${config.emoji}`);
                
                // Tir d'√©toiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = config.speed || 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;

                // Projectile principal
                // Pour phase 19 (multicolor), choisir une couleur al√©atoire
                const randomColorIndex = (config.type === 'multicolor' && Array.isArray(config.color)) 
                    ? Math.floor(Math.random() * config.color.length) 
                    : 0;
                
                const projectile = {
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY,
                    phase: phaseActuelle,
                    config: config,
                    colorIndex: randomColorIndex,
                    rotation: 0,
                    creationTime: Date.now()
                };
                
                projectiles.push(projectile);
                console.log(`‚ú® Projectile cr√©√©! Total: ${projectiles.length}, emoji: ${config.emoji}, color: ${config.color[0]}`);
                
                // Son de tir
                AudioSystem.playShoot();
                
                // Double tir pour phase 21 (si activ√©)
                if (config.doubleShot && window.doubleShotActive) {
                    const angle = Math.atan2(velY, velX);
                    const offset = 0.3; // 30 degr√©s de d√©calage
                    
                    const velX2 = Math.cos(angle + offset) * vitesse;
                    const velY2 = Math.sin(angle + offset) * vitesse;
                    
                    // Couleur al√©atoire aussi pour le 2e projectile en multicolor
                    const randomColorIndex2 = (config.type === 'multicolor' && Array.isArray(config.color)) 
                        ? Math.floor(Math.random() * config.color.length) 
                        : 0;
                    
                    projectiles.push({
                        x: startX,
                        y: startY,
                        dx: velX2,
                        dy: velY2,
                        phase: phaseActuelle,
                        config: config,
                        colorIndex: randomColorIndex2,
                        rotation: 0,
                        creationTime: Date.now()
                    });
                }

                // MUNITIONS INFINIES - ne pas d√©cr√©menter
                // munitions--;

                // Plus besoin de v√©rifier la derni√®re munition (infinies)
            }

            rechargement = config ? config.cadence : 20; // D√©lai entre les tirs selon la phase
        }

        // Mettre √† jour les projectiles
        function mettreAJourProjectiles() {
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur';
            
            if (animationBateau.active || (phaseJeu !== 'lanterne' && !isWallPhase)) {
                // Nettoyer les projectiles si on n'est pas en phase lanterne ou mur
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;
                
                // Mettre √† jour les effets sp√©ciaux
                if (proj.config) {
                    // Rotation pour phase 23
                    if (proj.config.rotation) {
                        proj.rotation += 0.1;
                    }
                    
                    // Changement de couleur pour phase 20 (rainbow)
                    if (proj.config.colorChange) {
                        const elapsed = Date.now() - proj.creationTime;
                        proj.colorIndex = Math.floor(elapsed / 100) % proj.config.color.length;
                    }
                }

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // üåà Phase 22 : Collision avec le power-up Espoir cach√©
                if (powerUps && powerUps.length > 0) {
                    for (let pIndex = powerUps.length - 1; pIndex >= 0; pIndex--) {
                        const power = powerUps[pIndex];
                        if (power.type === 'rainbow_hope' && !power.collected) {
                            // V√©rifier collision projectile avec power-up (30√ó30 - plus discret)
                            const dx = proj.x - (power.x + power.w/2);
                            const dy = proj.y - (power.y + power.h/2);
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            
                            if (distance < power.w/2 + 12) { // Rayon adapt√© (15 + 12 = 27px)
                                // Power-up Espoir collect√© ! üåà
                                power.collected = true;
                                powerUps.splice(pIndex, 1);
                                projectiles.splice(i, 1);
                                
                                // Explosion arc-en-ciel massive
                                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                                for (let c = 0; c < 7; c++) {
                                    ajouterParticules(power.x + power.w/2, power.y + power.h/2, rainbowColors[c], 15);
                                }
                                
                                // Bonus √©norme
                                score += 5000;
                                window.score = score;
                                
                                // Triple son de cloche pour la collecte ! üîîüîîüîî
                                AudioSystem.playChime();
                                setTimeout(() => AudioSystem.playCoin(), 100);
                                setTimeout(() => AudioSystem.playCoin(), 200);
                                
                                // Message sp√©cial
                                afficherMessagePowerupSimple('üåà ‚ú® ESPOIR R√âV√âL√â ! ‚ú® üåà\n+5000 XP');
                                
                                console.log('üåà Power-up ESPOIR collect√© en phase 22 ! +5000 XP');
                                console.log('   ‚Üí Le joueur peut maintenant finir les briques restantes pour passer √† la phase suivante.');
                                
                                // NE PAS d√©clencher de transition ici !
                                // Le power-up d√©bloque juste la possibilit√© de finir la phase
                                // La transition se fera quand TOUTES les briques seront d√©truites
                                
                                break;
                            }
                        }
                    }
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;
                            
                            // Son "poque" √† chaque impact
                            AudioSystem.playWallHit();
                            
                            // Cr√©er des particules pour les phases 20, 22-23
                            if (proj.config && proj.config.particles) {
                                const particleCount = proj.config.particleCount || 8;
                                const colors = proj.config.color;
                                
                                // Phase 20 : particules emoji üí∞
                                if (proj.config.particleEmoji) {
                                    for (let p = 0; p < particleCount; p++) {
                                        const angle = (Math.PI * 2 * p) / particleCount;
                                        const speed = 2 + Math.random() * 3;
                                        particules.push({
                                            x: proj.x,
                                            y: proj.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            couleur: '#FFD700',
                                            vie: 30 + Math.random() * 20,
                                            taille: 16,
                                            type: 'emoji',
                                            emoji: proj.config.particleEmoji,
                                            rotation: Math.random() * Math.PI * 2,
                                            rotationSpeed: (Math.random() - 0.5) * 0.1
                                        });
                                    }
                                } else {
                                    // Autres phases : particules color√©es normales
                                    for (let p = 0; p < particleCount; p++) {
                                        const angle = (Math.PI * 2 * p) / particleCount;
                                        const speed = 2 + Math.random() * 3;
                                        if (window.ajouterParticules) {
                                            const color = Array.isArray(colors) ? colors[p % colors.length] : colors[0];
                                            ajouterParticules(proj.x, proj.y, color, 1);
                                        }
                                    }
                                }
                            }

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est d√©truite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Son th√©matique selon la phase
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                switch(phaseActuelle) {
                                    case 17: // AVARICE ü™ô
                                        AudioSystem.playCoin();
                                        break;
                                    case 18: // LIBERT√â ‚òÅÔ∏è
                                        AudioSystem.playWindBreak();
                                        break;
                                    case 19: // REFUS ‚öíÔ∏è
                                        AudioSystem.playHammerBreak();
                                        break;
                                    case 20: // ORGUEIL üíµ
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 21: // IN√âGALIT√âS ‚≠ê
                                        AudioSystem.playHeartBreak();
                                        break;
                                    case 22: // ESPOIR üíñ
                                        AudioSystem.playDeepKnock();
                                        break;
                                    case 19: // REFUS ‚öíÔ∏è
                                        AudioSystem.playHammerBreak();
                                        break;
                                    case 20: // ORGUEIL üíµ
                                        AudioSystem.playHeartBreak();
                                        break;
                                    case 21: // IN√âGALIT√âS ‚≠ê
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 22: // ESPOIR üíñ
                                        AudioSystem.playCoin();
                                        break;
                                    case 20: // ORGUEIL ÔøΩ
                                        AudioSystem.playCoin();
                                        break;
                                    case 21: // IN√âGALIT√âS ‚≠ê
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 22: // ESPOIR üíñ
                                        AudioSystem.playHeartBreak();
                                        break;
                                    default:
                                        AudioSystem.playWallBreak();
                                }

                                // Explosion en 3 petits c≈ìurs
                                for(let j = 0; j < 3; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                // Phase 22 : taux r√©duit √† 5% pour ne pas masquer le rainbow_hope
                                const tauxPowerup = (phaseActuelle === 22) ? 0.05 : 0.3;
                                if(Math.random() < tauxPowerup) {
                                    // üåà PROTECTION Phase 22 : Ne pas cr√©er de power-up al√©atoire trop proche du rainbow_hope
                                    let peutCreerPowerup = true;
                                    if (phaseActuelle === 22) {
                                        const espoirPresent = powerUps.find(p => p.type === 'rainbow_hope' && !p.collected);
                                        if (espoirPresent) {
                                            const distance = Math.sqrt(
                                                Math.pow(brique.x + brique.w/2 - espoirPresent.x, 2) + 
                                                Math.pow(brique.y + brique.h/2 - espoirPresent.y, 2)
                                            );
                                            // Ne pas cr√©er si trop proche du rainbow_hope (moins de 60px)
                                            if (distance < 60) {
                                                console.log(`üö´ Power-up al√©atoire annul√© - trop proche du rainbow_hope (distance: ${distance.toFixed(1)}px)`);
                                                peutCreerPowerup = false;
                                            }
                                        }
                                    }
                                    
                                    if (peutCreerPowerup) {
                                        // Utiliser le power-up sp√©cifique de la phase si configur√©
                                        const phasePowerup = proj.config && proj.config.powerup ? proj.config.powerup : null;
                                        creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2, phasePowerup);
                                    }
                                }

                                // V√©rifier si toutes les briques sont d√©truites
                                if(briques.every(b => !b.visible)) {
                                    // üåà EXCEPTION PHASE 22 : Ne pas terminer automatiquement !
                                    // Le joueur doit collecter le power-up Espoir cach√© avant de continuer
                                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                    let peutTerminerPhase = true; // Variable de contr√¥le
                                    
                                    if (phaseActuelle === 22) {
                                        // V√©rifier si le power-up existe et n'est PAS collect√©
                                        const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                        if (espoirPresent) {
                                            console.log('üåà Phase 22 : Mur d√©truit mais power-up ESPOIR pas encore collect√© !');
                                            console.log('   ‚Üí La phase ne se termine pas automatiquement.');
                                            peutTerminerPhase = false; // ‚Üê Bloquer la fin automatique SANS return
                                        } else {
                                            console.log('‚úÖ Phase 22 : Mur d√©truit ET power-up ESPOIR collect√© ‚Üí Transition !');
                                        }
                                    }

                                    // Terminer la phase uniquement si autoris√©
                                    if (peutTerminerPhase) {
                                        // Auto-r√©cup√©rer les powerups restants (sauf rainbow_hope qui doit √™tre collect√© manuellement)
                                        if(powerUps && powerUps.length > 0) {
                                            powerUps.forEach(powerup => {
                                                // Ne pas auto-collecter le rainbow_hope en Phase 22
                                                if (powerup.type === 'rainbow_hope' && phaseActuelle === 22) {
                                                    return; // Skip
                                                }
                                                // D√©clencher les effets selon le type
                                                switch(powerup.type) {
                                                    case 'etoile_montante':
                                                        score += 1000;
                                                        break;
                                                    case 'bonus_points':
                                                        score += 500;
                                                        break;
                                                    case 'allume_lanterne':
                                                        lanterne.active = true;
                                                        lanterne.intensite = 1.0;
                                                        break;
                                                }
                                                // Particules d'effet
                                                if(window.ajouterParticules) {
                                                    ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                                }
                                            });
                                            powerUps = powerUps.filter(p => p.type === 'rainbow_hope' && phaseActuelle === 22); // Garder rainbow_hope en Phase 22
                                        }

                                        phaseJeu = 'fin_niveau';
                                        // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                        animerExplosionIconeCollector(() => {
                                            narrationManager.goToNextPhaseDirect();
                                        });
                                    }
                                }
                            }
                        }
                    }
                });

                // üåà Collision avec le power-up Espoir (Phase 22 uniquement)
                if (powerUps && powerUps.length > 0) {
                    for (let p = powerUps.length - 1; p >= 0; p--) {
                        const powerup = powerUps[p];
                        
                        // V√©rifier uniquement le power-up Espoir arc-en-ciel
                        if (powerup.type === 'rainbow_hope' && !powerup.collected) {
                            const distance = Math.sqrt(
                                Math.pow(proj.x - (powerup.x + powerup.w/2), 2) +
                                Math.pow(proj.y - (powerup.y + powerup.h/2), 2)
                            );
                            
                            // Collision d√©tect√©e (rayon du power-up)
                            if (distance < (powerup.w / 2 + 15)) {
                                // ‚úÖ MARQUER COMME COLLECT√â (ne pas supprimer du tableau !)
                                powerup.collected = true;
                                
                                // üéÜ EXPLOSION ARC-EN-CIEL MASSIVE !
                                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                                rainbowColors.forEach((color, index) => {
                                    setTimeout(() => {
                                        if (window.ajouterParticules) {
                                            ajouterParticules(powerup.x, powerup.y, color, 15);
                                        }
                                    }, index * 50);
                                });
                                
                                // üèÜ √âNORME BONUS
                                score += 5000;
                                window.score = score;
                                
                                // üîì D√©bloquer l'√©nigme Espoir
                                if (enigmaCollector) {
                                    setTimeout(() => {
                                        enigmaCollector.collecterEnigme('espoir_mur', true);
                                        score += 1000; // Bonus √©nigme
                                        window.score = score;
                                        console.log('üåà √ânigme ESPOIR d√©bloqu√©e par collecte du power-up !');
                                    }, 500);
                                }
                                
                                // üîä Son de collecte magique (triple)
                                if (AudioSystem && AudioSystem.playCoin) {
                                    AudioSystem.playCoin();
                                    setTimeout(() => AudioSystem.playCoin(), 150);
                                    setTimeout(() => AudioSystem.playCoin(), 300);
                                }
                                
                                // üí¨ Message spectaculaire
                                afficherMessagePowerupSimple('üåà ‚ú® ESPOIR R√âV√âL√â ! ‚ú® üåà\n+6000 XP');
                                
                                // ‚õî NE PAS SUPPRIMER le power-up du tableau (juste marqu√© collected = true)
                                // powerUps.splice(p, 1); ‚Üê SUPPRIM√â
                                
                                // Supprimer le projectile
                                projectiles.splice(i, 1);
                                
                                console.log('üåàüí´ Power-up ESPOIR collect√© ! +6000 XP (5000 + 1000 √©nigme) !');
                                console.log('‚úÖ Power-up reste dans le tableau avec collected = true');
                                
                                // ‚úÖ Phase 22 : V√©rifier si on peut passer √† la phase suivante
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                if (phaseActuelle === 22) {
                                    // V√©rifier s'il reste des briques
                                    const briquesRestantes = briques.filter(b => b.visible).length;
                                    
                                    if (briquesRestantes === 0) {
                                        console.log('‚ú® Phase 22 compl√©t√©e : ESPOIR collect√© + TOUTES les briques d√©truites ‚Üí Transition !');
                                        // Attendre un peu pour laisser voir l'explosion et le message
                                        setTimeout(() => {
                                            phaseJeu = 'fin_niveau';
                                            animerExplosionIconeCollector(() => {
                                                narrationManager.goToNextPhaseDirect();
                                            });
                                        }, 2000); // 2 secondes pour profiter du moment
                                    } else {
                                        console.log(`‚ú® ESPOIR collect√© mais il reste ${briquesRestantes} briques ‚Üí Continue de jouer !`);
                                        // Ne pas d√©clencher de transition - le joueur doit finir les briques
                                    }
                                }
                                
                                break;
                            }
                        }
                    }
                }
            }

            // R√©duire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Syst√®me de laser pour phase 23
        function activerLaser() {
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle !== 23) return;
            
            const now = Date.now();
            const config = getProjectileConfig(23);
            
            // V√©rifier si on peut tirer (tous les 20s)
            if (now - laserState.lastFired >= config.laserInterval) {
                laserState.active = true;
                laserState.startTime = now;
                laserState.lastFired = now;
                
                // Message d'activation
                afficherMessagePowerupSimple(getTranslatedText('game.messages.laser_activated', '‚ö° RAYON LASER ACTIV√â !'));
                
                // D√©truire toutes les briques sur une ligne horizontale (au niveau du milieu)
                const laserY = C.H * 0.3;
                const laserHeight = 40;
                
                briques.forEach(brique => {
                    if (brique.visible && brique.y >= laserY - laserHeight && brique.y <= laserY + laserHeight) {
                        brique.visible = false;
                        briques = briques.filter(b => b !== brique || b.visible);
                        
                        // Particules d'explosion
                        if (window.ajouterParticules) {
                            const colors = ['#FF1493', '#FFD700', '#00FF00', '#1E90FF', '#9370DB'];
                            for (let i = 0; i < 20; i++) {
                                ajouterParticules(
                                    brique.x + brique.w / 2,
                                    brique.y + brique.h / 2,
                                    colors[i % colors.length],
                                    1
                                );
                            }
                        }
                        
                        // Score
                        score += 100;
                        brises++;
                    }
                });
            }
        }
        
        // Mettre √† jour et dessiner le laser
        function mettreAJourLaser() {
            if (!laserState.active) return;
            
            const now = Date.now();
            const elapsed = now - laserState.startTime;
            
            // D√©sactiver apr√®s la dur√©e
            if (elapsed >= laserState.duration) {
                laserState.active = false;
                return;
            }
            
            // Dessiner le rayon laser
            ctx.save();
            
            const laserY = C.H * 0.3;
            const progress = elapsed / laserState.duration;
            const alpha = Math.sin(progress * Math.PI); // Fade in/out
            
            // Effet n√©on √©lectrique
            ctx.globalAlpha = alpha * 0.6;
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#00FFFF';
            
            // Rayon principal
            const gradient = ctx.createLinearGradient(0, laserY - 20, 0, laserY + 20);
            gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 255, 1)');
            gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, laserY - 20, C.W, 40);
            
            // √âclairs √©lectriques
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(0, laserY + (Math.random() - 0.5) * 30);
                const segments = 10;
                for (let j = 1; j <= segments; j++) {
                    const x = (C.W * j) / segments;
                    const y = laserY + (Math.random() - 0.5) * 30;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // G√©rer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // V√©rifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqu√©
            }

            // Appliquer le multiplicateur de vitesse s'il existe
            const vitesseMulti = balle.multiplicateurVitesse || 1;
            balle.x += balle.dx * vitesseMulti;
            balle.y += balle.dy * vitesseMulti;

            // Mode casse-briques : rebonds classiques (lanterne et mur)
            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                    // üîä Son de rebond sur les murs
                    AudioSystem.playBounce();
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                    // üîä Son de rebond sur le haut
                    AudioSystem.playBounce();
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' || phaseJeu === 'mur' ? C.SP * 1.5 : C.SP) * ecart * 0.8 * multiplicateurPuissance;

                    // üîä Son de rebond sur le bateau (raquette)
                    AudioSystem.playBounce();
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode √©toiles : traverser les bords avec t√©l√©portation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // R√©appara√Æt √† droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // R√©appara√Æt √† gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // T√©l√©portation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // R√©appara√Æt en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de v√©rit√© (bas) - seulement dans les phases o√π la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'√©toile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'√©toile continue sa trajectoire
            }

            // Briser les pr√©jug√©s - une seule brique par frame maximum
            let briqueTouchee = false;
            briques.forEach(brique => {
                if(briqueTouchee) return; // Arr√™ter si on a d√©j√† touch√© une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Bloquer les collisions pendant le mode secret
                        if (secretModeModule && secretModeModule.isActive) {
                            return; // Pas de collision avec les briques en mode secret
                        }
                        if (modeSecret) {
                            return; // Pas de collision avec les briques en mode secret (fallback)
                        }

                        // Marquer qu'on a touch√© une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond sur la brique
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // D√©terminer si le rebond est horizontal ou vertical
                        const deltaX = Math.abs(centreBalleX - centreBriqueX);
                        const deltaY = Math.abs(centreBalleY - centreBriqueY);

                        if (deltaX > deltaY) {
                            // Rebond horizontal (c√¥t√©s gauche/droite)
                            balle.dx = -balle.dx;
                        } else {
                            // Rebond vertical (haut/bas)
                            balle.dy = -balle.dy;
                        }

                        // üîä Son de rebond sur brique
                        AudioSystem.playBounce();

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;

                        // üîä Son de casse brique (al√©atoire entre 3 sons)
                        const sonAleatoire = Math.random();
                        if (sonAleatoire < 0.33) {
                            AudioSystem.playBrickBreakToc();
                        } else if (sonAleatoire < 0.66) {
                            AudioSystem.playBrickBreakGlass();
                        } else {
                            AudioSystem.playBrickBreakCrack();
                        }

                        // Explosion en 3 petits c≈ìurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: Math.random() * 30 + 40, // 40-70 frames (2.3-4s √† 60fps)
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du c≈ìur qui grossit et monte au ciel
                        // En mode lanterne : afficher seulement 1 texte sur 4 pour √©viter la surcharge
                        if (phaseJeu !== 'lanterne' || Math.random() < 0.25) {
                            ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                        }

                        // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // D√©sactiv√© : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de cr√©er un power-up bleu
                        // Phase 22 : taux r√©duit √† 5% pour ne pas masquer le rainbow_hope
                        const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                        const tauxPowerupBalle = (phaseActuelle === 22 && phaseJeu === 'mur') ? 0.05 : 0.3;
                        if(Math.random() < tauxPowerupBalle) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    // V√©rifier la condition de fin selon le mode de jeu
                    if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                        // Mode briques : v√©rifier si toutes les briques sont d√©truites
                        const briquesRestantes = briques.filter(b => b.visible).length;console.log(`üîç V√©rif briques restantes (balle): ${briquesRestantes}, phase: ${phaseJeu}`);
                        if(briquesRestantes === 0) {
                            // üåà EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collect√© !
                            if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                // V√©rifier si le power-up existe et n'est PAS collect√©
                                const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                if (espoirPresent) {
                                    console.log('üåà Phase 22 : Mur d√©truit mais power-up ESPOIR pas encore collect√© (collision balle) !');
                                    console.log('   ‚Üí La phase ne se termine pas automatiquement.');
                                    // Ne rien faire - attendre la collecte du power-up
                                    return; // ‚Üê Sortir sans transition ET sans animation
                                }
                            }

                            console.log('üéØ Toutes les briques d√©truites (balle)! Transition vers phase suivante...');

                            // Auto-r√©cup√©rer les powerups restants
                            if(powerUps && powerUps.length > 0) {console.log(`üéÅ Auto-r√©cup√©ration de ${powerUps.length} powerups restants (balle)`);
                                powerUps.forEach(powerup => {
                                    switch(powerup.type) {
                                        case 'etoile_montante': score += 1000; break;
                                        case 'bonus_points': score += 500; break;
                                        case 'allume_lanterne': lanterne.active = true; lanterne.intensite = 1.0; break;
                                    }
                                    if(window.ajouterParticules) {
                                        ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                    }
                                });
                                powerUps = [];
                            }

                            if(!modeEtoileLance) {
                                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    narrationManager.goToNextPhaseDirect();
                                });

                                // La fin sera g√©r√©e par finalizeNarration() automatiquement
                            } else if(modeEtoileLance) {
                                // Mode √©toile infini : relancer le m√™me niveau stars
                                jeu = false;
                                relancerModeEtoileInfini();
                            } else {
                                veriteLiberee();
                            }
                        }
                    } else if(brises >= VOYAGE.length) {
                        if(!modeEtoileLance) {
                            // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante apr√®s animation
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                            });

                            // La fin sera g√©r√©e par finalizeNarration() automatiquement
                        } else if(modeEtoileLance) {
                            // Mode √©toile infini : relancer le m√™me niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // √âv√©nements
        function perdreVie() {
            vies--;
            
            // En phase mur, perdre 1000 points quand la balle est perdue
            if(phaseJeu === 'mur') {
                window.score = Math.max(0, (window.score || 0) - 1000);
                afficherMessagePowerupSimple(getTranslatedText('game.messages.wall_resists_minus_1000', 'üß± Le mur r√©siste ! -1000 points'));
            }
            
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position √† l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                // En phase lanterne/mur, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                // Message d√©j√† affich√© plus haut pour phase mur (avec -1000 points)
                if(phaseJeu === 'lanterne') {
                    afficherMessagePowerupSimple(getTranslatedText('system.keep_searching_truth', 'üíî Continue √† chercher la v√©rit√© !'));
                }
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                balle.dy = -C.SP * multiplicateurPuissance;
                afficherMessagePowerupSimple(getTranslatedText('system.keep_searching_truth', 'üíî Continue √† chercher la v√©rit√© !'));
            }
        }

        function finDuVoyage() {
            jeu = false;
            afficherMessage(`
                <div style="font-weight: bold; font-size: 17px; text-align: center;">
                    ${getTranslatedText('game.journey_continues', 'üò¢ Le voyage vers la v√©rit√© continue...')}<br><br>
                    "${getTranslatedText('game.truth_triumphs', 'La v√©rit√© finit toujours par triompher !')}"<br><br>
                    <button onclick="recommencerJeuGameOver()" 
                            style="background: linear-gradient(45deg, #4169E1, #1E90FF); 
                                   color: white; border: none; padding: 15px 30px; 
                                   border-radius: 25px; font-size: 18px; font-weight: bold; 
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(65,105,225,0.4);
                                   transition: all 0.3s ease;
                                   margin: 10px;"
                            onmouseover="this.style.transform='scale(1.05)'"
                            onmouseout="this.style.transform='scale(1)'">
                        ${getTranslatedText('ui.restart_journey')}
                    </button>
                </div>
            `, 0);
        }

        function recommencerJeuGameOver() {
            cacherMessage();
            
            // Red√©marrage √† la phase actuelle (pas depuis le d√©but)
            // R√©initialiser les variables de jeu mais garder la progression
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false;

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Red√©marrer la phase courante (pas depuis le d√©but)
            setTimeout(() => {
                if (narrationManager) {
                    narrationManager.restart(); // restart() = phase courante, pas start() = d√©but
                }
            }, 1000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // D√©lai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(periode === 'jour') {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    // Message g√©r√© par le nouveau syst√®me narratif
                } else {
                    // Fin du chapitre 2 : d√©clencher la s√©quence finale des feux d'artifice
                    // Phase finale : s√©quence compl√®te avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARR√äT DU SYST√àME NARRATIF pour √©viter les interf√©rences
                    phaseIntro.active = false;
                    // Introduction termin√©e

                    // √âTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = Date.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // √âTAPE 2 : Feux d'artifice 5s
                        animationBateau.active = false;

                        // Cr√©er des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // √âTAPE 3 : Lever de soleil + fin normale via finalizeNarration
                            leverSoleilFinal();
                            setTimeout(() => {
                                narrationManager.finalizeNarration();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de d√©lai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le d√©but pour √©viter les probl√®mes
            chapitre = 1;
            VOYAGE = JOUR;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            // Bloquer les changements de phase si le mode secret est actif
            if (secretModeModule && secretModeModule.isActive) {
                return;
            }
            if (modeSecret) {console.log('üö´ Mode secret actif (fallback), recommencer bloqu√©');
                return;
            }

            // V√©rifier la condition de fin selon le mode de jeu
            if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                // Mode briques : v√©rifier si toutes les briques sont d√©truites
                const briquesRestantes = briques.filter(b => b.visible).length;
                if(briquesRestantes === 0) {
                    // ÔøΩ EXCEPTION PHASE 22 : Ne pas terminer automatiquement !
                    // Le joueur doit collecter le power-up Espoir cach√© avant de continuer
                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                    if (phaseActuelle === 22 && phaseJeu === 'mur') {
                        // V√©rifier si le power-up existe et n'est PAS collect√©
                        const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                        if (espoirPresent) {
                            // ‚ùå NE RIEN FAIRE - attendre la collecte du power-up
                            // Ne pas logger √† chaque frame pour √©viter de spammer la console
                            return; // ‚Üê SORTIR COMPL√àTEMENT sans transition
                        } else {
                            // Espoir d√©j√† collect√©, on peut passer √† la suite
                            animerExplosionIconeCollector(() => {
                                console.log('üéÜ Animation briques termin√©e - Phase 22 avec ESPOIR collect√©');
                                narrationManager.goToNextPhaseDirect();
                            });
                        }
                    } else {
                        // Autres phases : transition normale
                        animerExplosionIconeCollector(() => {
                            console.log('üéÜ Animation briques termin√©e (lanterne/stars/mur), passage √† la phase suivante');
                            narrationManager.goToNextPhaseDirect();
                        });
                    }
                }
            } else if(brises >= VOYAGE.length) {
                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante apr√®s animation
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                    }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                });
            }

            // Forcer l'affichage des briques
            briques.forEach(brique => {
                brique.visible = true;
            });

            // Forcer la visibilit√© de la balle et activer le jeu
            if(balle) {
                balle.visible = true;
            }
            jeu = true;

            cacherMessage();
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            // Mode passe phase d√©sactiv√©
            return;
            if(periode === 'jour') {
                periode = 'nuit';
                VOYAGE = NUIT;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Cr√©er les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilit√© de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
            } else {
                periode = 'jour';
                VOYAGE = JOUR;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recr√©er les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits c≈ìurs visibles et d√©sactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
            }
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessagePowerupSimple(getTranslatedText('system.no_bricks_found', '‚ùå Aucune brique trouv√©e'));
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessagePowerupSimple(getTranslatedText('system.fast_mode_activated', `‚ö° Mode rapide activ√© - ${briquesModifiees} briques`));
            } else {
                afficherMessagePowerupSimple(getTranslatedText('system.all_bricks_one_life', '‚ÑπÔ∏è Toutes les briques d√©j√† √† 1 vie'));
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // D√©sactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessagePowerupSimple(getTranslatedText('system.star_shooting_disabled', '‚≠ê Tir √©toiles d√©sactiv√©'));
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessagePowerupSimple(getTranslatedText('system.auto_star_shooting_enabled', 'üåü Tir √©toiles automatique activ√©'));

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si n√©cessaire
                        if(!jeu) jeu = true;

                        // Viser une brique al√©atoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Lib√©rer les c≈ìurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise √† jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode √©toile test

            // Configuration pour mode √©toile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = NUIT;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode √©toile depuis le menu

            // Forcer l'arr√™t des syst√®mes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'√©toiles automatique en mode √©toile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les √©l√©ments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Cr√©er les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessagePowerupSimple(getTranslatedText('system.infinite_star_mode', 'üåü Mode √©toile infini activ√©'));
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones √† chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centr√©e
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion apr√®s 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // D√©lai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le m√™me niveau stars infini
                phaseJeu = 'stars';
                periode = 'nuit';
                VOYAGE = NUIT;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessagePowerupSimple(getTranslatedText('system.level_completed_new_stars', 'üåü Niveau termin√© - Nouveau niveau stars'));

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'√©toiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // D√©lai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // S√©quence finale : 3 formations al√©atoires avec explosions

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations al√©atoires diff√©rentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // S√©quence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position al√©atoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);console.log(`Formation ${index + 1}: ${formation} √† (${x}, ${y})`);

                        // Explosion apr√®s formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu apr√®s la s√©quence compl√®te (3 √ó 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arr√™ter le tir automatique √† la fin du mode √©toile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard correct
            narrationManager.showFinalMenu();
        }


        function afficherMenuFinal() {
            // Fermer le formulaire s'il est ouvert
            const formulaire = document.getElementById('formulaire-fin-overlay');
            if (formulaire) {
                formulaire.remove();
            }

            // ‚úÖ Ouvrir automatiquement le menu Info/√ânigmes sur l'onglet INFO
            ouvrirMenuEnigmesCanvas();
            menuEnigmesCanvas.ongletActif = 'info'; // Activer l'onglet Info
            menuEnigmesCanvas.scrollY = 0; // Reset scroll
            menuEnigmesCanvas.projectButtons = null; // üî• FORCE le rafra√Æchissement pour Firefox

            // ‚ùå NE PAS red√©marrer automatiquement - laisser le joueur sur la phase 23 finale
            // Le bouton [Recommencer] dans le message final fera le restart si le joueur le souhaite
        }

        // Lancer la phase bonus
        // Donn√©es du livre blanc moderne
        const livreBonus = {
            currentPage: 0,
            animation: 0,
            pages: [
                {
                    title: "Partie 1 - Le Mur",
                    text: `Au loin‚Ä¶ je vois un mur.
Un mur dress√© dans la mer comme une cicatrice.
Un mur qui n'est pas fait de pierres,
mais de lois, de papiers et de regards ferm√©s.`
                },
                {
                    title: "Partie 2 - La Prison",
                    text: `Ce mur est la prison de la libert√© des hommes.
Il s√©pare ceux qui peuvent courir sans cha√Ænes,
et ceux qu'on enferme dans des fronti√®res invisibles.`
                },
                {
                    title: "Partie 3 - Les Pauvres",
                    text: `Pour les pauvres, il est barbel√© de refus,
ferm√© comme une porte rouill√©e.
Ils y frappent de leurs mains nues,
leurs r√™ves bris√©s par le silence des gardiens.`
                },
                {
                    title: "Partie 4 - Les Riches",
                    text: `Pour les riches, il est une porte d'or.
Elle s'ouvre sans effort,
et les laisse circuler comme le vent qui n'a pas de patrie.`
                },
                {
                    title: "Partie 5 - La Question",
                    text: `Alors je me demande‚Ä¶
La libert√© est-elle vraiment un droit,
ou est-elle devenue un privil√®ge vendu aux plus offrants ?`
                },
                {
                    title: "Partie 6 - L'Espoir",
                    text: `Mais dans le c≈ìur des vagues,
la mer murmure une v√©rit√© :
aucun mur n'est √©ternel.

Ces murs sont les n√¥tres,
on les cr√©e par nos peurs et nos divisions.
Mais l'humanit√© n'a pas besoin de murs.
Elle a besoin de ponts.`
                }
            ]
        };

        function dessinerLivreBonus() {
            livreBonus.animation += 0.02;

            // Fond blanc moderne avec subtil gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, C.H);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#f8f9fa');
            gradient.addColorStop(1, '#ffffff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, C.W, C.H);

            // Dimensions de la page
            const pageWidth = C.W * 0.88;
            const pageHeight = C.H * 0.80;
            const pageX = (C.W - pageWidth) / 2;
            const pageY = (C.H - pageHeight) / 2;

            // Ombre subtile de la page
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 25;
            ctx.shadowOffsetY = 10;

            // Page unique blanche avec coins arrondis
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(pageX + 8, pageY);
            ctx.lineTo(pageX + pageWidth - 8, pageY);
            ctx.quadraticCurveTo(pageX + pageWidth, pageY, pageX + pageWidth, pageY + 8);
            ctx.lineTo(pageX + pageWidth, pageY + pageHeight - 8);
            ctx.quadraticCurveTo(pageX + pageWidth, pageY + pageHeight, pageX + pageWidth - 8, pageY + pageHeight);
            ctx.lineTo(pageX + 8, pageY + pageHeight);
            ctx.quadraticCurveTo(pageX, pageY + pageHeight, pageX, pageY + pageHeight - 8);
            ctx.lineTo(pageX, pageY + 8);
            ctx.quadraticCurveTo(pageX, pageY, pageX + 8, pageY);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;

            // Bordure subtile grise
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Page actuelle
            const page = livreBonus.pages[livreBonus.currentPage];

            // Titre
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 22px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(page.title, C.W / 2, pageY + 50);

            // Ligne d√©corative sous le titre
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(C.W / 2 - 80, pageY + 65);
            ctx.lineTo(C.W / 2 + 80, pageY + 65);
            ctx.stroke();

            // Num√©ro de page
            ctx.fillStyle = '#95a5a6';
            ctx.font = 'italic 13px Georgia';
            ctx.fillText(`Page ${livreBonus.currentPage + 1} / ${livreBonus.pages.length}`, C.W / 2, pageY + 90);

            // Texte centr√© sur la page
            ctx.fillStyle = '#34495e';
            ctx.font = '16px Georgia';
            ctx.textAlign = 'center';
            
            const lines = page.text.split('\n');
            const lineHeight = 28;
            const startY = pageY + 130;

            lines.forEach((line, i) => {
                ctx.fillText(line, C.W / 2, startY + i * lineHeight);
            });

            // Boutons de navigation modernes
            const buttonY = pageY + pageHeight + 30;

            // Bouton Pr√©c√©dent
            if (livreBonus.currentPage > 0) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚óÑ', C.W / 2 - 90, buttonY);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '15px Georgia';
                ctx.fillText('Pr√©c√©dent', C.W / 2 - 90, buttonY + 22);
            }

            // Bouton Suivant
            if (livreBonus.currentPage < livreBonus.pages.length - 1) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ñ∫', C.W / 2 + 90, buttonY);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '15px Georgia';
                ctx.fillText('Suivant', C.W / 2 + 90, buttonY + 22);
            }

            // Bouton Fermer
            ctx.fillStyle = '#95a5a6';
            ctx.font = '15px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('‚úï Fermer', C.W / 2, buttonY + 8);
        }

        function lancerPhaseBonus() {
            // Donner le bonus XP
            giveXPBonus(200);
            
            // Passer en mode livre bonus
            jeu = false;
            phaseJeu = 'bonus_livre';
            livreBonus.currentPage = 0;
        }

        function demarrerPhaseBonus() {
            lancerPhaseBonus();
        }

        // Fonction d√©di√©e pour donner XP bonus (simple avec score)
        function giveXPBonus(amount) {
            try {

                // Ajouter au score directement
                score += amount;

                // Message simple
                afficherMessagePowerupSimple(getTranslatedText('system.bonus_points_endgame', `üåü +${amount} Points bonus fin de jeu`));

                return true;
            } catch (error) {
                console.error('‚ùå Erreur attribution bonus score:', error);
                return false;
            }
        }

        function afficherCreditsFinaux() {
            const msg = document.getElementById('message');
            msg.innerHTML = `
                <div style="text-align: center; background: linear-gradient(135deg, #8B4513, #A0522D); padding: 25px; border-radius: 15px; margin: 20px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 20px; color: #ffffff;">üìú Menu Artistique Emmanuel üìú</h2>
                    <p style="color: #ffd700; margin-bottom: 20px;"><strong>‚ú® Signature Artistique :</strong> Dreamer Unisona</p>

                    <!-- Section Cr√©dits avec style am√©lior√© -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FFD700; text-align: center; margin-bottom: 15px;">üé® Cr√©ation Artistique</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>üéÆ Cr√©ation & D√©veloppement :</strong> Emmanuel Payet</p>
                            <p><strong>üé® Design & Concept :</strong> Emmanuel Payet</p>
                            <p><strong>‚úçÔ∏è Narration & Po√©sie :</strong> Emmanuel Payet</p>
                            <p><strong>üéµ Vision Artistique :</strong> Emmanuel Payet</p>
                        </div>
                    </div>

                    <!-- Section Projet avec ic√¥nes -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #87CEEB; text-align: center; margin-bottom: 15px;">üåü Fable Interactive</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>üíù Projet :</strong> "PETIT BATEAU"</p>
                            <p><strong>üåü Message :</strong> Une fable interactive sur les pr√©jug√©s</p>
                            <p><strong>üìÖ Ann√©e :</strong> 2025</p>
                            <p><strong>üè∑Ô∏è Copyright :</strong> ¬© Emmanuel Payet - Tous droits r√©serv√©s</p>
                        </div>
                    </div>

                    <!-- Section Syst√®mes de Jeu -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FF6B35; text-align: center; margin-bottom: 15px;">üìä Syst√®mes Impl√©ment√©s</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>‚≠ê XP :</strong> Points de Connaissance (phase d'apprentissage)</p>
                            <p><strong>üïäÔ∏è Score d'Ange :</strong> Performance de jeu principal</p>
                            <p><strong>‚ù§Ô∏è Vies :</strong> Syst√®me de survie (3 maximum)</p>
                            <p><strong>üß± Briques :</strong> Progression par niveau</p>
                            <p><strong>üìú √ânigmes :</strong> 10 r√©v√©lations po√©tiques d√©bloquables</p>
                            <p><strong>üéÆ Mode Secret :</strong> Mini-jeu kawaii cach√©</p>
                        </div>
                    </div>

                    <!-- Section √ânigmes Collectables -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #8A2BE2; text-align: center; margin-bottom: 15px;">üìú Collection d'√ânigmes</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>üíñ Phase C≈ìurs :</strong> Humanit√©, Diversit√©, Respect, Restauration</p>
                            <p><strong>üß± Phase Briques :</strong> Paix, Foi, Gu√©rison</p>
                            <p><strong>üåôüíñ Phase Nuit C≈ìurs :</strong> Libert√©, Entraide</p>
                            <p><strong>üèÆ Phase Lanterne :</strong> Ange Gardien (sp√©ciale)</p>
                        </div>
                    </div>

                    <!-- Citation Po√©tique am√©lior√©e -->
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1)); border: 3px solid #FFD700; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: center;">
                        <p style="font-style: italic; color: #ffd700; font-size: 1.1rem; line-height: 1.5;">
                            "Aucun mur n'est √©ternel.<br>
                            Car l'eau finit toujours par user la pierre,<br>
                            et la libert√© reprendra son chemin."
                        </p>
                        <p style="font-style: italic; color: #87CEEB; margin-top: 15px; font-size: 1rem;">
                            ‚Äî Dreamer Unisona
                        </p>
                        <hr style="margin: 15px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p style="font-style: italic; color: #ffffff; font-size: 0.9rem;">
                            "Dans chaque √©nigme se cache une v√©rit√©,<br>
                            dans chaque v√©rit√© se r√©v√®le notre humanit√©."
                        </p>
                    </div>

                    <!-- Boutons de navigation am√©lior√©s -->
                    <div style="margin-top: 25px;">
                        <button onclick="const lang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr'; window.open('emmanuel-artist-module.html?lang=' + lang, '_blank')"
                                style="background: linear-gradient(145deg, #4169E1, #1E90FF); border: none; border-radius: 25px; padding: 12px 25px; margin: 8px; color: white; font-size: 14px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            üìú Voir Collection Compl√®te
                        </button>
                        <br>
                        <button onclick="narrationManager.showFinalMenu()"
                                style="background: linear-gradient(145deg, #2E8B57, #3CB371); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            ‚Üê Retour au Menu Principal
                        </button>
                    </div>
                </div>
            `;
        }

        function recommencerJeu() {
            // R√©initialiser compl√®tement le jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;

            // Les objets kawaii sont r√©serv√©s au mode secret seulement
            // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret
            vies = 3;
            brises = 0;
            jeu = false; // Commencer avec jeu d√©sactiv√© pour l'intro

            // R√©initialiser les syst√®mes
            animationBateau.active = false;
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
            narrationManager.reset();

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Cacher le message
            cacherMessage();

            // D√©marrer la narration compl√®te P1 √† P16
            setTimeout(() => {
                narrationManager.start();
            }, 1000);
        }

        // üîÑ Recommencer directement √† la phase 2 (sauter la phase 1)
        function recommencerDepuisPhase2() {
            // R√©initialiser compl√®tement le jeu comme recommencerJeu()
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'briques'; // Phase 2 = mode briques
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false;

            // R√©initialiser les syst√®mes
            animationBateau.active = false;
            phaseIntro = { active: false, etape: 'complete', tempsDebut: 0 }; // Pas d'intro
            narrationManager.reset();

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerBriques(); // Cr√©er les briques pour la phase 2

            // Cacher le message
            cacherMessage();

            // ‚úÖ D√©marrer directement √† la phase 2
            setTimeout(() => {
                narrationManager.currentPhase = 2; // Positionner sur phase 2
                narrationManager.executeCurrentPhase(true); // Ex√©cuter avec texte narratif
            }, 500);
        }

        // üé≠ MESSAGES AVEC ANIMATIONS TYPEWRITER - Pour mode secret et effets sp√©ciaux
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Callback pour g√©rer la fin de l'animation et le timing de disparition
            const onComplete = () => {
                // Attendre un peu apr√®s la fin de l'animation avant de faire dispara√Ætre
                setTimeout(() => {
                    cacherMessage();
                }, Math.max(1000, duree * 0.2)); // Au moins 1s d'attente apr√®s l'animation
            };

            // Cr√©er une nouvelle instance TextAnimator avec le nouveau code optimis√©
            const anim = new TextAnimator('message');

            switch(animation) {
                case 'typewriter':
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'digital':
                    anim.digital(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fade':
                    anim.fade(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'glitch':
                    anim.glitch(texteComplet, {
                        duration: Math.max(2000, duree * 0.3),
                        onComplete: onComplete
                    });
                    break;
                case 'emboss':
                    anim.setColors('#ffffff', '#666666');
                    anim.applyEffect('emboss');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'neon':
                    anim.setColors('#64ffda', '#64ffda');
                    anim.applyEffect('neon');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'shadow3d':
                    anim.setColors('#ffffff', '#333333');
                    anim.applyEffect('shadow3d');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fire':
                    anim.setColors('#ff4444', '#ff8800');
                    anim.applyEffect('fire');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'ice':
                    anim.setColors('#ffffff', '#ffffff');
                    anim.applyEffect('none');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'outline':
                    anim.setColors('#ffffff', '#000000');
                    anim.applyEffect('outline');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                default:
                    msg.innerHTML = texteComplet.replace(/\n/g, '<br>');
                    onComplete();
            }
        }

        // üìù FONCTION PRINCIPALE D'AFFICHAGE - Messages standard blancs centr√©s
        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    msg.style.display = 'none'; // Remettre display none apr√®s la dur√©e
                }, duree);
            }
        }

        // Fonction pour afficher les messages narratifs de phase (style cin√©matique)
        function afficherMessageNarratifPhase(texte, duree) {
            const msg = document.getElementById('message');

            // AJOUTER la classe narratif pour le style cin√©matique
            msg.classList.add('narratif');

            msg.innerHTML = texte;
            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    msg.classList.remove('narratif'); // Retirer la classe apr√®s
                    msg.style.display = 'none';
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Cr√©er le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        ${getTranslatedText('ui.replay_button')}
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ‚û°Ô∏è Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }


        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifi√© et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;

            // Couleur de la mer selon le chapitre
            const merGrad = ctx.createLinearGradient(0, merY, 0, C.H);
            if(periode === 'jour') {
                // Mer bleue paisible
                merGrad.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
                merGrad.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
                merGrad.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            } else {
                // Mer sombre et mena√ßante
                merGrad.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
                merGrad.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
                merGrad.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
            }
            ctx.fillStyle = merGrad;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // Vagues selon le chapitre
            if(periode === 'jour') {
                // Vagues paisibles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                // Vagues agit√©es
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = periode === 'jour' ? (8 - ligne * 2) : (12 - ligne * 3);
                const fr√©quence = 0.01 + ligne * 0.005;
                const vitesse = periode === 'jour' ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                for(let x = 0; x <= C.W; x += 10) {
                    const vague = Math.sin(x * fr√©quence + offset) * amplitude;
                    if(x === 0) ctx.moveTo(x, y + vague);
                    else ctx.lineTo(x, y + vague);
                }
                ctx.stroke();
            }

            // Ailerons de requin dans le chapitre 2 (d√©sactiv√©s en phase finale)
            if(periode === 'nuit' && !leverSoleil.active && phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                const requins = [
                    { x: 0.2, vitesse: 0.3, taille: 1.0 },
                    { x: 0.6, vitesse: 0.5, taille: 0.8 },
                    { x: 0.9, vitesse: 0.4, taille: 1.2 }
                ];

                requins.forEach(requin => {
                    const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                    const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                    const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;

                    // Aileron de requin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8); // Base gauche
                    ctx.lineTo(reqX, reqY - taille); // Pointe
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5); // Base droite
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8); // Retour base
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Sillage du requin
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // D√©clarer les variables pour √©viter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(periode === 'jour') {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% √† 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui √©volue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // Rayons du soleil (plus nombreux pendant le lever)
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3;
                const nbRayons = leverSoleil.active ? 16 : 8;
                for(let i = 0; i < nbRayons; i++) {
                    const rotationSoleil = Date.now() * 0.0005; // Rotation lente
                    const angle = (i / nbRayons) * Math.PI * 2 + rotationSoleil;
                    const longueurRayon = leverSoleil.active ? 25 : 15;
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            } else {
                // CHAPITRE 2: Lune inqui√©tante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(periode === 'jour') {
                // V√©rifier si le soleil fait un clin d'≈ìil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'≈ìil pendant 2 secondes

                // Arr√™ter le clignotement apr√®s 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant √† la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et ferm√©s (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux ferm√©s paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et mod√©r√©
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence √† sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'≈ìil ! ≈íil gauche ferm√©, ≈ìil droit ouvert
                        // ≈íil gauche ferm√© (clin d'≈ìil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // ≈íil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'≈ìil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au d√©but
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inqui√©tante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre (d√©sactiv√©s en phase finale et feux d'artifice)
            if(phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                if(periode === 'jour') {
                    // Nuages blancs paisibles
                    const nuages = [
                        { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                        { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                        { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                    ];

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                    ctx.lineWidth = 2;

                    nuages.forEach(nuage => {
                        const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                        const nuageY = C.H * nuage.y;
                        const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                        for(let i = 0; i < 3; i++) {
                            const offsetX = (i - 1) * taille * 0.8;
                            const rayonNuage = taille * (0.8 + i * 0.1);
                            ctx.beginPath();
                            ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                } else {
                    // Nuages d'orage gris avec √©clairs
                    const nuagesOrage = [
                        { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                        { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                        { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                    ];

                    nuagesOrage.forEach(nuage => {
                        const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                        const nuageY = C.H * nuage.y;
                        const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                        // Nuages gris mena√ßants
                        ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                        ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                        ctx.lineWidth = 2;

                        for(let i = 0; i < 4; i++) {
                            const offsetX = (i - 1.5) * taille * 0.6;
                            const rayonNuage = taille * (0.7 + i * 0.1);
                            ctx.beginPath();
                            ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }

                        // √âclairs occasionnels
                        if(Math.random() < 0.02) {
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(nuageX, nuageY + taille);
                            ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                            ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                            ctx.stroke();
                        }
                    });
                }
            }
        }

        // Rendu principal
        function dessiner() {

            // Fond d√©grad√© selon le chapitre
            // Protection contre les valeurs non finies
            if (!isFinite(C.H) || C.H <= 0) {
                console.error('Erreur: C.H non valide:', C.H);
                return;
            }

            const grad = ctx.createLinearGradient(0, 0, 0, C.H);
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                // D√©grad√© cr√©pusculaire pour phase finale (coucher de soleil)
                grad.addColorStop(0, '#FFB347'); // Orange doux en haut
                grad.addColorStop(0.3, '#FF8C69'); // Orange saumon
                grad.addColorStop(0.6, '#FF6B9D'); // Rose-corail
                grad.addColorStop(1, '#4A90E2'); // Bleu ciel en bas
            } else if(periode === 'jour') {
                // Ciel diurne
                grad.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
                grad.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
                grad.addColorStop(1, 'rgba(240,248,255,0.98)');
            } else {
                // Ciel nocturne orageux
                grad.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
                grad.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
                grad.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, C.H);

            // Phase finale : soleil couchant derri√®re la mer
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                // Position du soleil (√† moiti√© immerg√© dans la mer)
                const soleilX = C.W * 0.75; // √Ä 75% de la largeur (vers la droite)
                const merY = C.H - 60;
                const soleilY = merY + 10; // Partiellement sous l'horizon
                const rayonSoleil = 60;

                // Halo lumineux du soleil (le plus en arri√®re)
                const gradHalo = ctx.createRadialGradient(soleilX, soleilY, 0, soleilX, soleilY, rayonSoleil * 3);
                gradHalo.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
                gradHalo.addColorStop(0.3, 'rgba(255, 150, 80, 0.2)');
                gradHalo.addColorStop(0.7, 'rgba(255, 100, 50, 0.1)');
                gradHalo.addColorStop(1, 'rgba(255, 100, 50, 0)');
                ctx.fillStyle = gradHalo;
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, rayonSoleil * 3, 0, Math.PI * 2);
                ctx.fill();

                // Soleil lui-m√™me (derri√®re)
                const gradSoleil = ctx.createRadialGradient(soleilX, soleilY, 0, soleilX, soleilY, rayonSoleil);
                gradSoleil.addColorStop(0, '#FFFACD'); // Centre jaune p√¢le
                gradSoleil.addColorStop(0.4, '#FFD700'); // Jaune dor√©
                gradSoleil.addColorStop(0.8, '#FF8C00'); // Orange
                gradSoleil.addColorStop(1, '#FF6347'); // Rouge tomate au bord
                ctx.fillStyle = gradSoleil;
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, rayonSoleil, 0, Math.PI * 2);
                ctx.fill();

                // Reflet du soleil sur l'eau
                const refletGrad = ctx.createLinearGradient(soleilX, merY, soleilX, C.H);
                refletGrad.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
                refletGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
                refletGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = refletGrad;
                ctx.fillRect(soleilX - 40, merY, 80, C.H - merY);

                // Dessiner la mer par-dessus (pour masquer la partie basse du soleil)
                dessinerMer();

                // Quelques nuages l√©gers
                const temps = Date.now() * 0.0002;
                for(let i = 0; i < 3; i++) {
                    const nuageX = (C.W * (0.1 + i * 0.3) + temps * 15 * (i + 1)) % (C.W + 200) - 100;
                    const nuageY = C.H * 0.2 + i * 50;
                    const nuageW = 100 + i * 30;
                    const nuageH = 30;

                    ctx.fillStyle = `rgba(255, 180, 180, ${0.25 - i * 0.05})`;
                    ctx.beginPath();
                    ctx.ellipse(nuageX, nuageY, nuageW, nuageH, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                dessinerCiel();
                dessinerMer();
            }

            // Effet d'√©clairs en mode nuit
            if (periode === 'nuit') {
                dessinerEclairNuit();
            }

            dessinerInterface();
            dessinerPowerUps();    // ‚Üê Power-ups d'abord (cach√©s derri√®re)
            dessinerPrejuges();    // ‚Üê Briques par-dessus (cachent les power-ups)
            dessinerCoeursBateau();
            
            // D√©sactiver petits c≈ìurs d√©coratifs pour phases 17-23 (syst√®me de projectiles progressifs)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (!(phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur')) {
                dessinerPetitsCoeurs();
            }
            
            dessinerBateau();
            dessinerEcume(); // √âcume en avant-plan du bateau
            afficherMunitions();
            dessinerStarsProjectiles(); // √âtoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // √âtoiles (phase briques)
            // Mode secret - d√©sactiv√© en phase finale
            if (phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                if (secretModeModule && secretModeModule.isActive) {
                    secretModeModule.render();
                } else if (modeSecret) {
                    // Fallback si le module n'est pas disponible
                    dessinerProjectilesSecret();
                }
            }
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret
            dessinerChauveSouris(); // Chauve-souris r√©v√©l√©e
            // Animation d'ic√¥ne supprim√©e - les ic√¥nes en haut servent de menu direct
            // Les ic√¥nes en haut servent maintenant de menu direct

            // Obstacles g√©r√©s par le module secret seulement

            // Objets kawaii r√©serv√©s au mode secret uniquement
            // (Les objets kawaii sont maintenant dans le module secret)

            dessinerParticules();
            dessinerPluie(); // Dessiner la pluie (phase 5)

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
            dessinerEtoileCompteur(); // √âtoile avec compteur de clics corbeau
            dessinerMessagePowerupSimple(); // Messages simples des powerups en haut
            dessinerMessageNarratifSimple(); // Messages narratifs centr√©s
            dessinerBoutonPasser(); // Bouton passer simple en haut

            // Menu √©nigmes
            dessinerMenuEnigmesCanvas();

            // Bouton plein √©cran
            dessinerBoutonPleinEcran();

            // üåç Ancien ic√¥ne de langue d√©sactiv√© - remplac√© par l'onglet langues int√©gr√©
            // Le s√©lecteur de langue est maintenant dans le menu √©nigmes (onglet Langues)
            if (false && languageSelector.languageChosen) {
                const langIconX = C.W - 35;
                const langIconY = 70;
                const langIconRadius = 18;

                ctx.save();
                // Cercle de fond blanc arrondi
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(langIconX, langIconY, langIconRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Drapeau de la langue actuelle
                const currentLangBtn = languageSelector.buttons.find(b => b.code === currentLang);
                const drapeau = currentLangBtn ? currentLangBtn.drapeau : 'üá´üá∑';
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(drapeau, langIconX, langIconY);
                ctx.restore();

                // Stocker pour d√©tection de clic
                languageSelector.iconButton.x = langIconX;
                languageSelector.iconButton.y = langIconY;
                languageSelector.iconButton.radius = langIconRadius;

                // Menu d√©roulant (si ouvert)
                if (languageSelector.menuOpen) {
                    const menuWidth = 150;
                    const menuItemHeight = 40;
                    const menuHeight = languageSelector.buttons.length * menuItemHeight;
                    const menuX = langIconX - menuWidth - 10;
                    const menuY = langIconY - menuHeight / 2;

                    // Fond du menu
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.roundRect(menuX, menuY, menuWidth, menuHeight, 8);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Liste des langues
                    languageSelector.buttons.forEach((btn, index) => {
                        const itemY = menuY + (index * menuItemHeight);
                        const isActive = btn.code === currentLang;

                        // Stocker position pour clic
                        btn.menuX = menuX;
                        btn.menuY = itemY;
                        btn.menuWidth = menuWidth;
                        btn.menuHeight = menuItemHeight;

                        // Fond de l'item (si actif)
                        if (isActive) {
                            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                            ctx.fillRect(menuX, itemY, menuWidth, menuItemHeight);
                        }

                        // Drapeau
                        ctx.save();
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(btn.drapeau, menuX + 15, itemY + menuItemHeight / 2);

                        // Nom
                        ctx.font = 'bold 14px "Segoe UI", Arial, sans-serif';
                        ctx.fillStyle = isActive ? '#3b82f6' : '#1e293b';
                        ctx.fillText(btn.nom, menuX + 50, itemY + menuItemHeight / 2);
                        ctx.restore();
                    });
                }
            }

            // Bouton continuer EN DERNIER pour √™tre au premier plan (Phase 16)
            dessinerBoutonContinuer();

            // Bouton Suivant simple pour phase 16
            dessinerBoutonSuivantP16();

            // üîä Menu audio en haut √† droite : +- pour passer les chansons
            const menuX = C.W - 50; // 50px du bord droit
            const menuY = 8;

            ctx.save();
            ctx.font = '16px Arial';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 2;

            // Chanson pr√©c√©dente ‚àí
            const prevBtn = { x: menuX, y: menuY, w: 16, h: 20 };
            window.prevSongZone = prevBtn;
            ctx.fillText('‚àí', prevBtn.x + prevBtn.w/2, prevBtn.y);

            // Chanson suivante +
            const nextBtn = { x: menuX + 20, y: menuY, w: 16, h: 20 };
            window.nextSongZone = nextBtn;
            ctx.fillText('+', nextBtn.x + nextBtn.w/2, nextBtn.y);

            ctx.restore();

            // Rendu des drones feux d'artifice EN DERNIER pour √™tre visible
            if (droneModule) {
                try {
                    droneModule.render();
                } catch (error) {
                    console.error('‚ùå Erreur rendu drones:', error);
                }
            }

            // Menu de langue en jeu (d√©sactiv√© - ce code n'est plus utilis√©)
            // Le s√©lecteur de langue s'affiche uniquement au premier d√©marrage (voir plus bas)
            /*
            if (languageSelector.active) {
                const elapsed = Date.now() - languageSelector.debut;

                // Si langue pas choisie, ouvrir automatiquement le menu
                if (!languageSelector.languageChosen && !languageSelector.menuOpen) {
                    languageSelector.menuOpen = true;
                }

                if (elapsed > languageSelector.duree && languageSelector.languageChosen) {
                    languageSelector.active = false;
                } else {
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Position du bouton principal (centr√© en haut)
                    languageSelector.mainButton.x = (C.W - languageSelector.mainButton.width) / 2;
                    // Y reste √† 20 (d√©fini dans la variable)

                    // Bouton principal üåç
                    const mainBtn = languageSelector.mainButton;
                    const isHovered = mainBtn.hover;

                    // Fond du bouton (ROND)
                    ctx.fillStyle = isHovered ? '#ffffff' : 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = isHovered ? '#3b82f6' : '#cbd5e1';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height / 2, mainBtn.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Drapeau de la langue actuelle
                    const currentLangBtn = languageSelector.buttons.find(b => b.code === currentLang);
                    const drapeau = currentLangBtn ? currentLangBtn.drapeau : 'üá´üá∑';
                    ctx.font = '32px Arial';
                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(drapeau, mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height / 2);

                    // Texte "Choose language" si pas encore choisi
                    if (!languageSelector.languageChosen) {
                        ctx.font = 'bold 16px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#3b82f6';
                        const langText = currentLang === 'fr' ? 'Choisir la langue' :
                                       currentLang === 'en' ? 'Choose language' :
                                       currentLang === 'jp' ? 'Ë®ÄË™û„ÇíÈÅ∏Êäû' : '–û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É';
                        ctx.fillText(langText, mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height + 20);
                    }

                    // Menu ouvert : afficher les choix (vers le bas)
                    if (languageSelector.menuOpen) {
                        const totalWidth = (languageSelector.buttons.length * 70) + ((languageSelector.buttons.length - 1) * 10);
                        let startX = (C.W - totalWidth) / 2;
                        const menuY = mainBtn.y + mainBtn.height + 15; // En dessous du bouton

                        // Fond du menu
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.strokeStyle = '#cbd5e1';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(startX - 10, menuY - 10, totalWidth + 20, 100, 12);
                        ctx.fill();
                        ctx.stroke();

                        // Dessiner les boutons de langue
                        languageSelector.buttons.forEach((btn, index) => {
                            btn.x = startX + (index * 80);
                            btn.y = menuY;

                            const isActive = currentLang === btn.code;
                            const isBtnHovered = btn.hover;

                            // Fond du bouton
                            ctx.fillStyle = isActive ? '#3b82f6' : (isBtnHovered ? '#e2e8f0' : '#f8fafc');
                            ctx.strokeStyle = isActive ? '#2563eb' : '#cbd5e1';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 8);
                            ctx.fill();
                            ctx.stroke();

                            // Drapeau
                            ctx.font = '28px Arial';
                            ctx.fillText(btn.drapeau, btn.x + btn.width / 2, btn.y + 25);

                            // Nom de la langue
                            ctx.font = 'bold 10px "Segoe UI", system-ui, sans-serif';
                            ctx.fillStyle = isActive ? '#ffffff' : '#1e293b';
                            ctx.fillText(btn.nom, btn.x + btn.width / 2, btn.y + 52);
                        });
                    }

                    ctx.restore();
                }
            }
            */

            // üåç MINI-JEU "BRISER LES FRONTI√àRES" - Par-dessus tout
            if (briqueLangue.active) {
                ctx.save();

                // Dimensions s√©curis√©es - utiliser les dimensions du canvas r√©el
                const canvasW = canvas.width && isFinite(canvas.width) ? canvas.width : 800;
                const canvasH = canvas.height && isFinite(canvas.height) ? canvas.height : 600;

                // V√©rification de s√©curit√©
                if (!isFinite(canvasW) || !isFinite(canvasH) || canvasW <= 0 || canvasH <= 0) {
                    ctx.restore();
                    return;
                }

                // Fond d√©grad√© bleu roi -> blanc -> rouge
                const gradient = ctx.createLinearGradient(0, 0, 0, canvasH);
                gradient.addColorStop(0, '#0055A4');      // Bleu roi
                gradient.addColorStop(0.5, '#ffffff');    // Blanc
                gradient.addColorStop(1, '#EF4135');      // Rouge
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvasW, canvasH);

                // Vagues anim√©es en fond
                const time = Date.now() / 1000;
                ctx.save();

                // Vague 1 (arri√®re)
                ctx.globalAlpha = 0.15;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.3 + Math.sin(x * 0.01 + time * 0.5) * 40 + Math.cos(x * 0.02 + time * 0.3) * 20;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 2 (milieu)
                ctx.globalAlpha = 0.2;
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.5 + Math.sin(x * 0.015 + time * 0.7) * 50 + Math.cos(x * 0.025 + time * 0.5) * 25;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 3 (avant)
                ctx.globalAlpha = 0.25;
                ctx.lineWidth = 5;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.7 + Math.sin(x * 0.02 + time * 1) * 60 + Math.cos(x * 0.03 + time * 0.8) * 30;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.restore();

                // Particules d√©coratives (r√©duites)
                for (let i = 0; i < 15; i++) {
                    const x = (i * canvasW / 15) + (Math.sin(time + i) * 50);
                    const y = (i * canvasH / 15) + (Math.cos(time + i) * 30);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.15 + Math.sin(time + i) * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // NUAGE DE TRADUCTIONS "PETIT BATEAU"
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;

                const margin = 100;
                const translations = [
                    { text: '‚õµ', x: canvasW/2, y: canvasH/2 - 310, size: 64, opacity: 1 },
                    { text: 'PETIT BATEAU', x: canvasW/2, y: canvasH/2 - 180, size: 48, opacity: 1 },
                    { text: 'LITTLE BOAT', x: Math.max(margin, canvasW/2 - 200), y: canvasH/2 - 220, size: 36, opacity: 0.85 },
                    { text: 'Â∞è„Åï„Å™Ëàπ', x: Math.min(canvasW - margin, canvasW/2 + 220), y: canvasH/2 - 210, size: 32, opacity: 0.8 },
                    { text: '–ú–ê–õ–ï–ù–¨–ö–ò–ô –ß–û–í–ï–ù', x: Math.max(margin + 50, canvasW/2 - 180), y: canvasH/2 - 130, size: 28, opacity: 0.75 },
                    { text: 'ŸÇÿßÿ±ÿ® ÿµÿ∫Ÿäÿ±', x: Math.min(canvasW - margin, canvasW/2 + 200), y: canvasH/2 - 140, size: 30, opacity: 0.7 },
                    { text: '‡§õ‡•ã‡§ü‡•Ä ‡§®‡§æ‡§µ', x: Math.max(margin, canvasW/2 - 250), y: canvasH/2 - 170, size: 24, opacity: 0.65 },
                    { text: 'PEQUE√ëO BARCO', x: Math.min(canvasW - margin - 50, canvasW/2 + 180), y: canvasH/2 - 170, size: 26, opacity: 0.7 },
                    { text: 'PICCOLA BARCA', x: Math.max(margin + 30, canvasW/2 - 140), y: canvasH/2 - 90, size: 22, opacity: 0.6 },
                    { text: 'ÏûëÏùÄ Î∞∞', x: Math.min(canvasW - margin, canvasW/2 + 240), y: canvasH/2 - 100, size: 28, opacity: 0.65 },
                ];

                translations.forEach(trans => {
                    ctx.font = `bold ${trans.size}px "Segoe UI", Arial, sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${trans.opacity})`;
                    ctx.fillText(trans.text, trans.x, trans.y);
                });

                ctx.shadowBlur = 0;

                // Initialiser le jeu si n√©cessaire
                if (!briqueLangue.game) {
                    briqueLangue.game = {
                        bricks: [],
                        projectiles: [], // Lanternes tir√©es
                        bateau: { x: canvasW/2, y: canvasH - 80, width: 60, height: 40 }
                    };

                    // Tous les drapeaux du monde
                    const tousLesDrapeaux = [
                        { drapeau: 'üá´üá∑', code: 'fr', nom: 'Fran√ßais' },
                        { drapeau: 'üá¨üáß', code: 'en', nom: 'English' },
                        { drapeau: 'üáØüáµ', code: 'jp', nom: 'Êó•Êú¨Ë™û' },
                        { drapeau: 'üá∫üá¶', code: 'uk', nom: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞' },
                        { drapeau: 'üá™üá∏', code: 'es', nom: 'Espa√±ol' },
                        { drapeau: 'üá©üá™', code: 'de', nom: 'Deutsch' },
                        { drapeau: 'üáÆüáπ', code: 'it', nom: 'Italiano' },
                        { drapeau: 'üáµüáπ', code: 'pt', nom: 'Portugu√™s' },
                        { drapeau: 'üá∑üá∫', code: 'ru', nom: '–†—É—Å—Å–∫–∏–π' },
                        { drapeau: 'üá®üá≥', code: 'zh', nom: '‰∏≠Êñá' },
                        { drapeau: 'üá∞üá∑', code: 'ko', nom: 'ÌïúÍµ≠Ïñ¥' },
                        { drapeau: 'üá∏üá¶', code: 'ar', nom: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©' },
                        { drapeau: 'üáÆüá≥', code: 'hi', nom: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä' },
                        { drapeau: 'üáßüá∑', code: 'br', nom: 'Brasil' },
                        { drapeau: 'üá≤üáΩ', code: 'mx', nom: 'M√©xico' },
                        { drapeau: 'üá®üá¶', code: 'ca', nom: 'Canada' },
                        { drapeau: 'üá¶üá∫', code: 'au', nom: 'Australia' },
                        { drapeau: 'üáøüá¶', code: 'za', nom: 'South Africa' },
                        { drapeau: 'üá™üá¨', code: 'eg', nom: 'ŸÖÿµÿ±' },
                        { drapeau: 'üá≥üá¨', code: 'ng', nom: 'Nigeria' },
                        { drapeau: 'üá∞üá™', code: 'ke', nom: 'Kenya' },
                        { drapeau: 'üáπüá∑', code: 'tr', nom: 'T√ºrkiye' },
                        { drapeau: 'üáÆüá∑', code: 'ir', nom: 'ŸÅÿßÿ±ÿ≥€å' },
                        { drapeau: 'üáπüá≠', code: 'th', nom: '‡πÑ‡∏ó‡∏¢' },
                        { drapeau: 'üáªüá≥', code: 'vn', nom: 'Vi·ªát Nam' },
                        { drapeau: 'üáµüá≠', code: 'ph', nom: 'Philippines' },
                        { drapeau: 'üáÆüá©', code: 'id', nom: 'Indonesia' },
                        { drapeau: 'üá≤üáæ', code: 'my', nom: 'Malaysia' },
                        { drapeau: 'üá∏üá¨', code: 'sg', nom: 'Singapore' }
                    ];

                    // Cr√©er les briques drapeaux (4 lignes)
                    const brickW = 70;
                    const brickH = 45;
                    const cols = Math.floor(canvasW / brickW);
                    const startX = (canvasW - (cols * brickW)) / 2;
                    const startY = 80;

                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < cols; col++) {
                            const randomDrapeau = tousLesDrapeaux[Math.floor(Math.random() * tousLesDrapeaux.length)];
                            briqueLangue.game.bricks.push({
                                x: startX + col * brickW,
                                y: startY + row * brickH,
                                width: brickW - 6,
                                height: brickH - 6,
                                flag: randomDrapeau.drapeau,
                                code: randomDrapeau.code,
                                nom: randomDrapeau.nom,
                                alive: true
                            });
                        }
                    }
                }

                const game = briqueLangue.game;

                // V√©rifier victoire
                const brickesRestantes = game.bricks.filter(b => b.alive).length;
                if (brickesRestantes === 0) {
                    briqueLangue.active = false;
                    const totalScore = game.bricks.length * 3;
                    afficherMessagePowerupSimple(getTranslatedText('system.victory_points', `üéâ Victoire ! +${totalScore} points`));
                    ctx.restore();
                    return;
                }

                // Mettre √† jour projectiles (lanternes)
                for (let i = game.projectiles.length - 1; i >= 0; i--) {
                    const proj = game.projectiles[i];
                    proj.y -= 6; // Vitesse vers le haut

                    // Supprimer si hors √©cran
                    if (proj.y < -20) {
                        game.projectiles.splice(i, 1);
                        continue;
                    }

                    // Collision avec briques
                    let hit = false;
                    game.bricks.forEach(brick => {
                        if (!brick.alive || hit) return;
                        if (proj.x > brick.x && proj.x < brick.x + brick.width &&
                            proj.y > brick.y && proj.y < brick.y + brick.height) {
                            brick.alive = false;
                            hit = true;

                            // C≈ìurs
                            for (let j = 0; j < 3; j++) {
                                powerUps.push({
                                    x: brick.x + brick.width/2,
                                    y: brick.y + brick.height/2,
                                    dx: (Math.random() - 0.5) * 2,
                                    dy: Math.random() * 2 + 1,
                                    type: 'coeur',
                                    taille: 20,
                                    w: 20,
                                    h: 20,
                                    temps: 0
                                });
                            }

                            // Particules
                            for (let j = 0; j < 15; j++) {
                                particules.push({
                                    x: brick.x + brick.width/2,
                                    y: brick.y + brick.height/2,
                                    dx: (Math.random() - 0.5) * 5,
                                    dy: (Math.random() - 0.5) * 5,
                                    vie: 30,
                                    taille: Math.random() * 5 + 2,
                                    couleur: `hsl(${Math.random() * 360}, 70%, 60%)`
                                });
                            }
                        }
                    });

                    if (hit) {
                        game.projectiles.splice(i, 1);
                    }
                }

                // Dessiner briques
                game.bricks.forEach(brick => {
                    if (!brick.alive) return;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                    ctx.font = '36px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(brick.flag, brick.x + brick.width/2, brick.y + brick.height/2 - 5);

                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(brick.nom, brick.x + brick.width/2, brick.y + brick.height/2 + 15);
                });

                // Dessiner projectiles (lanternes)
                game.projectiles.forEach(proj => {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);

                    // Lanterne brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                    gradient.addColorStop(0, 'rgba(255, 220, 100, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 180, 50, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0.3)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // Emoji lanterne
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üèÆ', 0, 0);

                    ctx.restore();
                });

                // Dessiner bateau
                ctx.save();
                ctx.translate(game.bateau.x, game.bateau.y);

                // Bateau emoji
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('‚õµ', 0, 0);
                ctx.shadowBlur = 0;

                ctx.restore();

                // Instructions
                const instructionOpacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.3;
                ctx.font = 'bold 22px "Segoe UI", Arial, sans-serif';
                ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity})`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.fillText(getTranslatedText('game.frontiers.title', 'üß± Fronti√®res'), canvasW/2, canvasH - 30);
                ctx.font = 'bold 16px "Segoe UI", Arial, sans-serif';
                ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity * 0.8})`;
                ctx.fillText(getTranslatedText('game.frontiers.subtitle', '√âchapper aux fronti√®res'), canvasW/2, canvasH - 8);

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // Contr√¥les tactiles et souris unifi√©s avec support pixel ratio
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            
            // Calculer la position relative au canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Position ajust√©e pour le pixel ratio sur mobile
            const x = (touch.clientX - rect.left) * (isMobile ? 1 : scaleX / (window.devicePixelRatio || 1));
            const y = (touch.clientY - rect.top) * (isMobile ? 1 : scaleY / (window.devicePixelRatio || 1));
            
            return { x, y };
        }

        // Variable pour throttle du son de voile
        let dernierSonVoile = 0;
        const delaiSonVoile = 600; // 600ms entre chaque son

        function deplacerRaquette(x) {
            if(!jeu) return;
            const ancienX = raquette.x;
            raquette.x = x - C.PW/2;
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));

            // üîä Son de voile quand le bateau bouge (avec throttle)
            const now = Date.now();
            if (Math.abs(raquette.x - ancienX) > 5 && now - dernierSonVoile > delaiSonVoile) {
                AudioSystem.playVoile();
                dernierSonVoile = now;
            }
        }

        // √âv√©nements tactiles - REFONTE COMPL√àTE
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            tactile = true;

            const pos = obtenirPosition(e);
            const x = pos.x;
            const y = pos.y || 0;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üéØ PRIORIT√â 1: MENU √âNIGMES OUVERT
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (menuEnigmesCanvas.visible) {
                const menuPadding = 40;
                const menuWidth = C.W - 2 * menuPadding;
                const menuHeight = C.H - 2 * menuPadding;
                const menuX = menuPadding;
                const menuY = menuPadding;
                
                // Bouton fermer (X)
                const closeBtn = menuEnigmesCanvas.closeButton;
                if (closeBtn && x >= closeBtn.x && x <= closeBtn.x + closeBtn.width &&
                    y >= closeBtn.y && y <= closeBtn.y + closeBtn.height) {
                    if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Clic en dehors du menu ‚Üí fermer
                if (x < menuX || x > menuX + menuWidth ||
                    y < menuY || y > menuY + menuHeight) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Onglets
                const onglets = menuEnigmesCanvas.onglets;
                if (onglets) {
                    // Onglet √ânigmes
                    if (onglets.enigmes && x >= onglets.enigmes.x && x <= onglets.enigmes.x + onglets.enigmes.width &&
                        y >= onglets.enigmes.y && y <= onglets.enigmes.y + onglets.enigmes.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'enigmes';
                        menuEnigmesCanvas.scrollY = 0;
                        return;
                    }
                    
                    // Onglet Classement
                    if (onglets.classement && x >= onglets.classement.x && x <= onglets.classement.x + onglets.classement.width &&
                        y >= onglets.classement.y && y <= onglets.classement.y + onglets.classement.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'classement';
                        menuEnigmesCanvas.scrollY = 0;
                        return;
                    }
                    
                    // Onglet Langues
                    if (onglets.langues && x >= onglets.langues.x && x <= onglets.langues.x + onglets.langues.width &&
                        y >= onglets.langues.y && y <= onglets.langues.y + onglets.langues.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'langues';
                        menuEnigmesCanvas.scrollY = 0;
                        return;
                    }
                }
                
                // Boutons de langue (onglet langues)
                if (menuEnigmesCanvas.ongletActif === 'langues' && menuEnigmesCanvas.langueButtons) {
                    for (const btn of menuEnigmesCanvas.langueButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            if (window.i18n && btn.code !== window.i18n.getCurrentLanguage()) {
                                if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                                
                                const languageNames = {
                                    'fr': 'Fran√ßais', 'en': 'English', 'es': 'Espa√±ol',
                                    'jp': 'Êó•Êú¨Ë™û', 'uk': '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞', 'de': 'Deutsch',
                                    'it': 'Italiano', 'pt': 'Portugu√™s', 'ru': '–†—É—Å—Å–∫–∏–π',
                                    'ar': 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', 'zh': '‰∏≠Êñá', 'hi': '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä',
                                    'sw': 'Kiswahili', 'he': '◊¢◊ë◊®◊ô◊™'
                                };
                                const newLangName = languageNames[btn.code] || btn.code.toUpperCase();
                                
                                const confirmMessages = {
                                    'fr': `üåç Changer vers ${newLangName} ?\n\nLa page sera recharg√©e.`,
                                    'en': `üåç Change to ${newLangName}?\n\nPage will reload.`,
                                    'es': `üåç ¬øCambiar a ${newLangName}?\n\nLa p√°gina se recargar√°.`,
                                    'jp': `üåç ${newLangName}„Å´Â§âÊõ¥?\n\n„Éö„Éº„Ç∏ÂÜçË™≠„ÅøËæº„Åø„ÄÇ`,
                                    'uk': `üåç –ó–º—ñ–Ω–∏—Ç–∏ –Ω–∞ ${newLangName}?\n\n–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è.`
                                };
                                const currentLangCode = window.i18n.getCurrentLanguage() || 'fr';
                                const confirmMessage = confirmMessages[currentLangCode] || confirmMessages['en'];
                                
                                if (confirm(confirmMessage)) {
                                    window.i18n.setLanguage(btn.code).then(() => {
                                        currentLang = btn.code;
                                        localStorage.setItem('petit_bateau_lang', btn.code);
                                        setTimeout(() => location.reload(), 500);
                                    });
                                }
                            }
                            return;
                        }
                    }
                }
                
                // Touch dans le menu mais pas sur √©l√©ment interactif ‚Üí ne rien faire
                return;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üéØ PRIORIT√â 2: BOUTONS D'INTERFACE (menu ferm√©)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            const headerH = Math.max(C.H * 0.045, 32);
            
            // Bouton plein √©cran (en haut √† droite)
            const btnFullscreen = {
                x: C.W - 120,
                y: Math.max(headerH / 2 - 25, 5),
                radius: 25
            };
            const distFullscreen = Math.sqrt(
                Math.pow(x - (btnFullscreen.x + btnFullscreen.radius), 2) + 
                Math.pow(y - (btnFullscreen.y + btnFullscreen.radius), 2)
            );
            if (distFullscreen < btnFullscreen.radius + 10) {
                toggleFullscreen();
                return;
            }
            
            // Zone drapeau (en haut √† gauche) ‚Üí ouvre menu langues
            const statsY = Math.max(C.H * 0.045, 30);
            const flagZone = { x: 10, y: statsY - 15, width: 130, height: 30 };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                if (!menuEnigmesCanvas.visible && typeof ouvrirMenuEnigmesCanvas === 'function') {
                    ouvrirMenuEnigmesCanvas();
                }
                menuEnigmesCanvas.ongletActif = 'langues';
                menuEnigmesCanvas.scrollY = 0;
                return;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üéØ PRIORIT√â 3: BOUTON "PASSER" (si visible)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (verifierClicBoutonPasser && verifierClicBoutonPasser(x, y)) {
                if (AudioSystem && AudioSystem.playNegative) AudioSystem.playNegative();
                afficherMessagePowerupSimple(getTranslatedText('interface.system.no_exclamation', 'NON!'));
                return;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üéØ PRIORIT√â 4: INTERACTIONS DE JEU
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Bloquer si animation ou transition
            if (animationBateau.active || narrationManager.isTransitioning) {
                return;
            }
            
            // Phase STARS ‚Üí tir d'√©toiles
            if (phaseJeu === 'stars') {
                tirerStarsProjectile(x, y);
                if (typeof libererVaguesAmour === 'function') libererVaguesAmour();
                return;
            }
            
            // Phase LANTERNE ou MUR ‚Üí casse-briques
            if (phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                if (balle.enAttente) {
                    // Lancer la balle
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance;
                    balle.enAttente = false;
                    const msg = phaseJeu === 'mur' 
                        ? getTranslatedText('game.messages.attack_launched', 'üß± Attaque lanc√©e !')
                        : getTranslatedText('game.messages.lantern_launched', 'üèÆ Lanterne lanc√©e !');
                    afficherMessagePowerupSimple(msg);
                } else if (window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir √©toiles (power-up)
                    if (Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        tirerStarsProjectile(x, y);
                    }
                } else {
                    // D√©placer la raquette
                    deplacerRaquette(x);
                }
                return;
            }
            
            // Autres phases ‚Üí d√©placer bateau + amour
            deplacerRaquette(x);
            if (typeof libererVaguesAmour === 'function') libererVaguesAmour();
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // Syst√®me de tir continu
        let tirEnCours = false;
        let dernierTir = 0;
        const delaiTir = 150; // D√©lai entre chaque tir en ms

        // Syst√®me de swipe pour le menu
        let swipeStartY = 0;
        let isSwipingMenu = false;

        // √âv√©nements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // üåç V√©rifier le survol du drapeau en haut
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            const wasHovering = flagHover;
            flagHover = (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                        y >= flagZone.y && y <= flagZone.y + flagZone.height);
            
            // Changer le curseur
            if (flagHover && !wasHovering) {
                canvas.style.cursor = 'pointer';
            } else if (!flagHover && wasHovering) {
                canvas.style.cursor = 'default';
            }

            // Contr√¥ler le bateau du mini-jeu "Briser les Fronti√®res"
            if (briqueLangue.active && briqueLangue.game) {
                const game = briqueLangue.game;
                game.bateau.x = x;
                game.bateau.x = Math.max(30, Math.min(C.W - 30, game.bateau.x));
            }

            // Menu HOME supprim√©

            // V√©rifier le survol des ic√¥nes en haut
            verifierSurvolIconesHaut(x, y);

            // V√©rifier le survol des cartes d'√©nigmes
            verifierSurvolCartes(x, y);

            // Swipe dans le menu √©nigmes
            if (isSwipingMenu && menuEnigmesCanvas.visible) {
                const deltaY = swipeStartY - y;
                menuEnigmesCanvas.scrollY += deltaY * 0.5;
                menuEnigmesCanvas.scrollY = Math.max(0, Math.min(menuEnigmesCanvas.scrollY, menuEnigmesCanvas.maxScrollY));
                swipeStartY = y;
            } else {
                deplacerRaquette(e.clientX - rect.left);

                // Tir continu si bouton maintenu
                if(tirEnCours && (phaseJeu === 'lanterne' || phaseJeu === 'mur' || phaseJeu === 'stars')) {
                    const now = Date.now();
                    if(now - dernierTir > delaiTir) {
                        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                        if(phaseJeu === 'stars') {
                            tirerStarsProjectile(mouseX, mouseY);
                        } else if(phaseJeu === 'mur') {
                            // Mode tir MUR (syst√®me projectiles progressifs phases 17-22)
                            tirerProjectile(mouseX, mouseY);
                        } else if(window.modeTirStars && window.modeTirStars.actif) {
                            // Mode tir √©toiles POXERSTART (power-up 7s)
                            tirerStarsProjectile(mouseX, mouseY);
                        } else {
                            // Tir normal
                            tirerProjectile(mouseX, mouseY);
                        }
                        dernierTir = now;
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Gestion des clics sur le livre bonus (priorit√© absolue)
            if (phaseJeu === 'bonus_livre') {
                const pageHeight = C.H * 0.80;
                const pageY = (C.H - pageHeight) / 2;
                const buttonY = pageY + pageHeight + 30;

                // Clic sur Pr√©c√©dent
                if (Math.abs(x - (C.W / 2 - 90)) < 60 && Math.abs(y - buttonY) < 35) {
                    if (livreBonus.currentPage > 0) {
                        livreBonus.currentPage--;
                    }
                    return;
                }
                // Clic sur Suivant
                else if (Math.abs(x - (C.W / 2 + 90)) < 60 && Math.abs(y - buttonY) < 35) {
                    if (livreBonus.currentPage < livreBonus.pages.length - 1) {
                        livreBonus.currentPage++;
                    }
                    return;
                }
                // Clic sur Fermer
                else if (Math.abs(x - C.W / 2) < 60 && Math.abs(y - (buttonY + 8)) < 25) {
                    // Red√©marrer en gardant le score
                    if (narrationManager && narrationManager.restartKeepScore) {
                        narrationManager.restartKeepScore();
                    }
                    return;
                }
                return; // Ignorer tous les autres clics en mode livre
            }

            // üåç V√©rifier le clic sur le drapeau en haut (priorit√© absolue)
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                // Ne pas traiter comme swipe ou tir
                return;
            }

            if (menuEnigmesCanvas.visible) {
                isSwipingMenu = true;
                swipeStartY = y;
            } else {
                tirEnCours = true;
                dernierTir = 0; // Reset pour tir imm√©diat au premier clic
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            tirEnCours = false;
            isSwipingMenu = false;
        });

        canvas.addEventListener('mouseleave', (e) => {
            tirEnCours = false;
            isSwipingMenu = false;
        });

        // Scroll dans le menu √©nigmes
        canvas.addEventListener('wheel', (e) => {
            if (menuEnigmesCanvas.visible) {
                e.preventDefault();
                const scrollAmount = e.deltaY * 0.5; // Vitesse de scroll
                menuEnigmesCanvas.scrollY += scrollAmount;

                // Limiter le scroll
                menuEnigmesCanvas.scrollY = Math.max(0, Math.min(menuEnigmesCanvas.scrollY, menuEnigmesCanvas.maxScrollY));
            }
        }, { passive: false });

        // Ancien syst√®me de swipe pour le s√©lecteur de langue - D√âSACTIV√â
        canvas.addEventListener('mousedown', (e) => {
            // Ancien syst√®me d√©sactiv√©
            if (false && !languageSelector.active) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Zone de swipe (drapeaux au centre)
            const flagY = C.H/2;
            const onFlags = y >= flagY - 60 && y <= flagY + 60;

            if (onFlags) {
                languageSelector.isSwipingLang = true;
                languageSelector.swipeStartX = x;
                languageSelector.swipeOffset = 0;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            // Ancien syst√®me de swipe d√©sactiv√©
            if (false && !languageSelector.active || !languageSelector.isSwipingLang) return;

            languageSelector.isSwipingLang = false;

            const spacing = 80;
            const offset = languageSelector.swipeOffset || 0;

            // Calculer le changement de langue bas√© sur le swipe
            let languageChange = 0;
            if (Math.abs(offset) > spacing / 2) {
                languageChange = Math.round(offset / spacing);
            }

            if (languageChange !== 0) {
                // Trouver l'index actuel et calculer le nouvel index
                const currentIndex = languageSelector.buttons.findIndex(b => b.code === currentLang);
                let newIndex = currentIndex - languageChange; // Inversion pour swipe naturel

                // Boucler si on d√©passe les limites
                if (newIndex < 0) newIndex = languageSelector.buttons.length - 1;
                if (newIndex >= languageSelector.buttons.length) newIndex = 0;

                const newLang = languageSelector.buttons[newIndex];

                // Charger la nouvelle langue AVEC rafra√Æchissement
                loadTranslations(newLang.code).then(() => {
                    console.log('üåç Langue chang√©e vers:', newLang.code);
                    console.log('üîÑ Rafra√Æchissement de la page pour appliquer les traductions...');
                    
                    // üîÑ RAFRA√éCHIR LA PAGE pour recharger tous les textes
                    setTimeout(() => {
                        location.reload();
                    }, 500); // Petit d√©lai pour voir le message
                });
            } else {
                // R√©initialiser l'offset si le swipe n'√©tait pas assez grand
                languageSelector.swipeOffset = 0;
            }
        });

        // Gestionnaire prioritaire pour le drapeau (capture = true pour priorit√© absolue)
        // üìñ Gestion des clics sur le livre de la phase bonus
        canvas.addEventListener('click', (e) => {
            if (phaseJeu === 'bonus_mur' && window.phaseBonusMur) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const centerX = canvas.width / 2;
                const bookWidth = canvas.width * 0.85;
                const bookHeight = canvas.height * 0.75;
                const bookY = canvas.height / 2 - bookHeight / 2;
                const buttonY = bookY + bookHeight + 15;

                // Bouton Pr√©c√©dent
                if (Math.abs(x - (centerX - 60)) < 40 && Math.abs(y - buttonY) < 20) {
                    window.phaseBonusMur.previousPage();
                    e.preventDefault();
                    return;
                }

                // Bouton Suivant
                if (Math.abs(x - (centerX + 60)) < 40 && Math.abs(y - buttonY) < 20) {
                    window.phaseBonusMur.nextPage();
                    e.preventDefault();
                    return;
                }

                // Bouton Fermer
                if (Math.abs(x - centerX) < 40 && Math.abs(y - (buttonY + 10)) < 15) {
                    window.phaseBonusMur.closePage();
                    e.preventDefault();
                    return;
                }
            }
        }, { capture: true });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // üåç Zone du drapeau - priorit√© absolue
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                
                // Emp√™cher compl√®tement la propagation
                e.preventDefault();
                e.stopImmediatePropagation();
                
                // üîä Son de clic
                AudioSystem.playClick();
                
                // Ouvrir le menu √©nigme sur l'onglet langues
                if (!menuEnigmesCanvas.visible) {
                    ouvrirMenuEnigmesCanvas();
                }
                menuEnigmesCanvas.ongletActif = 'langues';
                menuEnigmesCanvas.scrollY = 0;
                
                return false; // Emp√™cher tout traitement ult√©rieur
            }
        }, { capture: true }); // Capture = priorit√© absolue

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Le drapeau est g√©r√© par le gestionnaire prioritaire ci-dessus

            // Tirer une lanterne du mini-jeu "Briser les Fronti√®res"
            if (briqueLangue.active && briqueLangue.game) {
                const game = briqueLangue.game;
                // Cr√©er une nouvelle lanterne √† la position du bateau
                game.projectiles.push({
                    x: game.bateau.x,
                    y: game.bateau.y - 20
                });
                return;
            }

            // üåç Ancien syst√®me de clic sur l'ic√¥ne de langue - D√âSACTIV√â
            // Le nouveau syst√®me est dans l'onglet langues du menu √©nigmes
            if (false && languageSelector.languageChosen && languageSelector.iconButton) {
                // Clic sur un item du menu (si ouvert)
                if (languageSelector.menuOpen) {
                    for (const btn of languageSelector.buttons) {
                        if (btn.menuX && x >= btn.menuX && x <= btn.menuX + btn.menuWidth &&
                            y >= btn.menuY && y <= btn.menuY + btn.menuHeight) {
                            // Charger les nouvelles traductions AVEC rafra√Æchissement
                            loadTranslations(btn.code).then(() => {
                                console.log('üåç Langue chang√©e vers:', btn.code);
                                console.log('üîÑ Rafra√Æchissement de la page pour appliquer les traductions...');
                                
                                // üîÑ RAFRA√éCHIR LA PAGE
                                setTimeout(() => {
                                    location.reload();
                                }, 500);
                            });
                            return;
                        }
                    }

                    // Fermer le menu si clic en dehors
                    const distance = Math.sqrt(
                        Math.pow(x - languageSelector.iconButton.x, 2) +
                        Math.pow(y - languageSelector.iconButton.y, 2)
                    );
                    if (distance > languageSelector.iconButton.radius) {
                        languageSelector.menuOpen = false;console.log('üåç Menu ferm√© (clic en dehors)');
                        return;
                    }
                }

                // Clic sur l'ic√¥ne elle-m√™me
                const distance = Math.sqrt(
                    Math.pow(x - languageSelector.iconButton.x, 2) +
                    Math.pow(y - languageSelector.iconButton.y, 2)
                );
                if (distance <= languageSelector.iconButton.radius) {
                    // Ouvrir/fermer menu pour changer de langue
                    languageSelector.menuOpen = !languageSelector.menuOpen;
                    return;
                }
            }

            // üéµ D√©marrer la musique au premier clic (autoplay policy)
            if (window.musicReadyToStart && musicManager && !window.musicStartedOnce) {
                musicManager.play('normal');
                window.musicReadyToStart = false;
                window.musicStartedOnce = true; // Marquer comme lanc√©e une fois
            }

            // üîä V√©rifier les clics sur les boutons audio
            // Volume ‚àí
            if (window.prevSongZone) {
                const btn = window.prevSongZone;
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    if (musicManager) {
                        const volumes = [0, 0.33, 0.66, 1];
                        const currentIndex = volumes.findIndex(v => v >= musicManager.volume.master);
                        const newVol = volumes[Math.max(0, currentIndex - 1)] || 0;
                        musicManager.setVolume(newVol);
                        AudioSystem.playClick();
                    }
                    return;
                }
            }

            // Volume +
            if (window.nextSongZone) {
                const btn = window.nextSongZone;
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    if (musicManager) {
                        const volumes = [0, 0.33, 0.66, 1];
                        const currentIndex = volumes.findIndex(v => v > musicManager.volume.master);
                        const newVol = volumes[Math.min(volumes.length - 1, currentIndex)] || 1;
                        musicManager.setVolume(newVol);
                        AudioSystem.playClick();
                    }
                    return;
                }
            }

            // üîä Son de clic sur tout clic
            AudioSystem.playClick();

            // V√©rifier le clic sur les onglets du menu √©nigmes
            if (menuEnigmesCanvas.visible) {
                // Calculer les dimensions du menu pour v√©rifier si le clic est √† l'int√©rieur
                const menuPadding = 40;
                const menuWidth = canvas.width - 2 * menuPadding;
                const menuHeight = canvas.height - 2 * menuPadding;
                const menuX = menuPadding;
                const menuY = menuPadding;
                
                // V√©rifier le clic sur le bouton de fermeture (X)
                const closeBtn = menuEnigmesCanvas.closeButton;
                if (x >= closeBtn.x && x <= closeBtn.x + closeBtn.width &&
                    y >= closeBtn.y && y <= closeBtn.y + closeBtn.height) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Si le clic est en dehors du menu, le fermer
                if (x < menuX || x > menuX + menuWidth ||
                    y < menuY || y > menuY + menuHeight) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Onglet √ânigmes
                const ongletEnigmes = menuEnigmesCanvas.onglets.enigmes;
                if (x >= ongletEnigmes.x && x <= ongletEnigmes.x + ongletEnigmes.width &&
                    y >= ongletEnigmes.y && y <= ongletEnigmes.y + ongletEnigmes.height) {
                    menuEnigmesCanvas.ongletActif = 'enigmes';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Onglet Classement
                const ongletClassement = menuEnigmesCanvas.onglets.classement;
                if (x >= ongletClassement.x && x <= ongletClassement.x + ongletClassement.width &&
                    y >= ongletClassement.y && y <= ongletClassement.y + ongletClassement.height) {
                    menuEnigmesCanvas.ongletActif = 'classement';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Onglet Langues
                const ongletLangues = menuEnigmesCanvas.onglets.langues;
                if (x >= ongletLangues.x && x <= ongletLangues.x + ongletLangues.width &&
                    y >= ongletLangues.y && y <= ongletLangues.y + ongletLangues.height) {
                    menuEnigmesCanvas.ongletActif = 'langues';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Clic sur les boutons de langue dans l'onglet langues
                if (menuEnigmesCanvas.ongletActif === 'langues' && menuEnigmesCanvas.langueButtons) {
                    for (const btn of menuEnigmesCanvas.langueButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            // Changer la langue AVEC rafra√Æchissement complet
                            if (window.i18n && btn.code !== window.i18n.getCurrentLanguage()) {
                                // Demander confirmation avant de recharger
                                const languageNames = {
                                    'fr': 'Fran√ßais',
                                    'en': 'English',
                                    'es': 'Espa√±ol',
                                    'jp': 'Êó•Êú¨Ë™û',
                                    'uk': '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞'
                                };
                                const newLangName = languageNames[btn.code] || btn.code.toUpperCase();
                                
                                // Messages traduits selon la langue actuelle
                                const confirmMessages = {
                                    'fr': `üåç Changer la langue vers ${newLangName} ?\n\nLa page sera recharg√©e pour appliquer les traductions.`,
                                    'en': `üåç Change language to ${newLangName}?\n\nThe page will be reloaded to apply translations.`,
                                    'es': `üåç ¬øCambiar idioma a ${newLangName}?\n\nLa p√°gina se recargar√° para aplicar las traducciones.`,
                                    'jp': `üåç Ë®ÄË™û„Çí${newLangName}„Å´Â§âÊõ¥„Åó„Åæ„Åô„ÅãÔºü\n\nÁøªË®≥„ÇíÈÅ©Áî®„Åô„Çã„Åü„ÇÅ„Éö„Éº„Ç∏„ÅåÂÜçË™≠„ÅøËæº„Åø„Åï„Çå„Åæ„Åô„ÄÇ`,
                                    'uk': `üåç –ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É –Ω–∞ ${newLangName}?\n\n–°—Ç–æ—Ä—ñ–Ω–∫–∞ –±—É–¥–µ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞ –¥–ª—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–∫–ª–∞–¥—ñ–≤.`
                                };
                                const currentLangCode = window.i18n.getCurrentLanguage() || 'fr';
                                const confirmMessage = confirmMessages[currentLangCode] || confirmMessages['en'];
                                const confirmChange = confirm(confirmMessage);
                                
                                if (confirmChange) {
                                    window.i18n.setLanguage(btn.code).then(() => {
                                        console.log('üåç Langue chang√©e vers:', btn.code);
                                        
                                        // Synchroniser currentLang et sauvegarder
                                        currentLang = btn.code;
                                        localStorage.setItem('petit_bateau_lang', btn.code);
                                        
                                        console.log('üîÑ Rafra√Æchissement de la page pour appliquer les traductions...');
                                        
                                        // üîÑ RAFRA√éCHIR LA PAGE pour recharger tous les textes
                                        setTimeout(() => {
                                            location.reload();
                                        }, 500); // Petit d√©lai pour voir le message
                                    }).catch(err => {
                                        console.error('‚ùå Erreur changement langue:', err);
                                    });
                                }
                            }
                            // Ne pas fermer le menu - pas de return qui sortirait de la fonction
                            break; // Sortir de la boucle mais rester dans le menu
                        }
                    }
                }

                // Onglet Info
                const ongletInfo = menuEnigmesCanvas.onglets.info;
                if (x >= ongletInfo.x && x <= ongletInfo.x + ongletInfo.width &&
                    y >= ongletInfo.y && y <= ongletInfo.y + ongletInfo.height) {
                    menuEnigmesCanvas.ongletActif = 'info';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    // R√©initialiser les boutons de projets pour qu'ils soient recr√©√©s
                    menuEnigmesCanvas.projectButtons = null;
                    return;
                }

                // Clic sur les boutons de projets dans l'onglet Info
                if (menuEnigmesCanvas.ongletActif === 'info' && menuEnigmesCanvas.projectButtons) {
                    for (const btn of menuEnigmesCanvas.projectButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            
                            let projectUrl = btn.link;
                            
                            // V√©rifier si c'est un lien externe (commence par http)
                            if (projectUrl.startsWith('http')) {
                                // Lien externe - ouvrir directement
                                window.open(projectUrl, '_blank');
                            } else {
                                // Lien interne - ajouter la langue actuelle
                                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                                
                                if (projectUrl.includes('?')) {
                                    projectUrl += `&lang=${currentLang}`;
                                } else {
                                    projectUrl += `?lang=${currentLang}`;
                                }
                                
                                window.open(projectUrl, '_blank');
                            }
                            
                            console.log(`üöÄ Ouverture du projet: ${btn.title}`);
                            return;
                        }
                    }
                }

            }

            // V√©rifier le clic sur le lien "Le voyage d'une vie"
            if (messageNarratifActif && messageNarratifActif.lienLivre && messageNarratifActif.lienZone) {
                const zone = messageNarratifActif.lienZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {
                    window.open(messageNarratifActif.lienLivre, '_blank');
                    return;
                }
            }

            // V√©rifier le clic sur le bouton de partage
            if (messageNarratifActif && messageNarratifActif.avecPartage && messageNarratifActif.partageZone) {
                const zone = messageNarratifActif.partageZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {

                    // Utiliser l'API Web Share si disponible, sinon copier dans le presse-papiers
                    if (navigator.share) {
                        navigator.share({
                            title: 'PETIT BATEAU - Mon Voyage',
                            text: messageNarratifActif.textePartage
                        }).then(() => {
                        }).catch(err => {
                        });
                    } else {
                        // Fallback : copier dans le presse-papiers
                        navigator.clipboard.writeText(messageNarratifActif.textePartage).then(() => {
                            alert(getTranslatedText('interface.system.text_copied_clipboard', '‚úÖ Texte copi√© dans le presse-papiers !\n\nPartagez-le sur vos r√©seaux sociaux üåç'));
                        }).catch(err => {
                            console.error('‚ùå Erreur copie:', err);
                        });
                    }
                    return;
                }
            }

            // V√©rifier le clic sur le bouton Recommencer (message final)
            if (messageNarratifActif && messageNarratifActif.avecRestart && messageNarratifActif.restartZone) {
                const zone = messageNarratifActif.restartZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {
                    console.log('üîÑ Bouton [Recommencer] cliqu√© - R√©initialisation compl√®te');
                    if (narrationManager) {
                        narrationManager.restart(); // Red√©marrer le jeu sans recharger la page
                    }
                    return;
                }
            }

            // V√©rifier le clic sur le bouton Suivant (Phase 16)
            if (window.boutonSuivantP16 && window.boutonSuivantP16.visible) {
                const btn = window.boutonSuivantP16;
                if (x >= btn.x && x <= btn.x + btn.width &&
                    y >= btn.y && y <= btn.y + btn.height) {
                    window.boutonSuivantP16.visible = false;
                    if (narrationManager) {
                        narrationManager.goToNextPhaseDirect();
                    }
                    return;
                }
            }

            // Clic sur le mur en phases 17-22 : activer mode tir lanterne (phase 23 = fin)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur') {
                // En mode mur phases 17-22, les munitions sont automatiquement d√©finies
                // Plus besoin d'activer un mode tir sp√©cial
            }

            // V√©rifier le clic sur le bouton Continuer (Phase 16)
            if (window.boutonContinuer && window.boutonContinuer.visible) {
                const btn = window.boutonContinuer;
                if (x >= btn.x && x <= btn.x + btn.width &&
                    y >= btn.y && y <= btn.y + btn.height) {
                    window.boutonContinuer.visible = false;
                    if (narrationManager) {
                        narrationManager.goToNextPhaseDirect();
                    }
                    return;
                }
            }

            // V√©rifier d'abord les clics sur l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                // Clic sur l'ic√¥ne centrale - ouvrir le menu √©nigmes
                ouvrirMenuEnigmesCanvas();
                return;
            }

            // V√©rifier les clics sur les ic√¥nes en haut (si elles existent)
            if (menuEnigmesCanvas.topIcons && menuEnigmesCanvas.topIcons.length > 0) {
                for (let icon of menuEnigmesCanvas.topIcons) {
                    if (x >= icon.x && x <= icon.x + icon.width &&
                        y >= icon.y && y <= icon.y + icon.height) {
                        // Clic sur une ic√¥ne en haut - ouvrir le menu √©nigmes
                        ouvrirMenuEnigmesCanvas();
                        return;
                    }
                }
            }

            // V√©rifier les clics dans le menu √©nigmes si ouvert
            if (menuEnigmesCanvas.visible) {
                // üéØ EXCEPTION : En phases mur 17-22, fermer le menu et permettre de tirer
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                if (phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur') {
                    console.log('üéØ Phase mur 17-22 : Fermeture auto du menu √©nigmes pour permettre de tirer');
                    fermerMenuEnigmesCanvas();
                    // Ne pas return - laisser le clic passer pour tirer
                } else {
                    // Bouton de fermeture du menu principal
                    if (x >= menuEnigmesCanvas.closeButton.x &&
                        x <= menuEnigmesCanvas.closeButton.x + menuEnigmesCanvas.closeButton.width &&
                        y >= menuEnigmesCanvas.closeButton.y &&
                        y <= menuEnigmesCanvas.closeButton.y + menuEnigmesCanvas.closeButton.height) {
                        fermerMenuEnigmesCanvas();
                        return;
                    }

                // Clics sur les cartes d'√©nigmes - syst√®me de liste d√©roulante
                for (let card of menuEnigmesCanvas.enigmaCards) {
                    const cardY = card.y - menuEnigmesCanvas.scrollY;
                    if (x >= card.x && x <= card.x + card.width &&
                        y >= cardY && y <= cardY + card.height) {

                        const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                        if (isCollected) {
                            // Toggle : d√©plier/replier la carte
                            if (menuEnigmesCanvas.expandedCard === card.id) {
                                menuEnigmesCanvas.expandedCard = null; // Replier
                            } else {
                                menuEnigmesCanvas.expandedCard = card.id; // D√©plier
                                // Reg√©n√©rer les positions pour mettre √† jour les hauteurs
                                genererPositionsCartesEnigmes();
                            }
                        } else {
                            // √ânigme non collect√©e - afficher juste qu'elle n'est pas d√©couverte
                            afficherMessagePowerupSimple('üîí ' + getTranslatedText('interface.system.enigma_not_discovered', '√ânigme non d√©couverte'));
                        }
                        return;
                    }
                }

                    // Clic en dehors du menu centr√© = fermer
                    const menuWidth = Math.min(C.W - 80, 600);
                    const menuHeight = Math.min(C.H - 80, 500);
                    const menuX = (C.W - menuWidth) / 2;
                    const menuY = (C.H - menuHeight) / 2;

                    if (x < menuX || x > menuX + menuWidth || y < menuY || y > menuY + menuHeight) {
                        fermerMenuEnigmesCanvas();
                    }
                    return; // Ne pas traiter d'autres clics si le menu est ouvert
                }
            }

            // L'ancien bouton menu √©nigmes est remplac√© par les ic√¥nes en haut

            // V√©rifier le clic sur le bouton passer
            if (verifierClicBoutonPasser(x, y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                // üîä Son de refus
                AudioSystem.playNegative();
                afficherMessagePowerupSimple(getTranslatedText('interface.system.no_exclamation', 'NON!'));
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            
            // Red√©marrage automatique supprim√© - utiliser le bouton dans le message de Game Over
            
            if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // PRIORIT√â : Mode mur phases 17-22 tire des projectiles, phase 23 fin
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const estPhaseMur17_22 = phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur';

                console.log(`üñ±Ô∏è MOUSEDOWN - Phase ${phaseActuelle}, phaseJeu=${phaseJeu}, estPhaseMur17_22=${estPhaseMur17_22}, balle.enAttente=${balle.enAttente}`);

                // Mode MUR en phases 17-22 : tire des projectiles (munitions infinies)
                if(estPhaseMur17_22) {
                    console.log(`üéØ APPEL tirerProjectile() pour phase mur ${phaseActuelle}`);
                    tirerProjectile(mouseX, mouseY);  // Syst√®me progressif phases 17-22
                }
                // Lancer la balle si en attente (phases lanterne normales)
                else if(balle.enAttente) {
                    console.log(`‚öΩ Lancer la balle`);
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance;
                    balle.enAttente = false;
                    afficherMessagePowerupSimple(phaseJeu === 'mur' ? getTranslatedText('game.messages.attack_launched', 'üß± Attaque lanc√©e !') : getTranslatedText('game.messages.lantern_launched', 'üèÆ Lanterne lanc√©e !'));
                }
                // Mode tir POXERSTART (power-up 7s)
                else if(window.modeTirStars && window.modeTirStars.actif) {
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        tirerStarsProjectile(mouseX, mouseY);  // Ancien syst√®me stars
                    }
                }
                // Tir normal (phases lanterne, ou mur hors 17-22)
                else {
                    tirerProjectile(mouseX, mouseY);
                }
            } else {
                // Le syst√®me de clic sur les oiseaux est maintenant g√©r√© par les √©v√©nements CSS
                // Voir la fonction setupBirdClickHandlers() plus bas

                // Clic normal sur canvas pour lib√©rer l'amour
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, utiliser le module
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.createProjectile(x, y);
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        creerProjectile();
                    }
                }
            }
        });

        // Redimensionnement responsive avec gestion orientation mobile
        let resizeTimer;
        window.addEventListener('resize', () => {
            // D√©bounce pour √©viter trop d'appels
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                size = setupCanvas();
                // Mettre √† jour l'objet C avec les nouvelles dimensions
                C.W = size.width;
                C.H = size.height;
                C.PW = Math.max(size.width * 0.3, 100);
                C.PH = Math.max(size.height * 0.025, 15);
                C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                C.SP = Math.max(Math.min(size.width, size.height) * 0.002, 1.5);
                if(!jeu) initJeu();
            }, 100);
        });
        
        // Gestion changement d'orientation sur mobile
        if (isMobile) {
            // Fonction pour v√©rifier et afficher/masquer le message d'orientation
            function checkOrientation() {
                const orientationWarning = document.querySelector('.orientation-warning');
                const gameContainer = document.querySelector('.game-container');
                
                if (!orientationWarning || !gameContainer) return;
                
                // D√©tecter l'orientation r√©elle
                const isLandscape = window.innerWidth > window.innerHeight;
                const isVerySmallHeight = window.innerHeight < 500;
                
                // Bloquer UNIQUEMENT les paysages sur tr√®s petits √©crans (< 500px hauteur)
                if (isLandscape && isVerySmallHeight && window.innerWidth < 900) {
                    // Mode paysage probl√©matique (trop petit verticalement)
                    orientationWarning.style.display = 'flex';
                    gameContainer.style.display = 'none';
                    console.warn('‚ö†Ô∏è √âcran trop petit en paysage - Jeu masqu√©');
                } else {
                    // Mode portrait ou paysage avec hauteur suffisante
                    orientationWarning.style.display = 'none';
                    gameContainer.style.display = 'flex';
                }
            }
            
            // V√©rifier au chargement
            checkOrientation();
            
            // Event orientationchange (API standard)
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    checkOrientation();
                    size = setupCanvas();
                    C.W = size.width;
                    C.H = size.height;
                    C.PW = Math.max(size.width * 0.3, 100);
                    C.PH = Math.max(size.height * 0.025, 15);
                    C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                    C.SP = Math.max(Math.min(size.width, size.height) * 0.002, 1.5);
                    if(!jeu) initJeu();
                }, 300); // D√©lai pour laisser le temps au navigateur de se repositionner
            });
            
            // Event resize (backup pour PWA qui n'utilisent pas orientationchange)
            window.addEventListener('resize', () => {
                checkOrientation();
            });
        }

        // ========== MODULE MODE SECRET - INITIALISATION ==========
        function initSecretModeModule() {
            if (!canvas || !ctx) {
                console.error('Canvas ou contexte non disponible pour le module secret');
                return;
            }

            // V√©rifier si la classe SecretModeModule est disponible
            if (typeof SecretModeModule === 'undefined') {
                console.warn('‚ö†Ô∏è SecretModeModule non trouv√© - Utilisation du mode secret int√©gr√©');
                secretModeModule = null;
                return;
            }

            try {
                // Cr√©er l'instance du module avec un objet gameState plus simple
                const gameStateRef = {
                    get modeSecret() { return modeSecret; },
                    set modeSecret(val) { modeSecret = val; },
                    get jeu() { return jeu; },
                    set jeu(val) { jeu = val; },
                    get score() { return score; },
                    set score(val) { score = val; },
                    get raquette() { return raquette; },
                    get C() { return C; },
                    get phaseJeu() { return phaseJeu; },
                    set phaseJeu(val) { phaseJeu = val; },
                    get animationBateau() { return animationBateau; },
                    afficherMessage: (msg, duree) => afficherMessage(msg, duree),
                    afficherMessagePowerupSimple: (msg) => afficherMessagePowerupSimple(msg),
                    ajouterParticules: (x, y, couleur, nb) => ajouterParticules(x, y, couleur, nb)
                };

                secretModeModule = new SecretModeModule(canvas, ctx, gameStateRef);
                //
            } catch (error) {
                console.error('‚ùå Erreur initialisation module secret:', error);
                secretModeModule = null;
            }
        }

        // ========== GESTIONNAIRE AUDIO - INITIALISATION ==========
        function initMusicManager() {
            if (typeof AudioManager === 'undefined') {
                console.warn('‚ö†Ô∏è AudioManager non trouv√© - Pas de son');
                return;
            }

            try {
                musicManager = new AudioManager();
                console.log('üéµ Gestionnaire audio initialis√© (d√©marrera apr√®s intro)');
            } catch (error) {
                console.error('‚ùå Erreur initialisation gestionnaire audio:', error);
                musicManager = null;
            }
        }

        // ========== MODULE OBJETS KAWAII - INITIALISATION ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret DOM
        // Plus besoin d'initialisation s√©par√©e

        // ========== MODULE OBJETS KAWAII - SUPPRIM√â ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret
        function activerObjetsKawaii() {
        }

        function desactiverObjetsKawaii() {
        }

        function configurerObjetsKawaii(config) {
        }

        // ========== MODULE OISEAUX CSS - GESTIONNAIRE √âV√âNEMENTS ==========
        function setupBirdClickHandlers() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            // Clic sur le corbeau
            crowElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'corbeau') {
                    handleBirdClick();
                }
            });

            // Clic sur la colombe
            doveElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'colombe') {
                    handleBirdClick();
                }
            });
        }

        function handleBirdClick() {
            corbeau.touches++;
            score += 100; // Points bonus pour toucher l'oiseau

            // üîä Son d'√©tincelle magique l√©g√®re (plus lumineux si lanterne allum√©e)
            if (lanterne.active) {
                AudioSystem.playSparkle();
                // Particules dor√©es suppl√©mentaires avec la lanterne
                ajouterParticules(corbeau.x, corbeau.y, '#FFA500', 4);
            } else {
                AudioSystem.playSparkle();
            }

            // Effet visuel
            ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

            // Afficher l'√©toile avec le compteur de clics
            afficherEtoileCompteur();

            if (corbeau.touches >= 3 && corbeau.type === 'corbeau') {
                // V√©rifier si on est en phases 1 ou 2 - pas de transformation
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                if (phaseActuelle === 1 || phaseActuelle === 2) {
                    console.log('üö´ Transformation corbeau bloqu√©e en phases 1 et 2');
                    afficherMessagePowerupSimple(getTranslatedText('game.messages.bird_no', 'üê¶ NON !'));
                    // R√©initialiser les touches pour qu'il puisse r√©essayer plus tard
                    corbeau.touches = 0;
                    return;
                }

                // Transformer en colombe !
                corbeau.type = 'colombe';
                score += 1000; // Gros bonus pour la transformation

                // D√©bloquer le niveau secret !
                niveauSecretDebloque = true;

                afficherMessagePowerupSimple(getTranslatedText('game.messages.crow_transformed', 'üïäÔ∏è Corbeau transform√© en Colombe!'));

                // Le soleil fait un clin d'≈ìil
                soleil.clignotement = true;
                soleil.tempsClignotement = Date.now();

                // D√©clencher le niveau secret apr√®s un d√©lai
                setTimeout(() => {
                    if (secretModeModule) {
                        secretModeModule.activate();
                    } else {
                        console.error('Module secret non initialis√© !');
                        lancerNiveauSecret(); // Fallback vers l'ancien syst√®me
                    }
                }, 4000);
            } else {
                // Message discret en bas √† droite
                const message = getTranslatedText('game.messages.crow_hit', 'üê¶ Corbeau touch√© {count}/7 fois')
                    .replace('{count}', corbeau.touches);
                afficherMessageCorbeauBas(message, 1000);
            }
        }

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        // Variables pour l'√©toile compteur
        let etoileCompteur = {
            actif: false,
            x: 0,
            y: 0,
            tempsFin: 0,
            alpha: 1
        };

        function afficherEtoileCompteur() {
            // Positionner l'√©toile pr√®s du corbeau
            etoileCompteur.x = corbeau.x + 30;
            etoileCompteur.y = corbeau.y - 20;
            etoileCompteur.actif = true;
            etoileCompteur.tempsFin = Date.now() + 2000; // Afficher 2 secondes
            etoileCompteur.alpha = 1;
        }

        function mettreAJourEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            const tempsRestant = etoileCompteur.tempsFin - Date.now();
            if (tempsRestant <= 0) {
                etoileCompteur.actif = false;
                return;
            }

            // Fade out progressif
            if (tempsRestant < 500) {
                etoileCompteur.alpha = tempsRestant / 500;
            }
        }

        function dessinerEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            ctx.save();
            ctx.globalAlpha = etoileCompteur.alpha;

            // Dessiner l'√©toile blanche
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;

            const x = etoileCompteur.x;
            const y = etoileCompteur.y;
            const rayon = 15;

            // Forme d'√©toile √† 5 branches
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const x1 = x + Math.cos(angle) * rayon;
                const y1 = y + Math.sin(angle) * rayon;

                const angleInterne = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                const x2 = x + Math.cos(angleInterne) * (rayon * 0.4);
                const y2 = y + Math.sin(angleInterne) * (rayon * 0.4);

                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Texte du compteur
            ctx.fillStyle = 'black';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(corbeau.touches.toString(), x, y);

            ctx.restore();
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas √† droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu || phaseIntro.active) return; // Attendre la fin de l'intro

            // Initialiser le temps de d√©part si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire appara√Ætre le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;

                // Alterner la direction √† chaque passage
                if(corbeau.direction === 1) {
                    // Gauche vers droite
                    corbeau.x = -100;
                    corbeau.vx = 0.8 / 1.5;
                } else {
                    // Droite vers gauche
                    corbeau.x = C.W + 100;
                    corbeau.vx = -(0.8 / 1.5);
                }

                corbeau.y = C.H * 0.4; // Vers le milieu de l'√©cran
                corbeau.touches = 0; // R√©initialiser le compteur de touches

                // Alterner pour le prochain passage
                corbeau.direction *= -1;

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;

                // üîä Son de corbeau (cri)
                AudioSystem.playCrow();

                //
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                corbeau.y += Math.sin(Date.now() * 0.0005) * 0.25; // Mouvement ondulant tr√®s doux et petit

                // V√©rifier collision avec la lanterne allum√©e
                if(lanterne.active && balle.visible && !chauveSouris.revelee) {
                    const distanceX = Math.abs(corbeau.x - balle.x);
                    const distanceY = Math.abs(corbeau.y - balle.y);
                    const distanceCollision = 60; // Distance de collision

                    if(distanceX < distanceCollision && distanceY < distanceCollision) {
                        // R√©v√©ler la chauve-souris !
                        revelerChauveSouris(corbeau.x, corbeau.y);

                        // Faire dispara√Ætre l'oiseau
                        corbeau.actif = false;
                        corbeau.x = 0;
                        corbeau.y = 0;
                    }
                }

                // Retirer le corbeau s'il sort de l'√©cran (dans les deux directions)
                if((corbeau.vx > 0 && corbeau.x > C.W + 100) || (corbeau.vx < 0 && corbeau.x < -100)) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        // ========== MODULE OISEAUX CSS - FONCTION MODIFI√âE ==========
        function dessinerCorbeau() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            if (!corbeau.actif || phaseIntro.active) {
                // Masquer tous les oiseaux
                crowElement.classList.remove('bird-visible');
                crowElement.classList.add('bird-hidden');
                doveElement.classList.remove('bird-visible');
                doveElement.classList.add('bird-hidden');
                return;
            }

            // Positionner l'oiseau selon les coordonn√©es
            const activeElement = corbeau.type === 'corbeau' ? crowElement : doveElement;
            const inactiveElement = corbeau.type === 'corbeau' ? doveElement : crowElement;

            // Masquer l'oiseau inactif
            inactiveElement.classList.remove('bird-visible');
            inactiveElement.classList.add('bird-hidden');

            // Positionner et afficher l'oiseau actif
            activeElement.style.left = corbeau.x + 'px';
            activeElement.style.top = corbeau.y + 'px';

            // Orienter l'oiseau selon sa direction avec l'animation appropri√©e
            if (corbeau.vx < 0) {
                // Va vers la gauche - utiliser animation retourn√©e
                activeElement.style.animation = 'crow-auto-flight-left calc(2s / var(--animation-speed)) infinite';
                //console.log('üê¶ Corbeau orient√© GAUCHE ‚Üê (animation crow-auto-flight-left), x:', corbeau.x);
            } else {
                // Va vers la droite - animation normale
                activeElement.style.animation = 'crow-auto-flight calc(2s / var(--animation-speed)) infinite';
                //console.log('üê¶ Corbeau orient√© DROITE ‚Üí (animation crow-auto-flight), x:', corbeau.x);
            }

            activeElement.classList.remove('bird-hidden');
            activeElement.classList.add('bird-visible');
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y, invisible = false) {
            // D√©caler largement la position pour √©viter les superpositions
            const decalageAleatoire = Math.random() * 100 - 50; // ¬±50px
            const yDecale = y + (textesVolants.length * 50); // D√©calage vertical de 50px par texte existant

            textesVolants.push({
                texte: texte,
                x: x + decalageAleatoire,
                y: yDecale,
                xDepart: x + decalageAleatoire,
                yDepart: yDecale,
                vy: 0, // Vitesse calcul√©e dynamiquement
                taille: 12, // Taille initiale
                alpha: invisible ? 0 : 1, // Opacit√© (0 si invisible)
                temps: 0,
                phase: 'descente', // 'descente' puis 'montee'
                invisible: invisible // Marquer comme invisible
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.006; // Ralenti (√©tait 0.012)

                // Mouvement vers le centre horizontal plus lent
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Ralenti (√©tait 3)
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis mont√©e
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 100); // Ralenti (√©tait 200)

                    // Fondu pendant la descente plus lent
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Ralenti (√©tait 4)

                    // Passer √† la phase mont√©e plus tard
                    if(texte.temps > 0.3) { // Plus long (√©tait 0.15)
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 80); // Ralenti (√©tait 180)

                    // Fondu retour pendant la mont√©e plus lent
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 2); // Ralenti (√©tait 4)
                }

                // Grossissement tr√®s progressif et doux
                texte.taille = 12 + texte.temps * 15; // Ralenti (√©tait 20)

                // Disparition finale plus lente
                if(texte.temps > 0.8) { // Plus long (√©tait 0.4)
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.8) * 2); // Ralenti (√©tait 4)
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu
        function boucleJeu() {
            // Animation du survol du drapeau (simple)
            if (flagHover && flagHoverAnimation < 1) {
                flagHoverAnimation = Math.min(1, flagHoverAnimation + flagHoverAnimationSpeed);
            } else if (!flagHover && flagHoverAnimation > 0) {
                flagHoverAnimation = Math.max(0, flagHoverAnimation - flagHoverAnimationSpeed);
            }
            
            // üåç SI LANGUE NON CHOISIE : dessiner seulement le s√©lecteur
            if (languageSelector.active && !languageSelector.languageChosen) {
                // Clear canvas
                ctx.clearRect(0, 0, C.W, C.H);

                // Fond d√©grad√© bleu roi -> blanc -> rouge
                const gradient = ctx.createLinearGradient(0, 0, 0, C.H);
                gradient.addColorStop(0, '#0055A4');      // Bleu roi
                gradient.addColorStop(0.5, '#ffffff');    // Blanc
                gradient.addColorStop(1, '#EF4135');      // Rouge
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, C.W, C.H);

                // Vagues anim√©es en fond
                const time = Date.now() / 1000;
                ctx.save();

                // Vague 1 (arri√®re)
                ctx.globalAlpha = 0.15;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < C.W; x += 5) {
                    const y = C.H * 0.3 + Math.sin(x * 0.01 + time * 0.5) * 40 + Math.cos(x * 0.02 + time * 0.3) * 20;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 2 (milieu)
                ctx.globalAlpha = 0.2;
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let x = 0; x < C.W; x += 5) {
                    const y = C.H * 0.5 + Math.sin(x * 0.015 + time * 0.7) * 50 + Math.cos(x * 0.025 + time * 0.5) * 25;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 3 (avant)
                ctx.globalAlpha = 0.25;
                ctx.lineWidth = 5;
                ctx.beginPath();
                for (let x = 0; x < C.W; x += 5) {
                    const y = C.H * 0.7 + Math.sin(x * 0.02 + time * 1) * 60 + Math.cos(x * 0.03 + time * 0.8) * 30;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.restore();

                // Particules d√©coratives (r√©duites)
                for (let i = 0; i < 15; i++) {
                    const x = (i * C.W / 15) + (Math.sin(time + i) * 50);
                    const y = (i * C.H / 15) + (Math.cos(time + i) * 30);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.15 + Math.sin(time + i) * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // NUAGE DE TRADUCTIONS "PETIT BATEAU"
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;

                // Traductions de "Petit Bateau" dans diff√©rentes langues avec positions et tailles vari√©es
                // Positions ajust√©es pour √©viter les bords
                const margin = 100; // Marge de s√©curit√©
                const translations = [
                    { text: '‚õµ', x: C.W/2, y: C.H/2 - 310, size: 64, opacity: 1 },
                    { text: 'PETIT BATEAU', x: C.W/2, y: C.H/2 - 180, size: 48, opacity: 1 },
                    { text: 'LITTLE BOAT', x: Math.max(margin, C.W/2 - 200), y: C.H/2 - 220, size: 36, opacity: 0.85 },
                    { text: 'Â∞è„Åï„Å™Ëàπ', x: Math.min(C.W - margin, C.W/2 + 220), y: C.H/2 - 210, size: 32, opacity: 0.8 },
                    { text: '–ú–ê–õ–ï–ù–¨–ö–ò–ô –ß–û–í–ï–ù', x: Math.max(margin + 50, C.W/2 - 180), y: C.H/2 - 130, size: 28, opacity: 0.75 },
                    { text: 'ŸÇÿßÿ±ÿ® ÿµÿ∫Ÿäÿ±', x: Math.min(C.W - margin, C.W/2 + 200), y: C.H/2 - 140, size: 30, opacity: 0.7 },
                    { text: '‡§õ‡•ã‡§ü‡•Ä ‡§®‡§æ‡§µ', x: Math.max(margin, C.W/2 - 250), y: C.H/2 - 170, size: 24, opacity: 0.65 },
                    { text: 'PEQUE√ëO BARCO', x: Math.min(C.W - margin - 50, C.W/2 + 180), y: C.H/2 - 170, size: 26, opacity: 0.7 },
                    { text: 'PICCOLA BARCA', x: Math.max(margin + 30, C.W/2 - 140), y: C.H/2 - 90, size: 22, opacity: 0.6 },
                    { text: 'ÏûëÏùÄ Î∞∞', x: Math.min(C.W - margin, C.W/2 + 240), y: C.H/2 - 100, size: 28, opacity: 0.65 },
                ];

                translations.forEach(trans => {
                    ctx.font = `bold ${trans.size}px "Segoe UI", Arial, sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${trans.opacity})`;
                    ctx.fillText(trans.text, trans.x, trans.y);
                });

                ctx.shadowBlur = 0;

                // üåç MINI-JEU "BRISER LES FRONTI√àRES" - Ind√©pendant
                if (briqueLangue.active) {
                    ctx.save();

                    // Initialiser le jeu si n√©cessaire
                    if (!briqueLangue.game) {
                        briqueLangue.game = {
                            bricks: [],
                            ball: { x: C.W/2, y: C.H - 100, dx: 4, dy: -4, radius: 10, launched: false },
                            paddle: { x: C.W/2 - 50, y: C.H - 40, width: 100, height: 15 }
                        };

                        // Tous les drapeaux du monde
                        const tousLesDrapeaux = [
                            { drapeau: 'üá´üá∑', code: 'fr', nom: 'Fran√ßais' },
                            { drapeau: 'üá¨üáß', code: 'en', nom: 'English' },
                            { drapeau: 'üáØüáµ', code: 'jp', nom: 'Êó•Êú¨Ë™û' },
                            { drapeau: 'üá∫üá¶', code: 'uk', nom: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞' },
                            { drapeau: 'üá™üá∏', code: 'es', nom: 'Espa√±ol' },
                            { drapeau: 'üá©üá™', code: 'de', nom: 'Deutsch' },
                            { drapeau: 'üáÆüáπ', code: 'it', nom: 'Italiano' },
                            { drapeau: 'üáµüáπ', code: 'pt', nom: 'Portugu√™s' },
                            { drapeau: 'üá∑üá∫', code: 'ru', nom: '–†—É—Å—Å–∫–∏–π' },
                            { drapeau: 'üá®üá≥', code: 'zh', nom: '‰∏≠Êñá' },
                            { drapeau: 'üá∞üá∑', code: 'ko', nom: 'ÌïúÍµ≠Ïñ¥' },
                            { drapeau: 'üá∏üá¶', code: 'ar', nom: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©' },
                            { drapeau: 'üáÆüá≥', code: 'hi', nom: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä' },
                            { drapeau: 'üáßüá∑', code: 'br', nom: 'Brasil' },
                            { drapeau: 'üá≤üáΩ', code: 'mx', nom: 'M√©xico' },
                            { drapeau: 'üá®üá¶', code: 'ca', nom: 'Canada' },
                            { drapeau: 'üá¶üá∫', code: 'au', nom: 'Australia' },
                            { drapeau: 'üáøüá¶', code: 'za', nom: 'South Africa' },
                            { drapeau: 'üá™üá¨', code: 'eg', nom: 'ŸÖÿµÿ±' },
                            { drapeau: 'üá≥üá¨', code: 'ng', nom: 'Nigeria' },
                            { drapeau: 'üá∞üá™', code: 'ke', nom: 'Kenya' },
                            { drapeau: 'üáπüá∑', code: 'tr', nom: 'T√ºrkiye' },
                            { drapeau: 'üáÆüá∑', code: 'ir', nom: 'ŸÅÿßÿ±ÿ≥€å' },
                            { drapeau: 'üáπüá≠', code: 'th', nom: '‡πÑ‡∏ó‡∏¢' },
                            { drapeau: 'üáªüá≥', code: 'vn', nom: 'Vi·ªát Nam' },
                            { drapeau: 'üáµüá≠', code: 'ph', nom: 'Philippines' },
                            { drapeau: 'üáÆüá©', code: 'id', nom: 'Indonesia' },
                            { drapeau: 'üá≤üáæ', code: 'my', nom: 'Malaysia' },
                            { drapeau: 'üá∏üá¨', code: 'sg', nom: 'Singapore' }
                        ];

                        // Cr√©er les briques drapeaux (4 lignes avec plein de drapeaux)
                        const brickW = 70;
                        const brickH = 45;
                        const cols = Math.floor(C.W / brickW);
                        const startX = (C.W - (cols * brickW)) / 2;
                        const startY = 80;

                        for (let row = 0; row < 4; row++) {
                            for (let col = 0; col < cols; col++) {
                                const randomDrapeau = tousLesDrapeaux[Math.floor(Math.random() * tousLesDrapeaux.length)];
                                briqueLangue.game.bricks.push({
                                    x: startX + col * brickW,
                                    y: startY + row * brickH,
                                    width: brickW - 6,
                                    height: brickH - 6,
                                    flag: randomDrapeau.drapeau,
                                    code: randomDrapeau.code,
                                    nom: randomDrapeau.nom,
                                    alive: true
                                });
                            }
                        }
                    }

                    const game = briqueLangue.game;

                    // V√©rifier si toutes les briques sont cass√©es
                    const brickesRestantes = game.bricks.filter(b => b.alive).length;
                    if (brickesRestantes === 0) {
                        briqueLangue.active = false;
                        const points = game.bricks.length * 3;
                        const message = getTranslatedText('game.messages.frontiers_broken', 'üåçüíï FRONTI√àRES BRIS√âES! +XXX ‚ù§Ô∏è').replace('XXX', points);
                        afficherMessagePowerupSimple(message);
                        return;
                    }

                    // Physique de la balle
                    if (game.ball.launched) {
                        game.ball.x += game.ball.dx;
                        game.ball.y += game.ball.dy;

                        // Rebonds murs
                        if (game.ball.x - game.ball.radius < 0 || game.ball.x + game.ball.radius > C.W) {
                            game.ball.dx = -game.ball.dx;
                        }
                        if (game.ball.y - game.ball.radius < 0) {
                            game.ball.dy = -game.ball.dy;
                        }

                        // Rebond raquette
                        if (game.ball.y + game.ball.radius > game.paddle.y &&
                            game.ball.x > game.paddle.x && game.ball.x < game.paddle.x + game.paddle.width &&
                            game.ball.dy > 0) {
                            game.ball.dy = -Math.abs(game.ball.dy);
                            const hitPos = (game.ball.x - game.paddle.x) / game.paddle.width;
                            game.ball.dx = (hitPos - 0.5) * 8;
                        }

                        // Collision briques
                        game.bricks.forEach(brick => {
                            if (!brick.alive) return;
                            if (game.ball.x + game.ball.radius > brick.x &&
                                game.ball.x - game.ball.radius < brick.x + brick.width &&
                                game.ball.y + game.ball.radius > brick.y &&
                                game.ball.y - game.ball.radius < brick.y + brick.height) {
                                brick.alive = false;
                                game.ball.dy = -game.ball.dy;

                                // Faire tomber des c≈ìurs au lieu de changer de langue
                                for (let i = 0; i < 3; i++) {
                                    powerUps.push({
                                        x: brick.x + brick.width/2,
                                        y: brick.y + brick.height/2,
                                        dx: (Math.random() - 0.5) * 2,
                                        dy: Math.random() * 2 + 1,
                                        type: 'coeur',
                                        taille: 20
                                    });
                                }

                                // Particules d'explosion
                                for (let i = 0; i < 15; i++) {
                                    particules.push({
                                        x: brick.x + brick.width/2,
                                        y: brick.y + brick.height/2,
                                        dx: (Math.random() - 0.5) * 5,
                                        dy: (Math.random() - 0.5) * 5,
                                        vie: 30,
                                        taille: Math.random() * 5 + 2,
                                        couleur: `hsl(${Math.random() * 360}, 70%, 60%)`
                                    });
                                }
                            }
                        });

                        // Balle perdue
                        if (game.ball.y > C.H) {
                            game.ball.x = game.paddle.x + game.paddle.width/2;
                            game.ball.y = game.paddle.y - 20;
                            game.ball.launched = false;
                        }
                    } else {
                        // Balle suit la raquette
                        game.ball.x = game.paddle.x + game.paddle.width/2;
                        game.ball.y = game.paddle.y - 20;
                    }

                    // Dessiner briques
                    game.bricks.forEach(brick => {
                        if (!brick.alive) return;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillText(brick.flag, brick.x + brick.width/2, brick.y + brick.height/2 - 5);

                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(brick.nom, brick.x + brick.width/2, brick.y + brick.height/2 + 15);
                    });

                    // Dessiner raquette
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 8;
                    ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);

                    // Dessiner balle
                    ctx.beginPath();
                    ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Instructions
                    const instructionOpacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.3;
                    ctx.font = 'bold 22px "Segoe UI", Arial, sans-serif';
                    ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 5;
                    ctx.fillText(game.ball.launched ? getTranslatedText('interface.game.break_borders', 'üåç BRISER LES FRONTI√àRES üåç') : getTranslatedText('interface.game.click_to_launch', 'üöÄ CLIQUEZ POUR LANCER'), C.W/2, C.H - 80);

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }

                requestAnimationFrame(boucleJeu);
                return; // NE PAS CONTINUER
            }

            // G√©rer l'animation du bateau (sauf si s√©lecteur de langue actif)
            if (!languageSelector.active) {
                gererAnimationBateau();
            }

            // G√©rer la phase d'introduction (sauf si s√©lecteur de langue actif)
            if (!languageSelector.active) {
                gererPhaseIntro();
            }

            // Mise √† jour du module de drones (sauf si s√©lecteur de langue actif)
            if (droneModule && !languageSelector.active) {
                droneModule.animate();
            }

            // Phase bonus - Livre blanc moderne
            if (phaseJeu === 'bonus_livre') {
                dessinerLivreBonus();
            } else if(jeu || phaseIntro.active) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Syst√®me projectiles stars
                    mettreAJourProjectiles(); // Nouveau syst√®me de projectiles
                    mettreAJourBulle(); // Ancien syst√®me pour les autres phases
                    mettreAJourLaser(); // Laser phase 23
                    
                    // Activation automatique du laser en phase 23
                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                    if (phaseActuelle === 23 && phaseJeu === 'mur') {
                        activerLaser();
                    }
                }
                mettreAJourParticules();

                // Pluie uniquement en phase 5
                if (narrationManager && narrationManager.currentPhase === 5) {
                    creerGouttesPluie();
                    mettreAJourPluie();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                
                // D√©sactiver petits c≈ìurs pour phases 17-23
                const phaseActuelleMaj = narrationManager ? narrationManager.currentPhase : 0;
                if (!(phaseActuelleMaj >= 17 && phaseActuelleMaj <= 23 && phaseJeu === 'mur')) {
                    mettreAJourPetitsCoeurs();
                }
                
                mettreAJourTextesVolants();

                // Corbeau et chauve-souris - toujours v√©rifier
                mettreAJourCorbeau(); // V√©rifie en interne si actif
                if (corbeau.actif) mettreAJourMessageCorbeauBas();
                if (chauveSouris.active) mettreAJourChauveSouris();

                mettreAJourMenuEnigmesCanvas();

                // V√©rification automatique des √©nigmes (r√©duite √† 0.5%)
                if (enigmaCollector && Math.random() < 0.005) {
                    enigmaCollector.verifierCollectionAutomatique();
                }
                mettreAJourEtoileCompteur();

                // √âclairs uniquement en mode nuit
                if (periode === 'nuit') {
                    mettreAJourEclairNuit();
                }

                // Obstacles g√©r√©s par le module secret seulement

                // Objets kawaii r√©serv√©s au mode secret uniquement
                // (Les objets kawaii sont maintenant dans le module secret)
                // Mode secret - d√©sactiv√© en phase finale
                if (phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.update();
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        mettreAJourProjectilesSecret();
                    }
                }
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }

        // D√©marrage avec intro forc√©e
        initJeu();

        // Initialiser le module secret
        initSecretModeModule();

        // FORCER l'intro apr√®s initJeu (car initJeu peut modifier ces valeurs)
        phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        jeu = false; // Important: forcer jeu = false pour permettre l'intro

        // üéØ AFFICHAGE IMM√âDIAT DE L'INTRO (solution radicale)
        setTimeout(() => {
            // üéØ ACTIVER LE TITRE DANS LE CANVAS APR√àS 7 SECONDES
            setTimeout(() => {
                titreVoyage.active = true;
                titreVoyage.texte = getTranslatedText('narrative.phase1.title', 'L\'aube des doutes\nPhase 1');
                titreVoyage.fin = Date.now() + 30000; // Affich√© pendant 30 secondes
            }, 15000); // 15 secondes de d√©lai



            // Code bouton supprim√© pour simplicit√©
            /*afficherMessage(`
                <div style="font-size: 22px; color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); line-height: 1.4;">
                    üåü "On m'a dit qu'ils √©taient tous des monstres...
                    <br>‚ú® On m'a dit tant de mal, tant de malheurs sur eux...
                    <br>üîç Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."
                </div>

                CODE BOUTON COMPLEXE SUPPRIM√â POUR SIMPLICIT√â
            */

            // Affichage direct de l'intro Phase 1 avec bouton passer
            // Utiliser notre syst√®me simple
            afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.intro_full', "On m'a dit qu'ils √©taient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai pr√©f√©r√© aller voir\nde mes propres yeux..."), 12000);

            // Activer le bouton passer pendant l'intro
            boutonPasser.actif = true;

            // D√©sactiver le bouton apr√®s l'intro (m√™me timing que le message narratif)
            setTimeout(() => {
                boutonPasser.actif = false;
            }, 12000);

            // üéØ AFFICHER LE MESSAGE "NON ON PEUT PAS LAISSER PASSER √áA" √Ä LA FIN
            setTimeout(() => {
                afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.reaction', 'NON on peut pas laisser passer √ßa !'), 3000);

                // üåßÔ∏è Pluie √©motionnelle IMM√âDIATE pendant le message
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();

                    // üåßÔ∏è Deuxi√®me vague de pluie plus intense 1 seconde apr√®s
                    setTimeout(() => {
                        declencherPluieLumineuse();
                    }, 1000);
                } else {
                    console.error('‚ùå Fonction declencherPluieLumineuse non trouv√©e !');
                }
            }, 12000); // √Ä la fin de l'intro (12 secondes)

            // üéØ D√âCLENCHER LA R√âCOMPENSE 100 POINTS APR√àS LE MESSAGE ET ACTIVER LE JEU
            setTimeout(async () => {

                // Attendre que les traductions soient charg√©es
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                try {
                    if (phaseJeu === 'tir_coeurs_haut') {
                        //
                        pointsConnaissance += 100;
                        //
                    } else {
                        //
                        score += 100;
                        //
                    }

                    // Message simple
                    afficherMessagePowerupSimple(getTranslatedText('game.messages.intro_points', 'üåü +100 Points intro compl√®te'));
                } catch (error) {
                    console.error('‚ùå Erreur lors de l\'attribution points intro:', error);
                }

                // üéÆ FORCER L'ACTIVATION DU JEU APR√àS L'INTRO
                phaseIntro.active = false;
                jeu = true;

                // üé¨ CR√âER LES PETITS C≈íURS POUR LA PHASE 1
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();
                creerPetitsCoeurs();
            }, 15000); // D√©clencher apr√®s le message NON (12000ms + 3000ms)

        }, 500); // Attendre 0.5 seconde pour √™tre s√ªr que l'interface est pr√™te

        // === RACCOURCIS TEST ===
        document.addEventListener('keydown', (e) => {
            // Ne pas intercepter les touches si on est dans un input/textarea/select
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            if (e.key === 'F1') {
                e.preventDefault();
                narrationManager.showFinalMenu();
            }

            // Touche 1 pour aller directement √† la phase 11
            if (e.key === '1') {
                e.preventDefault();
                narrationManager.currentPhase = 11;
                narrationManager.goToNextPhase();
            }

            // Touche 2 pour passer √† la phase suivante
            if (e.key === '2') {
                e.preventDefault();
                narrationManager.goToNextPhase();
            }

            // Touche M pour menu final
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                narrationManager.showFinalMenu();
            }

            // Touche J x7 pour activer le mini-jeu "Briser les Fronti√®res"
            if (e.key === 'j' || e.key === 'J') {
                e.preventDefault();

                if (!window.jKeyPresses) {
                    window.jKeyPresses = [];
                }

                const now = Date.now();
                window.jKeyPresses.push(now);

                // Garder seulement les pressions des derni√®res 3 secondes
                window.jKeyPresses = window.jKeyPresses.filter(time => now - time < 3000);

                // Si 7 pressions rapides
                if (window.jKeyPresses.length >= 7) {
                    window.jKeyPresses = [];
                    briqueLangue.active = true;
                    briqueLangue.game = null; // R√©initialiser pour cr√©er un nouveau jeu
                    afficherMessagePowerupSimple(getTranslatedText('game.messages.frontier_mode', 'üß± Mode Fronti√®res activ√© !'));
                }
            }
        });

        // === ANCIEN SYST√àME NARRATION SUPPRIM√â ===
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let phaseAvantSecret = null; // Sauvegarder la phase avant le mode secret
        let modeEtoileLance = false; // Pour tracker si on est en mode √©toile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        // anciens messages supprim√©s

        // Fonction supprim√©e

        // Fonctions supprim√©es

        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Ne pas intercepter les touches si on est dans un input/textarea/select
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            // Touche ESC pour fermer les menus
            if (e.key === 'Escape') {
                e.preventDefault();
                if (menuEnigmesCanvas.visible) {
                    fermerMenuEnigmesCanvas();
                }
            }

            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer √† la phase suivante (d√©sactiv√©)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprim√©e pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Touche 3 pour aller √† la phase 20
            if(e.key === '3') {
                e.preventDefault();
                if (narrationManager) {
                    narrationManager.currentPhase = 20;
                    narrationManager.start();
                }
            }

            // Touche S pour recommencer la phase
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                if (narrationManager) {
                    narrationManager.restart();
                } else {
                    recommencer();
                }
            }

            // Touche N pour niveau secret
            if(e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Touche R pour recommencer UNIQUEMENT la phase actuelle (pas depuis le d√©but)
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                if (narrationManager && narrationManager.restart) {
                    // Red√©marrer juste la phase en cours
                    narrationManager.restart();
                }
            }

            // üéÜ TEST : Touche X pour tester l'animation d'explosion
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                animerExplosionIconeCollector(() => {
                });
            }

            // üîÑ RESET : Touche Z pour r√©initialiser √† z√©ro
            if(e.key === 'z' || e.key === 'Z') {
                e.preventDefault();

                // Effacer toutes les donn√©es localStorage
                localStorage.removeItem('vdv_enigmes_collectees');
                localStorage.removeItem('petit_bateau_progression');
                localStorage.removeItem('vdv_gameState');

                // Recharger la page
                location.reload();
            }

            // üåßÔ∏è PLUIE : Touche P pour d√©clencher pluie de traits lumineux
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }

            // Mode passe : Touche E pour tir automatique √©toiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

            // Cheat code : Touche X pour multiplier puissance x10
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                if (multiplicateurPuissance === 1) {
                    multiplicateurPuissance = 10;
                } else {
                    multiplicateurPuissance = 1;
                }
            }

            // Cheat code : Touche C pour casser TOUT instantan√©ment
            if(e.key === 'c' || e.key === 'C') {
                e.preventDefault();

                // Casser toutes les briques
                if (briques && briques.length > 0) {
                    const nbBriques = briques.length;
                    briques.forEach(brique => {
                        if (brique.visible) {
                            brique.visible = false;
                            brises++;
                            score += 100;
                            // Particules d'explosion
                            for(let i = 0; i < 3; i++) {
                                particules.push({
                                    x: brique.x + brique.w/2,
                                    y: brique.y + brique.h/2,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -(Math.random() * 3 + 2),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 2,
                                    type: 'coeur'
                                });
                            }
                        }
                    });
                    briques = briques.filter(b => b.visible);
                    window.score = score;
                }

                // Casser tous les petits c≈ìurs d√©coratifs
                if (petitsCoeurs && petitsCoeurs.length > 0) {
                    const nbCoeurs = petitsCoeurs.length;
                    petitsCoeurs.forEach(coeur => {
                        score += 50;
                        // Particules
                        for(let i = 0; i < 2; i++) {
                            particules.push({
                                x: coeur.x,
                                y: coeur.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -(Math.random() * 2 + 1),
                                couleur: coeur.couleur,
                                vie: 1,
                                taille: Math.random() * 2 + 1,
                                type: 'coeur'
                            });
                        }
                    });
                    petitsCoeurs = [];
                    window.score = score;
                }

                afficherMessageNarratifSimple(getTranslatedText('game.messages.all_broken', 'üí• TOUT CASS√â ! üí•'), 2000);

                // V√©rifier la fin de niveau apr√®s le cheat
                setTimeout(() => {
                    const briquesRestantes = briques.filter(b => b.visible).length;
                    const coeursRestants = petitsCoeurs.filter(c => c.visible).length;

                    // Si tout est d√©truit, d√©clencher la fin du niveau
                    if (briquesRestantes === 0 && coeursRestants === 0) {
                        // üåà EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collect√© !
                        const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                        if (phaseActuelle === 22 && phaseJeu === 'mur') {
                            const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                            if (espoirPresent) {
                                console.log('üåà Phase 22 : Cheat utilis√© mais power-up ESPOIR pas encore collect√© !');
                                return; // ‚Üê Sortir sans animation
                            }
                        }

                        // Animation d'explosion et passage √† la phase suivante
                        if (typeof animerExplosionIconeCollector === 'function') {
                            animerExplosionIconeCollector(() => {
                                if (narrationManager && typeof narrationManager.goToNextPhaseDirect === 'function') {
                                    narrationManager.goToNextPhaseDirect();
                                }
                            });
                        }
                    }
                }, 100);
            }

        });

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            // Bloquer en phases 1 et 2
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle === 1 || phaseActuelle === 2) {
                console.log('üö´ Mode secret bloqu√© en phases 1 et 2');
                afficherMessagePowerupSimple(getTranslatedText('game.messages.bird_no', 'üê¶ NON !'));
                return;
            }

            // D√©sactiver les objets kawaii pendant le mode secret
            desactiverObjetsKawaii();

            // Utiliser le module si disponible, sinon le syst√®me int√©gr√©
            if (secretModeModule) {
                secretModeModule.activate();
                return;
            }

            // Fallback vers l'ancien syst√®me
            // Sauvegarder la phase actuelle
            phaseAvantSecret = phaseJeu;

            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = []; // R√©initialiser les obstacles pour le fallback

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Mode secret utilise maintenant le module secret - pas d'obstacles de fallback

            afficherMessageAnime(getTranslatedText('game.messages.secret_mode', 'üéØ Mode Secret : Tir de Pr√©cision üéØ\n\nüßä Tirez sur les icebergs et poubelles ‚ôª\nüêã Les baleines sont prot√©g√©es !\nüö´ Tirer sur une baleine = perte de vie\nüëÜ Chaque clic = un tir pr√©cis\nüí∞ +100 points par obstacle d√©truit'), 5000, 'glitch', 50);
        }



        function creerProjectile() {
            // Cr√©er un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // V√©rifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle d√©j√† touch√©

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision d√©tect√©e !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine prot√©g√©e ! Perdre une vie
                            vies--;

                            // Messages amusants vari√©s
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                // Restaurer la phase d'origine m√™me en Game Over
                                if (phaseAvantSecret) {
                                    phaseJeu = phaseAvantSecret;
                                    phaseAvantSecret = null;
                                } else {
                                    phaseJeu = 'briques'; // Fallback par d√©faut
                                }

                                // R√©activer les objets kawaii apr√®s Game Over
                                activerObjetsKawaii();

                                afficherMessageAvecBoutons(`üíÄ ${messageAleatoire} üíÄ\n\nüêã Tu as tir√© sur une baleine prot√©g√©e !\nüò± Toutes tes vies sont √©puis√©es !\nüö´ Les baleines ne se tirent pas !\nü§™ HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `üö´ ${messageAleatoire} üö´\n\nüêã Les baleines sont prot√©g√©es !\nüíî Vie perdue : ${vies} restantes\nüò§ Tire seulement sur les icebergs !\nüôÑ TSSS TSSS!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã BALEINE = INTERDITE !\nüíî Oups : ${vies} vies restantes\nüò§ ICEBERGS SEULEMENT !\nü§¶‚Äç‚ôÇÔ∏è PFFFFFF!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã PAUVRE BALEINE !\nüíî Punition : ${vies} vies left\nüò§ GLACE = OK, BALEINE = NON !\nüòÇ HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (col√®re)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK √† d√©truire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle d√©truit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succ√®s)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touch√© temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // SUPPRIM√â: creerObstaclesMarins() - remplac√© par le module secret

        // SUPPRIM√â: mettreAJourObstacles() - remplac√© par le module secret

        // SUPPRIM√â: Module obstacles legacy - remplac√© par le module secret

        // SUPPRIM√â: dessinerObstacles() - remplac√© par le module secret

        // L'animation d√©marre automatiquement via gererAnimationBateau()
        window.addEventListener('load', async function() {

            // Initialiser le module i18n en premier
            if (window.i18n) {
                console.log('üåç Initialisation du module i18n...');
                await window.i18n.init();
                console.log('üåç Module i18n initialis√© avec succ√®s');
                
                // Synchroniser la langue actuelle
                currentLang = window.i18n.getCurrentLanguage();
                console.log(`üåç Langue actuelle: ${currentLang}`);
                
                // Forcer le chargement des traductions si ce n'est pas le fran√ßais
                if (currentLang !== 'fr') {
                    await window.i18n.loadLanguage(currentLang);
                    console.log(`üåç Traductions ${currentLang} charg√©es`);
                }
            } else {
                console.warn('‚ö†Ô∏è Module i18n non disponible, utilisation du fran√ßais par d√©faut');
                currentLang = 'fr';
            }

            // Initialiser les tableaux de briques
            if (JOUR.length === 0 || NUIT.length === 0) {
                initializeBrickArrays();
            }

            // Attente pour s'assurer que tout est initialis√©
            setTimeout(() => {
                console.log('üéÆ D√©marrage de la boucle de jeu');
                boucleJeu();
            }, 500);
        });
    </script>


<div id="info-artist-container" style="position: fixed; top: 0px; left: 0px; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgb(26, 26, 46), rgb(22, 33, 62), rgb(15, 52, 96)); overflow-y: auto; padding: 20px; z-index: 10000; display: none; font-family: Georgia, serif; color: rgb(255, 255, 255);">
    <div class="module-container">

        
        <div class="header">
            <h1 class="main-title pulse">Emmanuel Payet</h1>
            <p class="subtitle">Artiste Chr√©tien ‚Ä¢ Cr√©ateur ‚Ä¢ Inspirateur</p>
        </div>

        <div class="platforms-grid">
            <div class="platform-card" style="opacity: 0; transform: translateY(30px); transition: opacity 0.6s, transform 0.6s;">
                <div class="platform-icon gallery-icon" style="transition: transform 0.6s;">‚óÜ</div>
                <h3 class="platform-title">Jeux &amp; D√©co</h3>
                <p class="platform-description">D√©couvre mes cr√©ations visuelles, jeux interactifs et d√©corations artistiques qui c√©l√®brent la foi et la beaut√©.</p>
                <a href="https://emmanuel.gallery/" class="platform-url" target="_blank">emmanuel.gallery</a>
            </div>

            <div class="platform-card" style="opacity: 0; transform: translateY(30px); transition: opacity 0.6s 0.2s, transform 0.6s 0.2s;">
                <div class="platform-icon art-icon" style="transition: transform 0.6s;">‚ñ≤</div>
                <h3 class="platform-title">Livres &amp; Art</h3>
                <p class="platform-description">Plonge dans mes ≈ìuvres litt√©raires et artistiques, cr√©√©es avec ma fille B√©thanie, pour nourrir l'√¢me et l'esprit.</p>
                <a href="https://emmanuelpayet.art/" class="platform-url" target="_blank">emmanuelpayet.art</a>
            </div>

            <div class="platform-card" style="opacity: 0; transform: translateY(30px); transition: opacity 0.6s 0.4s, transform 0.6s 0.4s;">
                <div class="platform-icon music-icon" style="transition: transform 0.6s;">‚óè</div>
                <h3 class="platform-title">Gospel Gratuit</h3>
                <p class="platform-description">√âcoute mes compositions gospel sur AudioMack, des m√©lodies qui louent Dieu et inspirent l'unit√© dans la diversit√©.</p>
                <a href="https://audiomack.com/emmanuelpayet888" class="platform-url" target="_blank">AudioMack - emmanuelpayet888</a>
            </div>

            <div class="platform-card" style="opacity: 0; transform: translateY(30px); transition: opacity 0.6s 0.6s, transform 0.6s 0.6s;">
                <div class="platform-icon shop-icon" style="transition: transform 0.6s;">‚ñ†</div>
                <h3 class="platform-title">La Bonne Heure</h3>
                <p class="platform-description">C'est maintenant ! D√©couvre ma boutique Redbubble avec des designs uniques et des cr√©ations inspirantes √† porter.</p>
                <a href="https://www.redbubble.com/fr/people/h777plx/shop" class="platform-url" target="_blank">Redbubble Shop</a>
            </div>
        </div>

        <div class="inspiring-quote">
            L'art chr√©tien unit les c≈ìurs au-del√† des diff√©rences, 
c√©l√©brant la beaut√© de la cr√©ation divine dans toute sa diversit√©.
        </div>
        
        <div style="text-align: center; margin-top: 20px; font-size: 0.8em; color: #95a5a6; font-style: italic;">
            Cod√© par Claude ‚Ä¢ Id√©e originale Emmanuel Payet
        </div>
    </div>

    <script>
        // Animation au scroll pour les cartes
        const cards = document.querySelectorAll('.platform-card');
        
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);

        cards.forEach((card, index) => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(30px)';
            card.style.transition = `opacity 0.6s ease ${index * 0.2}s, transform 0.6s ease ${index * 0.2}s`;
            observer.observe(card);
        });

        // Animation des ic√¥nes au survol
        cards.forEach(card => {
            const icon = card.querySelector('.platform-icon');
            
            card.addEventListener('mouseenter', () => {
                icon.style.transform = 'rotateY(180deg)';
            });
            
            card.addEventListener('mouseleave', () => {
                icon.style.transform = 'rotateY(0deg)';
            });
            
            icon.style.transition = 'transform 0.6s ease';
        });
    </script>

</div><div id="info-artist-container" style="position: fixed; top: 0px; left: 0px; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgb(26, 26, 46), rgb(22, 33, 62), rgb(15, 52, 96)); overflow-y: auto; padding: 20px; z-index: 10000; display: none; font-family: Georgia, serif; color: rgb(255, 255, 255);">
    <div class="module-container">

        
        <div class="header">
            <h1 class="main-title pulse">Emmanuel Payet</h1>
            <p class="subtitle">Artiste Chr√©tien ‚Ä¢ Cr√©ateur ‚Ä¢ Inspirateur</p>
        </div>

        <div class="platforms-grid">
            <div class="platform-card">
                <div class="platform-icon gallery-icon">‚óÜ</div>
                <h3 class="platform-title">Jeux &amp; D√©co</h3>
                <p class="platform-description">D√©couvre mes cr√©ations visuelles, jeux interactifs et d√©corations artistiques qui c√©l√®brent la foi et la beaut√©.</p>
                <a href="https://emmanuel.gallery/" class="platform-url" target="_blank">emmanuel.gallery</a>
            </div>

            <div class="platform-card">
                <div class="platform-icon art-icon">‚ñ≤</div>
                <h3 class="platform-title">Livres &amp; Art</h3>
                <p class="platform-description">Plonge dans mes ≈ìuvres litt√©raires et artistiques, cr√©√©es avec ma fille B√©thanie, pour nourrir l'√¢me et l'esprit.</p>
                <a href="https://emmanuelpayet.art/" class="platform-url" target="_blank">emmanuelpayet.art</a>
            </div>

            <div class="platform-card">
                <div class="platform-icon music-icon">‚óè</div>
                <h3 class="platform-title">Gospel Gratuit</h3>
                <p class="platform-description">√âcoute mes compositions gospel sur AudioMack, des m√©lodies qui louent Dieu et inspirent l'unit√© dans la diversit√©.</p>
                <a href="https://audiomack.com/emmanuelpayet888" class="platform-url" target="_blank">AudioMack - emmanuelpayet888</a>
            </div>

            <div class="platform-card">
                <div class="platform-icon shop-icon">‚ñ†</div>
                <h3 class="platform-title">La Bonne Heure</h3>
                <p class="platform-description">C'est maintenant ! D√©couvre ma boutique Redbubble avec des designs uniques et des cr√©ations inspirantes √† porter.</p>
                <a href="https://www.redbubble.com/fr/people/h777plx/shop" class="platform-url" target="_blank">Redbubble Shop</a>
            </div>
        </div>

        <div class="inspiring-quote">
            L'art chr√©tien unit les c≈ìurs au-del√† des diff√©rences, 
c√©l√©brant la beaut√© de la cr√©ation divine dans toute sa diversit√©.
        </div>
        
        <div style="text-align: center; margin-top: 20px; font-size: 0.8em; color: #95a5a6; font-style: italic;">
            Cod√© par Claude ‚Ä¢ Id√©e originale Emmanuel Payet
        </div>
    </div>

</div>

<!-- PWA Service Worker -->
<script>
    // Enregistrement du Service Worker pour PWA
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then(registration => {
                    console.log('‚úÖ Service Worker enregistr√©:', registration.scope);
                    
                    // V√©rifier les mises √† jour
                    registration.addEventListener('updatefound', () => {
                        console.log('üîÑ Mise √† jour disponible');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // Nouvelle version disponible avec nouvelles ic√¥nes
                                const updateMessage = 'üé® Nouvelle version disponible avec des ic√¥nes am√©lior√©es !\n\n' +
                                                     '‚ú® Nouvelles ic√¥nes optimis√©es\n' +
                                                     'üîß Am√©liorations PWA\n\n' +
                                                     'Voulez-vous mettre √† jour maintenant ?';
                                
                                if (confirm(updateMessage)) {
                                    newWorker.postMessage({type: 'SKIP_WAITING'});
                                    window.location.reload();
                                } else {
                                    // Afficher un bouton de mise √† jour dans le jeu
                                    showUpdateBanner();
                                }
                            }
                        });
                    });
                })
                .catch(error => {
                    console.log('‚ùå Erreur Service Worker:', error);
                });
        });

        // √âcouter les changements de contr√¥leur
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            window.location.reload();
        });
    }

    // G√©rer l'√©v√©nement beforeinstallprompt pour personnaliser l'installation
    let deferredPrompt;

    // √âcouter les changements de langue pour mettre √† jour l'affichage
    window.addEventListener('languageChanged', (event) => {
        console.log('üåç Langue chang√©e vers:', event.detail.language);
        // L'affichage sera automatiquement mis √† jour au prochain render du menu
    });
    window.addEventListener('beforeinstallprompt', (e) => {
        console.log('üîß PWA installable d√©tect√©e');
        e.preventDefault();
        deferredPrompt = e;
        
        // Optionnel: Afficher un bouton d'installation personnalis√©
        // showInstallButton();
    });

    // D√©tecter si l'app est install√©e
    window.addEventListener('appinstalled', (evt) => {
        console.log('üéâ PWA install√©e avec succ√®s');
        deferredPrompt = null;
    });

    // Fonction pour d√©clencher l'installation (optionnelle)
    function installPWA() {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((result) => {
                if (result.outcome === 'accepted') {
                    console.log('‚úÖ Utilisateur a accept√© l\'installation');
                } else {
                    console.log('‚ùå Utilisateur a refus√© l\'installation');
                }
                deferredPrompt = null;
            });
        }
    }

    // Fonction pour afficher un banner de mise √† jour
    function showUpdateBanner() {
        const banner = document.createElement('div');
        banner.id = 'update-banner';
        banner.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(45deg, #4169E1, #1E90FF);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            animation: slideDown 0.5s ease-out;
        `;
        
        banner.innerHTML = `
            üé® Nouvelle version avec ic√¥nes am√©lior√©es disponible !
            <button onclick="updateApp()" style="
                background: white; 
                color: #4169E1; 
                border: none; 
                padding: 8px 16px; 
                margin-left: 15px; 
                border-radius: 20px; 
                font-weight: bold; 
                cursor: pointer;
            ">Mettre √† jour</button>
            <button onclick="hideUpdateBanner()" style="
                background: transparent; 
                color: white; 
                border: 1px solid white; 
                padding: 8px 16px; 
                margin-left: 10px; 
                border-radius: 20px; 
                cursor: pointer;
             data-i18n="ui.buttons.later">Plus tard</button>
        `;
        
        // Ajouter animation CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateY(-100%); }
                to { transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(banner);
    }

    function updateApp() {
        window.location.reload();
    }

    function hideUpdateBanner() {
        const banner = document.getElementById('update-banner');
        if (banner) {
            banner.style.animation = 'slideDown 0.5s ease-out reverse';
            setTimeout(() => banner.remove(), 500);
        }
    }
</script>

</body></html>
