<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- 🔄 FORCER LE NO-CACHE POUR LES TRADUCTIONS -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- SEO Meta Tags Français -->
    <title>Petit Bateau Rouge ⛵ - Jeu d'Énigmes Poétique par Emmanuel Payet</title>
    <meta name="description" content="Découvrez Petit Bateau Rouge, un jeu d'énigmes philosophique et poétique créé par Emmanuel Payet. Naviguez à travers 14 langues dans un univers où chaque énigme révèle une vérité sur l'humanité. Objectif : 33 millions de joueurs !">
    <meta name="keywords" content="jeu d'énigmes, petit bateau rouge, Emmanuel Payet, jeu philosophique, énigmes poétiques, multilingue, 14 langues, créole réunionnais, jeu français, puzzle game, dreamer unisona, unispourlapaix">
    <meta name="author" content="Emmanuel Payet - Dreamer Unisona">
    <meta name="robots" content="index, follow">
    <meta name="language" content="French">
    <meta name="revisit-after" content="7 days">
    <meta name="distribution" content="global">
    <meta name="rating" content="general">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://unispourlapaix.github.io/petitbateau/">
    <meta property="og:title" content="Petit Bateau Rouge ⛵ - Jeu d'Énigmes Poétique">
    <meta property="og:description" content="Un voyage philosophique à travers les énigmes de l'humanité. Créé par Emmanuel Payet, disponible en 14 langues. Objectif : 33 millions de joueurs !">
    <meta property="og:image" content="https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:site_name" content="Petit Bateau Rouge">
    <meta property="og:locale" content="fr_FR">
    <meta property="og:locale:alternate" content="en_US">
    <meta property="og:locale:alternate" content="es_ES">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://unispourlapaix.github.io/petitbateau/">
    <meta name="twitter:title" content="Petit Bateau Rouge ⛵ - Jeu d'Énigmes Poétique">
    <meta name="twitter:description" content="Un voyage philosophique à travers les énigmes de l'humanité. Créé par Emmanuel Payet, disponible en 14 langues.">
    <meta name="twitter:image" content="https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png">
    <meta name="twitter:creator" content="@unispourlapaix">
    
    <!-- Liens Canoniques et Alternatives -->
    <link rel="canonical" href="https://unispourlapaix.github.io/petitbateau/">
    <link rel="alternate" hreflang="fr" href="https://unispourlapaix.github.io/petitbateau/?lang=fr">
    <link rel="alternate" hreflang="en" href="https://unispourlapaix.github.io/petitbateau/?lang=en">
    <link rel="alternate" hreflang="es" href="https://unispourlapaix.github.io/petitbateau/?lang=es">
    <link rel="alternate" hreflang="de" href="https://unispourlapaix.github.io/petitbateau/?lang=de">
    <link rel="alternate" hreflang="x-default" href="https://unispourlapaix.github.io/petitbateau/">
    
    <!-- JSON-LD Schema.org -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Petit Bateau Rouge",
      "description": "Jeu d'énigmes philosophique et poétique créé par Emmanuel Payet, disponible en 14 langues",
      "author": {
        "@type": "Person",
        "name": "Emmanuel Payet",
        "url": "https://emmanuelpayet.art",
        "sameAs": [
          "https://emmanuel.gallery",
          "https://www.tiktok.com/@unispourlapaix",
          "https://audiomack.com/emmanuelpayet888"
        ]
      },
      "genre": "Puzzle",
      "gamePlatform": ["Web Browser", "Mobile", "Desktop"],
      "inLanguage": ["fr", "en", "es", "de", "it", "pt", "ru", "zh", "ko", "ja", "ar", "he", "uk", "rc"],
      "url": "https://unispourlapaix.github.io/petitbateau/",
      "image": "https://unispourlapaix.github.io/petitbateau/icons/icon-512x512.png",
      "publisher": {
        "@type": "Organization",
        "name": "UnisPourLaPaix",
        "url": "https://github.com/unispourlapaix"
      },
      "datePublished": "2025-10-12",
      "applicationCategory": "Game",
      "operatingSystem": "Web Browser"
    }
    </script>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#ff6b6b">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Petit Bateau Rouge">
    <meta name="msapplication-TileColor" content="#ff6b6b">
    <meta name="msapplication-TileImage" content="./icons/icon-144x144.png">
    
    <!-- 🔒 Forcer orientation portrait -->
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="full-screen" content="yes">
    <meta name="x5-fullscreen" content="true">
    
    <!-- Firefox PWA Support -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Petit Bateau Rouge">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Icons -->
    <link rel="icon" href="data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'&gt;&lt;text y='0.9em' font-size='90'&gt;🚣&lt;/text&gt;&lt;/svg&gt;">
    <link rel="apple-touch-icon" href="./icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="192x192" href="./icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-72x72.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-72x72.png">
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; 
            min-height: -webkit-fill-available; /* iOS fix */
            width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
            position: fixed; /* Empêche le scroll sur mobile */
        }

        .game-container {
            position: relative;
            width: 100vw; 
            width: 100dvw; /* Dynamic viewport for mobile */
            height: 100vh;
            height: 100dvh; /* Dynamic viewport for mobile */
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
        
        /* Optimisation mobile - Plein écran natif */
        @media (max-width: 499px) {
            body {
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            .game-container {
                width: 100vw;
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            #gameCanvas {
                max-width: 100%;
                max-height: 100%;
            }
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: transparent;
            backdrop-filter: none; -webkit-backdrop-filter: none;
            border: none;
            border-radius: 0; padding: 25px 113px;
            box-shadow: none;
            max-width: none; width: 100%; text-align: center; z-index: 200;
            display: none; font-size: clamp(21px, 5.25vw, 24px); color: #ffffff;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow:
                0 0 2px rgba(0,0,0,0.8),
                1px 1px 2px rgba(0,0,0,0.6);
        }

        .message.show {
            display: block;
        }

        /* Messages narratifs - style cinématique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: transparent;
            border: none;
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow:
                0 0 10px rgba(0,0,0,1),
                2px 2px 6px rgba(0,0,0,0.95),
                4px 4px 12px rgba(0,0,0,0.8),
                6px 6px 20px rgba(0,0,0,0.6);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: none; width: 100%;
                font-size: clamp(21px, 2.7vw, 24px);
                padding: 20px 113px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Indicateur d'étape */
        .etape-indicateur {
            display: none !important;
        }

        .etape-indicateur.show {
            display: block;
        }

        /* Animation shake pour le bouton skip */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes etapeGlow {
            0% {
                box-shadow:
                    0 4px 15px rgba(0,0,0,0.3),
                    0 0 20px rgba(77,166,255,0.2),
                    inset 0 1px 1px rgba(255,255,255,0.1);
            }
            100% {
                box-shadow:
                    0 4px 20px rgba(0,0,0,0.4),
                    0 0 30px rgba(77,166,255,0.5),
                    inset 0 1px 1px rgba(255,255,255,0.2);
            }
        }
        
        /* Message d'orientation 100% VISUEL - Fond blanc, juste ↻ */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #ffffff;
            z-index: 10000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            text-align: center;
            padding: 20px;
        }
        
        /* Animation de rotation du téléphone */
        @keyframes rotate-pulse {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(90deg) scale(1.1); }
        }
        
        /* 🔒 BLOQUER MODE PAYSAGE SUR MOBILE UNIQUEMENT - FORCER PORTRAIT */
        @media (max-width: 768px) and (orientation: landscape) {
            .orientation-warning {
                display: flex !important;
                z-index: 9999 !important;
                background: #ffffff !important;
            }
            
            .game-container {
                display: none !important;
            }
            
            /* Bloquer aussi le scroll en paysage */
            body, html {
                overflow: hidden !important;
            }
        }
        
        /* Double sécurité : si très petit écran en paysage (mobile seulement) */
        @media (max-width: 768px) and (max-height: 500px) and (orientation: landscape) {
            .orientation-warning {
                display: flex !important;
                z-index: 9999 !important;
            }
            
            .game-container {
                display: none !important;
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* Bouton Installation PWA */
        #install-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            cursor: pointer;
            z-index: 10001;
            display: none;
            transition: all 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            pointer-events: auto;
        }

        #install-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        #install-button:active {
            transform: translateY(0);
        }

        #install-button::before {
            content: '📥 ';
            font-size: 16px;
        }

        /* Sur mobile, adapter la position */
        @media (max-width: 768px) {
            #install-button {
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 13px;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════ */
        /* 🎬 STYLES TEXTANIMATOR OPTIMISÉ */
        /* ═══════════════════════════════════════════════════════════════════ */

        .text-animator-display {
            font-size: 1.2em;
            line-height: 1.6;
            background: transparent;
        }

        /* Animations de base */
        .ta-typewriter { border-right: 2px solid #ffffff; animation: ta-blink 1s infinite; }
        .ta-digital { color: #00cc44; text-shadow: 0 0 8px #00cc44; font-family: 'Courier New', monospace; letter-spacing: 2px; }
        .ta-fade-in { animation: ta-fadeIn 1s ease-in; }
        .ta-glitch { position: relative; color: #fff; animation: ta-glitch 2s infinite; }

        /* Effets 3D optimisés */
        .ta-effect-shadow3d { text-shadow: 2px 2px 0px var(--ta-effect-color, #64ffda), 4px 4px 0px rgba(0,0,0,0.5), 6px 6px 10px rgba(0,0,0,0.8); }
        .ta-effect-neon { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda), 0 0 80px var(--ta-effect-color, #64ffda); animation: ta-neonPulse 2s ease-in-out infinite alternate; }
        .ta-effect-emboss { text-shadow: 1px 1px 0px var(--ta-effect-color, #64ffda), -1px -1px 0px rgba(0,0,0,0.8), 2px 2px 5px rgba(0,0,0,0.6); color: var(--ta-text-color, #fff); }
        .ta-effect-outline { text-shadow: -2px -2px 0 var(--ta-effect-color, #64ffda), 2px -2px 0 var(--ta-effect-color, #64ffda), -2px 2px 0 var(--ta-effect-color, #64ffda), 2px 2px 0 var(--ta-effect-color, #64ffda), 0 0 10px rgba(0,0,0,0.5); }
        .ta-effect-fire { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; animation: ta-fireFlicker 1.5s ease-in-out infinite alternate; }
        .ta-effect-ice { background: linear-gradient(45deg, #87ceeb, #add8e6, #e0ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); animation: ta-iceShimmer 3s ease-in-out infinite; }

        /* Keyframes optimisées */
        @keyframes ta-blink { 0%, 50% { border-color: transparent; } 51%, 100% { border-color: #ffffff; } }
        @keyframes ta-fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes ta-glitch { 0%, 100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000; transform: translate(0); } 20% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; transform: translate(-2px, 2px); } 40% { text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff; transform: translate(-2px, -2px); } 60% { text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; transform: translate(2px, 2px); } 80% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff; transform: translate(2px, -2px); } }
        @keyframes ta-neonPulse { from { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda); } to { text-shadow: 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-text-color, #fff), 0 0 30px var(--ta-effect-color, #64ffda), 0 0 60px var(--ta-effect-color, #64ffda), 0 0 100px var(--ta-effect-color, #64ffda); } }
        @keyframes ta-fireFlicker { 0%, 100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; } 50% { text-shadow: 0 0 5px #ff4500, 0 0 15px #ff8c00, 0 0 25px #ffd700, 0 0 35px #ff4500; } }
        @keyframes ta-iceShimmer { 0%, 100% { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); } 50% { text-shadow: 1px 1px 3px rgba(0,0,0,1); } }
        /* ===========================================
           MODULE OISEAUX VOLANTS - INTÉGRATION
           Par Emmanuel Payet / Dreamer Unisona
           ========================================== */

        /* Variables CSS pour le module oiseaux */
        :root {
            --bird-scale: 1;
            --animation-speed: 1;
            --crow-color: #1A1A1A;
            --dove-color: #FFFFFF;
            --bat-color: #000000;
        }

        /* Container pour oiseaux sur canvas */
        .flying-birds-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 150;
        }

        /* Base commune pour tous les oiseaux */
        .bird-base {
            position: absolute;
            left: 0;
            top: 0;
            transform-origin: center;
            pointer-events: auto;
            transition: opacity 0.3s ease;
            cursor: pointer;
            will-change: transform; /* Optimisation GPU */
        }

        /* États de visibilité */
        .bird-hidden {
            opacity: 0;
        }


        .bird-visible {
            opacity: 1;
        }

        /* CORBEAU BADASS - ID: crow */
        #crow {
            width: 45px;
            height: 30px;
            background: linear-gradient(135deg, var(--crow-color), #000000);
            clip-path: polygon(10% 15%, 25% 0%, 75% 5%, 90% 25%, 95% 60%, 85% 90%, 15% 95%, 5% 70%);
            animation: crow-auto-flight calc(2s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* Aile du corbeau */
        #crow::before {
            content: '';
            position: absolute;
            width: 28px;
            height: 18px;
            background: linear-gradient(45deg, #4A4A4A, #2F2F2F, #1A1A1A);
            clip-path: polygon(0% 20%, 30% 0%, 70% 5%, 100% 30%, 90% 70%, 60% 100%, 20% 85%, 5% 50%);
            top: 5px;
            left: 2px;
            z-index: -1;
            animation: crow-wing-beat calc(0.15s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        /* Œil rouge du corbeau */
        #crow::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 5px;
            background: linear-gradient(135deg, #FF0000, #8B0000);
            clip-path: polygon(0% 40%, 30% 0%, 100% 20%, 80% 100%, 20% 80%);
            top: 9px;
            right: 8px;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
            animation: crow-evil-glow calc(1.5s / var(--animation-speed)) infinite;
        }

        /* COLOMBE ÉLÉGANTE - ID: dove */
        #dove {
            width: 40px;
            height: 25px;
            background: linear-gradient(135deg, var(--dove-color), #F8F8FF, #E6E6FA);
            clip-path: polygon(15% 10%, 40% 0%, 85% 8%, 95% 35%, 90% 65%, 75% 90%, 25% 95%, 5% 60%, 10% 30%);
            animation: dove-auto-flight calc(3s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.15));
        }

        /* Aile de la colombe */
        #dove::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 12px;
            background: linear-gradient(45deg, #F8F8FF, #E6E6FA, #D6D6EA);
            clip-path: polygon(0% 30%, 25% 0%, 60% 5%, 85% 15%, 100% 40%, 95% 70%, 75% 100%, 40% 95%, 15% 85%, 5% 60%);
            top: 6px;
            left: 6px;
            z-index: -1;
            animation: dove-wing-beat calc(0.4s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.2));
        }

        /* Œil bleu de la colombe */
        #dove::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle at 30% 30%, #87CEEB, #4169E1);
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            top: 8px;
            right: 8px;
            box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
            animation: dove-sparkle calc(3s / var(--animation-speed)) infinite;
        }

        /* ANIMATIONS DU MODULE */
        @keyframes crow-auto-flight {
            0%, 100% {
                transform: translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: translateY(-15px) rotate(2deg) scale(var(--bird-scale));
            }
            50% {
                transform: translateY(-8px) rotate(-1deg) scale(var(--bird-scale));
            }
            75% {
                transform: translateY(-20px) rotate(1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-auto-flight-left {
            0%, 100% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(0px) rotate(0deg);
            }
            25% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-15px) rotate(-2deg);
            }
            50% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-8px) rotate(1deg);
            }
            75% {
                transform: scale(calc(-1 * var(--bird-scale)), var(--bird-scale)) translateY(-20px) rotate(-1deg);
            }
        }

        @keyframes crow-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-15deg) scaleX(1);
            }
            100% {
                transform: rotateY(-20deg) rotateZ(10deg) scaleX(1.1);
            }
        }

        @keyframes crow-evil-glow {
            0%, 100% {
                box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 0, 0, 1);
                filter: brightness(1.3);
            }
        }

        @keyframes dove-auto-flight {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(var(--bird-scale));
            }
            33% {
                transform: translateY(-12px) translateX(2px) scale(var(--bird-scale));
            }
            66% {
                transform: translateY(-8px) translateX(-1px) scale(var(--bird-scale));
            }
        }

        @keyframes dove-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-8deg) translateX(0px);
            }
            100% {
                transform: rotateY(-12deg) rotateZ(5deg) translateX(1px);
            }
        }

        @keyframes dove-sparkle {
            0%, 100% {
                box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 8px rgba(135, 206, 235, 0.8);
                filter: brightness(1.2);
            }
        }

    </style>

<!-- 🚀 MODE PRODUCTION ALPHA 1 -->
<script>
window.PRODUCTION_MODE = true;
// ✅ Désactiver seulement les logs non-critiques
const originalLog = console.log;
const originalWarn = console.warn;
const originalInfo = console.info;

console.log = function(...args) {
    // ✅ Autoriser les logs audio critiques
    if (args.some(arg => String(arg).includes('🎵') || String(arg).includes('AudioManager'))) {
        originalLog.apply(console, args);
    }
};
console.warn = function(...args) {
    // ✅ Autoriser les warnings audio critiques
    if (args.some(arg => String(arg).includes('🎵') || String(arg).includes('AudioManager') || String(arg).includes('audio'))) {
        originalWarn.apply(console, args);
    }
};
console.info = function() {}; // Désactiver les infos
// Garder console.error pour le debug critique
</script>

<style id="kawaii-objects-styles">
/* ===============================
   OBJETS KAWAII - STYLES DE BASE
   =============================== */

.kawaii-object {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid #FF69B4;
    box-shadow: 0 4px 15px rgba(255,105,180,0.3);
    border-radius: 15px;
    background: transparent; /* FOND TRANSPARENT */
}

.kawaii-object:hover {
    transform: scale(1.15) rotate(-5deg);
    box-shadow: 0 8px 25px rgba(255,105,180,0.5);
    filter: brightness(1.1);
}

/* EXPLOSION KAWAII */
.explode {
    animation: explodeKawaii 0.6s ease-out forwards !important;
}

@keyframes explodeKawaii {
    0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1); }
    25% { transform: scale(1.3) rotate(10deg); opacity: 0.9; filter: brightness(1.3); }
    50% { transform: scale(1.8) rotate(-5deg); opacity: 0.7; filter: brightness(1.6); }
    100% { transform: scale(2.5) rotate(15deg); opacity: 0; filter: brightness(2); }
}

/* ===============================
   BALEINE KAWAII (ID: baleine)
   =============================== */

.obj-baleine {
    width: 60px;
    height: 70px;
    background: linear-gradient(180deg, #4FC3F7 0%, #4FC3F7 40%, #87CEEB 60%, #87CEEB 100%);
    border-radius: 8px 8px 30px 30px;
}

.obj-baleine::before {
    content: '';
    position: absolute;
    bottom: 15px;
    left: 18px;
    width: 8px;
    height: 8px;
    background: #000;
    border-radius: 50%;
    box-shadow: 
        0 0 0 2px #FFF,
        12px 0 0 -6px #000,
        12px 0 0 -4px #FFF,
        -5px 8px 0 -4px #FFB3BA,
        17px 8px 0 -4px #FFB3BA,
        6px 6px 0 -6px #FF69B4;
}

.obj-baleine::after {
    content: '';
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 25px solid #4FC3F7;
}

.baleine-nageoire-gauche {
    position: absolute;
    top: 15px;
    left: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 15px 0 0 15px;
    transform: rotate(45deg);
    animation: nageoireGauche 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

.baleine-nageoire-droite {
    position: absolute;
    top: 15px;
    right: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 0 15px 15px 0;
    transform: rotate(-45deg);
    animation: nageoireDroite 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

@keyframes nageoireGauche {
    0%, 100% { transform: rotate(45deg) translateY(0px); }
    25% { transform: rotate(55deg) translateY(-4px); }
    50% { transform: rotate(45deg) translateY(0px); }
    75% { transform: rotate(35deg) translateY(2px); }
}

@keyframes nageoireDroite {
    0%, 100% { transform: rotate(-45deg) translateY(0px); }
    25% { transform: rotate(-55deg) translateY(-4px); }
    50% { transform: rotate(-45deg) translateY(0px); }
    75% { transform: rotate(-35deg) translateY(2px); }
}

@keyframes heartFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.7; }
    50% { transform: translateY(-8px) rotate(10deg); opacity: 1; }
}

/* ===============================
   ASTÉROÏDE KAWAII (ID: asteroide)
   =============================== */

.obj-asteroide {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #654321 0%, #8B4513 30%, #A0522D 60%, #654321 100%);
    border-radius: 50%;
    position: relative;
    animation: asteroidFloat 3s ease-in-out infinite;
}

.obj-asteroide::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    box-shadow:
        /* Morceaux détachés autour */
        -15px -10px 0 -20px #654321,
        20px -5px 0 -22px #8B4513,
        -8px 18px 0 -25px #A0522D,
        15px 15px 0 -23px #654321,
        /* Cratères sur la surface */
        inset -8px -8px 0 -15px rgba(0,0,0,0.4),
        inset 10px -5px 0 -18px rgba(0,0,0,0.3),
        inset -5px 12px 0 -20px rgba(0,0,0,0.2);
}

.obj-asteroide::after {
    content: '';
    position: absolute;
    top: -30px;
    left: 50%;
    width: 3px;
    height: 25px;
    background: linear-gradient(180deg, transparent 0%, #FFA500 30%, #FF6500 70%, transparent 100%);
    transform: translateX(-50%) skewY(-20deg);
    animation: trailingEffect 2s ease-in-out infinite;
}

@keyframes asteroidFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-3px) rotate(5deg); }
}

@keyframes trailingEffect {
    0% { opacity: 0.8; transform: translateX(-50%) skewY(-20deg) scaleY(1); }
    50% { opacity: 1; transform: translateX(-50%) skewY(-15deg) scaleY(1.2); }
    100% { opacity: 0.6; transform: translateX(-50%) skewY(-25deg) scaleY(0.8); }
}

/* ===============================
   ÉTOILE KAWAII (ID: etoile)
   =============================== */

.obj-etoile {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #FFEE58 0%, #FFD54F 100%);
    border-radius: 50%;
}

.obj-etoile::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 6px;
    height: 3px;
    background: #000;
    border-radius: 3px 3px 0 0;
    box-shadow: 
        10px 0 0 #000,
        3px 8px 0 -4px #FF6B6B,
        1px 10px 0 -5px #000,
        7px 10px 0 -5px #000,
        -8px 6px 0 -2px #FFCDD2,
        18px 6px 0 -2px #FFCDD2;
}

.obj-etoile::after {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -8px;
    font-size: 16px;
    animation: sparkleKawaii 1.5s ease-in-out infinite;
}

@keyframes sparkleKawaii {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
}

/* ===============================
   TANK KAWAII (ID: tank)
   =============================== */

.obj-tank {
    width: 75px;
    height: 40px;
    background: linear-gradient(135deg, #2E7D32 0%, #4CAF50 50%, #388E3C 100%);
    border-radius: 8px 8px 3px 3px;
    border: 3px solid #1B5E20;
    position: relative;
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.3),
        inset 0 -3px 6px rgba(0,0,0,0.3),
        0 4px 12px rgba(0,0,0,0.4);
    animation: tankRumble 3s ease-in-out infinite;
}

/* Yeux sérieux et déterminés */
.obj-tank::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 25px;
    width: 6px;
    height: 6px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        14px 0 0 -2px #FFF,
        14px 0 0 0 #000,
        /* Petites pupilles noires mignonnes */
        1px 1px 0 -3px #000,
        15px 1px 0 -3px #000,
        /* Petits reflets blancs kawaii */
        -1px -1px 0 -4px #FFF,
        13px -1px 0 -4px #FFF,
        /* Sourcils sérieux plus marqués */
        -3px -5px 0 -2px #1B5E20,
        17px -5px 0 -2px #1B5E20,
        /* Bouche souriante kawaii */
        7px 8px 0 -3px #FF69B4,
        4px 10px 0 -4px #FF69B4,
        10px 10px 0 -4px #FF69B4,
        /* Casque militaire */
        -5px -8px 0 -1px #795548,
        19px -8px 0 -1px #795548,
        /* Joues roses kawaii */
        -8px 2px 0 -2px #FFB6C1,
        22px 2px 0 -2px #FFB6C1;
}

/* Canon principal plus imposant */
.obj-tank::after {
    content: '';
    position: absolute;
    bottom: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 10px;
    height: 15px;
    background: linear-gradient(180deg, #263238 0%, #37474F 50%, #263238 100%);
    border: 2px solid #000;
    border-radius: 4px;
    box-shadow:
        0 -6px 0 -3px #FFD54F,
        inset 0 2px 4px rgba(255,255,255,0.2),
        0 0 8px rgba(0,0,0,0.5),
        /* Tourelle ronde au bout du canon */
        0 20px 0 -2px #37474F,      /* Tourelle gris foncé */
        0 20px 0 0px #000,          /* Contour noir */
        /* Mini yeux kawaii espacés */
        -3px 22px 0 -5px #FFF,      /* Œil gauche blanc */
        3px 22px 0 -5px #FFF,       /* Œil droit blanc */
        -2px 23px 0 -6px #000,      /* Pupille gauche */
        4px 23px 0 -6px #000;       /* Pupille droite */
}

@keyframes tankRumble {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-1px); }
    75% { transform: translateX(1px); }
}

@keyframes nervousEyes {
    0% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -4px 32px 0 -5px #FF0000,
            4px 32px 0 -5px #FF0000;
    }
    100% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -3px 31px 0 -5px #FF0000,
            5px 31px 0 -5px #FF0000;
    }
}

@keyframes tankSmoke {
    0% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            7px -15px 0 -3px #FF8C00,
            5px -18px 0 -4px #FF6500,
            9px -18px 0 -4px #FF6500,
            6px -21px 0 -5px #FF4500,
            8px -21px 0 -5px #FF4500;
    }
    50% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            8px -16px 0 -3px #FF8C00,
            4px -19px 0 -4px #FF6500,
            10px -19px 0 -4px #FF6500,
            5px -22px 0 -5px #FF4500,
            9px -22px 0 -5px #FF4500;
    }
    100% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            6px -17px 0 -3px #FF8C00,
            6px -20px 0 -4px #FF6500,
            8px -20px 0 -4px #FF6500,
            7px -23px 0 -5px #FF4500,
            7px -23px 0 -5px #FF4500;
    }
}

/* Système de chenilles complet */
.obj-tank {
    overflow: visible;
}

/* Rectangles noirs pour les chenilles */
.tank-track {
    position: absolute;
    width: 8px;
    height: 80px;
    background: #000;
    top: -5px;
    border-radius: 2px;
}

.tank-track.center {
    left: 50%;
    transform: translateX(-50%);
}

/* Fumée du tank */
.tank-smoke {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 30px;
    pointer-events: none;
}

.tank-smoke::before {
    content: '💕';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    animation: smokeAnimation 2s ease-in-out infinite;
}

.tank-smoke::after {
    content: '✨';
    position: absolute;
    top: 3px;
    left: 70%;
    transform: translateX(-50%);
    font-size: 12px;
    animation: fireAnimation 1.5s ease-in-out infinite alternate;
}

@keyframes smokeAnimation {
    0% {
        opacity: 0.6;
        transform: translateX(-50%) scale(0.8) rotate(-5deg);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scale(1.1) rotate(5deg) translateY(-3px);
    }
    100% {
        opacity: 0.7;
        transform: translateX(-50%) scale(0.9) rotate(-3deg) translateY(-1px);
    }
}

@keyframes fireAnimation {
    0% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1);
    }
    100% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
    }
}


/* Anciennes classes tank supprimées - tout en CSS box-shadow maintenant */

@keyframes powerPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.2); }
}

/* ===============================
   LUNE KAWAII (ID: lune)
   =============================== */

.obj-lune {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #F8F8FF 0%, #E6E6FA 100%);
    border-radius: 50%;
}

.obj-lune::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 8px;
    height: 4px;
    background: #000;
    border-radius: 4px 4px 0 0;
    box-shadow: 
        12px 0 0 #000,
        6px 8px 0 -4px #DDA0DD,
        4px 10px 0 -5px #000,
        8px 10px 0 -5px #000,
        -8px 6px 0 -2px #F8BBD9,
        20px 6px 0 -2px #F8BBD9,
        -15px -8px 0 -3px #E0E0E0,
        25px 15px 0 -3px #E0E0E0;
}

.obj-lune::after {
    content: '💤';
    position: absolute;
    top: -15px;
    right: -10px;
    font-size: 12px;
    animation: sleepFloat 2s ease-in-out infinite;
}

@keyframes sleepFloat {
    0%, 100% { transform: translateY(0); opacity: 0.6; }
    50% { transform: translateY(-10px); opacity: 1; }
}

/* ===============================
   AUTRES OBJETS KAWAII
   =============================== */

.obj-banane {
    width: 60px;
    height: 60px;
    position: relative;
    border: 3px solid #FFD700;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,193,7,0.2) 100%);
}

.obj-banane::before {
    content: '🍌';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-30deg);
    font-size: 35px;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
}

@keyframes bananaGlow {
    0% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.4),
            inset 0 -4px 8px rgba(0,0,0,0.3),
            0 6px 20px rgba(255,193,7,0.4),
            0 0 15px rgba(255,235,59,0.3);
    }
    100% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.6),
            inset 0 -4px 8px rgba(0,0,0,0.2),
            0 8px 25px rgba(255,193,7,0.6),
            0 0 25px rgba(255,235,59,0.5);
        transform: rotate(-30deg) scale(1.05);
    }
}

/* IPHONE KAWAII 📱 */
.obj-smartphone {
    width: 42px;
    height: 70px;
    background: linear-gradient(145deg, #1A1A1A 0%, #000 100%);
    border-radius: 12px;
    border: 1px solid #333;
    position: relative;
    box-shadow:
        0 6px 12px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 0 0 1px rgba(255,255,255,0.05);
}

.obj-smartphone::before {
    content: '';
    position: absolute;
    top: 6px;
    left: 3px;
    width: 34px;
    height: 56px;
    background: linear-gradient(145deg, #0066CC 0%, #004499 100%);
    border-radius: 8px;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.2),
        inset 0 -1px 2px rgba(0,0,0,0.3);
}

.obj-smartphone::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 3px;
    background: #333;
    border-radius: 2px;
    box-shadow: 0 0 0 1px #000;
}

/* POUBELLE KAWAII MIGNONNE 🗑️ */
.obj-poubelle {
    width: 50px;
    height: 60px;
    background: linear-gradient(180deg, #4CAF50 0%, #388E3C 50%, #2E7D32 100%);
    border-radius: 8px 8px 12px 12px;
    border: 2px solid #2E7D32;
    position: relative;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.2),
        0 4px 8px rgba(0,0,0,0.3);
    animation: binHappy 3s ease-in-out infinite;
}

.obj-poubelle::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    width: 8px;
    height: 8px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        12px 0 0 -2px #FFF,
        12px 0 0 0 #000,
        /* Pupilles mignonnes */
        1px 1px 0 -4px #000,
        11px 1px 0 -4px #000,
        /* Joues roses */
        -6px 8px 0 -3px #FFB6C1,
        18px 8px 0 -3px #FFB6C1,
        /* Sourire kawaii */
        6px 15px 0 -4px #FF69B4,
        3px 17px 0 -5px #FF69B4,
        9px 17px 0 -5px #FF69B4;
}

.obj-poubelle::after {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 35px;
    height: 6px;
    background: linear-gradient(90deg, #66BB6A 0%, #4CAF50 50%, #66BB6A 100%);
    border-radius: 3px;
    border: 1px solid #388E3C;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

@keyframes binHappy {
    0%, 100% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.05) rotate(1deg); }
}

/* BOMBARDIER FURTIF B-2 SPIRIT 🛩️ */
.obj-avion {
    width: 90px;
    height: 70px;
    background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 30%, #2c2c2c 60%, #000000 100%);
    border-radius: 0;
    border: none;
    position: relative;
    transform: rotate(180deg); /* Orienté vers le bas - nez pointant vers le sol */
    /* Forme en triangle caractéristique du B-2 avec ailes diagonales */
    clip-path: polygon(
        50% 0%,      /* Nez pointu */
        15% 35%,     /* Aile gauche diagonale */
        0% 70%,      /* Bout aile gauche */
        30% 85%,     /* Arrière gauche */
        50% 100%,    /* Queue centrale */
        70% 85%,     /* Arrière droite */
        100% 70%,    /* Bout aile droite */
        85% 35%      /* Aile droite diagonale */
    );
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.08),
        inset 0 -3px 6px rgba(0,0,0,0.7),
        0 8px 16px rgba(0,0,0,0.8),
        0 0 20px rgba(0,100,255,0.2);
    animation: stealthFly 4s ease-in-out infinite;
}

.obj-avion::before {
    content: '';
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 6px;
    background: linear-gradient(90deg, transparent, #00ffff 50%, transparent);
    border-radius: 2px;
    opacity: 0.6;
    box-shadow:
        0 0 10px rgba(0,255,255,0.5),
        0 0 20px rgba(0,255,255,0.3);
    animation: stealthLights 2s ease-in-out infinite alternate;
}

.obj-avion::after {
    content: '';
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 3px;
    background: linear-gradient(90deg,
        transparent 0%,
        #ff4500 20%,
        #ff6600 40%,
        #ffaa00 60%,
        #ff4500 80%,
        transparent 100%);
    border-radius: 50%;
    opacity: 0.9;
    box-shadow:
        0 0 8px rgba(255,69,0,0.6),
        0 0 16px rgba(255,102,0,0.4);
    animation: stealthJet 1s ease-in-out infinite;
}

@keyframes stealthFly {
    0%, 100% {
        transform: rotate(180deg) translateY(0);
        filter: brightness(0.8);
    }
    50% {
        transform: rotate(180deg) translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }
}

@keyframes stealthLights {
    0% {
        opacity: 0.6;
        box-shadow:
            0 0 8px #FF0000,
            8px 15px 0 -2px #FF0000,
            -8px 15px 0 -2px #FF0000;
    }
    100% {
        opacity: 1;
        box-shadow:
            0 0 15px #FF0000,
            8px 15px 0 -2px #FF4444,
            -8px 15px 0 -2px #FF4444,
            0 0 25px rgba(255,0,0,0.8);
    }
}

@keyframes stealthJet {
    0%, 100% {
        opacity: 0.8;
        transform: translateX(-50%) scaleY(1);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scaleY(1.3);
    }
}

@keyframes phoneGlow {
    0%, 100% { text-shadow: 0 0 10px #FF69B4; }
    50% { text-shadow: 0 0 20px #FF1493; }
}


/* ===============================
   NOUVELLES ANIMATIONS DÉBRIS ET AVION FURTIF
   =============================== */

@keyframes debrisFloat {
    0%, 100% { transform: translate(0, 0) rotate(0deg); opacity: 0.8; }
    25% { transform: translate(-3px, -5px) rotate(90deg); opacity: 1; }
    50% { transform: translate(5px, -8px) rotate(180deg); opacity: 0.6; }
    75% { transform: translate(-2px, -3px) rotate(270deg); opacity: 1; }
}

@keyframes dustTrail {
    0%, 100% { transform: scale(0.8) rotate(0deg); opacity: 0.5; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 0.9; }
}

@keyframes reactorFlame {
    0%, 100% { transform: scale(0.8); opacity: 0.7; filter: hue-rotate(0deg); }
    50% { transform: scale(1.2); opacity: 1; filter: hue-rotate(60deg); }
}

@keyframes missileGlow {
    0%, 100% { transform: translateX(-50%) scale(0.8); opacity: 0.6; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
}

@keyframes sonicBoom {
    0%, 100% { transform: scale(0.9) translateX(0); opacity: 0.4; }
    50% { transform: scale(1.3) translateX(-5px); opacity: 0.8; }
}

/* 🇫🇷 Popup Élégant Bleu-Blanc-Rouge */
.custom-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease;
}

.custom-popup-overlay.active {
    display: flex;
}

.custom-popup {
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    border-radius: 16px;
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
    max-width: 380px;
    width: 85%;
    overflow: hidden;
    animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid transparent;
    background-clip: padding-box;
    position: relative;
}

.custom-popup::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #0055A4 33%, #FFFFFF 33%, #FFFFFF 66%, #EF4135 66%);
}

.custom-popup-header {
    padding: 16px 16px 12px;
    text-align: center;
    position: relative;
}

.custom-popup-icon {
    font-size: 3rem;
    margin-bottom: 8px;
    animation: bounceIn 0.5s ease;
}

.custom-popup-title {
    font-size: 18px;
    font-weight: 700;
    color: #1e293b;
    margin: 0;
    font-family: "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif;
}

.custom-popup-body {
    padding: 0 16px 16px;
    text-align: center;
}

.custom-popup-message {
    font-size: 14px;
    line-height: 1.5;
    color: #475569;
    margin: 0;
    white-space: pre-line;
    font-family: "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif;
}

.custom-popup-buttons {
    display: flex;
    gap: 10px;
    padding: 0 16px 16px;
    justify-content: center;
}

.custom-popup-btn {
    padding: 12px 32px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif;
    min-width: 120px;
}

.custom-popup-btn-confirm {
    background: linear-gradient(135deg, #0055A4, #0041a8);
    color: white;
    box-shadow: 0 4px 12px rgba(0, 85, 164, 0.3);
}

.custom-popup-btn-confirm:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 85, 164, 0.4);
}

.custom-popup-btn-cancel {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.custom-popup-btn-cancel:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
}

.custom-popup-btn-ok {
    background: linear-gradient(135deg, #0055A4, #0041a8);
    color: white;
    box-shadow: 0 4px 12px rgba(0, 85, 164, 0.3);
}

.custom-popup-btn-ok:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 85, 164, 0.4);
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes popIn {
    0% {
        transform: scale(0.5) translateY(-50px);
        opacity: 0;
    }
    100% {
        transform: scale(1) translateY(0);
        opacity: 1;
    }
}

@keyframes bounceIn {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-10px);
    }
    60% {
        transform: translateY(-5px);
    }
}

        </style></head>
<body>
    <!-- 🇫🇷 Popup Élégant Bleu-Blanc-Rouge -->
    <div class="custom-popup-overlay" id="customPopupOverlay">
        <div class="custom-popup">
            <div class="custom-popup-header">
                <div class="custom-popup-icon" id="customPopupIcon">ℹ️</div>
                <h2 class="custom-popup-title" id="customPopupTitle">Information</h2>
            </div>
            <div class="custom-popup-body">
                <p class="custom-popup-message" id="customPopupMessage"></p>
            </div>
            <div class="custom-popup-buttons" id="customPopupButtons"></div>
        </div>
    </div>

    <!-- Message d'orientation pour mobile en mode paysage - Minimaliste -->
    <div class="orientation-warning">
        <div style="font-size: 120px; color: #333; animation: rotate-pulse 2s ease-in-out infinite;">
            ↻
        </div>
    </div>

    <!-- Bouton Installation PWA -->
    <button id="install-button">Installer l'app</button>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="449" height="799" style="width: 449px; height: 799px;"></canvas>

        <!-- CHARGER LES MODULES AVANT LE SCRIPT PRINCIPAL -->
        <script src="modules/i18n.js"></script>
    <script src="modules/i18n-apply.js"></script>

    <!-- Système de Popup Élégant -->
    <script>
        // � Obtenir le drapeau de la langue actuelle
        function getCurrentLanguageFlag() {
            const langCode = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            const flagMap = {
                'fr': '🇫🇷', 'en': '🇬🇧', 'es': '🇪🇸', 'de': '🇩🇪',
                'it': '🇮🇹', 'pt': '🇵🇹', 'ru': '🇷🇺', 'uk': '🇺🇦',
                'zh': '🇨🇳', 'jp': '🇯🇵', 'ko': '🇰🇷', 'ar': '🇸🇦',
                'he': '🇮🇱', 'rc': '🇷🇪', 'lg': '🇨🇩'
            };
            return flagMap[langCode] || '🌍';
        }

        // �🇫🇷 Système de popup élégant bleu-blanc-rouge
        const CustomPopup = {
            show(options) {
                // 🔍 DEBUG: Tracer tous les appels au popup
                console.log('📣 CustomPopup.show() appelé avec:', options);
                console.trace('📍 Stack trace de l\'appel:');
                
                return new Promise((resolve) => {
                    const overlay = document.getElementById('customPopupOverlay');
                    const icon = document.getElementById('customPopupIcon');
                    const title = document.getElementById('customPopupTitle');
                    const message = document.getElementById('customPopupMessage');
                    const buttons = document.getElementById('customPopupButtons');

                    // Définir l'icône
                    icon.textContent = options.icon || 'ℹ️';
                    
                    // Définir le titre (force la conversion en chaîne pour éviter les objets DOM)
                    const titleText = options.title ? String(options.title) : 'Information';
                    // Vérifier si c'est un sélecteur CSS, XPath ou objet HTML (bug potentiel)
                    const isSelectorOrObject = 
                        (titleText.includes('body') && titleText.includes('div')) || // CSS path
                        titleText.startsWith('/html/body/div') || // XPath
                        titleText.includes('[object HTML') || // HTML object
                        titleText.includes('#customPopup') || // CSS selector with ID
                        (titleText.includes('.custom-popup') && titleText.length > 50); // Long CSS class path
                    
                    if (isSelectorOrObject) {
                        console.error('🚨 BUG CRITIQUE: Sélecteur/objet passé comme titre de popup!');
                        console.error('Titre reçu:', titleText);
                        console.error('Type:', typeof options.title);
                        console.error('Options complètes:', options);
                        console.trace('Stack trace du bug:');
                        title.textContent = 'Information'; // Fallback sûr
                    } else {
                        title.textContent = titleText;
                    }
                    
                    // Définir le message (avec protection similaire)
                    const messageText = options.message ? String(options.message) : '';
                    if (messageText.startsWith('/html/body/div') || messageText.includes('[object HTML')) {
                        console.warn('⚠️ BUG DÉTECTÉ: Tentative d\'affichage d\'un sélecteur/objet comme message!', messageText);
                        message.textContent = '';
                    } else {
                        message.textContent = messageText;
                    }

                    // Créer les boutons
                    buttons.innerHTML = '';
                    
                    if (options.type === 'confirm') {
                        // Bouton Annuler
                        const cancelBtn = document.createElement('button');
                        cancelBtn.className = 'custom-popup-btn custom-popup-btn-cancel';
                        cancelBtn.textContent = options.cancelText || getTranslatedText('popup.cancel', '✖ Annuler');
                        cancelBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve(false);
                        };
                        buttons.appendChild(cancelBtn);

                        // Bouton Confirmer
                        const confirmBtn = document.createElement('button');
                        confirmBtn.className = 'custom-popup-btn custom-popup-btn-confirm';
                        confirmBtn.textContent = options.confirmText || getTranslatedText('popup.confirm', '✓ Confirmer');
                        confirmBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve(true);
                        };
                        buttons.appendChild(confirmBtn);
                    } else {
                        // Bouton OK
                        const okBtn = document.createElement('button');
                        okBtn.className = 'custom-popup-btn custom-popup-btn-ok';
                        okBtn.textContent = options.okText || getTranslatedText('popup.ok', '✓ OK');
                        okBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve(true);
                        };
                        buttons.appendChild(okBtn);
                    }

                    // Afficher le popup
                    overlay.classList.add('active');

                    // Fermer avec Escape
                    const escapeHandler = (e) => {
                        if (e.key === 'Escape') {
                            overlay.classList.remove('active');
                            document.removeEventListener('keydown', escapeHandler);
                            resolve(false);
                        }
                    };
                    document.addEventListener('keydown', escapeHandler);
                });
            },

            alert(message, title, icon) {
                return this.show({
                    type: 'alert',
                    message,
                    title: title || getTranslatedText('popup.information', 'Information'),
                    icon: icon || 'ℹ️'
                });
            },

            confirm(message, title, icon, confirmText, cancelText) {
                return this.show({
                    type: 'confirm',
                    message,
                    title: title || getTranslatedText('popup.confirmation', 'Confirmation'),
                    icon: icon || getCurrentLanguageFlag(),
                    confirmText: confirmText || getTranslatedText('popup.yes', '✓ Oui'),
                    cancelText: cancelText || getTranslatedText('popup.no', '✖ Non')
                });
            },

            // Popup à 3 choix pour changement de langue (sans texte, icônes seulement)
            chooseLanguageAction(targetFlag, hasSave) {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('customPopupOverlay');
                    const icon = document.getElementById('customPopupIcon');
                    const title = document.getElementById('customPopupTitle');
                    const message = document.getElementById('customPopupMessage');
                    const buttons = document.getElementById('customPopupButtons');
                    const popup = overlay.querySelector('.custom-popup');

                    // Icône = drapeau de la langue cible
                    icon.textContent = targetFlag;
                    icon.style.fontSize = '3rem';
                    
                    // Pas de titre ni message (universel)
                    title.textContent = '';
                    message.textContent = '';

                    // ❌ Ajouter croix de fermeture en haut à droite
                    const existingClose = popup.querySelector('.popup-close-btn');
                    if (existingClose) existingClose.remove();
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'popup-close-btn';
                    closeBtn.innerHTML = '✕';
                    closeBtn.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(255, 255, 255, 0.1);
                        border: 2px solid rgba(255, 255, 255, 0.3);
                        border-radius: 50%;
                        width: 32px;
                        height: 32px;
                        font-size: 20px;
                        color: rgba(255, 255, 255, 0.7);
                        cursor: pointer;
                        transition: all 0.3s;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10;
                    `;
                    closeBtn.onmouseenter = () => {
                        closeBtn.style.background = 'rgba(255, 80, 80, 0.2)';
                        closeBtn.style.borderColor = 'rgba(255, 80, 80, 0.6)';
                        closeBtn.style.color = '#ff5050';
                        closeBtn.style.transform = 'rotate(90deg) scale(1.1)';
                    };
                    closeBtn.onmouseleave = () => {
                        closeBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                        closeBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                        closeBtn.style.color = 'rgba(255, 255, 255, 0.7)';
                        closeBtn.style.transform = 'rotate(0deg) scale(1)';
                    };
                    closeBtn.onclick = () => {
                        overlay.classList.remove('active');
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        resolve('cancel');
                    };
                    popup.insertBefore(closeBtn, popup.firstChild);

                    // Créer les boutons icônes
                    buttons.innerHTML = '';
                    buttons.style.display = 'flex';
                    buttons.style.gap = '20px';
                    buttons.style.justifyContent = 'center';

                    if (hasSave) {
                        // ➡️ Continuer (garder progression) - Bleu doux
                        const continueBtn = document.createElement('button');
                        continueBtn.className = 'custom-popup-btn custom-popup-btn-icon';
                        continueBtn.textContent = '➡️';
                        continueBtn.style.cssText = 'background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); border: 3px solid #93c5fd; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2); font-size: 2.2rem; padding: 18px; min-width: 80px; border-radius: 12px; transition: all 0.3s; cursor: pointer;';
                        continueBtn.onmouseenter = () => {
                            continueBtn.style.transform = 'translateY(-5px) scale(1.05)';
                            continueBtn.style.boxShadow = '0 8px 30px rgba(59, 130, 246, 0.6), inset 0 2px 15px rgba(255, 255, 255, 0.3)';
                        };
                        continueBtn.onmouseleave = () => {
                            continueBtn.style.transform = 'translateY(0) scale(1)';
                            continueBtn.style.boxShadow = '0 4px 20px rgba(59, 130, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2)';
                        };
                        continueBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve('continue');
                        };
                        buttons.appendChild(continueBtn);

                        // 🔄 Redémarrer (nouvelle partie) - Violet doux
                        const restartBtn = document.createElement('button');
                        restartBtn.className = 'custom-popup-btn custom-popup-btn-icon';
                        restartBtn.textContent = '🔄';
                        restartBtn.style.cssText = 'background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%); border: 3px solid #c4b5fd; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2); font-size: 2.2rem; padding: 18px; min-width: 80px; border-radius: 12px; transition: all 0.3s; cursor: pointer;';
                        restartBtn.onmouseenter = () => {
                            restartBtn.style.transform = 'translateY(-5px) scale(1.05) rotate(-15deg)';
                            restartBtn.style.boxShadow = '0 8px 30px rgba(139, 92, 246, 0.6), inset 0 2px 15px rgba(255, 255, 255, 0.3)';
                        };
                        restartBtn.onmouseleave = () => {
                            restartBtn.style.transform = 'translateY(0) scale(1) rotate(0deg)';
                            restartBtn.style.boxShadow = '0 4px 20px rgba(139, 92, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2)';
                        };
                        restartBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve('restart');
                        };
                        buttons.appendChild(restartBtn);
                    } else {
                        // Pas de sauvegarde : juste un bouton pour confirmer - Bleu doux
                        const confirmBtn = document.createElement('button');
                        confirmBtn.className = 'custom-popup-btn custom-popup-btn-icon';
                        confirmBtn.textContent = '➡️';
                        confirmBtn.style.cssText = 'background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); border: 3px solid #93c5fd; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2); font-size: 2.2rem; padding: 18px; min-width: 80px; border-radius: 12px; transition: all 0.3s; cursor: pointer;';
                        confirmBtn.onmouseenter = () => {
                            confirmBtn.style.transform = 'translateY(-5px) scale(1.05)';
                            confirmBtn.style.boxShadow = '0 8px 30px rgba(59, 130, 246, 0.6), inset 0 2px 15px rgba(255, 255, 255, 0.3)';
                        };
                        confirmBtn.onmouseleave = () => {
                            confirmBtn.style.transform = 'translateY(0) scale(1)';
                            confirmBtn.style.boxShadow = '0 4px 20px rgba(59, 130, 246, 0.4), inset 0 2px 10px rgba(255, 255, 255, 0.2)';
                        };
                        confirmBtn.onclick = () => {
                            overlay.classList.remove('active');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            resolve('continue');
                        };
                        buttons.appendChild(confirmBtn);
                    }

                    // Afficher le popup
                    overlay.classList.add('active');

                    // Fermer avec Escape = Annuler
                    const escapeHandler = (e) => {
                        if (e.key === 'Escape') {
                            overlay.classList.remove('active');
                            document.removeEventListener('keydown', escapeHandler);
                            resolve('cancel');
                        }
                    };
                    document.addEventListener('keydown', escapeHandler);
                });
            }
        };

        // Remplacer les fonctions natives
        window.customAlert = CustomPopup.alert.bind(CustomPopup);
        window.customConfirm = CustomPopup.confirm.bind(CustomPopup);
    </script>

    <!-- Initialisation du système de traduction -->
    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // 🗑️ FORCER LA SUPPRESSION DU CACHE NAVIGATEUR
            console.log('🔄 Suppression forcée du cache des traductions...');
            
            // Vider le cache des traductions si présent
            if (window.i18n && window.i18n.translations) {
                window.i18n.translations = { fr: { loaded: true } };
                console.log('✅ Cache mémoire i18n vidé');
            }
            
            // Récupérer la langue sauvegardée ou utiliser français
            const savedLang = localStorage.getItem('petit_bateau_lang') || 'fr';
            console.log(`🌍 Langue détectée: ${savedLang}`);

            // Initialiser i18n
            await window.i18n.init();

            // Créer l'applicateur
            if (!window.i18nApplicator) {
                window.i18nApplicator = new I18nApplicator(window.i18n);
            }

            // Appliquer les traductions
            await window.i18nApplicator.applyAll(savedLang);

            // Mettre à jour le titre du document
            if (window.i18n && window.i18n.t) {
                const docTitle = window.i18n.t('meta.document_title');
                const docDescription = window.i18n.t('meta.description');
                const ogTitle = window.i18n.t('meta.og_title');
                const ogDescription = window.i18n.t('meta.og_description');
                
                if (docTitle) document.title = docTitle;
                
                // Mettre à jour meta description
                const metaDesc = document.querySelector('meta[name="description"]');
                if (metaDesc && docDescription) metaDesc.setAttribute('content', docDescription);
                
                // Mettre à jour Open Graph title
                const ogTitleMeta = document.querySelector('meta[property="og:title"]');
                if (ogTitleMeta && ogTitle) ogTitleMeta.setAttribute('content', ogTitle);
                
                // Mettre à jour Open Graph description
                const ogDescMeta = document.querySelector('meta[property="og:description"]');
                if (ogDescMeta && ogDescription) ogDescMeta.setAttribute('content', ogDescription);
                
                // Mettre à jour l'attribut lang du HTML
                const htmlLang = savedLang === 'fr' ? 'fr' : savedLang === 'en' ? 'en' : savedLang === 'es' ? 'es' : 'fr';
                document.documentElement.setAttribute('lang', htmlLang);
            }

            console.log(`🌍 Jeu chargé en ${window.i18n.supportedLanguages[savedLang]}`);
        } catch (error) {
            console.error('❌ Erreur initialisation i18n:', error);
        }
    });
    </script>

        <script src="modules/kawaii_objects_module.js"></script>
        <script src="modules/secret-mode.js"></script>
        <script src="modules/info-auteur.js"></script>
        <script src="modules/audio-manager.js"></script>
        <script src="modules/supabase-scores.js"></script>

        <!-- MODULE OISEAUX VOLANTS CSS -->
        <div class="flying-birds-overlay">
            <!-- Corbeau Badass -->
            <div id="crow" class="bird-base bird-hidden"></div>

            <!-- Colombe Élégante -->
            <div id="dove" class="bird-base bird-hidden"></div>
        </div>
        <div id="message" class="message" data-i18n="game.messages.intro_bonus" style="transform: translate(-50%, -50%) scale(1); display: none;">🌟 +100 Points pour avoir regardé l'introduction complète ! 🌟</div>
        <div id="etapeIndicateur" class="etape-indicateur show">
                    <div>🧱 2/23</div>
                    <div id="voyageLight" data-i18n="game.voyage_light" style="font-size: 10px; margin-top: 2px; opacity: 0.8;">Voyage — La lumière</div>
                </div>

    <div id="kawaii-secret-container" style="position: absolute; top: 110px; left: 0px; width: 100%; height: calc(-110px + 100vh); pointer-events: none; z-index: 30; overflow: visible; background: transparent;"></div></div>


    <script>
        // 🚫 MODE PRODUCTION - Désactiver tous les console.log
        // Mettre PRODUCTION_MODE = false pour réactiver les logs en développement
        const PRODUCTION_MODE = false; // ✅ LOGS RÉACTIVÉS POUR DÉBOGAGE MUSIQUE
        window.PRODUCTION_MODE = PRODUCTION_MODE; // Variable globale pour les modules
        
        if (PRODUCTION_MODE) {
            const noop = () => {};
            const originalConsole = {
                log: console.log,
                warn: console.warn,
                error: console.error,
                info: console.info,
                debug: console.debug
            };
            
            // Désactiver les logs sauf les erreurs
            console.log = noop;
            console.info = noop;
            console.debug = noop;
            // Garder console.warn et console.error pour les bugs critiques
            
            // Fonction pour réactiver temporairement les logs (console du navigateur)
            // Utilisation: window.enableLogs() dans la console
            window.enableLogs = () => {
                console.log = originalConsole.log;
                console.warn = originalConsole.warn;
                console.error = originalConsole.error;
                console.info = originalConsole.info;
                console.debug = originalConsole.debug;
                console.log('✅ Logs réactivés - Mode debug activé');
            };
            
            // Fonction pour redésactiver les logs
            window.disableLogs = () => {
                console.log = noop;
                console.info = noop;
                console.debug = noop;
                originalConsole.log('🚫 Logs désactivés - Mode production');
            };
            
            // 🔥 Fonction de HARD RESET accessible depuis la console
            // Utilisation: window.hardReset() dans la console
            window.hardReset = async () => {
                const confirm1 = await customConfirm(
                    getTranslatedText('hard_reset.confirm_1', 'ATTENTION : Cela va TOUT effacer (progression, scores, énigmes collectées).\n\nÊtes-vous SÛR de vouloir continuer ?'),
                    '🔥 Hard Reset',
                    '⚠️',
                    '✓ Oui, tout effacer',
                    '✖ Non, annuler'
                );
                if (confirm1) {
                    const confirm2 = await customConfirm(
                        getTranslatedText('hard_reset.confirm_2', 'DERNIÈRE CONFIRMATION : Cette action est IRRÉVERSIBLE.\n\nVraiment continuer ?'),
                        '⚠️ Dernière confirmation',
                        '🔥',
                        '✓ Oui, c\'est sûr',
                        '✖ Non, annuler'
                    );
                    if (confirm2) {
                        hardResetGame();
                    } else {
                        originalConsole.log(getTranslatedText('hard_reset.cancelled_step_2', '❌ Hard Reset annulé (2ème confirmation)'));
                    }
                } else {
                    originalConsole.log(getTranslatedText('hard_reset.cancelled', '❌ Hard Reset annulé'));
                }
            };
        }

        // 💾 === SYSTÈME DE SAUVEGARDE/REPRISE DE JEU ===
        const GameSaveSystem = {
            SAVE_KEY: 'petit_bateau_save',
            VERSION: '1.2', // ✅ Fix langue + optimisations

            // Sauvegarder l'état du jeu
            save() {
                try {
                    // 🚫 Ne pas sauvegarder si changement de langue en cours
                    if (window.isChangingLanguage) {
                        console.log('🌍 Changement de langue en cours - sauvegarde annulée');
                        return false;
                    }
                    
                    // ✅ SIMPLIFICATION: Sauvegarder SEULEMENT à partir de Phase 2
                    const currentPhase = narrationManager ? narrationManager.currentPhase : 1;
                    if (currentPhase < 2) {
                        console.log('ℹ️ Phase 1 (intro) - pas de sauvegarde nécessaire');
                        return false;
                    }
                    
                    // ✅ DONNÉES MINIMALES: Phase + Playlist uniquement
                    const saveData = {
                        version: this.VERSION,
                        timestamp: Date.now(),
                        language: window.i18n ? window.i18n.getCurrentLanguage() : (localStorage.getItem('petit_bateau_lang') || 'fr'),
                        gameState: {
                            // 🎯 Phase actuelle (essentiel)
                            currentPhase: currentPhase,
                            
                            // 🎵 Progression playlist (essentiel)
                            musicTrackIndex: musicManager ? (musicManager.currentTrackIndex || 0) : 0,
                            musicMuted: musicManager ? (musicManager.isMuted || false) : false
                        }
                    };

                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('💾 Jeu sauvegardé (simplifié):', saveData);
                    return true;
                } catch (e) {
                    console.error('❌ Erreur sauvegarde:', e);
                    return false;
                }
            },

            // Charger l'état du jeu
            load() {
                try {
                    const savedData = localStorage.getItem(this.SAVE_KEY);
                    if (!savedData) {
                        console.log('ℹ️ Aucune sauvegarde trouvée');
                        return null;
                    }

                    const save = JSON.parse(savedData);
                    
                    // ✅ Vérifier compatibilité de version (accepter versions mineures)
                    const savedVersion = parseFloat(save.version || '1.0');
                    const currentVersion = parseFloat(this.VERSION);
                    
                    if (Math.floor(savedVersion) !== Math.floor(currentVersion)) {
                        console.warn(`⚠️ Version incompatible: ${save.version} vs ${this.VERSION}`);
                        // ❌ Version majeure différente → Invalider
                        return null;
                    }
                    
                    // ✅ Vérifier que la langue correspond (optionnel - warning seulement)
                    const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : (localStorage.getItem('petit_bateau_lang') || 'fr');
                    if (save.language && save.language !== currentLang) {
                        console.warn(`⚠️ Langue différente: sauvegarde=${save.language}, actuelle=${currentLang}`);
                        // ✅ On charge quand même, mais on log le warning
                    }

                    console.log('💾 Sauvegarde chargée:', save);
                    return save.gameState;
                } catch (e) {
                    console.error('❌ Erreur chargement:', e);
                    return null;
                }
            },

            // Restaurer l'état du jeu
            restore(gameState) {
                if (!gameState) return false;

                try {
                    console.log('� Restauration simplifiée depuis sauvegarde:', gameState);
                    
                    // ✅ SIMPLIFICATION: On restaure UNIQUEMENT la phase + musique
                    // Le reste se réinitialise normalement via narrationManager
                    
                    // 🎵 Restaurer la playlist
                    if (musicManager) {
                        if (gameState.musicMuted !== undefined) {
                            musicManager.isMuted = gameState.musicMuted;
                        }
                        
                        if (gameState.musicTrackIndex !== undefined) {
                            musicManager.currentTrackIndex = gameState.musicTrackIndex;
                            
                            // Reprendre la piste sauvegardée si pas en mute
                            if (!musicManager.isMuted) {
                                // ✅ Délai plus long pour laisser l'AudioContext s'initialiser + forcer le démarrage
                                setTimeout(() => {
                                    if (musicManager && musicManager.playlist && musicManager.playlist[gameState.musicTrackIndex]) {
                                        musicManager.currentTrackIndex = gameState.musicTrackIndex;
                                        musicManager.currentTrack = musicManager.playlist[gameState.musicTrackIndex];
                                        
                                        // ✅ Forcer l'initialisation de l'AudioContext et démarrer
                                        console.log(`🎵 Restauration et démarrage piste ${gameState.musicTrackIndex}...`);
                                        musicManager.play('normal');
                                        window.musicStartedOnce = true; // Marquer comme démarrée
                                        console.log(`🎵 Piste ${gameState.musicTrackIndex} restaurée et démarrée`);
                                    }
                                }, 2500); // Délai plus long: 2.5s au lieu de 1s
                            }
                        }
                        
                        console.log('🎵 Playlist restaurée:', {
                            trackIndex: gameState.musicTrackIndex,
                            muted: gameState.musicMuted
                        });
                    }

                    // 📖 Restaurer la phase - le narrationManager gère le reste
                    if (narrationManager && gameState.currentPhase) {
                        narrationManager.currentPhase = gameState.currentPhase;
                        
                        // 🔥 Bloquer l'intro
                        window.narrationStarted = true;
                        window.skipNarrationIntro = true;
                        
                        console.log(`📖 Phase ${gameState.currentPhase} restaurée`);
                    }

                    // 🎬 Désactiver intro et démarrer
                    phaseIntro.active = false;
                    phaseIntro.etape = 'terminee';
                    jeu = true;
                    
                    // 🔄 Recréer la phase restaurée (SANS narration)
                    if (narrationManager && gameState.currentPhase) {
                        setTimeout(() => {
                            console.log('🔄 Recréation de la phase depuis sauvegarde');
                            recreerPhaseActuelle();
                            console.log('✅ Phase restaurée et recréée sans narration');
                        }, 500);
                    }

                    console.log('✅ Restauration simplifiée terminée');
                    return true;
                } catch (e) {
                    console.error('❌ Erreur restauration:', e);
                    return false;
                }
            },

            // Vérifier s'il existe une sauvegarde
            hasSave() {
                return localStorage.getItem(this.SAVE_KEY) !== null;
            },

            // Supprimer la sauvegarde
            clear() {
                localStorage.removeItem(this.SAVE_KEY);
                // ⚠️ NE PAS supprimer 'gameResetInProgress' ici !
                // Il doit rester actif pour bloquer le beforeunload pendant le reload
                // Il sera nettoyé dans le load event de la nouvelle page
                console.log('🗑️ Sauvegarde supprimée');
            },

            // Obtenir l'info de la sauvegarde
            getSaveInfo() {
                try {
                    const savedData = localStorage.getItem(this.SAVE_KEY);
                    if (!savedData) return { hasSave: false };

                    const save = JSON.parse(savedData);
                    
                    // ✅ Vérifier compatibilité
                    const savedVersion = parseFloat(save.version || '1.0');
                    const currentVersion = parseFloat(this.VERSION);
                    
                    if (Math.floor(savedVersion) !== Math.floor(currentVersion)) {
                        console.warn(`⚠️ Sauvegarde incompatible: v${save.version}`);
                        return { hasSave: false, incompatible: true };
                    }
                    
                    // ✅ SIMPLIFICATION: Retourner infos minimales
                    return {
                        hasSave: true,
                        date: new Date(save.timestamp),
                        phase: save.gameState.currentPhase || 2,
                        language: save.language || 'fr',
                        version: save.version,
                        musicTrack: save.gameState.musicTrackIndex || 0
                    };
                } catch (e) {
                    console.error('❌ Erreur getSaveInfo:', e);
                    return { hasSave: false, error: true };
                }
            }
        };

        // 🎮 Sauvegarder automatiquement toutes les 30 secondes pendant le jeu
        setInterval(() => {
            if (typeof jeu !== 'undefined' && jeu && !PRODUCTION_MODE) {
                GameSaveSystem.save();
            }
        }, 30000);

        // 💾 Sauvegarder avant fermeture de la page
        window.addEventListener('beforeunload', () => {
            // � Ne pas sauvegarder si changement de langue en cours
            if (window.isChangingLanguage) {
                console.log('🌍 Changement de langue - sauvegarde beforeunload annulée');
                return;
            }
            
            // �🔥 Ne pas sauvegarder si on a demandé un reset
            const resetFlag = localStorage.getItem('gameResetInProgress');
            if (resetFlag === 'true') {
                console.log('🔄 Reset en cours détecté - AUCUNE sauvegarde');
                return;
            }
            
            if (typeof jeu !== 'undefined' && jeu) {
                console.log('💾 Sauvegarde automatique avant fermeture');
                GameSaveSystem.save();
            }
        });

        // 🎯 Fonctions globales accessibles
        window.saveGame = () => GameSaveSystem.save();
        window.loadGame = () => {
            const state = GameSaveSystem.load();
            if (state) {
                GameSaveSystem.restore(state);
            }
        };
        window.getSaveInfo = () => GameSaveSystem.getSaveInfo();
        
        // ✅ Fonction pour nettoyer les sauvegardes invalides
        window.clearInvalidSaves = () => {
            const saveInfo = GameSaveSystem.getSaveInfo();
            if (saveInfo && (saveInfo.incompatible || saveInfo.error)) {
                console.log('🗑️ Suppression sauvegarde invalide');
                GameSaveSystem.clear();
                return true;
            }
            return false;
        };
        
        // 🔍 Vérifier au chargement si la sauvegarde est valide
        window.addEventListener('load', () => {
            const saveInfo = GameSaveSystem.getSaveInfo();
            if (saveInfo && saveInfo.incompatible) {
                console.warn('⚠️ Sauvegarde incompatible détectée - suppression automatique');
                GameSaveSystem.clear();
            }
        });
    </script>

    <script>
        // ============================================
        // 🌍 SYSTÈME DE TRADUCTION MULTILINGUE
        // ============================================

        // 🌍 Système de traduction unifié - utilise le module i18n.js
        let currentLang = localStorage.getItem('petit_bateau_lang') || 'fr';
        
        // État du survol du drapeau avec animation
        let flagHover = false;
        let flagHoverAnimation = 0; // 0 = normal, 1 = survolé
        let flagHoverAnimationSpeed = 0.15; // Vitesse de transition

        // Charger l'icône du jeu pour le menu Info
        const gameIcon = new Image();
        gameIcon.src = 'icons/icon-96x96.png';

        // Obtenir le drapeau de la langue actuelle
        function getCurrentLanguageFlag() {
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            const flags = {
                    'fr': '🇫🇷', 'en': '🇬🇧', 'es': '🇪🇸', 'de': '🇩🇪',
                    'it': '🇮🇹', 'pt': '🇵🇹', 'ru': '🇷🇺', 'uk': '🇺🇦',
                    'zh': '🇨🇳', 'jp': '🇯🇵', 'ko': '🇰🇷', 'rc': '🇷🇪',
                    'lg': '🇨🇩', 'ar': '🇸🇦', 'he': '🇮🇱'
                };
            return flags[currentLang] || '🌍';
        }

        // ============================================
        // 🎮 DÉBUT DU CODE DU JEU
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Détection mobile et tactile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                         || (window.innerWidth < 500);
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // 🔒 FORCER MODE PORTRAIT SUR MOBILE
        if (isMobile) {
            const forcerPortrait = async () => {
                try {
                    // API Screen Orientation (Android Chrome, Firefox mobile)
                    if (screen.orientation && screen.orientation.lock) {
                        await screen.orientation.lock('portrait-primary');
                        console.log('✅ Mode portrait forcé (orientation.lock)');
                    } 
                    // iOS Safari ne supporte pas orientation.lock
                    else if (screen.lockOrientation) {
                        screen.lockOrientation('portrait-primary');
                        console.log('✅ Mode portrait forcé (lockOrientation)');
                    } 
                    else if (screen.mozLockOrientation) {
                        screen.mozLockOrientation('portrait-primary');
                        console.log('✅ Mode portrait forcé (mozLockOrientation)');
                    } 
                    else if (screen.msLockOrientation) {
                        screen.msLockOrientation('portrait-primary');
                        console.log('✅ Mode portrait forcé (msLockOrientation)');
                    }
                    else {
                        console.log('⚠️ Lock orientation non supporté - Utilisation du CSS uniquement');
                    }
                } catch (err) {
                    console.log('ℹ️ Orientation lock non disponible:', err.message);
                    console.log('📱 Le CSS media query bloquera le paysage si nécessaire');
                }
            };
            
            // Tenter immédiatement
            forcerPortrait();
            
            // Retenter au premier touch (requis sur certains navigateurs)
            const activerPortraitAuTouch = () => {
                forcerPortrait();
                document.removeEventListener('touchstart', activerPortraitAuTouch);
                document.removeEventListener('click', activerPortraitAuTouch);
            };
            document.addEventListener('touchstart', activerPortraitAuTouch, { once: true });
            document.addEventListener('click', activerPortraitAuTouch, { once: true });
        }
        
        // 📱 PLEIN ÉCRAN AUTOMATIQUE SUR MOBILE
        if (isMobile) {
            // Fonction pour activer le plein écran (DÉSACTIVÉE)
            const activerPleinEcranMobile = async () => {
                console.log('ℹ️ Mode plein écran désactivé');
                return; // DÉSACTIVÉ
                
                /*
                const elem = document.documentElement;
                
                // Vérifier si déjà en plein écran
                if (document.fullscreenElement || document.webkitFullscreenElement || 
                    document.mozFullScreenElement || document.msFullscreenElement) {
                    console.log('✅ Déjà en plein écran');
                    return;
                }
                
                try {
                    // Tenter avec les différentes API selon le navigateur
                    if (elem.requestFullscreen) {
                        await elem.requestFullscreen({ navigationUI: "hide" });
                        console.log('✅ Plein écran activé (standard)');
                    } else if (elem.webkitRequestFullscreen) { // Safari iOS
                        await elem.webkitRequestFullscreen();
                        console.log('✅ Plein écran activé (webkit)');
                    } else if (elem.mozRequestFullScreen) { // Firefox
                        await elem.mozRequestFullScreen();
                        console.log('✅ Plein écran activé (moz)');
                    } else if (elem.msRequestFullscreen) { // IE/Edge
                        await elem.msRequestFullscreen();
                        console.log('✅ Plein écran activé (ms)');
                    } else {
                        console.log('⚠️ Plein écran non supporté par ce navigateur');
                    }
                    
                    // Masquer la barre d'adresse sur mobile (iOS Safari)
                    window.scrollTo(0, 1);
                    setTimeout(() => window.scrollTo(0, 0), 0);
                    
                } catch (err) {
                    console.log('ℹ️ Plein écran non activable automatiquement:', err.message);
                }
                */
                
                // Retirer les écouteurs après tentative
                document.removeEventListener('touchstart', activerPleinEcranMobile);
                document.removeEventListener('click', activerPleinEcranMobile);
                canvas.removeEventListener('touchstart', activerPleinEcranMobile);
                canvas.removeEventListener('click', activerPleinEcranMobile);
            };
            
            // Tenter immédiatement (ne fonctionnera que si appelé depuis un event user)
            activerPleinEcranMobile();
            
            // Si échec, attendre le premier touch/click
            document.addEventListener('touchstart', activerPleinEcranMobile, { once: true });
            document.addEventListener('click', activerPleinEcranMobile, { once: true });
            
            // Aussi écouter sur le canvas directement
            setTimeout(() => {
                if (canvas) {
                    canvas.addEventListener('touchstart', activerPleinEcranMobile, { once: true });
                    canvas.addEventListener('click', activerPleinEcranMobile, { once: true });
                }
            }, 100);
            
            // Réactiver le plein écran si l'utilisateur en sort
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    console.log('⚠️ Plein écran quitté - Réactivation au prochain touch');
                    document.addEventListener('touchstart', activerPleinEcranMobile, { once: true });
                    document.addEventListener('click', activerPleinEcranMobile, { once: true });
                }
            });
            
            // Pour webkit (Safari)
            document.addEventListener('webkitfullscreenchange', () => {
                if (!document.webkitFullscreenElement) {
                    console.log('⚠️ Plein écran quitté (webkit) - Réactivation au prochain touch');
                    document.addEventListener('touchstart', activerPleinEcranMobile, { once: true });
                }
            });
            
            console.log('📱 Système de plein écran automatique initialisé');
        }
        
        // Alternative : API ScreenOrientation pour PWA
        if (isMobile && window.screen && window.screen.orientation) {
            // Écouter les changements d'orientation
            window.screen.orientation.addEventListener('change', () => {
                const orientation = window.screen.orientation.type;
                console.log('📱 Orientation changée:', orientation);
            });
        }

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            let width = container?.clientWidth || 0;
            let height = container?.clientHeight || 0;

            // Sur mobile, utiliser les dimensions réelles de l'écran
            if (isMobile) {
                // 📱 SYSTÈME DE QUALITÉ ADAPTATIVE OPTIMISÉ - Résolution réduite pour performances
                const basePixelRatio = window.devicePixelRatio || 1;
                
                // Détecter les performances du device avec priorité aux performances
                const detectQualityLevel = () => {
                    const memory = navigator.deviceMemory || 4; // GB de RAM
                    const cores = navigator.hardwareConcurrency || 4;
                    const screenPixels = window.screen.width * window.screen.height;
                    const screenWidth = window.screen.width;
                    
                    // 🟢 HAUTE PERFORMANCE : Flagships récents (iPhone 14+, Galaxy S23+)
                    // - 8GB+ RAM ET 8+ cores - ratio réduit pour perfs optimales
                    if (memory >= 8 && cores >= 8 && screenWidth <= 1440) {
                        return { level: 'high', ratio: 0.5, name: '🟢 Haute' };
                    }
                    
                    // 🟡 PERFORMANCE ÉQUILIBRÉE : Milieu/haut de gamme (iPhone 11-13, Galaxy A/S)
                    // - 4GB+ RAM OU 6+ cores - le meilleur compromis perf/qualité
                    if (memory >= 4 || cores >= 6 || screenPixels < 2500000) {
                        return { level: 'medium', ratio: 0.4, name: '🟡 Équilibrée' };
                    }
                    
                    // 🔴 ÉCONOMIQUE : Entrée de gamme
                    // - < 4GB RAM, peu de cores - prioriser la fluidité
                    return { level: 'low', ratio: 0.33, name: '🔴 Économique' };
                };
                
                const quality = detectQualityLevel();
                // Limiter le pixelRatio final - max 1.0 pour éviter surcharge GPU
                // Sur iPhone 14 (ratio 3×): 3 × 0.5 = 1.5 → limité à 1.0
                // Résolution finale: 393×852 × 1.0 = 393×852 pixels (au lieu de 1179×2556!)
                const pixelRatio = Math.min(basePixelRatio * quality.ratio, 1.0);
                
                // console.log(`📱 Qualité adaptative: ${quality.name} (ratio: ${pixelRatio.toFixed(2)}×)`);
                // console.log(`   RAM: ${navigator.deviceMemory || '?'}GB | Cores: ${navigator.hardwareConcurrency || '?'} | Écran: ${window.screen.width}×${window.screen.height}`);
                
                // Dimensions physiques de l'écran
                width = window.innerWidth || 449;
                height = window.innerHeight || 799;
                
                // Sur iOS, corriger pour la barre d'adresse
                if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                    height = window.innerHeight || 799;
                }
                
                // Sécurité: valeurs minimales
                width = Math.max(width, 320);
                height = Math.max(height, 480);
                
                // Optimiser le canvas pour le pixel ratio adaptatif
                canvas.width = width * pixelRatio;
                canvas.height = height * pixelRatio;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Scaler le contexte pour compenser le pixel ratio
                ctx.scale(pixelRatio, pixelRatio);
                
                // Stocker le niveau de qualité pour autres optimisations
                window.PERF_QUALITY_LEVEL = quality.level;
                window.PERF_PIXEL_RATIO = pixelRatio;
                
                return { width, height };
            }

            // PC : comportement normal avec valeurs par défaut
            width = width || 449;
            height = height || 799;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            // Pas de réduction de qualité sur desktop
            window.PERF_QUALITY_LEVEL = 'high';
            window.PERF_PIXEL_RATIO = 1.0;

            return { width, height };
        }
        
        // 🎨 Helper: Adapter les effets visuels selon le niveau de qualité
        window.getAdaptiveEffectSettings = () => {
            const level = window.PERF_QUALITY_LEVEL || 'high';
            
            return {
                // Ombres (shadowBlur coûteux sur mobile)
                shadows: level === 'high',
                shadowBlurMax: level === 'high' ? 15 : (level === 'medium' ? 8 : 0),
                
                // Particules (réduire en mode économique)
                particleMultiplier: level === 'high' ? 1.0 : (level === 'medium' ? 0.6 : 0.3),
                
                // Blur et filtres CSS (très coûteux - désactiver sauf haute qualité)
                useBlur: level === 'high',
                
                // Gradients complexes (désactiver en mode économique)
                complexGradients: level !== 'low',
                
                // Anti-aliasing (garder sauf mode économique)
                imageSmoothingEnabled: level !== 'low',
                
                // FPS visés selon le niveau
                targetFPS: level === 'high' ? 60 : (level === 'medium' ? 50 : 40)
            };
        };

        let size = setupCanvas();
        
        // Sécurité: forcer des valeurs minimales si setupCanvas retourne 0
        if (!size.width || size.width <= 0) {
            console.warn('⚠️ Largeur invalide détectée, utilisation de 449px par défaut');
            size.width = 449;
        }
        if (!size.height || size.height <= 0) {
            console.warn('⚠️ Hauteur invalide détectée, utilisation de 799px par défaut');
            size.height = 799;
        }
        
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: 3.5, // Vitesse fixe standard casse-briques réduite (3.5 au lieu de 5 pixels/frame)
            CV: Math.max(Math.min(size.width, size.height) * 0.0015, 0.5) // Vitesse corbeau réduite (~0.5-3 px/frame)
        };
        
        console.log('✅ Canvas initialisé:', C.W + 'x' + C.H);

        // Déclaration des tableaux (seront initialisés après chargement des traductions)
        let JOUR = [];
        let NUIT = [];

        // Chargement initial des traductions
        window.translationsReady = (async () => {
            try {
                await loadTranslations(currentLang);
                initializeBrickArrays();
            } catch (error) {
                console.error('❌ Erreur chargement traductions:', error);
            }
        })();

        // Fonction pour initialiser les tableaux de briques
        function initializeBrickArrays() {
            // Vérifier si i18n est disponible
            if (!window.i18n) {
                console.warn('⚠️ i18n non disponible, utilisation des textes français par défaut');
                initializeFrenchBricks();
                return;
            }

            const currentLang = window.i18n.getCurrentLanguage();
            
            // Pour le français, TOUJOURS utiliser les textes originaux codés en dur
            if (currentLang === 'fr') {
                console.log('🇫🇷 Utilisation des textes français originaux (codés en dur)');
                initializeFrenchBricks();
            } else {
                // Pour les autres langues, essayer les traductions, sinon français
                console.log(`🌍 Tentative de chargement des traductions pour: ${currentLang}`);
                initializeTranslatedBricks();
            }
        }

        // Fonction pour initialiser les briques en français (fallback)
        function initializeFrenchBricks() {
            // Voyage de découverte de la vérité - Le Jour : La Lumière
            JOUR = [
                { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: '🗣️ Les manipulations s\'effacent devant la vérité !' },
                { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: '👨‍👩‍👧‍👦 Non... des humains comme nous !' },
                { nom: 'PRÉJUGÉS', couleur: '#DDA0DD', msg: '🎭 Les masques tombent un à un...' },
                { nom: 'PEURS', couleur: '#98FB98', msg: '👁️ J\'ai choisi de voir par moi-même !' },
                { nom: 'MÉFIANCE', couleur: '#FFCCCB', msg: '🤝 La méfiance cède à la compassion...' },
                { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '❓ Cette question hante mes nuits...' },
                { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: '👁️ Et mes yeux se sont ouverts...' },
                { nom: 'UN PÈRE', couleur: '#FFDAB9', msg: '👨 Un homme qui aime ses enfants...' },
                { nom: 'UNE MÈRE', couleur: '#AFEEEE', msg: '👩 Une femme courageuse...' },
                { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: '👶 Des rires purs et innocents...' },
                { nom: 'L\'HUMANITÉ', couleur: '#FFE4E1', msg: '💫 L\'essence même de ce que nous sommes...' },
                { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '❤️ Plus fort que toutes les barrières...' },
                { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: '🤗 Qui unit au-delà des différences...' },
                { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: '🌅 Une lumière dans l\'obscurité...' },
                { nom: 'LA PAIX', couleur: '#F5F5DC', msg: '🕊️ Possible quand on choisis d\'aimer...' },
                { nom: 'COMME MOI', couleur: '#FFFACD', msg: '🌍 On est tous des immigrés...' },
                { nom: 'VÉRITÉ RÉVÉLÉE', couleur: '#FFE4B5', msg: '👁️ Mes yeux se sont enfin ouverts...' },
                { nom: 'COURAGE DU CŒUR', couleur: '#FFF0F5', msg: '💪 J\'ai choisi de voir par moi-même...' },
                { nom: 'PRÉCIEUX', couleur: '#F0F8FF', msg: '💎 Chaque être humain est précieux...' }
            ];

            // La Nuit : L'Obscurité - Les maux qui tentent de corrompre
            NUIT = [
                { nom: 'DISCORDES', couleur: '#8B0000', msg: '⚡ Des discordes... des haines... des destructions...' },
                { nom: 'HAINES', couleur: '#4B0000', msg: '💔 Venues avec les maux de l\'ombre...' },
                { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: '🌪️ Le vol, le mensonge, la manipulation...' },
                { nom: 'VOL', couleur: '#36454F', msg: '🦹 Qui s\'empare de ce qui n\'appartient pas...' },
                { nom: 'MENSONGE', couleur: '#2F2F2F', msg: '🎭 Les masques de la tromperie...' },
                { nom: 'MANIPULATION', couleur: '#654321', msg: '🕷️ Les fils invisibles tirent les cœurs...' },
                { nom: 'CUPIDITÉ', couleur: '#654321', msg: '💰 La cupidité et l\'avidité...' },
                { nom: 'AVIDITÉ', couleur: '#483C32', msg: '⛓️ Comme des chaînes invisibles...' },
                { nom: 'CHAÎNES', couleur: '#2E4B2E', msg: '🔗 Serrant le cœur des hommes...' },
                { nom: 'MURS DE FER', couleur: '#191970', msg: '🧱 Enfermés derrière des murs de fer et de peur...' },
                { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: '💚 Le poison vert de l\'envie...' },
                { nom: 'ORGUEIL', couleur: '#191970', msg: '👑 La couronne qui aveugle...' },
                { nom: 'COLÈRE', couleur: '#8B1538', msg: '🔥 Les flammes qui consument la raison...' },
                { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '⚔️ La spirale sans fin de la souffrance...' },
                { nom: 'INDIFFÉRENCE', couleur: '#708090', msg: '🧊 Le froid qui glace les âmes...' },
                { nom: 'ÉGOÏSME', couleur: '#5D5D5D', msg: '🪞 Ne voir que son propre reflet...' },
                { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: '🙈 Choisir de fermer les yeux...' },
                { nom: 'RÉSISTANCE', couleur: '#1C1C1C', msg: '🛡️ Mais je garde mon cœur pur dans la tempête...' },
                { nom: 'LUMIÈRE', couleur: '#483D8B', msg: '✨ Car au-delà des nuages, elle existe toujours...' },
                { nom: 'ESPOIR RENAISSANT', couleur: '#4682B4', msg: '🌅 La lumière perce enfin les ténèbres...' },
                { nom: 'FORCE INTÉRIEURE', couleur: '#556B2F', msg: '🌟 Mon cœur résiste à l\'obscurité...' },
                { nom: 'SAGESSE ACQUISE', couleur: '#2F4F4F', msg: '🧠 Dans la nuit, j\'ai appris à voir...' }
            ];

            // Initialiser VOYAGE avec JOUR
            VOYAGE = JOUR;
            window.brickArraysInitialized = true;
        }

        // Fonction pour initialiser les briques traduites
        function initializeTranslatedBricks() {
            try {
                const currentLang = window.i18n.getCurrentLanguage();
                
                // Accéder directement aux données JSON chargées
                const translations = window.i18n.translations[currentLang];
                
                if (!translations || !translations.bricks) {
                    console.warn('⚠️ Structure bricks non trouvée dans les traductions, utilisation du français');
                    initializeFrenchBricks();
                    return;
                }

                // Support pour les clés en français (jour/nuit) et anglais (day/night)
                let jourBricks = translations.bricks.jour || translations.bricks.day;
                let nuitBricks = translations.bricks.nuit || translations.bricks.night;

                // Convertir objet en tableau si nécessaire
                if (jourBricks && !Array.isArray(jourBricks) && typeof jourBricks === 'object') {
                    jourBricks = Object.values(jourBricks);
                }
                if (nuitBricks && !Array.isArray(nuitBricks) && typeof nuitBricks === 'object') {
                    nuitBricks = Object.values(nuitBricks);
                }

                if (jourBricks && Array.isArray(jourBricks)) {
                    // Ajouter les couleurs aux briques traduites du jour
                    const jourColors = ['#FFB6C1', '#87CEEB', '#DDA0DD', '#98FB98', '#FFCCCB', '#F0E68C', '#E6E6FA', '#FFDAB9', '#AFEEEE', '#F5DEB3', '#FFE4E1', '#E0FFFF', '#FFF8DC', '#F0FFF0', '#F5F5DC', '#FFFACD', '#FFE4B5', '#FFF0F5', '#F0F8FF'];
                    
                    JOUR = jourBricks.map((brick, index) => ({
                        nom: brick.name || brick.nom,
                        couleur: jourColors[index] || '#FFE4E1',
                        msg: brick.msg
                    }));

                    console.log(`🌍 ${jourBricks.length} briques JOUR chargées en ${currentLang}`);
                } else {
                    console.warn('⚠️ Briques JOUR non trouvées dans les traductions, utilisation du français');
                    initializeFrenchBricks();
                    return;
                }

                if (nuitBricks && Array.isArray(nuitBricks)) {
                    // Ajouter les couleurs aux briques traduites de la nuit
                    const nuitColors = ['#8B0000', '#4B0000', '#2F1B14', '#36454F', '#2F2F2F', '#654321', '#654321', '#483C32', '#2E4B2E', '#191970'];
                    
                    NUIT = nuitBricks.map((brick, index) => ({
                        nom: brick.name || brick.nom,
                        couleur: nuitColors[index] || '#2F2F2F',
                        msg: brick.msg
                    }));

                    console.log(`🌍 ${nuitBricks.length} briques NUIT chargées en ${currentLang}`);
                } else {
                    console.warn('⚠️ Briques NUIT non trouvées dans les traductions, utilisation du français pour NUIT');
                    // Utiliser la version française pour NUIT si pas trouvée
                    NUIT = [
                        { nom: 'DISCORDES', couleur: '#8B0000', msg: '⚡ Des discordes... des haines... des destructions...' },
                        { nom: 'HAINES', couleur: '#4B0000', msg: '💔 Venues avec les maux de l\'ombre...' },
                        { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: '🌪️ Le vol, le mensonge, la manipulation...' },
                        { nom: 'VOL', couleur: '#36454F', msg: '🦹 Qui s\'empare de ce qui n\'appartient pas...' },
                        { nom: 'MENSONGE', couleur: '#2F2F2F', msg: '🎭 Les masques de la tromperie...' },
                        { nom: 'MANIPULATION', couleur: '#654321', msg: '🕷️ Les fils invisibles tirent les cœurs...' },
                        { nom: 'CUPIDITÉ', couleur: '#654321', msg: '💰 La cupidité et l\'avidité...' },
                        { nom: 'AVIDITÉ', couleur: '#483C32', msg: '⛓️ Comme des chaînes invisibles...' },
                        { nom: 'CHAÎNES', couleur: '#2E4B2E', msg: '🔗 Serrant le cœur des hommes...' },
                        { nom: 'MURS DE FER', couleur: '#191970', msg: '🧱 Enfermés derrière des murs de fer et de peur...' }
                    ];
                }

                // Initialiser VOYAGE avec JOUR
                VOYAGE = JOUR;
                window.brickArraysInitialized = true;
                console.log(`🌍 Briques initialisées en ${currentLang} avec succès !`);

            } catch (error) {
                console.error('❌ Erreur lors de l\'initialisation des briques traduites:', error);
                initializeFrenchBricks();
            }
        }

        // ===============================================
        // FONCTION HELPER POUR TRADUCTIONS AVEC FALLBACK FRANÇAIS
        // ===============================================
        
        // 🌍 Cache des traductions pour éviter les appels répétitifs (boucle infinie 60fps)
        const translationCache = new Map();
        
        /**
         * 🌍 SYSTÈME DE TRADUCTION UNIFIÉ - Gère français intégré + JSON externes
         * @param {string} key - Clé de traduction (ex: 'interface.tabs.enigmas')  
         * @param {string} [frenchText] - Texte français optionnel (si absent, utilise une base française)
         * @returns {string} - Texte traduit ou français
         */
        /**
         * 🌍 Fonction de traduction compatible avec i18n.js
         * Utilise window.i18n.t() pour la cohérence avec data-i18n
         */
        function getTranslatedText(key, frenchText = null) {
            // Si i18n n'est pas chargé, retourner le fallback français
            if (!window.i18n) {
                return frenchText || key;
            }

            const currentLang = window.i18n.getCurrentLanguage();
            const cacheKey = `${currentLang}:${key}`;
            
            // ⚡ CACHE HIT - évite les recalculs pour 60fps
            if (translationCache.has(cacheKey)) {
                const cached = translationCache.get(cacheKey);
                return cached;
            }
            
            // Utiliser i18n.t() pour obtenir la traduction
            const translation = window.i18n.t(key);
            
            // Si traduction trouvée (i18n.t retourne la clé si pas de traduction)
            if (translation && translation !== key) {
                translationCache.set(cacheKey, translation);
                return translation;
            }
            
            // Si pas de traduction, utiliser le fallback français
            const fallback = frenchText || key;
            translationCache.set(cacheKey, fallback);
            return fallback;
        }
        
        // 🌍 Fonction pour vider le cache lors du changement de langue
        function clearTranslationCache() {
            const cacheSize = translationCache.size;
            translationCache.clear();
            console.log(`🗑️ Cache des traductions vidé (${cacheSize} entrées supprimées)`);
        }
        
        // Exposer globalement pour le sélecteur de langue
        window.clearTranslationCache = clearTranslationCache;

        // Voyage actuel selon la période
        let VOYAGE = [];

        // ===============================================
        // SYSTÈME D'ÉNIGMES COLLECTIBLES
        // ===============================================

        // Base de données des énigmes avec informations modulaires
        const ENIGMES_DATABASE = {
            humanite: {
                id: 'humanite',
                nom: () => getTranslatedText('enigmes.humanity.name', 'Humanité'),
                icone: '🤝',
                description: () => getTranslatedText('enigmes.humanity.description', 'La force qui unit tous les cœurs'),
                mystere: () => getTranslatedText('enigmes.humanity.mystery', 'Qu\'est-ce qui nous rend véritablement humains ?'),
                revelation: () => getTranslatedText('enigmes.humanity.revelation', 'L\'humanité réside dans notre capacité à ressentir de la compassion pour autrui, même pour ceux qui nous sont différents.'),
                sagesse: () => getTranslatedText('enigmes.humanity.wisdom', 'Un père, une mère, des enfants... Tous cherchant simplement à vivre leur meilleure vie, comme nous.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            mur_peur: {
                id: 'mur_peur',
                nom: () => getTranslatedText('enigmes.wall_of_fear.name', 'Mur de Peur'),
                icone: '🏰',
                description: () => getTranslatedText('enigmes.wall_of_fear.description', 'L\'origine ancestrale de nos frontières'),
                mystere: () => getTranslatedText('enigmes.wall_of_fear.mystery', 'Pourquoi ces vieux réflexes animaux demeurent-ils ?'),
                revelation: () => getTranslatedText('enigmes.wall_of_fear.revelation', 'Le mur et nos frontières viennent de la peur et de la folie passée de guerre de territoire, ou la peur de perdre du terrain, d\'être envahi par des ennemis. Les forteresses étaient alors logiques et obligatoires pour se protéger, et ça depuis les grottes préhistoriques simplement pour se protéger des animaux. Mais aujourd\'hui pourquoi ces murs perdurent-ils ?'),
                sagesse: () => getTranslatedText('enigmes.wall_of_fear.wisdom', 'De la grotte préhistorique au mur moderne, la peur ancestrale persiste. Mais sommes-nous toujours des animaux apeurés, ou pouvons-nous devenir humains ?'),
                collecte: false,
                phaseRequise: 16
            },
            paix: {
                id: 'paix',
                nom: () => getTranslatedText('enigmes.peace.name', 'Paix'),
                icone: '🕊️',
                description: () => getTranslatedText('enigmes.peace.description', 'L\'harmonie qui transcende les conflits'),
                mystere: () => getTranslatedText('enigmes.peace.mystery', 'Comment trouve-t-on la paix dans un monde de chaos ?'),
                revelation: () => getTranslatedText('enigmes.peace.revelation', 'La paix naît lorsque nous choisissons d\'aimer plutôt que de haïr, de comprendre plutôt que de juger.'),
                sagesse: () => getTranslatedText('enigmes.peace.wisdom', 'Au-delà des nuages, il existe toujours une lumière. Mais pour la voir, il faut d\'abord traverser la nuit.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            diversite: {
                id: 'diversite',
                nom: () => getTranslatedText('enigmes.diversity.name', 'Diversité'),
                icone: '🌈',
                description: () => getTranslatedText('enigmes.diversity.description', 'La beauté de nos différences'),
                mystere: () => getTranslatedText('enigmes.diversity.mystery', 'Pourquoi craignons-nous ce qui est différent ?'),
                revelation: () => getTranslatedText('enigmes.diversity.revelation', 'La diversité est la richesse du monde. Chaque couleur, chaque culture apporte sa propre beauté à l\'arc-en-ciel humain.'),
                sagesse: () => getTranslatedText('enigmes.diversity.wisdom', 'On m\'a dit tant de mal sur eux... Mais j\'ai préféré aller voir de mes propres yeux.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            liberte: {
                id: 'liberte',
                nom: () => getTranslatedText('enigmes.freedom.name', 'Liberté'),
                icone: '🗽',
                description: () => getTranslatedText('enigmes.freedom.description', 'Le droit de vivre sans chaînes'),
                mystere: () => getTranslatedText('enigmes.freedom.mystery', 'Qu\'est-ce que la vraie liberté ?'),
                revelation: () => getTranslatedText('enigmes.freedom.revelation', 'La liberté n\'est pas l\'absence de contraintes, mais la capacité de choisir l\'amour malgré la peur.'),
                sagesse: () => getTranslatedText('enigmes.freedom.wisdom', 'La cupidité et l\'avidité, comme des chaînes invisibles, serrent le cœur des hommes.'),
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            foi: {
                id: 'foi',
                nom: () => getTranslatedText('enigmes.faith.name', 'Foi'),
                icone: '🙏',
                description: () => getTranslatedText('enigmes.faith.description', 'L\'espoir qui guide dans l\'obscurité'),
                mystere: () => getTranslatedText('enigmes.faith.mystery', 'Comment garder foi quand tout semble perdu ?'),
                revelation: () => getTranslatedText('enigmes.faith.revelation', 'Vouloir la liberté, c\'est aussi l\'accorder aux autres. La liberté nous sera alors à tous bénéfique et porteuse de paix.'),
                sagesse: () => getTranslatedText('enigmes.faith.wisdom', 'La foi n\'est pas l\'absence de doute, mais la décision de continuer malgré l\'incertitude, en accordant aux autres ce que nous désirons pour nous-mêmes.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            respect: {
                id: 'respect',
                nom: () => getTranslatedText('enigmes.respect.name', 'Respect'),
                icone: '🤲',
                description: () => getTranslatedText('enigmes.respect.description', 'La dignité accordée à chaque être'),
                mystere: () => getTranslatedText('enigmes.respect.mystery', 'Comment respecter ceux que nous ne comprenons pas ?'),
                revelation: () => getTranslatedText('enigmes.respect.revelation', 'Le respect naît de la reconnaissance que chaque être porte en lui une étincelle divine.'),
                sagesse: () => getTranslatedText('enigmes.respect.wisdom', 'Ils s\'enfermaient derrière des murs de fer et de peur... Mais l\'humanité existait encore.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            entraide: {
                id: 'entraide',
                nom: () => getTranslatedText('enigmes.mutual_aid.name', 'Entraide'),
                icone: '💞',
                description: () => getTranslatedText('enigmes.mutual_aid.description', 'La force de l\'union solidaire'),
                mystere: () => getTranslatedText('enigmes.mutual_aid.mystery', 'Pourquoi aider ceux qui ne peuvent rien nous donner ?'),
                revelation: () => getTranslatedText('enigmes.mutual_aid.revelation', 'Dans l\'entraide, nous découvrons que donner nous enrichit plus que recevoir.'),
                sagesse: () => getTranslatedText('enigmes.mutual_aid.wisdom', 'L\'amour, plus fort que toutes les barrières, unit au-delà des différences.'),
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            hopital: {
                id: 'hopital',
                nom: () => getTranslatedText('enigmes.healing.name', 'Guérison'),
                icone: '🏥',
                description: () => getTranslatedText('enigmes.healing.description', 'Le pouvoir de soigner les blessures'),
                mystere: () => getTranslatedText('enigmes.healing.mystery', 'Comment guérit-on les blessures invisibles ?'),
                revelation: () => getTranslatedText('enigmes.healing.revelation', 'La véritable guérison commence par l\'acceptation et se poursuit par le pardon.'),
                sagesse: () => getTranslatedText('enigmes.healing.wisdom', 'Si la tempête gronde, c\'est pour rappeler qu\'au-delà des nuages, il existe toujours une lumière.'),
                collecte: false,
                phaseRequise: 'briques'
            },
            restauration: {
                id: 'restauration',
                nom: () => getTranslatedText('enigmes.restoration.name', 'Restauration'),
                icone: '🌱',
                description: () => getTranslatedText('enigmes.restoration.description', 'Le renouveau après la destruction'),
                mystere: () => getTranslatedText('enigmes.restoration.mystery', 'Comment rebâtir après la dévastation ?'),
                revelation: () => getTranslatedText('enigmes.restoration.revelation', 'Chaque fin contient en elle les graines d\'un nouveau commencement.'),
                sagesse: () => getTranslatedText('enigmes.restoration.wisdom', 'Une lumière dans l\'obscurité... L\'espoir possible quand on choisit d\'aimer.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            avarice: {
                id: 'avarice',
                nom: () => getTranslatedText('enigmes.avarice.name', 'Avarice'),
                icone: '💰',
                description: () => getTranslatedText('enigmes.avarice.description', 'Le mur de la cupidité'),
                mystere: () => getTranslatedText('enigmes.avarice.mystery', 'Qu\'est-ce qui dresse des murs entre les hommes ?'),
                revelation: () => getTranslatedText('enigmes.avarice.revelation', 'L\'avarice bâtit des murs là où l\'amour construirait des ponts.'),
                sagesse: () => getTranslatedText('enigmes.avarice.wisdom', 'Un mur dressé dans la mer comme une cicatrice... Un mur qui n\'est pas fait de pierres, mais de lois, de papiers et de regards fermés.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            mur_liberte: {
                id: 'mur_liberte',
                nom: () => getTranslatedText('enigmes.prison_freedom.name', 'Prison de Liberté'),
                icone: '⛓️',
                description: () => getTranslatedText('enigmes.prison_freedom.description', 'Les chaînes invisibles'),
                mystere: () => getTranslatedText('enigmes.prison_freedom.mystery', 'Qui mérite d\'être libre ?'),
                revelation: () => getTranslatedText('enigmes.prison_freedom.revelation', 'La liberté n\'est pas un privilège à distribuer, mais un droit universel à honorer.'),
                sagesse: () => getTranslatedText('enigmes.prison_freedom.wisdom', 'Ce mur est la prison de la liberté des hommes. Il sépare ceux qui peuvent courir sans chaînes, et ceux qu\'on enferme dans des frontières invisibles.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            refus: {
                id: 'refus',
                nom: () => getTranslatedText('enigmes.refusal.name', 'Refus'),
                icone: '🚫',
                description: () => getTranslatedText('enigmes.refusal.description', 'Les barbelés du rejet'),
                mystere: () => getTranslatedText('enigmes.refusal.mystery', 'Pourquoi fermons-nous nos portes ?'),
                revelation: () => getTranslatedText('enigmes.refusal.revelation', 'Chaque refus est une blessure infligée à l\'humanité que nous partageons tous.'),
                sagesse: () => getTranslatedText('enigmes.refusal.wisdom', 'Des barbelés de fer et de peur... forgés par ceux qui ont oublié qu\'eux aussi furent un jour des voyageurs.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            privilege: {
                id: 'privilege',
                nom: () => getTranslatedText('enigmes.pride.name', 'Orgueil'),
                icone: '👑',
                description: () => getTranslatedText('enigmes.pride.description', 'L\'ego qui déforme notre regard'),
                mystere: () => getTranslatedText('enigmes.pride.mystery', 'Pourquoi voyons-nous les autres comme inférieurs ?'),
                revelation: () => getTranslatedText('enigmes.pride.revelation', 'L\'orgueil et l\'ego nous font voir les gens plus petits ou pauvres différemment, mais nous sommes tous égaux en humanité.'),
                sagesse: () => getTranslatedText('enigmes.pride.wisdom', 'Une porte dorée qui ne s\'ouvre que pour quelques-uns... Notre ego nous fait croire que nous la méritons, et que les autres ne la méritent pas.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            inegalites: {
                id: 'inegalites',
                nom: () => getTranslatedText('enigmes.inequality.name', 'Inégalités'),
                icone: '⚖️',
                description: () => getTranslatedText('enigmes.inequality.description', 'La pyramide des destins'),
                mystere: () => getTranslatedText('enigmes.inequality.mystery', 'Pourquoi certains portent-ils le fardeau des autres ?'),
                revelation: () => getTranslatedText('enigmes.inequality.revelation', 'Les inégalités ne sont pas une fatalité, mais un système que nous perpétuons en silence.'),
                sagesse: () => getTranslatedText('enigmes.inequality.wisdom', 'Une pyramide de destins empilés... Ceux d\'en bas portent le poids de ceux d\'en haut, et nul ne demande si c\'est juste.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            espoir_mur: {
                id: 'espoir_mur',
                nom: () => getTranslatedText('enigmes.hope.name', 'Espoir'),
                icone: '🌊',
                description: () => getTranslatedText('enigmes.hope.description', 'La liberté qui ne peut être enfermée'),
                mystere: () => getTranslatedText('enigmes.hope.mystery', 'Peut-on vraiment emprisonner la liberté ?'),
                revelation: () => getTranslatedText('enigmes.hope.revelation', 'Que l\'espoir remplisse vos cœurs, gardez avec persévérance le cap, laissez le vent de Dieu vous pousser, et ne craignez pas l\'impossible.'),
                sagesse: () => getTranslatedText('enigmes.hope.wisdom', 'Dans le cœur des vagues, la mer murmure une vérité : aucun mur n\'est éternel. Car l\'eau finit toujours par user la pierre, et la liberté, tôt ou tard, reprendra son chemin.'),
                collecte: false,
                phaseRequise: 'mur'
            },
            ange: {
                id: 'ange',
                nom: () => getTranslatedText('enigmes.lighthouse.name', 'Le Phare dans la Nuit'),
                icone: '🗼',
                description: () => getTranslatedText('enigmes.lighthouse.description', 'La lumière guide ceux qui sont perdus'),
                mystere: () => getTranslatedText('enigmes.lighthouse.mystery', 'Comment trouver son chemin dans l\'obscurité ?'),
                revelation: () => getTranslatedText('enigmes.lighthouse.revelation', 'La lumière est plus forte que la nuit. Même une petite flamme peut dissiper les ténèbres les plus profondes.'),
                sagesse: () => getTranslatedText('enigmes.lighthouse.wisdom', 'Dans les moments les plus sombres, soyez la lumière que vous cherchez. La compassion éclaire même les cœurs les plus obscurcis.'),
                collecte: false,
                phaseRequise: 'lanterne'
            },
            lampe: {
                id: 'lampe',
                nom: () => getTranslatedText('enigmes.lamp.name', 'La Lampe Remplie d\'Huile'),
                icone: '🪔',
                description: () => getTranslatedText('enigmes.lamp.description', 'L\'amour qui éclaire nos œuvres'),
                mystere: () => getTranslatedText('enigmes.lamp.mystery', 'Quelle est la source de notre lumière intérieure ?'),
                revelation: () => getTranslatedText('enigmes.lamp.revelation', 'L\'amour éclaire nos œuvres. Sans amour, on est l\'ombre de rien.'),
                sagesse: () => getTranslatedText('enigmes.lamp.wisdom', 'Nos actions ne prennent sens que lorsqu\'elles sont guidées par l\'amour. C\'est lui qui transforme le vide en plénitude, l\'ombre en lumière.'),
                collecte: false,
                phaseRequise: 'coeurs'
            },
            coeur_final: {
                id: 'coeur_final',
                nom: () => getTranslatedText('enigmes.heart.name', 'Le Cœur de l\'Humanité'),
                icone: '❤️',
                description: () => getTranslatedText('enigmes.heart.description', 'L\'essence même de notre humanité partagée'),
                mystere: () => getTranslatedText('enigmes.heart.mystery', 'Qu\'est-ce qui nous unit tous par-delà nos différences ?'),
                revelation: () => getTranslatedText('enigmes.heart.revelation', 'Au cœur de chaque être humain bat le même amour, les mêmes espoirs, les mêmes peurs. Nous sommes un.'),
                sagesse: () => getTranslatedText('enigmes.heart.wisdom', 'Le voyage s\'achève là où il a commencé : dans le cœur. C\'est en reconnaissant notre humanité commune que nous trouvons la véritable paix.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_humanite: {
                id: 'mur_humanite',
                nom: () => getTranslatedText('enigmes.humanity_no_borders.name', 'Humanité Sans Frontières'),
                icone: '🌍',
                description: () => getTranslatedText('enigmes.humanity_no_borders.description', 'L\'humanité au-delà des murs'),
                mystere: () => getTranslatedText('enigmes.humanity_no_borders.mystery', 'Les frontières définissent-elles qui nous sommes ?'),
                revelation: () => getTranslatedText('enigmes.humanity_no_borders.revelation', 'L\'humanité ne connaît pas de frontières. Nous sommes tous des voyageurs sur la même terre.'),
                sagesse: () => getTranslatedText('enigmes.humanity_no_borders.wisdom', 'Un père, une mère, des enfants... cherchant simplement à vivre, comme nous tous.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_maison: {
                id: 'mur_maison',
                nom: () => getTranslatedText('enigmes.right_to_happiness.name', 'Droit au Bonheur'),
                icone: '🏠',
                description: () => getTranslatedText('enigmes.right_to_happiness.description', 'Un toit pour chaque famille'),
                mystere: () => getTranslatedText('enigmes.right_to_happiness.mystery', 'Qui mérite un abri et le bonheur ?'),
                revelation: () => getTranslatedText('enigmes.right_to_happiness.revelation', 'Chacun a droit au bonheur, un abris, un toit. Construisons des maisons et des ponts avec des murs utiles, des murs d\'amour pour des familles qui en ont besoin.'),
                sagesse: () => getTranslatedText('enigmes.right_to_happiness.wisdom', 'Les murs ne doivent pas séparer, mais protéger. Les ponts ne doivent pas diviser, mais unir.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            mur_vie: {
                id: 'mur_vie',
                nom: () => getTranslatedText('enigmes.precious_life.name', 'Vie Précieuse'),
                icone: '💚',
                description: () => getTranslatedText('enigmes.precious_life.description', 'La valeur de chaque existence'),
                mystere: () => getTranslatedText('enigmes.precious_life.mystery', 'Toutes les vies ont-elles la même valeur ?'),
                revelation: () => getTranslatedText('enigmes.precious_life.revelation', 'Chaque vie est précieuse, qu\'elle soit née ici ou ailleurs.'),
                sagesse: () => getTranslatedText('enigmes.precious_life.wisdom', 'La vie ne se mesure pas à son origine, mais à son essence.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            },
            communautarisme: {
                id: 'communautarisme',
                nom: () => getTranslatedText('enigmes.communitarianism.name', 'Communautarisme'),
                icone: '⚔️',
                description: () => getTranslatedText('enigmes.communitarianism.description', 'Les dangers du sectarisme'),
                mystere: () => getTranslatedText('enigmes.communitarianism.mystery', 'Pourquoi nos divisions nous affaiblissent-elles ?'),
                revelation: () => getTranslatedText('enigmes.communitarianism.revelation', 'Important socialement mais dangereux dans les dérives de dictature. On retrouve le communautarisme un peu partout, de la politique et ses divisions, des religions aux sectes athéistes. Chacun mène son combat, le combat de l\'homme avec sa vision, son cœur. La communauté c\'est bien, mais détruire les idées des autres, sans tolérance et respect, n\'aide pas l\'humanité à progresser.'),
                sagesse: () => getTranslatedText('enigmes.communitarianism.wisdom', 'Notre sectarisme politique et religieux détruit les ponts, détruit la paix. Il nous faut cet élan de porter à bien le projet des autres, aider à la réussite, consolider et pas détruire hâtivement les idées des autres. Sans tolérance, point de progrès.'),
                collecte: false,
                phaseRequise: 'feux_artifice'
            }
        };

        // Gestionnaire de collection d'énigmes (version simplifiée pour canvas)
        class EnigmaCollector {
            constructor() {
                this.enigmesCollectees = new Set();
                this.chargerProgression();
            }

            // Charger la progression depuis localStorage
            chargerProgression() {
                const saved = localStorage.getItem('vdv_enigmes_collectees');
                if (saved) {
                    this.enigmesCollectees = new Set(JSON.parse(saved));
                }
            }

            // Sauvegarder la progression
            sauvegarderProgression() {
                localStorage.setItem('vdv_enigmes_collectees',
                    JSON.stringify([...this.enigmesCollectees]));
            }

            // Vérifier si une énigme peut être collectée
            peutCollecterEnigme(enigmeId) {
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) return false;

                // L'ange est collecté uniquement via la chauve-souris (pas automatiquement)
                if (enigmeId === 'ange') return false;

                // Vérifier si la phase actuelle correspond
                return phaseJeu === enigme.phaseRequise ||
                       (phaseJeu === 'petits_coeurs' && enigme.phaseRequise === 'coeurs');
            }

            // Collecter une énigme pendant le voyage
            collecterEnigme(enigmeId, forceCollection = false) {
                //
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) {
                    //
                    return false;
                }
                if (this.enigmesCollectees.has(enigmeId)) {
                    //
                    return false;
                }

                const peutCollecter = this.peutCollecterEnigme(enigmeId);
                //console.log(`🔍 peutCollecterEnigme(${enigmeId}): ${peutCollecter}, phaseJeu: ${phaseJeu}, phaseRequise: ${enigme.phaseRequise}`);

                // Permettre la collection forcée (pour les énigmes spéciales comme l'ange)
                if (forceCollection || peutCollecter) {
                    //
                    this.enigmesCollectees.add(enigmeId);
                    this.sauvegarderProgression();
                    this.afficherNotificationCollection(enigme);
                    //
                    return true;
                }
                //
                return false;
            }

            // Afficher notification de collection
            afficherNotificationCollection(enigme) {
                // Désactiver les notifications en phase 23
                const isPhase23 = narrationManager && narrationManager.currentPhase === 23;
                if (isPhase23) {
                    return; // Ne pas afficher de notification en phase 23
                }

                // Créer une notification simple et discrète
                const notification = document.createElement('div');

                // Position centrée verticalement pour bonne visibilité
                const isPhase16 = narrationManager && narrationManager.currentPhase === 16;
                const topPosition = isPhase16 ? '70%' : '35%'; // 70% pour phase 16, 35% pour centré

                notification.style.cssText = `
                    position: fixed;
                    top: ${topPosition};
                    left: 50%;
                    transform: translateX(-50%);
                    background: transparent;
                    color: #ffffff;
                    padding: 8px 15px;
                    font-size: 16px;
                    font-weight: normal;
                    z-index: 10000;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
                    animation: enigmaNotif 3s ease forwards;
                `;
                notification.innerHTML = `${enigme.icone} ${typeof enigme.nom === 'function' ? enigme.nom() : enigme.nom}`;

                // Ajouter les keyframes CSS si pas déjà présents
                if (!document.querySelector('#enigma-notif-style')) {
                    const style = document.createElement('style');
                    style.id = 'enigma-notif-style';
                    style.textContent = `
                        @keyframes enigmaNotif {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                            20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }

            // Vérifier et collecter automatiquement selon la phase
            verifierCollectionAutomatique() {
                // Mapper les phases aux énigmes
                const phaseEnigmeMap = {
                    'coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'petits_coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'briques': ['paix', 'foi', 'hopital'],
                    'nuit_coeurs': ['liberte', 'entraide']
                };

                const enigmesPourPhase = phaseEnigmeMap[phaseJeu] || [];

                // Collecter automatiquement une énigme aléatoire pour cette phase
                const enigmesNonCollectees = enigmesPourPhase.filter(id => !this.enigmesCollectees.has(id));

                if (enigmesNonCollectees.length > 0) {
                    const enigmeAleatoire = enigmesNonCollectees[Math.floor(Math.random() * enigmesNonCollectees.length)];

                    // Chance de 30% de collecter l'énigme pendant cette phase
                    if (Math.random() < 0.3) {
                        setTimeout(() => {
                            this.collecterEnigme(enigmeAleatoire);
                        }, Math.random() * 5000 + 2000); // Entre 2 et 7 secondes
                    }
                }
            }
        }

        // Initialiser le système d'énigmes
        const enigmaCollector = new EnigmaCollector();

        // ===============================================
        // SYSTÈME CHAUVE-SOURIS & ANGE GARDIEN
        // ===============================================

        // Révéler la chauve-souris quand la lanterne touche les oiseaux
        function revelerChauveSouris(x, y) {
            if(chauveSouris.revelee) return; // Déjà révélée

            chauveSouris.revelee = true;
            chauveSouris.active = true;
            chauveSouris.x = x;
            chauveSouris.y = y;
            chauveSouris.vx = (Math.random() - 0.5) * 2; // Mouvement erratique
            chauveSouris.vy = -1 - Math.random(); // Monte vers le haut
            chauveSouris.tempApparition = Date.now();
            chauveSouris.collectee = false;

            // Plus de message d'apparition - seulement à la collection
        }

        // Mettre à jour la chauve-souris
        function mettreAJourChauveSouris() {
            if(!chauveSouris.active) return;

            // ⚡ OPTIMISATION: Mettre à jour cache temporel
            updateChauveSourisCache();

            const tempsEcoule = chauveSourisCache.frameTime - chauveSouris.tempApparition;

            // Animation de vol erratique
            chauveSouris.x += chauveSouris.vx;
            chauveSouris.y += chauveSouris.vy;

            // ⚡ OPTIMISATION: Utiliser valeur cachée au lieu de recalculer
            // Mouvement en zigzag
            chauveSouris.vx += (Math.random() - 0.5) * 0.2;
            chauveSouris.vy += chauveSourisCache.sinValue * 0.1;

            // Limiter la vitesse
            chauveSouris.vx = Math.max(-3, Math.min(3, chauveSouris.vx));
            chauveSouris.vy = Math.max(-2, Math.min(1, chauveSouris.vy));

            // Vérifier collision avec la lanterne pour collecter
            if(!chauveSouris.collectee && balle.visible) {
                const distanceX = Math.abs(chauveSouris.x - balle.x);
                const distanceY = Math.abs(chauveSouris.y - balle.y);
                const distanceCollision = 50;

                if(distanceX < distanceCollision && distanceY < distanceCollision) {
                    collecterChauveSouris();
                }
            }

            // Faire disparaître après la durée de vie ou si elle sort de l'écran
            if(tempsEcoule > chauveSouris.dureeVie ||
               chauveSouris.x < -100 || chauveSouris.x > C.W + 100 ||
               chauveSouris.y < -100 || chauveSouris.y > C.H + 100) {
                chauveSouris.active = false;
            }
        }

        // Collecter la chauve-souris
        function collecterChauveSouris() {
            if(chauveSouris.collectee) return;

            chauveSouris.collectee = true;
            chauveSouris.active = false;

            // Ajouter 1000 XP
            score += 1000;
            window.score = score; // Synchroniser avec le score global

            // Collecter l'icône d'ange (collection forcée)
            if(enigmaCollector) {
                enigmaCollector.collecterEnigme('ange', true);
            }

            // Effet visuel spectaculaire
            for(let i = 0; i < 20; i++) {
                particules.push({
                    x: chauveSouris.x,
                    y: chauveSouris.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur: '#FFD700',
                    vie: Math.random() * 20 + 30, // 30-50 frames
                    taille: Math.random() * 6 + 4,
                    type: 'etoile'
                });
            }

            // Message de collection
            afficherMessageNarratifSimple(getTranslatedText('powerups.light_chases_night', '💡 La lumière chasse la nuit\n+1000 XP'), 4000);
        }

        // Dessiner la chauve-souris
        function dessinerChauveSouris() {
            if(!chauveSouris.active) return;

            ctx.save();
            ctx.translate(chauveSouris.x, chauveSouris.y);

            // ⚡ OPTIMISATION: Utiliser valeur de battement en cache
            ctx.rotate(chauveSourisCache.battement);

            // Corps de la chauve-souris
            ctx.fillStyle = '#2C1810';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ailes
            ctx.fillStyle = '#1A0F08';
            ctx.beginPath();
            // Aile gauche
            ctx.ellipse(-12, -5, 10, 8, -0.5, 0, Math.PI * 2);
            // Aile droite
            ctx.ellipse(12, -5, 10, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Yeux rouges
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(-3, -3, 2, 0, Math.PI * 2);
            ctx.arc(3, -3, 2, 0, Math.PI * 2);
            ctx.fill();

            // ⚡ OPTIMISATION: Calculer distance avant shadowBlur
            if(!chauveSouris.collectee && balle.visible) {
                const dx = chauveSouris.x - balle.x;
                const dy = chauveSouris.y - balle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if(distance < 80) {
                    // 📱 Adapter shadowBlur selon qualité
                    const effects = window.getAdaptiveEffectSettings();
                    if (effects.shadows) {
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = effects.shadowBlurMax;
                    }
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ===============================================
        // ANIMATION ICÔNE VERS MENU ÉNIGMES
        // ===============================================

        // Déclencher l'animation de l'icône vers le bouton du menu
        function lancerAnimationIconeVersMenu(icone) {
            if (animationIconeMenu.active) return; // Éviter les doublons

            // Position de départ (centre de l'icône thématique)
            animationIconeMenu.startX = C.W / 2;
            animationIconeMenu.startY = C.H * 0.30;

            // Position cible (bouton menu énigmes - plus bas à droite)
            animationIconeMenu.targetX = C.W - 65; // Position du bouton menu
            animationIconeMenu.targetY = 105; // Plus bas pour correspondre au bouton (80 + 25)

            // Initialiser l'animation
            animationIconeMenu.currentX = animationIconeMenu.startX;
            animationIconeMenu.currentY = animationIconeMenu.startY;
            animationIconeMenu.progress = 0;
            animationIconeMenu.startTime = Date.now();
            animationIconeMenu.icone = icone;
            animationIconeMenu.active = true;
        }

        // Mettre à jour l'animation de l'icône
        function mettreAJourAnimationIconeMenu() {
            if (!animationIconeMenu.active) return;

            const tempsEcoule = Date.now() - animationIconeMenu.startTime;
            const progression = Math.min(tempsEcoule / animationIconeMenu.duree, 1);

            // Appliquer l'easing
            const easedProgress = animationIconeMenu.easing(progression);

            // Calculer la position courante
            animationIconeMenu.currentX = animationIconeMenu.startX +
                (animationIconeMenu.targetX - animationIconeMenu.startX) * easedProgress;

            animationIconeMenu.currentY = animationIconeMenu.startY +
                (animationIconeMenu.targetY - animationIconeMenu.startY) * easedProgress;

            // Ajouter un arc parabolique pour plus de fluidité
            const arcHeight = 50;
            const arcY = Math.sin(progression * Math.PI) * arcHeight;
            animationIconeMenu.currentY -= arcY;

            // Terminer l'animation
            if (progression >= 1) {
                animationIconeMenu.active = false;

                // Effet visuel au moment de l'arrivée
                for(let i = 0; i < 10; i++) {
                    particules.push({
                        x: animationIconeMenu.targetX,
                        y: animationIconeMenu.targetY,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        couleur: '#64ffda',
                        vie: Math.random() * 25 + 35, // 35-60 frames
                        taille: Math.random() * 4 + 2,
                        type: 'rond'
                    });
                }
            }
        }

        // Dessiner l'icône en animation
        function dessinerIconeEnAnimation() {
            if (!animationIconeMenu.active) return;

            ctx.save();
            ctx.translate(animationIconeMenu.currentX, animationIconeMenu.currentY);

            // Effet de rotation pendant le vol
            const rotation = (Date.now() - animationIconeMenu.startTime) * 0.01;
            ctx.rotate(rotation);

            // Taille qui grandit légèrement pendant le vol
            const scale = 1 + Math.sin(animationIconeMenu.progress * Math.PI) * 0.3;
            ctx.scale(scale, scale);

            // Dessiner l'icône avec effet lumineux
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Lueur dorée
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#FFD700';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            // Deuxième couche plus claire
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            ctx.restore();
        }

        // ===============================================
        // BOUTON MENU ÉNIGMES DANS LE CANVAS
        // ===============================================

        // Bouton menu HOME supprimé

        // Objet bouton menu énigmes
        let boutonMenuEnigmes = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            hover: false
        };

        // Objet bouton plein écran
        let boutonPleinEcran = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            hover: false,
            isFullscreen: false
        };

        // État du menu énigmes dans le canvas
        let menuEnigmesCanvas = {
            visible: false,
            animation: 0, // 0 = fermé, 1 = ouvert
            animationStartTime: 0,
            animationDuration: 300,
            scrollY: 0,
            maxScrollY: 0,
            enigmaCards: [], // Position des cartes pour les clics
            closeButton: { x: 0, y: 0, width: 40, height: 40, hover: false },
            hoveredCard: null, // Carte actuellement survolée
            topIcons: [], // Positions des icônes en haut pour les clics
            centralIcon: { x: 0, y: 0, width: 60, height: 60, hover: false }, // Zone cliquable de l'icône centrale
            expandedCard: null, // ID de la carte actuellement dépliée (système de liste déroulante)
            ongletActif: 'enigmes', // 'enigmes', 'classement', 'langues' ou 'info'
            onglets: {
                enigmes: { x: 0, y: 0, width: 0, height: 0, hover: false },
                classement: { x: 0, y: 0, width: 0, height: 0, hover: false },
                langues: { x: 0, y: 0, width: 0, height: 0, hover: false },
                info: { x: 0, y: 0, width: 0, height: 0, hover: false }
            },
            // Cache pour optimisation des calculs répétés
            cachedTabWidths: null,
            cachedMenuDimensions: null,
            lastCalculationTime: 0,
            needsRecalculation: true,
            
            // ⚡ OPTIMISATION: Cache word wrapping carte expanded
            expandedCardCache: {
                cardId: null,
                mystereLines: [],
                revelationLines: [],
                sagesseLines: [],
                calculatedHeight: 0
            },
            
            // ⚡ OPTIMISATION: Cache textes énigmes traduits
            enigmeTextesCache: {},
            enigmeTextesInitialized: false,
            
            // ⚡ OPTIMISATION: Cache gradients menu
            gradientsCache: {
                classement: [],
                languesInactif: null,
                languesActif: null,
                initialized: false
            }
        };

        // Initialiser le module InfoAuteur
        let infoAuteur = null;
        if (typeof InfoAuteur !== 'undefined') {
            infoAuteur = new InfoAuteur();
        }

        // Créer un conteneur HTML pour l'onglet Info
        let infoContainer = null;
        // FONCTIONS DÉSACTIVÉES - Conteneur HTML Info non utilisé
        // Le système utilise maintenant uniquement le canvas pour l'onglet Info
        /*
        function creerInfoContainer() {
            if (infoContainer) return;

            infoContainer = document.createElement('div');
            infoContainer.id = 'info-artist-container';
            
            // Calculer les dimensions du menu canvas
            const menuWidth = Math.min(800, C.W * 0.95);
            const menuHeight = C.H * 0.85;
            const menuX = (C.W - menuWidth) / 2;
            const menuY = C.H * 0.075;
            
            infoContainer.style.cssText = `
                position: fixed;
                top: ${menuY}px;
                left: ${menuX}px;
                width: ${menuWidth}px;
                height: ${menuHeight}px;
                background: linear-gradient(135deg, #ffffff, #f8fafc);
                overflow-y: auto;
                overflow-x: hidden;
                padding: 20px;
                z-index: 9999;
                display: none;
                font-family: Georgia, serif;
                color: #1e293b;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                pointer-events: auto;
            `;

            // Charger le contenu depuis emmanuel-artist-module.html
            fetch('modules/emmanuel-artist-module.html')
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const bodyContent = doc.body.innerHTML;
                    infoContainer.innerHTML = bodyContent;
                    
                    const style = document.createElement('style');
                    style.textContent = `
                        #info-artist-container h1 { font-size: 24px; margin-top: 10px; }
                        #info-artist-container h2 { font-size: 20px; margin-top: 15px; }
                        #info-artist-container p { font-size: 14px; line-height: 1.6; }
                        #info-artist-container img { max-width: 100%; height: auto; }
                        #info-artist-container a { color: #3b82f6; text-decoration: none; }
                        #info-artist-container a:hover { text-decoration: underline; }
                    `;
                    infoContainer.appendChild(style);
                })
                .catch(err => {
                    console.error('Erreur chargement emmanuel-artist-module.html:', err);
                    infoContainer.innerHTML = '<p style="text-align:center;color:#ef4444;padding:40px;">' + getTranslatedText('game.content_unavailable', 'Contenu non disponible') + '</p>';
                });

            document.body.appendChild(infoContainer);
        }

        function afficherInfoContainer(visible) {
            if (!infoContainer) creerInfoContainer();
            if (infoContainer) {
                infoContainer.style.display = visible ? 'block' : 'none';
                
                if (visible) {
                    const menuWidth = Math.min(800, C.W * 0.95);
                    const menuHeight = C.H * 0.85;
                    const menuX = (C.W - menuWidth) / 2;
                    const menuY = C.H * 0.075;
                    
                    infoContainer.style.width = menuWidth + 'px';
                    infoContainer.style.height = menuHeight + 'px';
                    infoContainer.style.left = menuX + 'px';
                    infoContainer.style.top = menuY + 'px';
                }
            }
        }
        */

        // Dessiner les icônes d'énigmes collectées en haut du header
        // DÉSACTIVÉ : Les énigmes ne s'affichent que dans le menu, pas en haut
        function dessinerIconesCollecteesEnHaut(headerHeight) {
            // FONCTION DÉSACTIVÉE - Les énigmes collectées ne s'affichent QUE dans le menu 🧩
            // La chauve-souris et l'ange sont gérés séparément et toujours visibles
            return;
        }

        // CODE MORT - Ne sera jamais exécuté (après le return ci-dessus)
        /*
            // Afficher les icônes de droite à gauche
            enigmesCollectees.forEach((enigme, index) => {
                const x = startX - (index + 1) * spacing;

                // Zone cliquable
                const iconData = {
                    x: x - iconSize / 2,
                    y: iconY - iconSize / 2,
                    width: iconSize,
                    height: iconSize,
                    enigme: enigme
                };
                menuEnigmesCanvas.topIcons.push(iconData);

                // Effet de survol
                const isHovered = menuEnigmesCanvas.topIcons.some(icon =>
                    icon.enigme.id === enigme.id && icon.hover);

                // Fond de l'icône avec effet lumineux
                ctx.fillStyle = isHovered ? 'rgba(100, 255, 218, 0.3)' : 'rgba(100, 255, 218, 0.15)';
                ctx.beginPath();
                ctx.arc(x, iconY, iconSize / 2 + 2, 0, Math.PI * 2);
                ctx.fill();

                // Bordure
                ctx.strokeStyle = '#64ffda';
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.stroke();

                // Icône de l'énigme
                ctx.font = `${iconSize * 0.7}px Arial`;
                ctx.fillStyle = '#64ffda';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enigme.icone, x, iconY);

                // Badge de notification si c'est la première fois affiché
                if (index < 3) { // Badge seulement pour les 3 dernières collectées
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x + iconSize / 3, iconY - iconSize / 3, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();
        */

        // ⚡ OPTIMISATION: Initialiser cache textes énigmes traduits
        function initEnigmeTextesCache() {
            if (!menuEnigmesCanvas.enigmeTextesInitialized || !menuEnigmesCanvas.enigmeTextesCache) {
                menuEnigmesCanvas.enigmeTextesCache = {};
            }
            
            Object.keys(ENIGMES_DATABASE).forEach(id => {
                const enigme = ENIGMES_DATABASE[id];
                menuEnigmesCanvas.enigmeTextesCache[id] = {
                    nom: typeof enigme.nom === 'function' ? enigme.nom() : enigme.nom,
                    description: typeof enigme.description === 'function' ? enigme.description() : enigme.description,
                    mystere: typeof enigme.mystere === 'function' ? enigme.mystere() : enigme.mystere,
                    revelation: typeof enigme.revelation === 'function' ? enigme.revelation() : enigme.revelation,
                    sagesse: typeof enigme.sagesse === 'function' ? enigme.sagesse() : enigme.sagesse,
                    icone: enigme.icone
                };
            });
            
            menuEnigmesCanvas.enigmeTextesInitialized = true;
        }
        
        // ⚡ OPTIMISATION: Initialiser cache gradients menu
        function initMenuGradientsCache() {
            if (menuEnigmesCanvas.gradientsCache.initialized) return;
            
            // Gradients classement (10 entrées)
            menuEnigmesCanvas.gradientsCache.classement = [];
            for (let i = 0; i < 10; i++) {
                const gradient = ctx.createLinearGradient(0, 0, 0, 60);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.08)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.02)');
                menuEnigmesCanvas.gradientsCache.classement.push(gradient);
            }
            
            // Gradient langue inactif (réutilisable)
            const gradientInactif = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            gradientInactif.addColorStop(0, '#f9fafb');
            gradientInactif.addColorStop(0.7, '#f3f4f6');
            gradientInactif.addColorStop(1, '#e5e7eb');
            menuEnigmesCanvas.gradientsCache.languesInactif = gradientInactif;
            
            // Gradient langue actif
            const gradientActif = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            gradientActif.addColorStop(0, '#ffffff');
            gradientActif.addColorStop(0.7, '#f8fafc');
            gradientActif.addColorStop(1, '#e2e8f0');
            menuEnigmesCanvas.gradientsCache.languesActif = gradientActif;
            
            menuEnigmesCanvas.gradientsCache.initialized = true;
        }

        // Dessiner le bouton menu énigmes dans le canvas
        function dessinerBoutonMenuEnigmes() {
            // Position dans le header à droite
            const headerH = Math.max(C.H * 0.045, 32);
            boutonMenuEnigmes.x = C.W - 65;
            boutonMenuEnigmes.y = Math.max(headerH / 2 - 25, 5); // Centré dans le header

            ctx.save();

            // Effet de survol
            const scale = boutonMenuEnigmes.hover ? 1.1 : 1;
            const alpha = boutonMenuEnigmes.hover ? 1 : 0.8;

            ctx.globalAlpha = alpha;
            ctx.translate(boutonMenuEnigmes.x + boutonMenuEnigmes.width/2,
                         boutonMenuEnigmes.y + boutonMenuEnigmes.height/2);
            ctx.scale(scale, scale);

            // Arrière-plan du bouton
            const gradient = ctx.createLinearGradient(-25, -25, 25, 25);
            gradient.addColorStop(0, '#1a2d4a');
            gradient.addColorStop(1, '#0a1428');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Icône du puzzle
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#64ffda';
            ctx.fillText('🧩', 0, 0);

            // Indicateur du nombre d'énigmes collectées
            if (enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;

                if (collected > 0) {
                    // Badge de notification
                    ctx.fillStyle = '#10d9c4';
                    ctx.beginPath();
                    ctx.arc(15, -15, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#0a1428';
                    ctx.fillText(collected, 15, -15);
                }
            }

            ctx.restore();
        }

        // Dessiner le bouton plein écran dans le canvas
        function dessinerBoutonPleinEcran() {
            // Position dans le header à droite, à gauche du bouton menu
            const headerH = Math.max(C.H * 0.045, 32);
            boutonPleinEcran.x = C.W - 120; // 55px à gauche du bouton menu
            boutonPleinEcran.y = Math.max(headerH / 2 - 25, 5);

            ctx.save();

            // Effet de survol
            const scale = boutonPleinEcran.hover ? 1.1 : 1;
            const alpha = boutonPleinEcran.hover ? 1 : 0.8;

            ctx.globalAlpha = alpha;
            ctx.translate(boutonPleinEcran.x + boutonPleinEcran.width/2,
                         boutonPleinEcran.y + boutonPleinEcran.height/2);
            ctx.scale(scale, scale);

            // Arrière-plan du bouton
            const gradient = ctx.createLinearGradient(-25, -25, 25, 25);
            gradient.addColorStop(0, '#1a2d4a');
            gradient.addColorStop(1, '#0a1428');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = boutonPleinEcran.isFullscreen ? '#fbbf24' : '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Icône plein écran ou minimiser
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = boutonPleinEcran.isFullscreen ? '#fbbf24' : '#64ffda';
            ctx.fillText(boutonPleinEcran.isFullscreen ? '🗗' : '⛶', 0, 0);

            ctx.restore();
        }

        // Fonction pour basculer le plein écran (DÉSACTIVÉE)
        function toggleFullscreen() {
            console.log('ℹ️ Mode plein écran désactivé');
            return; // DÉSACTIVÉ
            
            /*
            const elem = document.documentElement;
            
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Entrer en plein écran
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { // Safari
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) { // Firefox
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) { // IE/Edge
                    elem.msRequestFullscreen();
                }
                boutonPleinEcran.isFullscreen = true;
                
                // 🔊 Son de succès
                if (AudioSystem && AudioSystem.playPowerUp) {
                    AudioSystem.playPowerUp();
                }
            } else {
                // Sortir du plein écran
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                boutonPleinEcran.isFullscreen = false;
                
                // 🔊 Son de clic
                if (AudioSystem && AudioSystem.playClick) {
                    AudioSystem.playClick();
                }
            }
            */
        }

        // Écouter les changements d'état du plein écran
        document.addEventListener('fullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.fullscreenElement;
        });
        document.addEventListener('webkitfullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.webkitFullscreenElement;
        });
        document.addEventListener('mozfullscreenchange', () => {
            boutonPleinEcran.isFullscreen = !!document.mozFullScreenElement;
        });
        document.addEventListener('MSFullscreenChange', () => {
            boutonPleinEcran.isFullscreen = !!document.msFullscreenElement;
        });

        // Fonctions menu HOME supprimées

        // ========================================
        // MENU PRINCIPAL - Accès à tous les menus
        // ========================================

        async function ouvrirMenuPrincipal() {
            // Créer un menu avec toutes les options
            const options = [
                { nom: '🧩 Énigmes', action: () => ouvrirMenuEnigmesCanvas() },
                { nom: '📜 Énigmes Complètes', action: () => ouvrirEnigmesCompletes() },
                { nom: '🎮 Menu Jeux', action: () =>console.log('Menu jeux ouvert') },
                { nom: '📜 Poème 1', action: () =>console.log('Poème 1 ouvert') },
                { nom: '📖 Poème 2', action: () =>console.log('Poème 2 ouvert') },
                { nom: '🎨 Info Artiste', action: () => ouvrirInfoArtiste() },
                { nom: '� Top 10000', action: () => ouvrirTop10000() },
                { nom: '�🎬 Générique', action: () =>console.log('Générique ouvert') },
                { nom: '🦇👼 Icônes', action: () =>console.log('Menu icônes ouvert') }
            ];

            // Pour l'instant, ouvrir le menu énigmes (à développer plus tard)
            ouvrirMenuEnigmesCanvas();
        }

        // Fonction pour ouvrir l'info artiste
        async function ouvrirInfoArtiste() {
            // Utiliser le fichier externe emmanuel-artist-module.html (plus fiable que document.write)
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            window.location.href = `modules/emmanuel-artist-module.html?lang=${currentLang}`;
        }

        // Fonction pour ouvrir le Top 10000
        async function ouvrirTop10000() {
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            // Ouvrir dans le même onglet pour éviter les popups
            window.location.href = `modules/top-scores-module.html?lang=${currentLang}`;
        }

        // Fonction pour ouvrir les énigmes complètes avec le nouveau style
        function ouvrirEnigmesCompletes() {
            // Ouvrir le fichier existant directement avec la langue actuelle
            const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
            window.location.href = `modules/emmanuel-artist-module.html?lang=${currentLang}`;
        }

        // Ouvrir le menu énigmes dans le canvas
        function ouvrirMenuEnigmesCanvas() {
            if (menuEnigmesCanvas.visible) return;

            menuEnigmesCanvas.visible = true;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.animationStartTime = Date.now();
            menuEnigmesCanvas.showInfo = false;
            menuEnigmesCanvas.selectedEnigma = null;
            menuEnigmesCanvas.scrollY = 0;
            menuEnigmesCanvas.ongletActif = 'enigmes'; // Réinitialiser à l'onglet Énigmes à chaque ouverture

            // Marquer que les calculs doivent être refaits
            menuEnigmesCanvas.needsRecalculation = true;
            
            // ⚡ OPTIMISATION: Initialiser les caches au premier appel
            if (!menuEnigmesCanvas.enigmeTextesInitialized) {
                initEnigmeTextesCache();
            }
            if (!menuEnigmesCanvas.gradientsCache.initialized) {
                initMenuGradientsCache();
            }

            // Générer les positions des cartes
            genererPositionsCartesEnigmes();
        }

        // Fermer le menu énigmes canvas
        function fermerMenuEnigmesCanvas() {
            menuEnigmesCanvas.visible = false;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.hoveredCard = null;
            menuEnigmesCanvas.expandedCard = null; // Refermer toutes les cartes dépliées
        }

        // Générer les positions des cartes d'énigmes - FORMAT LISTE avec déroulants
        function genererPositionsCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards = [];

            // Calculer les dimensions du menu centré
            const menuWidth = Math.min(C.W - 40, 700);
            const menuHeight = Math.min(C.H - 60, 600);
            const menuX = (C.W - menuWidth) / 2;
            const menuY = (C.H - menuHeight) / 2;

            const startX = menuX + 20;
            const startY = menuY + 160; // Ajusté pour laisser place aux onglets, titre et score
            const itemHeight = 80; // Hauteur de chaque ligne (agrandi)
            const spacing = 8;

            let currentY = startY;
            
            Object.values(ENIGMES_DATABASE).forEach(enigme => {
                menuEnigmesCanvas.enigmaCards.push({
                    id: enigme.id,
                    x: startX,
                    y: currentY,
                    width: menuWidth - 40,
                    height: itemHeight,
                    enigme: enigme,
                    hover: false
                });
                
                currentY += itemHeight + spacing;
                
                // NE PAS ajouter de hauteur pour le panneau déroulant
                // Le panneau s'affiche PAR-DESSUS sans décaler les autres cartes
            });

            // Calculer le scroll max
            const totalHeight = currentY - startY;
            menuEnigmesCanvas.maxScrollY = Math.max(0, totalHeight - (menuHeight - 180));
        }

        // Mettre à jour l'animation du menu
        function mettreAJourMenuEnigmesCanvas() {
            if (!menuEnigmesCanvas.visible) return;

            const elapsed = Date.now() - menuEnigmesCanvas.animationStartTime;
            const progress = Math.min(elapsed / menuEnigmesCanvas.animationDuration, 1);

            // Easing out
            menuEnigmesCanvas.animation = 1 - Math.pow(1 - progress, 3);
        }

        // Dessiner le menu énigmes dans le canvas
        function dessinerMenuEnigmesCanvas() {
            // Cacher le menu pendant les phases 17-22 (murs) UNIQUEMENT en mode 'mur'
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur') {
                return; // Ne pas afficher le menu pendant les phases de mur actives
            }

            if (!menuEnigmesCanvas.visible) {
                return;
            }

            ctx.save();

            // Arrière-plan avec transparence légère
            ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * menuEnigmesCanvas.animation})`;
            ctx.fillRect(0, 0, C.W, C.H);

            // Container principal
            const containerAlpha = menuEnigmesCanvas.animation;
            ctx.globalAlpha = containerAlpha;

            // Arrière-plan du menu - CENTRÉ et BLANC LUMINEUX
            const menuWidth = Math.min(C.W - 40, 800); // Augmenté pour 4 onglets
            const menuHeight = Math.min(C.H - 60, 600);
            const menuX = (C.W - menuWidth) / 2;
            const menuY = (C.H - menuHeight) / 2;

            // Fond blanc lumineux transparent
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            
            // 📱 Adapter shadowBlur selon qualité
            const effects = window.getAdaptiveEffectSettings();
            if (effects.shadows) {
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = effects.shadowBlurMax;
            }
            
            ctx.beginPath();
            ctx.roundRect(menuX, menuY, menuWidth, menuHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Onglets modernes et élégants - style minimaliste - 4 onglets ADAPTATIFS
            const ongletHeight = 45;
            const ongletY = menuY + 10;
            const espacementOnglets = 8;
            const paddingTexteInactif = 30;
            const paddingTexteActif = 50;
            
            // OPTIMISATION: Cache des calculs de largeur d'onglets (recalculer seulement si changement de langue ou onglet)
            const now = Date.now();
            if (menuEnigmesCanvas.needsRecalculation || !menuEnigmesCanvas.cachedTabWidths || (now - menuEnigmesCanvas.lastCalculationTime) > 1000) {
                ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
                const texteEnigmes = getTranslatedText('interface.tabs.enigmas', 'Énigmes');
                const texteScores = getTranslatedText('interface.tabs.scores', 'Scores');
                const texteLangue = getTranslatedText('interface.tabs.language', 'Langue');
                const texteInfo = getTranslatedText('interface.tabs.info', 'Info');
                
                const ongletActif = menuEnigmesCanvas.ongletActif;
                const paddingEnigmes = (ongletActif === 'enigmes') ? paddingTexteActif : paddingTexteInactif;
                const paddingScores = (ongletActif === 'classement') ? paddingTexteActif : paddingTexteInactif;
                const paddingLangue = (ongletActif === 'langues') ? paddingTexteActif : paddingTexteInactif;
                const paddingInfo = (ongletActif === 'info') ? paddingTexteActif : paddingTexteInactif;
                
                const largeurEnigmes = ctx.measureText(texteEnigmes).width + paddingEnigmes * 2;
                const largeurScores = ctx.measureText(texteScores).width + paddingScores * 2;
                const largeurLangue = ctx.measureText(texteLangue).width + paddingLangue * 2;
                const largeurInfo = ctx.measureText(texteInfo).width + paddingInfo * 2;
                
                const largeurTotaleOnglets = largeurEnigmes + largeurScores + largeurLangue + largeurInfo + (espacementOnglets * 3);
                const largeurDisponible = menuWidth - 50;
                
                let facteurReduction = 1;
                if (largeurTotaleOnglets > largeurDisponible) {
                    facteurReduction = largeurDisponible / largeurTotaleOnglets;
                }
                
                menuEnigmesCanvas.cachedTabWidths = {
                    texteEnigmes,
                    texteScores,
                    texteLangue,
                    texteInfo,
                    ongletWidthEnigmes: largeurEnigmes * facteurReduction,
                    ongletWidthScores: largeurScores * facteurReduction,
                    ongletWidthLangue: largeurLangue * facteurReduction,
                    ongletWidthInfo: largeurInfo * facteurReduction,
                    largeurTotaleReelle: (largeurEnigmes + largeurScores + largeurLangue + largeurInfo) * facteurReduction + (espacementOnglets * 3)
                };
                
                menuEnigmesCanvas.lastCalculationTime = now;
                menuEnigmesCanvas.needsRecalculation = false;
            }
            
            // Utiliser les valeurs en cache
            const { texteEnigmes, texteScores, texteLangue, texteInfo, ongletWidthEnigmes, ongletWidthScores, ongletWidthLangue, ongletWidthInfo, largeurTotaleReelle } = menuEnigmesCanvas.cachedTabWidths;
            
            const offsetCentrage = (menuWidth - largeurTotaleReelle) / 2;

            // Onglet Énigmes - CENTRÉ
            const ongletEnigmesX = menuX + offsetCentrage;
            menuEnigmesCanvas.onglets.enigmes.x = ongletEnigmesX;
            menuEnigmesCanvas.onglets.enigmes.y = ongletY;
            menuEnigmesCanvas.onglets.enigmes.width = ongletWidthEnigmes;
            menuEnigmesCanvas.onglets.enigmes.height = ongletHeight;

            const enigmesActif = menuEnigmesCanvas.ongletActif === 'enigmes';

            // Design moderne et épuré
            ctx.save();

            // Onglet Énigmes - Style minimaliste
            if (enigmesActif) {
                // Onglet actif : fond blanc pur avec légère élévation
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                // Onglet inactif : transparent avec bordure subtile
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletEnigmesX, ongletY, ongletWidthEnigmes, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure latérale - seulement ligne du bas pour onglet inactif
            if (!enigmesActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletEnigmesX, ongletY + ongletHeight);
                ctx.lineTo(ongletEnigmesX + ongletWidthEnigmes, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte élégant - police adaptée - BOLD SANS ICÔNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = enigmesActif ? '#1e293b' : '#64748b';
            ctx.textAlign = 'center';
            ctx.fillText(texteEnigmes, ongletEnigmesX + ongletWidthEnigmes / 2, ongletY + 28);

            // Indicateur actif sous le texte - ajusté dynamiquement
            if (enigmesActif) {
                ctx.fillStyle = '#3b82f6';
                const indicateurWidth = Math.min(40, ongletWidthEnigmes * 0.6);
                ctx.fillRect(ongletEnigmesX + ongletWidthEnigmes / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Classement
            const ongletClassementX = ongletEnigmesX + ongletWidthEnigmes + espacementOnglets;
            menuEnigmesCanvas.onglets.classement.x = ongletClassementX;
            menuEnigmesCanvas.onglets.classement.y = ongletY;
            menuEnigmesCanvas.onglets.classement.width = ongletWidthScores;
            menuEnigmesCanvas.onglets.classement.height = ongletHeight;

            const classementActif = menuEnigmesCanvas.ongletActif === 'classement';

            // Onglet Classement - Style minimaliste
            if (classementActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletClassementX, ongletY, ongletWidthScores, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure latérale - seulement ligne du bas pour onglet inactif
            if (!classementActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletClassementX, ongletY + ongletHeight);
                ctx.lineTo(ongletClassementX + ongletWidthScores, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte élégant - BOLD SANS ICÔNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = classementActif ? '#1e293b' : '#64748b';
            ctx.fillText(texteScores, ongletClassementX + ongletWidthScores / 2, ongletY + 28);

            // Indicateur actif - ajusté dynamiquement
            if (classementActif) {
                ctx.fillStyle = '#FFD700';
                const indicateurWidth = Math.min(50, ongletWidthScores * 0.6);
                ctx.fillRect(ongletClassementX + ongletWidthScores / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Langues
            const ongletLanguesX = ongletClassementX + ongletWidthScores + espacementOnglets;
            menuEnigmesCanvas.onglets.langues.x = ongletLanguesX;
            menuEnigmesCanvas.onglets.langues.y = ongletY;
            menuEnigmesCanvas.onglets.langues.width = ongletWidthLangue;
            menuEnigmesCanvas.onglets.langues.height = ongletHeight;

            const languesActif = menuEnigmesCanvas.ongletActif === 'langues';

            // Onglet Langues - Style minimaliste
            if (languesActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletLanguesX, ongletY, ongletWidthLangue, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure latérale - seulement ligne du bas pour onglet inactif
            if (!languesActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletLanguesX, ongletY + ongletHeight);
                ctx.lineTo(ongletLanguesX + ongletWidthLangue, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte - BOLD SANS ICÔNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = languesActif ? '#1e293b' : '#64748b';
            const currentFlag = getCurrentLanguageFlag();
            ctx.fillText(`${currentFlag} ${texteLangue}`, ongletLanguesX + ongletWidthLangue / 2, ongletY + 28);

            // Indicateur actif - ajusté dynamiquement
            if (languesActif) {
                ctx.fillStyle = '#10b981';
                const indicateurWidth = Math.min(50, ongletWidthLangue * 0.6);
                ctx.fillRect(ongletLanguesX + ongletWidthLangue / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            // Onglet Info
            const ongletInfoX = ongletLanguesX + ongletWidthLangue + espacementOnglets;
            menuEnigmesCanvas.onglets.info.x = ongletInfoX;
            menuEnigmesCanvas.onglets.info.y = ongletY;
            menuEnigmesCanvas.onglets.info.width = ongletWidthInfo;
            menuEnigmesCanvas.onglets.info.height = ongletHeight;

            const infoActif = menuEnigmesCanvas.ongletActif === 'info';

            // Onglet Info - Style minimaliste
            if (infoActif) {
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.roundRect(ongletInfoX, ongletY, ongletWidthInfo, ongletHeight, [8, 8, 0, 0]);
            ctx.fill();

            // Pas de bordure latérale - seulement ligne du bas pour onglet inactif
            if (!infoActif) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ongletInfoX, ongletY + ongletHeight);
                ctx.lineTo(ongletInfoX + ongletWidthInfo, ongletY + ongletHeight);
                ctx.stroke();
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // Texte élégant - BOLD SANS ICÔNE
            ctx.font = 'bold 14px "Segoe UI", system-ui, sans-serif';
            ctx.fillStyle = infoActif ? '#1e293b' : '#64748b';
            ctx.fillText(texteInfo, ongletInfoX + ongletWidthInfo / 2, ongletY + 28);

            // Indicateur actif - ajusté dynamiquement
            if (infoActif) {
                ctx.fillStyle = '#3b82f6';
                const indicateurWidth = Math.min(50, ongletWidthInfo * 0.6);
                ctx.fillRect(ongletInfoX + ongletWidthInfo / 2 - indicateurWidth / 2, ongletY + ongletHeight - 3, indicateurWidth, 3);
            }

            ctx.restore();

            // Titre moderne - plus petit et positionné sous les onglets - PLUS GROS
            if (enigmesActif) {
                ctx.font = '600 30px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.textAlign = 'center';
                ctx.fillText(getTranslatedText('interface.menus.voyage_enigmas', 'Voyage — Énigmes'), C.W / 2, menuY + 100);
            } else if (infoActif) {
                // Supprimé le texte "À propos"
            }

            // Statistiques (uniquement pour l'onglet Énigmes) - PLUS GROSSES
            if (menuEnigmesCanvas.ongletActif === 'enigmes' && enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;
                const percent = Math.round((collected / total) * 100);

                ctx.font = '20px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                const progressText = getTranslatedText('interface.menus.collected_progress', `Collectées: ${collected}/${total} (${percent}%)`)
                    .replace('{collected}', collected)
                    .replace('{total}', total)
                    .replace('{percent}', percent);
                ctx.fillText(progressText, C.W / 2, menuY + 130);

                // Afficher le score - PLUS GROS
                const xp = pointsConnaissance || 0;
                const scoreJeu = window.score || score;
                ctx.font = '20px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#3b82f6';
                const scoreText = getTranslatedText('interface.menus.score_xp', `🕊️ ${scoreJeu} | ⭐ XP: ${xp}`)
                    .replace('{score}', scoreJeu)
                    .replace('{xp}', xp);
                ctx.fillText(scoreText, C.W / 2, menuY + 155);
            }

            // Bouton de fermeture EN BAS du menu
            const buttonWidth = 120;
            const buttonHeight = 40;
            menuEnigmesCanvas.closeButton.x = menuX + (menuWidth - buttonWidth) / 2;
            menuEnigmesCanvas.closeButton.y = menuY + menuHeight - buttonHeight + 15; // Encore plus bas (dépasse du menu)
            menuEnigmesCanvas.closeButton.width = buttonWidth;
            menuEnigmesCanvas.closeButton.height = buttonHeight;

            // Rectangle arrondi pour le bouton
            ctx.fillStyle = menuEnigmesCanvas.closeButton.hover ? '#ff6b6b' : '#666';
            ctx.beginPath();
            ctx.roundRect(menuEnigmesCanvas.closeButton.x, menuEnigmesCanvas.closeButton.y, buttonWidth, buttonHeight, 8);
            ctx.fill();

            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(getTranslatedText('interface.buttons.close', 'Fermer'), menuEnigmesCanvas.closeButton.x + buttonWidth/2, menuEnigmesCanvas.closeButton.y + buttonHeight/2);

            // Afficher le contenu selon l'onglet actif
            if (menuEnigmesCanvas.ongletActif === 'enigmes') {
                // Zone de contenu avec clipping
                ctx.save();
                ctx.beginPath();
                ctx.rect(menuX + 10, menuY + 160, menuWidth - 20, menuHeight - 190);
                ctx.clip();

                // Dessiner les cartes d'énigmes
                dessinerCartesEnigmes();

                ctx.restore();

                // L'info-bulle popup est désactivée - utilisation du système de liste déroulante intégré
                // if (menuEnigmesCanvas.hoveredCard) {
                //     dessinerInfoBulleEnigme();
                // }
            } else if (menuEnigmesCanvas.ongletActif === 'info') {
                // Afficher l'icône et le message à 33 millions + projets d'Emmanuel
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 100;

                // Grande icône centrale - icône du jeu (PNG)
                const iconSize = 60;
                if (gameIcon.complete) {
                    ctx.drawImage(gameIcon, C.W / 2 - iconSize / 2, yPos - iconSize / 2, iconSize, iconSize);
                }
                yPos += 45;

                // Message humoristique - PLUS GROS
                ctx.font = 'bold 22px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#3b82f6';
                ctx.fillText(getTranslatedText('game.canvas.objective', 'Objectif : 33 millions ! 🌍'), C.W / 2, yPos);
                yPos += 25;

                ctx.font = '18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.click_info', '(Clic pour en savoir plus)'), C.W / 2, yPos);
                yPos += 40;

                // Citation philosophique - PLUS GROSSE
                ctx.font = 'italic 17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#7c3aed';
                ctx.fillText(getTranslatedText('game.quotes.enigma_truth', 'Dans chaque énigme se cache une vérité,'), C.W / 2, yPos);
                yPos += 22;
                ctx.fillText(getTranslatedText('game.quotes.truth_humanity', 'dans chaque vérité se révèle notre humanité.'), C.W / 2, yPos);
                yPos += 30;

                ctx.font = '18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.author', '🎨 Emmanuel Payet'), C.W / 2, yPos);
                yPos += 20;

                ctx.font = '17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.dreamer', 'Dreamer Unisona'), C.W / 2, yPos);
                yPos += 35;

                // Section des projets - PLUS GROS
                ctx.font = 'bold 20px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.projects', '📂 Projets'), C.W / 2, yPos);
                yPos += 25;

                // Créer les boutons des projets s'ils n'existent pas
                if (!menuEnigmesCanvas.projectButtons) {
                    menuEnigmesCanvas.projectButtons = [];
                    
                    const projects = [
                        {
                            titleKey: 'game.projects.games_deco',
                            titleFallback: 'Jeux & Déco',
                            link: 'https://emmanuel.gallery',
                            color: '#7c3aed'
                        },
                        {
                            titleKey: 'game.projects.unispourlapaix',
                            titleFallback: 'UnisPourLaPaix',
                            link: 'https://www.tiktok.com/@unispourlapaix',
                            color: '#059669'
                        },
                        {
                            titleKey: 'game.projects.free_gospel',
                            titleFallback: 'Free Gospel',
                            link: 'https://audiomack.com/emmanuelpayet888',
                            color: '#dc2626'
                        },
                        {
                            titleKey: 'game.projects.books_art',
                            titleFallback: 'Livres & Art',
                            link: 'https://emmanuelpayet.art',
                            color: '#0891b2'
                        },
                        {
                            titleKey: 'game.projects.good_time',
                            titleFallback: 'La Bonne Heure',
                            link: 'https://www.redbubble.com/fr/people/h777plx/shop',
                            color: '#8b5cf6'
                        }
                    ];

                    const buttonWidth = 200;
                    const buttonHeight = 35;
                    const spacing = 12;
                    const startX = C.W / 2 - buttonWidth / 2;

                    projects.forEach((project, index) => {
                        const x = startX;
                        const y = yPos + index * (buttonHeight + spacing);
                        
                        menuEnigmesCanvas.projectButtons.push({
                            x, y, width: buttonWidth, height: buttonHeight,
                            ...project
                        });
                    });
                }

                // Dessiner les boutons des projets (compacts)
                menuEnigmesCanvas.projectButtons.forEach((btn, index) => {
                    // Style du bouton simple et élégant
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = btn.color;
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 8);
                    ctx.fill();
                    ctx.stroke();

                    // Titre du projet centré - PLUS GROS
                    ctx.font = 'bold 17px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = btn.color;
                    ctx.textAlign = 'center';
                    const projectTitle = getTranslatedText(btn.titleKey, btn.titleFallback);
                    ctx.fillText(projectTitle, btn.x + btn.width / 2, btn.y + btn.height / 2 + 4);
                });

                ctx.restore();
            } else if (menuEnigmesCanvas.ongletActif === 'classement') {
                // Afficher le classement des scores
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 100;

                // ✅ Affichage mobile optimisé du meilleur score utilisateur
                if (userBestScore) {
                    // 📱 Détection mobile
                    const isMobileView = C.W < 500;
                    
                    ctx.font = `bold ${isMobileView ? 14 : 16}px "Segoe UI", system-ui, sans-serif`;
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(getTranslatedText('game.your_best', '✨ Votre meilleur score'), C.W / 2, yPos);
                    yPos += isMobileView ? 22 : 25;

                    // ✅ Fond amélioré avec coins arrondis - adaptatif
                    const donnees = userBestScore.donnees_extra;
                    let bgColor = 'rgba(59, 130, 246, 0.08)';
                    if (donnees && donnees.sagesse) {
                        const niveau = getNiveauSagesse(donnees.sagesse);
                        const hex = niveau.couleur.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);
                        bgColor = `rgba(${r}, ${g}, ${b}, 0.12)`;
                    }
                    
                    const userBoxWidth = isMobileView ? Math.min(C.W - 60, 260) : 320;
                    const userBoxHeight = isMobileView ? 45 : 50;
                    const userBoxX = C.W / 2 - userBoxWidth / 2;
                    
                    ctx.fillStyle = bgColor;
                    ctx.beginPath();
                    ctx.roundRect(userBoxX, yPos - 25, userBoxWidth, userBoxHeight, 8);
                    ctx.fill();

                    // Score utilisateur - adaptatif
                    ctx.font = `bold ${isMobileView ? 16 : 18}px "Segoe UI", system-ui, sans-serif`;
                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(userBestScore.score.toLocaleString() + ' pts', C.W / 2, yPos - 5);

                    // ✅ Niveau et énigmes - version mobile simplifiée
                    if (donnees && donnees.sagesse) {
                        const niveau = getNiveauSagesse(donnees.sagesse);
                        ctx.font = `${isMobileView ? 11 : 13}px "Segoe UI", system-ui, sans-serif`;
                        ctx.fillStyle = '#64748b';
                        
                        if (isMobileView) {
                            // Mobile: version compacte sans sagesse en nombre
                            const enigmesInfo = donnees.enigmes ? ` • ${donnees.enigmes}/18🧩` : '';
                            ctx.fillText(niveau.icone + ' ' + niveau.titre + enigmesInfo, C.W / 2, yPos + 12);
                        } else {
                            // Desktop: version complète
                            const enigmesInfo = donnees.enigmes ? ` • ${donnees.enigmes}/18🧩` : '';
                            ctx.fillText(niveau.icone + ' ' + niveau.titre + ' • ' + donnees.sagesse + '💎' + enigmesInfo, C.W / 2, yPos + 12);
                        }
                    }

                    yPos += isMobileView ? 48 : 55;
                }

                // ✅ Texte cliquable surligné "🏆 Scores Mondial" (lien vers emmanuel-artist-module.html)
                const titreText = getTranslatedText('ui.scores_title', '🏆 Scores Mondial');
                ctx.font = 'bold 18px "Segoe UI", system-ui, sans-serif';
                const titreMetrics = ctx.measureText(titreText);
                const titreWidth = titreMetrics.width;
                
                // Position du texte
                const textX = C.W / 2;
                const textY = yPos;
                
                // ✅ Fond surligné derrière le texte (comme un surlignage)
                const highlightPadding = 8;
                const highlightWidth = titreWidth + (highlightPadding * 2);
                const highlightHeight = 24;
                const highlightX = textX - highlightWidth / 2;
                const highlightY = textY - 18;
                
                ctx.fillStyle = 'rgba(59, 130, 246, 0.15)'; // Surlignage bleu léger
                ctx.beginPath();
                ctx.roundRect(highlightX, highlightY, highlightWidth, highlightHeight, 4);
                ctx.fill();
                
                // ✅ Texte bleu
                ctx.font = 'bold 18px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#3b82f6';
                ctx.textAlign = 'center';
                ctx.fillText(titreText, textX, textY);
                
                // ✅ Stocker les coordonnées pour la détection de clic (coordonnées absolues canvas)
                if (!menuEnigmesCanvas.titleLeaderboard) menuEnigmesCanvas.titleLeaderboard = {};
                menuEnigmesCanvas.titleLeaderboard = {
                    x: highlightX,
                    y: highlightY, 
                    width: highlightWidth,
                    height: highlightHeight,
                    centerY: yPos
                };
                
                // 🔧 LOG DE DEBUG PERMANENT
                console.log('📝 Titre créé:', {
                    titre: titreText,
                    zone: menuEnigmesCanvas.titleLeaderboard,
                    canvas: { menuX, menuY, C_W: C.W, C_H: C.H }
                });
                
                // Ajuster yPos après le texte surligné
                yPos += 30;

                // Vérifier si les données sont chargées
                if (loadingLeaderboard) {
                    ctx.font = '16px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(getTranslatedText('interface.system.loading', '⏳ Chargement...'), C.W / 2, yPos + 60);
                } else if (!leaderboardData || leaderboardData.length === 0) {
                    ctx.font = '16px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(getTranslatedText('interface.menus.no_score_recorded', 'Aucun score enregistré'), C.W / 2, yPos + 40);
                    yPos += 70;
                    ctx.font = '18px "Segoe UI", system-ui, sans-serif';
                    ctx.fillStyle = '#94a3b8';
                    ctx.fillText(getTranslatedText('game.quotes.be_first', 'Soyez le premier à terminer le jeu !'), C.W / 2, yPos);
                } else {
                    // ✅ AFFICHAGE OPTIMISÉ MOBILE DES SCORES - Layout adaptatif
                    ctx.textAlign = 'left';
                    
                    // 📱 OPTIMISATION MOBILE: Adapter l'espacement selon la largeur
                    const isMobileView = C.W < 500;
                    const startX = menuX + (isMobileView ? 15 : 40);
                    const lineHeight = isMobileView ? 48 : 55; // Plus compact sur mobile
                    const fontSize = isMobileView ? 13 : 16; // Texte plus petit sur mobile
                    const pseudoMaxLength = isMobileView ? 10 : 15; // Pseudo plus court sur mobile

                    leaderboardData.forEach((entry, index) => {
                        // Position et rang
                        let medal = '';
                        if (index === 0) medal = '🥇';
                        else if (index === 1) medal = '🥈';
                        else if (index === 2) medal = '🥉';
                        else medal = `${index + 1}.`;

                        // ✅ Fond coloré amélioré selon le niveau de sagesse
                        const donnees = entry.donnees_extra;
                        let bgColor = index % 2 === 0 ? 'rgba(0, 0, 0, 0.03)' : 'rgba(0, 0, 0, 0.01)';
                        if (donnees && donnees.sagesse) {
                            const niveau = getNiveauSagesse(donnees.sagesse);
                            const hex = niveau.couleur.replace('#', '');
                            const r = parseInt(hex.substr(0, 2), 16);
                            const g = parseInt(hex.substr(2, 2), 16);
                            const b = parseInt(hex.substr(4, 2), 16);
                            bgColor = `rgba(${r}, ${g}, ${b}, 0.08)`;
                        }
                        ctx.fillStyle = bgColor;
                        
                        // ✅ Rectangle arrondi pour chaque entrée
                        const entryX = menuX + (isMobileView ? 10 : 25);
                        const entryWidth = menuWidth - (isMobileView ? 20 : 50);
                        const entryHeight = lineHeight - 5;
                        const entryY = yPos - (isMobileView ? 24 : 28);
                        
                        ctx.beginPath();
                        ctx.roundRect(entryX, entryY, entryWidth, entryHeight, 6);
                        ctx.fill();

                        // Médaille/Rang - plus petit sur mobile
                        ctx.font = `bold ${isMobileView ? 13 : 16}px "Segoe UI", system-ui, sans-serif`;
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText(medal, startX, yPos);

                        // Avatar (si présent) - plus petit sur mobile
                        const avatar = entry.users?.avatar || donnees?.avatar;
                        let pseudoX = startX + (isMobileView ? 28 : 35);
                        if (avatar) {
                            ctx.font = `${isMobileView ? 15 : 18}px "Segoe UI", system-ui, sans-serif`;
                            ctx.fillText(avatar, startX + (isMobileView ? 25 : 35), yPos);
                            pseudoX = startX + (isMobileView ? 45 : 58);
                        }

                        // Pseudo (tronqué adaptatif selon taille écran)
                        ctx.font = `${isMobileView ? 13 : 15}px "Segoe UI", system-ui, sans-serif`;
                        ctx.fillStyle = '#475569';
                        const pseudo = entry.users?.pseudo || donnees?.pseudo || 'Anonyme';
                        const displayPseudo = pseudo.length > pseudoMaxLength ? pseudo.substring(0, pseudoMaxLength) + '...' : pseudo;
                        ctx.fillText(displayPseudo, pseudoX, yPos);

                        // ✅ Niveau de sagesse - Conditionnel sur mobile
                        if (donnees && donnees.sagesse) {
                            const niveau = getNiveauSagesse(donnees.sagesse);
                            
                            if (!isMobileView) {
                                // Version desktop complète
                                ctx.font = '11px "Segoe UI", system-ui, sans-serif';
                                ctx.fillStyle = '#94a3b8';
                                const enigmesInfo = donnees.enigmes ? ` • ${donnees.enigmes}/18🧩` : '';
                                const infoText = `${niveau.icone} ${niveau.titre}${enigmesInfo}`;
                                ctx.fillText(infoText, pseudoX, yPos + 18);

                                // Badges spéciaux
                                const badges = getBadges(donnees, index === 0, donnees.enigmes);
                                if (badges.length > 0) {
                                    let badgeX = menuX + menuWidth - 140;
                                    badges.forEach((badge, badgeIndex) => {
                                        if (badgeIndex < 3) {
                                            ctx.font = '12px "Segoe UI", system-ui, sans-serif';
                                            ctx.fillStyle = '#f39c12';
                                            ctx.fillText(badge.icone, badgeX, yPos + 18);
                                            badgeX += 16;
                                        }
                                    });
                                }
                            } else {
                                // 📱 Version mobile simplifiée - juste icône niveau
                                ctx.font = '9px "Segoe UI", system-ui, sans-serif';
                                ctx.fillStyle = '#94a3b8';
                                ctx.fillText(`${niveau.icone}`, pseudoX, yPos + 14);
                            }
                        }

                        // ✅ Score positionné adaptatif
                        ctx.font = `bold ${isMobileView ? 13 : 16}px "Segoe UI", system-ui, sans-serif`;
                        ctx.fillStyle = '#3b82f6';
                        ctx.textAlign = 'right';
                        const scoreText = isMobileView ? entry.score.toLocaleString() : entry.score.toLocaleString() + ' pts';
                        ctx.fillText(scoreText, menuX + menuWidth - (isMobileView ? 15 : 30), yPos - (isMobileView ? 2 : 5));
                        ctx.textAlign = 'left';

                        yPos += lineHeight;
                    });
                }

                // ✅ Message de motivation avec design moderne adaptatif
                yPos = menuY + menuHeight - 50;
                ctx.textAlign = 'center';
                
                // 📱 Adapter la taille selon l'écran
                const isMobileView = C.W < 500;
                ctx.font = `${isMobileView ? 11 : 13}px "Segoe UI", system-ui, sans-serif`;
                
                const motivationText = getTranslatedText('ui.complete_game_save_score', 
                    'Terminez le jeu pour enregistrer votre score !');
                const textMetrics = ctx.measureText(motivationText);
                const textWidth = textMetrics.width;
                const padding = isMobileView ? 8 : 12;
                const boxHeight = isMobileView ? 24 : 28;
                
                const boxX = C.W / 2 - textWidth / 2 - padding;
                const boxY = yPos - boxHeight / 2;
                const boxW = textWidth + padding * 2;
                
                // ✅ Fond rose moderne avec roundRect
                ctx.fillStyle = 'rgba(255, 182, 193, 0.25)';
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxW, boxHeight, isMobileView ? 10 : 14);
                ctx.fill();
                
                // Bordure
                ctx.strokeStyle = 'rgba(255, 105, 180, 0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Texte
                ctx.fillStyle = '#6b7280';
                ctx.fillText(motivationText, C.W / 2, yPos + 4);

                ctx.restore();
            } else if (menuEnigmesCanvas.ongletActif === 'langues') {
                // Nouvel design : boutons sur les bords reliés par des phrases d'amour
                ctx.save();
                ctx.textAlign = 'center';

                let yPos = menuY + 80;

                // Titre avec cœur
                ctx.font = 'bold 24px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText(getTranslatedText('game.canvas.languages_heart', '💝 Langues du Cœur 💝'), C.W / 2, yPos);
                yPos += 35;

                // Phrase d'introduction
                ctx.font = '16px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText(getTranslatedText('game.canvas.languages_message', 'Chaque langue porte l\'amour et la paix du monde'), C.W / 2, yPos);
                yPos += 55;

                // Langue actuelle
                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                const currentFlag = getCurrentLanguageFlag();
                
                // Définir les 14 langues avec phrases d'amour
                const languagesWithLove = {
                    'fr': { name: 'Français', love: 'L\'amour unit les cœurs' },
                    'en': { name: 'English', love: 'Love brings us together' },
                    'es': { name: 'Español', love: 'El amor nos une' },
                    'de': { name: 'Deutsch', love: 'Liebe verbindet uns' },
                    'it': { name: 'Italiano', love: 'L\'amore ci unisce' },
                    'pt': { name: 'Português', love: 'O amor nos une' },
                    'ru': { name: 'Русский', love: 'Любовь объединяет нас' },
                    'uk': { name: 'Українська', love: 'Любов єднає нас' },
                    'zh': { name: '中文', love: '爱将我们团结在一起' },
                    'jp': { name: '日本語', love: '愛が私たちを結ぶ' },
                    'ko': { name: '한국어', love: '사랑이 우리를 하나로' },
                    'rc': { name: 'Kréol Rényoné', love: 'Lamour i rèn nout kèr ansanm' },
                    'lg': { name: 'Lingala', love: 'Bolingo ekosangisa biso' },
                    'ar': { name: 'العربية', love: 'الحب يوحدنا' },
                    'he': { name: 'עברית', love: 'אהבה מאחדת אותנו' }
                };
                
                const currentLangData = languagesWithLove[currentLang] || languagesWithLove['fr'];

                // Afficher la langue actuelle au centre
                ctx.font = 'bold 18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText(`💖 ${currentFlag} ${currentLangData.name} 💖`, C.W / 2, yPos);
                yPos += 30;
                
                ctx.font = 'italic 15px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#e11d48';
                ctx.fillText(`"${currentLangData.love}"`, C.W / 2, yPos);
                yPos += 65;

                // Créer un cercle d'amour avec les langues autour
                const centerX = C.W / 2;
                const centerY = yPos + 120;
                const radius = 120;
                const langEntries = Object.entries(languagesWithLove);

                // Créer les zones cliquables en cercle
                if (!menuEnigmesCanvas.langueButtons || menuEnigmesCanvas.lastLangCheck !== currentLang) {
                    menuEnigmesCanvas.langueButtons = [];
                    menuEnigmesCanvas.lastLangCheck = currentLang;
                    
                    langEntries.forEach(([code, data], index) => {
                        const angle = (index / langEntries.length) * 2 * Math.PI - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius - 40;
                        const y = centerY + Math.sin(angle) * radius - 15;
                        const isActive = currentLang === code;

                        menuEnigmesCanvas.langueButtons.push({
                            x, y, width: 80, height: 30,
                            code, name: data.name, love: data.love, isActive, angle
                        });
                    });
                }

                // Dessiner les lignes d'amour qui relient les langues au centre
                ctx.strokeStyle = 'rgba(236, 72, 153, 0.3)';
                ctx.lineWidth = 2;
                menuEnigmesCanvas.langueButtons.forEach(btn => {
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(btn.x + btn.width / 2, btn.y + btn.height / 2);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Dessiner le cœur central
                ctx.font = '48px "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText('💗', centerX, centerY + 15);

                // Texte central "Amour Universel" AU-DESSUS du cœur
                ctx.font = 'bold 18px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif';
                ctx.fillStyle = '#1e293b';
                ctx.fillText(getTranslatedText('game.canvas.love', 'Amour'), centerX, centerY - 30);
                ctx.fillText(getTranslatedText('game.canvas.universal', 'Universel'), centerX, centerY - 12);

                // Dessiner les boutons de langue
                const flags = {
                    'fr': '🇫🇷', 'en': '🇬🇧', 'es': '🇪🇸', 'de': '🇩🇪',
                    'it': '🇮🇹', 'pt': '🇵🇹', 'ru': '🇷🇺', 'uk': '🇺🇦',
                    'zh': '🇨🇳', 'jp': '🇯🇵', 'ko': '🇰🇷', 'rc': '🇷🇪',
                    'lg': '🇨🇩', 'ar': '🇸🇦', 'he': '🇮🇱'
                };

                menuEnigmesCanvas.langueButtons.forEach(btn => {
                    // Mettre à jour le statut actif
                    btn.isActive = currentLang === btn.code;
                    
                    // Style du bouton rond élégant moderne
                    const centerX = btn.x + btn.width / 2;
                    const centerY = btn.y + btn.height / 2;
                    const radius = 20; // Rayon légèrement augmenté pour les drapeaux plus grands
                    
                    // ⚡ OPTIMISATION: Utiliser gradient pré-calculé au lieu de createRadialGradient() chaque frame
                    const gradient = btn.isActive 
                        ? menuEnigmesCanvas.gradientsCache.languesActif 
                        : menuEnigmesCanvas.gradientsCache.languesInactif;
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = btn.isActive ? '#3b82f6' : '#d1d5db'; // Bleu moderne ou gris
                    ctx.lineWidth = btn.isActive ? 3 : 2;

                    // Ombre moderne subtile
                    if (btn.isActive) {
                        ctx.shadowColor = 'rgba(59, 130, 246, 0.3)'; // Ombre bleue
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        ctx.shadowBlur = 8;
                    } else {
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 1;
                        ctx.shadowBlur = 3;
                    }

                    // Dessiner le cercle moderne
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // Effet de brillance moderne
                    if (btn.isActive) {
                        const highlightGradient = ctx.createRadialGradient(
                            centerX - 6, centerY - 6, 0, 
                            centerX - 6, centerY - 6, 12
                        );
                        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = highlightGradient;
                        ctx.beginPath();
                        ctx.arc(centerX - 4, centerY - 4, 8, 0, 2 * Math.PI);
                        ctx.fill();
                    }

                    // Réinitialiser l'ombre
                    ctx.shadowColor = 'transparent';
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.shadowBlur = 0;

                    // Drapeau ENCORE PLUS GRAND et parfaitement centré dans le cercle
                    const flag = flags[btn.code] || '🌍';
                    ctx.font = '26px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Encore plus grand
                    ctx.fillStyle = btn.isActive ? '#1f2937' : '#4b5563'; // Gris foncé moderne
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Centrage parfait dans le cercle
                    ctx.fillText(`${flag}`, centerX, centerY);
                    
                    // Nom de la langue sous le cercle (externe)
                    ctx.font = 'bold 11px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Plus grand
                    ctx.fillStyle = btn.isActive ? '#1f2937' : '#6b7280';
                    ctx.textBaseline = 'top';
                    
                    // Contour blanc subtil pour une meilleure lisibilité
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeText(btn.name, centerX, centerY + radius + 6);
                    ctx.fillText(btn.name, centerX, centerY + radius + 6);

                    // Phrase d'amour qui flotte près du bouton avec style moderne
                    if (btn.isActive) {
                        const textX = centerX;
                        const textY = centerY - radius - 35;
                        
                        // Fond moderne blanc pour la phrase
                        ctx.font = 'italic 13px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Plus grand
                        const textMetrics = ctx.measureText(`"${btn.love}"`);
                        const textWidth = textMetrics.width + 24; // Plus d'espace
                        const textHeight = 28; // Plus haut
                        
                        // Gradient moderne blanc pour le fond de la phrase
                        const phraseGradient = ctx.createLinearGradient(
                            textX - textWidth/2, textY - textHeight/2,
                            textX + textWidth/2, textY + textHeight/2
                        );
                        phraseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                        phraseGradient.addColorStop(1, 'rgba(248, 250, 252, 0.95)');
                        
                        ctx.fillStyle = phraseGradient;
                        ctx.strokeStyle = '#3b82f6'; // Bordure bleue moderne
                        ctx.lineWidth = 2;
                        
                        // Ombre moderne pour la bulle
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        ctx.shadowBlur = 8;
                        
                        ctx.beginPath();
                        ctx.roundRect(textX - textWidth/2, textY - textHeight/2, textWidth, textHeight, 12);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Réinitialiser l'ombre
                        ctx.shadowColor = 'transparent';
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        ctx.shadowBlur = 0;
                        
                        // Effet de brillance moderne sur la bulle
                        const bubbleHighlight = ctx.createLinearGradient(
                            textX - textWidth/2, textY - textHeight/2,
                            textX - textWidth/3, textY - textHeight/3
                        );
                        bubbleHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                        bubbleHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = bubbleHighlight;
                        ctx.beginPath();
                        ctx.roundRect(textX - textWidth/2, textY - textHeight/2, textWidth/2, textHeight/2, 12);
                        ctx.fill();
                        
                        ctx.font = 'italic 13px "Inter", "SF Pro Display", "Segoe UI", system-ui, sans-serif'; // Police moderne cohérente
                        ctx.fillStyle = '#374151'; // Gris foncé moderne
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Contour blanc subtil pour la phrase
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeText(`"${btn.love}"`, textX, textY);
                        ctx.fillText(`"${btn.love}"`, textX, textY);
                    }
                });

                ctx.restore();
            }

            ctx.restore();
        }

        // Dessiner les cartes d'énigmes avec système de liste déroulante
        function dessinerCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards.forEach(card => {
                let y = card.y - menuEnigmesCanvas.scrollY;

                // Ne dessiner que les lignes visibles
                if (y + card.height < 80 || y > C.H - 40) return;

                const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                const isExpanded = menuEnigmesCanvas.expandedCard === card.id;

                ctx.save();

                // Arrière-plan de la ligne - style blanc lumineux
                if (isCollected) {
                    ctx.fillStyle = card.hover ? 'rgba(100, 200, 100, 0.15)' : 'rgba(100, 200, 100, 0.08)';
                    ctx.strokeStyle = '#4CAF50';
                } else {
                    ctx.fillStyle = card.hover ? 'rgba(200, 200, 200, 0.3)' : 'rgba(230, 230, 230, 0.5)';
                    ctx.strokeStyle = '#ccc';
                }

                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(card.x, y, card.width, card.height, 8);
                ctx.fill();
                ctx.stroke();

                // Icône à gauche - PLUS GRANDE
                ctx.font = '56px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = isCollected ? '#333' : '#aaa';
                // ⚡ OPTIMISATION: Utiliser cache icône
                const cachedEnigme = menuEnigmesCanvas.enigmeTextesCache[card.id] || card.enigme;
                ctx.fillText(cachedEnigme.icone, card.x + 15, y + card.height/2);

                // Nom au centre - PLUS GROS ET GRAS
                ctx.font = 'bold 26px Arial';
                ctx.fillStyle = isCollected ? '#222' : '#999';
                // ⚡ OPTIMISATION: Utiliser cache nom (évite appel function)
                ctx.fillText(cachedEnigme.nom, card.x + 90, y + card.height/2 - 10);

                // Description en dessous (si collectée) - PLUS GROSSE
                if (isCollected) {
                    ctx.font = '18px Arial';
                    ctx.fillStyle = '#666';
                    const maxWidth = card.width - 140; // Réduit pour laisser place à la flèche
                    // ⚡ OPTIMISATION: Utiliser cache description (évite appel function)
                    const description = cachedEnigme.description;

                    // Limiter la longueur
                    if (ctx.measureText(description).width > maxWidth) {
                        let truncated = description;
                        while (ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                            truncated = truncated.slice(0, -1);
                        }
                        ctx.fillText(truncated + '...', card.x + 90, y + card.height/2 + 18);
                    } else {
                        ctx.fillText(description, card.x + 90, y + card.height/2 + 18);
                    }

                    // Flèche déroulante à droite (pour les cartes collectées) - PLUS GROSSE
                    const arrowX = card.x + card.width - 30;
                    const arrowY = y + card.height/2;
                    ctx.font = '28px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillText(isExpanded ? '▲' : '▼', arrowX, arrowY);
                }

                ctx.restore();
            });
            
            // Dessiner le panneau déroulant PAR-DESSUS toutes les cartes (après la boucle)
            const expandedCard = menuEnigmesCanvas.enigmaCards.find(card => card.id === menuEnigmesCanvas.expandedCard);
            if (expandedCard) {
                const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(expandedCard.id);
                if (isCollected) {
                    let y = expandedCard.y - menuEnigmesCanvas.scrollY + expandedCard.height + 5;
                    
                    const enigme = expandedCard.enigme;
                    const padding = 18;
                    const maxWidth = expandedCard.width - padding * 2;
                    
                    // ⚡ OPTIMISATION: Cache word wrapping (recalculer SEULEMENT si carte change)
                    if (menuEnigmesCanvas.expandedCardCache.cardId !== menuEnigmesCanvas.expandedCard) {
                        // Utiliser cache textes traduits
                        const cachedTexts = menuEnigmesCanvas.enigmeTextesCache[expandedCard.id] || enigme;
                        
                        // Préparer les textes - AJUSTÉ POUR MEILLEURE LISIBILITÉ
                        ctx.font = 'italic 17px Arial';
                        const mystereText = `💭 ${cachedTexts.mystere}`;
                        menuEnigmesCanvas.expandedCardCache.mystereLines = wrapText(ctx, mystereText, maxWidth);
                        
                        ctx.font = '17px Arial';
                        const revelationText = `✨ ${cachedTexts.revelation}`;
                        menuEnigmesCanvas.expandedCardCache.revelationLines = wrapText(ctx, revelationText, maxWidth);
                        
                        ctx.font = 'italic 15px Arial';
                        const sagesseText = `📖 ${cachedTexts.sagesse}`;
                        menuEnigmesCanvas.expandedCardCache.sagesseLines = wrapText(ctx, sagesseText, maxWidth);
                        
                        // CALCULER LA HAUTEUR DYNAMIQUE en fonction du contenu
                        const lineHeight = 24;
                        const sectionSpacing = 14;
                        menuEnigmesCanvas.expandedCardCache.calculatedHeight = padding * 2 + 20 + // padding + marge haut
                            menuEnigmesCanvas.expandedCardCache.mystereLines.length * lineHeight + sectionSpacing +
                            menuEnigmesCanvas.expandedCardCache.revelationLines.length * lineHeight + sectionSpacing +
                            menuEnigmesCanvas.expandedCardCache.sagesseLines.length * lineHeight;
                        
                        menuEnigmesCanvas.expandedCardCache.cardId = menuEnigmesCanvas.expandedCard;
                    }
                    
                    // Utiliser les valeurs en cache
                    const mystereLines = menuEnigmesCanvas.expandedCardCache.mystereLines;
                    const revelationLines = menuEnigmesCanvas.expandedCardCache.revelationLines;
                    const sagesseLines = menuEnigmesCanvas.expandedCardCache.sagesseLines;
                    const calculatedHeight = menuEnigmesCanvas.expandedCardCache.calculatedHeight;
                    const lineHeight = 24;
                    const sectionSpacing = 14;
                    
                    // Dessiner le fond du panneau déroulant avec HAUTEUR DYNAMIQUE
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    
                    // Ombre pour effet "par-dessus"
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetY = 3;
                    
                    ctx.beginPath();
                    ctx.roundRect(expandedCard.x, y, expandedCard.width, calculatedHeight, 8);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Pas besoin de clipping car la hauteur est calculée dynamiquement
                    
                    // Dessiner le contenu
                    let currentY = y + padding + 20;
                    
                    // Mystère - AJUSTÉ
                    ctx.font = 'italic 17px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    mystereLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    currentY += sectionSpacing;
                    
                    // Révélation - AJUSTÉ
                    ctx.font = '17px Arial';
                    ctx.fillStyle = '#2d5016';
                    revelationLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    currentY += sectionSpacing;
                    
                    // Sagesse - AJUSTÉ
                    ctx.font = 'italic 15px Arial';
                    ctx.fillStyle = '#777';
                    sagesseLines.forEach(line => {
                        ctx.fillText(line, expandedCard.x + padding, currentY);
                        currentY += lineHeight;
                    });
                    
                    // Plus besoin d'indicateur "..." car tout le texte est affiché
                    
                    ctx.restore();
                }
            }
        }

        // Dessiner une info-bulle centrée avec texte complet de l'énigme
        function dessinerInfoBulleEnigme() {
            const card = menuEnigmesCanvas.hoveredCard;
            if (!card || !card.enigme) return;

            const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
            if (!isCollected) return; // Afficher seulement pour les énigmes collectées

            ctx.save();

            // Info-bulle CENTRÉE à l'écran
            const maxWidth = Math.min(500, C.W - 60);
            const padding = 25;

            // Préparer le contenu
            const enigme = card.enigme;

            ctx.font = 'bold 26px Arial';
            const titreLines = wrapText(ctx, `${enigme.icone} ${typeof enigme.nom === 'function' ? enigme.nom() : enigme.nom}`, maxWidth - padding * 2);

            ctx.font = 'italic 18px Arial';
            const mystereLines = wrapText(ctx, `💭 ${typeof enigme.mystere === 'function' ? enigme.mystere() : enigme.mystere}`, maxWidth - padding * 2);

            ctx.font = '18px Arial';
            const revelationLines = wrapText(ctx, `✨ ${typeof enigme.revelation === 'function' ? enigme.revelation() : enigme.revelation}`, maxWidth - padding * 2);

            ctx.font = 'italic 16px Arial';
            const sagesseLines = wrapText(ctx, `📖 ${typeof enigme.sagesse === 'function' ? enigme.sagesse() : enigme.sagesse}`, maxWidth - padding * 2);

            // Calculer hauteur totale
            const lineHeight = 26;
            const sectionSpacing = 20;
            const totalHeight = padding * 2 +
                titreLines.length * 32 + sectionSpacing +
                mystereLines.length * lineHeight + sectionSpacing +
                revelationLines.length * lineHeight + sectionSpacing +
                sagesseLines.length * lineHeight;

            // Positionner au centre
            const tooltipX = (C.W - maxWidth) / 2;
            const tooltipY = (C.H - totalHeight) / 2;

            // Fond blanc lumineux
            ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(76, 175, 80, 0.5)';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.roundRect(tooltipX, tooltipY, maxWidth, totalHeight, 15);
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Dessiner le contenu
            let currentY = tooltipY + padding;

            // Titre
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            titreLines.forEach(line => {
                ctx.fillText(line, C.W / 2, currentY);
                currentY += 32;
            });
            currentY += sectionSpacing;

            // Mystère
            ctx.font = 'italic 18px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'left';
            mystereLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });
            currentY += sectionSpacing;

            // Révélation
            ctx.font = '18px Arial';
            ctx.fillStyle = '#2d5016';
            revelationLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });
            currentY += sectionSpacing;

            // Sagesse
            ctx.font = 'italic 16px Arial';
            ctx.fillStyle = '#888';
            sagesseLines.forEach(line => {
                ctx.fillText(line, tooltipX + padding, currentY);
                currentY += lineHeight;
            });

            ctx.restore();
        }

        // Vérifier le survol des icônes en haut ET de l'icône centrale
        function verifierSurvolIconesHaut(x, y) {
            // Vérifier le survol de l'icône centrale thématique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                centralIcon.hover = true;
            } else {
                centralIcon.hover = false;
            }

            // Vérifier le survol des icônes en haut
            if (!menuEnigmesCanvas.topIcons || menuEnigmesCanvas.topIcons.length === 0) return;

            for (let icon of menuEnigmesCanvas.topIcons) {
                if (x >= icon.x && x <= icon.x + icon.width &&
                    y >= icon.y && y <= icon.y + icon.height) {
                    icon.hover = true;
                } else {
                    icon.hover = false;
                }
            }
        }

        // Vérifier le survol des cartes d'énigmes
        function verifierSurvolCartes(x, y) {
            if (!menuEnigmesCanvas.visible) {
                menuEnigmesCanvas.hoveredCard = null;
                return;
            }

            let cardTrouvee = null;

            for (let card of menuEnigmesCanvas.enigmaCards) {
                const cardY = card.y - menuEnigmesCanvas.scrollY;

                // Vérifier si la carte est visible et survolée
                if (cardY + card.height >= 110 && cardY <= C.H - 40 &&
                    x >= card.x && x <= card.x + card.width &&
                    y >= cardY && y <= cardY + card.height) {

                    const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                    if (isCollected) {
                        cardTrouvee = card;
                        card.hover = true;
                    }
                } else {
                    card.hover = false;
                }
            }

            menuEnigmesCanvas.hoveredCard = cardTrouvee;
        }

        // Fonction utilitaire pour découper le texte en lignes
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Fonction utilitaire pour afficher des messages spéciaux - style bulle discrète
        function afficherMessageSpecial(texte, duree = 3000) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 60%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: normal;
                z-index: 10001;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.3);
                animation: messageSpecialAnim 4s ease forwards;
                text-align: center;
                border: 3px solid #FF8C00;
            `;
            messageDiv.innerHTML = texte;

            // Ajouter animation CSS si pas déjà présente
            if (!document.querySelector('#message-special-style')) {
                const style = document.createElement('style');
                style.id = 'message-special-style';
                style.textContent = `
                    @keyframes messageSpecialAnim {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                        15%, 85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), duree);
        }

        // ===============================================
        // NOUVEAU SYSTÈME DE NARRATION COMPLETE V2.0
        // ===============================================

        // Gestionnaire central de la narration
        class NarrationManager {
            constructor() {
                this.currentPhase = 1;
                this.isTransitioning = false;
                this.victoryTimers = new Map();
                this.phaseHistory = [];

                // Configuration des phases avec IDs uniques (textes traduits)
                // Note: les phases seront rechargées après le chargement de i18n
                this.phases = this.loadTranslatedPhases();
            }

            // Recharger les phases avec les nouvelles traductions
            reloadPhases() {
                this.phases = this.loadTranslatedPhases();
                console.log('✅ Phases narratives rechargées avec traductions');
            }

            // Fonction helper pour charger les titres et textes traduits
            loadTranslatedPhases() {
                return [
                    {
                        id: 'VDV_NARR_P01_INTRO_LUMIERE',
                        phase: 1,
                        titre: getTranslatedText('narrative.voyage_titles.phase1', 'Voyage — L\'aube des doutes'),
                        texte: getTranslatedText('narrative.phase1.text', "On m'a dit qu'ils étaient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai préféré aller voir\nde mes propres yeux..."),
                        mode: 'coeurs',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P02_REVELATION_FAMILLE',
                        phase: 2,
                        titre: getTranslatedText('narrative.voyage_titles.phase2', 'Voyage — La lumière'),
                        texte: getTranslatedText('narrative.phase2.text', 'Qui étaient-ils vraiment ?...\nEt j\'ai vu...\nUn père... une mère...\ndes enfants...\nTous cherchant simplement à vivre\nleur meilleure vie...\nComme moi.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'neon',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P03_TRANSITION_OBSCURITE',
                        phase: 3,
                        titre: getTranslatedText('narrative.voyage_titles.phase3', 'Voyage — L\'ombre des nuages'),
                        texte: getTranslatedText('narrative.phase3.text', 'Alors, la lune apparut.\nLe ciel s\'assombrit\ncomme une page brûlée\npar le temps.\nUn aileron fendit les vagues\nsombres...\nDes éclairs zébrèrent\nles nuages gris.\n\nEt avec eux vinrent les maux...\nLes discordes...'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'shadow3d',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P04_CHAPITRE2_NUAGES',
                        phase: 4,
                        titre: getTranslatedText('narrative.voyage_titles.phase4', 'Voyage — L\'ombre des nuages'),
                        texte: getTranslatedText('narrative.phase4.text', 'La haine...\nLa destruction...\nLe vol, le mensonge,\nLa manipulation...\nLa cupidité et l\'avidité,\nComme des chaînes invisibles,\nSerrant le cœur des hommes.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P05_MAUX_CHAINES',
                        phase: 5,
                        titre: getTranslatedText('narrative.voyage_titles.phase5', 'Voyage — Le silence de l\'âme'),
                        texte: getTranslatedText('narrative.phase5.text', 'On m\'a dit de ne pas écouter\nleurs cris...\nOn m\'a dit de ne pas laisser\nl\'orage me faire peur.\nCar l\'orage,\naussi bruyant qu\'il soit,\nne dure jamais\néternellement.'),
                        mode: 'nuit_coeurs',
                        duree: 20000,
                        transition: 'fire',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P06_ORAGE_TEMPORAIRE',
                        phase: 6,
                        titre: getTranslatedText('narrative.voyage_titles.phase6', 'Voyage — Le silence de l\'âme'),
                        texte: getTranslatedText('narrative.phase6.text', 'Et si la tempête gronde,\nc\'est peut-être\npour rappeler à l\'homme\nqu\'au-delà des nuages,\nil existe toujours\nune lumière.\nMais pour la voir,\nil faut d\'abord traverser\nla nuit...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P07_LUMIERE_NUAGES',
                        phase: 7,
                        titre: getTranslatedText('narrative.voyage_titles.phase7', 'Voyage — L\'humanité des cœurs'),
                        texte: getTranslatedText('narrative.phase7.text', 'On m\'a dit...\nque l\'humanité n\'existait plus,\nqu\'elle s\'était perdue\ndans les guerres\net les rancunes.\nOn m\'a dit que les hommes\nn\'accueillaient\nplus personne,\nqu\'ils s\'enfermaient\nderrière des murs de fer\net de peur...'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'outline',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P08_CHAPITRE3_HUMANITE',
                        phase: 8,
                        titre: getTranslatedText('narrative.voyage_titles.phase8', 'Voyage — L\'humanité des cœurs'),
                        texte: getTranslatedText('narrative.phase8.text', 'Mais moi, j\'ai vu…\nUne main tendue à un étranger.\nUn sourire partagé\nmalgré la faim.\nUne porte ouverte\npour celui qui tremblait\ndans la nuit...'),
                        mode: 'nuit_coeurs',
                        duree: 20000,
                        transition: 'digital',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P09_MAIN_TENDUE',
                        phase: 9,
                        titre: getTranslatedText('narrative.voyage_titles.phase9', 'Voyage — L\'humanité des cœurs'),
                        texte: getTranslatedText('narrative.phase9.text', 'C\'est cela,\nl\'hospitalité :\nnon pas donner ce qu\'on a de trop,\nmais partager\nmême ce qui manque...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P10_HOSPITALITE',
                        phase: 10,
                        titre: getTranslatedText('narrative.voyage_titles.phase10', 'Voyage — La sagesse des différences'),
                        texte: getTranslatedText('narrative.phase10.text', 'On m\'a dit que la liberté\nn\'était qu\'un mot,\nune illusion\nque les puissants\nvendaient aux faibles.\nMais j\'ai vu…\nUn enfant courir pieds nus\nsous la pluie,\nriant sans chaînes,\net dans ses rires,\nj\'ai compris que la liberté\nvit d\'abord dans l\'âme.'),
                        mode: 'coeurs',
                        duree: 40000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P11_LIBERTE_AME',
                        phase: 11,
                        titre: getTranslatedText('narrative.voyage_titles.phase11', 'Voyage — La sagesse des différences'),
                        texte: getTranslatedText('narrative.phase11.text', 'On m\'a dit que les hommes\nn\'aidaient plus,\nque chacun ne vivait que pour soi.\nMais j\'ai vu…\nDes inconnus soulever ensemble\nune pierre trop lourde,\net dans cette force partagée,\nj\'ai vu l\'amour naître.'),
                        mode: 'nuit_coeurs',
                        duree: 30000,
                        transition: 'neon',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P12_AMOUR_PARTAGE',
                        phase: 12,
                        titre: getTranslatedText('narrative.voyage_titles.phase12', 'Voyage — La sagesse des différences'),
                        texte: getTranslatedText('narrative.phase12.text', 'On m\'a dit que l\'amour\nétait fragile,\nmais j\'ai vu\nqu\'il est plus fort\nque la haine,\ncar il construit\nquand la haine\ndétruit...'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'fire',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P13_AMOUR_CONSTRUCTION',
                        phase: 13,
                        titre: getTranslatedText('narrative.voyage_titles.phase13', 'Voyage — L\'unité'),
                        texte: getTranslatedText('narrative.phase13.text', 'On m\'a dit que la tolérance\nétait une faiblesse,\nmais j\'ai vu qu\'elle est\nune sagesse :\ncelle de reconnaître\nque nous ne sommes pas tous\nsemblables...\nEt c\'est là\nle trésor de la vie,\nla voie vers\nla paix.'),
                        mode: 'coeurs',
                        duree: 30000,
                        transition: 'shadow3d',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P14_TOLERANCE_SAGESSE',
                        phase: 14,
                        titre: getTranslatedText('narrative.voyage_titles.phase14', 'Voyage — L\'unité'),
                        texte: getTranslatedText('narrative.phase14.text', 'La diversité…\nElle n\'est pas un danger,\nelle est un trésor.\nComme les couleurs\nd\'un arc-en-ciel,\nc\'est leur différence\nqui fait naître la beauté.'),
                        mode: 'nuit_coeurs',
                        duree: 30000,
                        transition: 'typewriter',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P15_DIVERSITE_TRESOR',
                        phase: 15,
                        titre: getTranslatedText('narrative.voyage_titles.phase15', 'Voyage — L\'unité'),
                        texte: getTranslatedText('narrative.phase15.text', 'Et dans ce mélange\nd\'humanité,\nj\'ai compris\nque nous sommes\nun seul peuple,\nlié par la même\nsoif de vivre,\nde créer,\net d\'aimer.'),
                        mode: 'briques',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P16_UNITE_HUMANITE',
                        phase: 16,
                        titre: getTranslatedText('narrative.voyage_titles.phase16', 'L\'Unité de l\'Humanité'),
                        texte: getTranslatedText('narrative.phase16.text', 'Le voyage commence,\net je vous souhaite bon vent.\n\nQue le vent vous porte toujours plus loin,\nlà où le bonheur est libre.\n\nLà où les frontières deviennent\ndes promesses, des espoirs,\ndes projets de vie nouvelle.\n\nNe vous arrêtez pas aux murs\nqui se dressent devant vous\neffroyables et froids,\nn\'abandonnez jamais,\nbrisez les murs,\nde peur, de honte, de rancœur, de haine,\npour être comme un phare pour les autres.'),
                        mode: 'briques',
                        duree: 999999999,
                        transition: 'neon',
                        speed: 40
                    },
                    // === NOUVEAU CHAPITRE : LE MUR D'AVARICE ===
                    {
                        id: 'VDV_NARR_P17_MUR_VISION',
                        phase: 17,
                        titre: getTranslatedText('narrative.voyage_titles.phase17', 'Voyage — Le Mur d\'avarice'),
                        texte: getTranslatedText('narrative.phase17.text', 'Au loin… je vois un mur.\nUn mur dressé dans la mer comme une cicatrice.\nUn mur qui n\'est pas fait de pierres,\nmais de lois, de papiers et de regards fermés.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P18_MUR_PRISON',
                        phase: 18,
                        titre: getTranslatedText('narrative.voyage_titles.phase18', 'Voyage — Prison de liberté'),
                        texte: getTranslatedText('narrative.phase18.text', 'Ce mur est la prison de la liberté des hommes.\nIl sépare ceux qui peuvent courir sans chaînes,\net ceux qu\'on enferme dans des frontières invisibles.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P19_MUR_PAUVRES',
                        phase: 19,
                        titre: getTranslatedText('narrative.voyage_titles.phase19', 'Voyage — Barbelés de refus'),
                        texte: getTranslatedText('narrative.phase19.text', 'Pour les pauvres, il est barbelé de refus,\nfermé comme une porte rouillée.\nIls y frappent de leurs mains nues,\nleurs rêves brisés par le silence des gardiens.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'neon',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P20_MUR_RICHES',
                        phase: 20,
                        titre: getTranslatedText('narrative.voyage_titles.phase20', 'Voyage — Porte d\'or'),
                        texte: getTranslatedText('narrative.phase20.text', 'Pour les riches, il est une porte d\'or.\nElle s\'ouvre sans effort,\net les laisse circuler comme le vent qui n\'a pas de patrie.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P21_MUR_QUESTION',
                        phase: 21,
                        titre: getTranslatedText('narrative.voyage_titles.phase21', 'Voyage — Question de liberté'),
                        texte: getTranslatedText('narrative.phase21.text', 'Alors je me demande…\nLa liberté est-elle vraiment un droit,\nou est-elle devenue un privilège vendu aux plus offrants ?'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P22_MUR_ESPOIR',
                        phase: 22,
                        titre: getTranslatedText('narrative.voyage_titles.phase22', 'Voyage — L\'espoir des vagues'),
                        texte: getTranslatedText('narrative.phase22.text', 'Mais dans le cœur des vagues,\nla mer murmure une vérité :\naucun mur n\'est éternel.\nCar l\'eau finit toujours par user la pierre,\net la liberté, tôt ou tard,\nreprendra son chemin.'),
                        mode: 'mur',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P23_CONCLUSION',
                        phase: 23,
                        titre: getTranslatedText('narrative.voyage_titles.phase23', 'Révélation'),
                        texte: getTranslatedText('narrative.phase23.text', '👁️ Ainsi s\'achève ce voyage...\n\nTu as navigué à travers les tempêtes,\nbrisé les murs de l\'ignorance,\net découvert que la vérité\nn\'est pas une fin,\nmais un chemin.\n\nChaque énigme résolue,\nchaque choix posé,\nt\'a rapproché de cette sagesse :\n\n💫 Nous sommes tous\nles gardiens de la lumière.\n\nLa diversité n\'est pas une menace,\nmais le plus beau des trésors.\n\n⛵ Le voyage continue...\nDans ton cœur, dans tes choix,\ndans ta façon de voir le monde.\n\n--Emmanuel Payet'),
                        mode: 'final',
                        duree: 30000,
                        transition: 'neon',
                        speed: 42
                    }
                ];
            }

            // Obtenir la phase actuelle
            getCurrentPhase() {
                // Trouver la phase par son numéro au lieu d'utiliser l'index
                return this.phases.find(phase => phase.phase === this.currentPhase) || null;
            }

            // Obtenir la phase par ID
            getPhaseById(id) {
                return this.phases.find(phase => phase.id === id) || null;
            }

            // Avancer à la prochaine phase
            nextPhase() {
                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    return false;
                }
                if (modeSecret) {console.log('🚫 Mode secret actif (fallback), nextPhase bloqué');
                    return false;
                }

                // Trouver la phase suivante par numéro
                const nextPhaseNumber = this.currentPhase + 1;
                const nextPhase = this.phases.find(phase => phase.phase === nextPhaseNumber);

                if (nextPhase) {
                    this.currentPhase = nextPhaseNumber;

                    // 🎵 Musique : passer à la suivante en phase 2
                    if (musicManager && nextPhaseNumber === 2) {
                        musicManager.playNext();
                    }

                    return true;
                } else {
                    return false; // Fin de la narration
                }
            }

            // Réinitialiser la narration
            reset() {
                // //console.log(`[DEBUG] reset() appelé - retour currentPhase à 1`);
                this.currentPhase = 1;
                this.phaseHistory = [];
                this.isTransitioning = false;
                this.victoryTimers.clear();
                this.hideStepIndicator();
            }

            // Démarrer la narration
            start() {console.log(`[NARRATION] start() appelé - démarrage de la narration`);
                this.reset();
                this.executeCurrentPhase(true); // true = afficher texte narratif
            }

            // Exécuter la phase actuelle
            executeCurrentPhase(afficherTexte = false) {
                const phase = this.getCurrentPhase();
                if (!phase) {
                    this.finalizeNarration();
                    return;
                }

                // Afficher le titre du voyage au début de la phase
                this.afficherTitreVoyage(true); // true = début de phase
                this.phaseHistory.push(phase.id);

                this.isTransitioning = true;

                // 🔊 Jouer le son de vague selon la phase
                AudioSystem.playAmbience();

                // 🔊 Jouer son d'orage à la phase 3
                if (phase.phase === 3) {
                    AudioSystem.playOrage();
                }

                // Mettre à jour l'indicateur d'étape
                this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                // Afficher le texte narratif seulement au démarrage initial
                if (afficherTexte && phase && phase.texte) {
                    const texte = typeof phase.texte === 'function' ? phase.texte() : phase.texte;
                    this.afficherMessageAnime(texte, phase.transition, phase.speed);
                }

                // Pour les modes non-interactifs, programmer un nextPhase automatique
                // Modes interactifs : coeurs, briques, nuit_coeurs, etoiles, lanterne, mur
                if (phase.mode !== 'coeurs' && phase.mode !== 'briques' && phase.mode !== 'nuit_coeurs' && phase.mode !== 'etoiles' && phase.mode !== 'lanterne' && phase.mode !== 'mur') {
                    setTimeout(() => {
                        this.nextPhase();
                        this.executeCurrentPhase();
                    }, phase.duree);
                }

                // Configurer le mode de jeu
                this.configureGameMode(phase.mode);

                // Marquer la transition comme terminée après configuration
                this.isTransitioning = false;
            }

            // Afficher le titre du voyage
            afficherTitreVoyage(debutPhase = false) {
                const phase = this.currentPhase;
                let voyageNom = '';

                if (phase === 1) {
                    voyageNom = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageNom = 'La lumière';
                } else if (phase >= 3 && phase <= 4) {
                    voyageNom = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageNom = 'Le silence de l\'âme';
                } else if (phase >= 7 && phase <= 9) {
                    voyageNom = 'L\'humanité des cœurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageNom = 'La sagesse des différences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageNom = 'L\'unité';
                } else if (phase === 16) {
                    voyageNom = 'Animation finale';
                }

                if (voyageNom) {
                    // Délai de 15 secondes pour la phase 1 au début, immédiat pour les autres cas
                    const delai = (phase === 1 && debutPhase) ? 15000 : 0;

                    setTimeout(() => {
                        titreVoyage.active = true;
                        titreVoyage.texte = voyageNom + '\nPhase ' + phase;
                        titreVoyage.fin = Date.now() + 5000; // 5 secondes
                    }, delai);
                }
            }

            // 📜 MESSAGES NARRATIFS DES PHASES - Style simple centré
            afficherMessageAnime(texte, animation = 'emboss', speed = 45, onComplete) {
                // Utiliser afficherMessageNarratifSimple() pour toutes les phases
                // Utiliser la durée de la phase actuelle
                const phase = this.getCurrentPhase();
                let duree = phase && phase.duree ? phase.duree : 12000;

                // Phase 16 : texte permanent (durée infinie)
                if (this.currentPhase === 16) {
                    duree = 999999999; // Durée très longue pour rester affichéconsole.log('📜 Texte:', texte.substring(0, 50) + '...');
                    // Forcer l'effacement de l'ancien message
                    messageNarratifActif = null;
                    window.logP16Done = false; // Reset log
                }

                afficherMessageNarratifSimple(texte, duree);

                // Appeler onComplete après la durée du message si fourni
                if (onComplete) {
                    setTimeout(onComplete, duree);
                }
            }

            // Mettre à jour l'indicateur d'étape
            updateStepIndicator(phase, titre, mode) {
                const indicateur = document.getElementById('etapeIndicateur');
                if (!indicateur) return;

                // Icône selon le mode
                let icone = '';
                switch(mode) {
                    case 'coeurs': icone = '💖'; break;
                    case 'nuit_coeurs': icone = '🌙💖'; break;
                    case 'briques': icone = '🧱'; break;
                    case 'etoiles': icone = '⭐'; break;
                    case 'mur': icone = '🧱'; break;
                    case 'transition': icone = '🌊'; break;
                    case 'final': icone = '✨'; break;
                    default: icone = '📖'; break;
                }

                // Mettre à jour le contenu
                indicateur.innerHTML = `
                    <div>${icone} ${phase}/23</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">${titre}</div>
                `;

                // Afficher l'indicateur
                indicateur.classList.add('show');
            }

            // Cacher l'indicateur d'étape
            hideStepIndicator() {
                const indicateur = document.getElementById('etapeIndicateur');
                if (indicateur) {
                    indicateur.classList.remove('show');
                }
            }

            // Configurer le mode de jeu selon la phase
            configureGameMode(mode) {
                // Ne pas reconfigurer si on est déjà dans le bon mode
                // SAUF pour les phases 17-22 (mode MUR) qui doivent recréer le mur à chaque fois
                const phaseNecessiteReconfiguration = this.currentPhase >= 17 && this.currentPhase <= 22 && mode === 'mur';

                if (!phaseNecessiteReconfiguration && (phaseJeu === mode ||
                    (mode === 'coeurs' && phaseJeu === 'tir_coeurs_haut') ||
                    (mode === 'nuit_coeurs' && phaseJeu === 'tir_coeurs_nuit') ||
                    (mode === 'briques' && phaseJeu === 'lanterne') ||
                    (mode === 'etoiles' && phaseJeu === 'stars') ||
                    (mode === 'mur' && phaseJeu === 'mur') ||
                    (mode === 'transition' && phaseJeu === 'transition'))) {
                    //
                    return;
                }

                switch(mode) {
                    case 'coeurs':
                        this.setupCoeursMode();
                        break;
                    case 'nuit_coeurs':
                        this.setupNuitCoeursMode();
                        break;
                    case 'briques':
                        this.setupBriquesMode();
                        break;
                    case 'etoiles':
                        this.setupEtoilesMode();
                        break;
                    case 'mur':
                        this.setupMurMode();
                        break;
                    case 'transition':
                        this.setupTransitionMode();
                        break;
                    case 'final':
                        this.setupFinalMode();
                        break;
                }
            }

            // Déterminer la période selon la phase (P3, P5, P11, P12 = nuit)
            getPeriodeFromPhase(phaseNumber) {
                return (phaseNumber === 3 || phaseNumber === 5 || phaseNumber === 11 || phaseNumber === 12) ? 'nuit' : 'jour';
            }

            // Configuration mode cœurs
            async setupCoeursMode() {
                const phase = this.getCurrentPhase();

                // Attendre que les traductions soient chargées
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                // Désactiver la pluie (sauf si phase 5)
                if (this.currentPhase !== 5) {
                    desactiverPluie();
                }

                // Déclencher la pluie d'averse en phase 3 (L'ombre des nuages)
                if (this.currentPhase === 3) {
                    setTimeout(() => {
                        if (typeof declencherPluieLumineuse === 'function') {
                            declencherPluieLumineuse();
                        }
                    }, 2000); // Après 2s pour laisser le temps au message narratif
                }

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);

                // Vérification finale
                if (JOUR.length === 0 || NUIT.length === 0) {
                    console.error('❌ Tableaux toujours vides après attente !');
                    return;
                }

                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet nuit selon la période
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les étoiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les éclairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier éclair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode nuit cœurs (parties ambiguës)
            async setupNuitCoeursMode() {
                const phase = this.getCurrentPhase();

                // Attendre que les traductions soient chargées
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                // Activer la pluie UNIQUEMENT pour la phase 5
                if (this.currentPhase === 5) {
                    activerParticulesP5();
                } else {
                    desactiverPluie();
                }

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);

                // Vérification finale
                if (JOUR.length === 0 || NUIT.length === 0) {
                    console.error('❌ Tableaux NUIT toujours vides après attente !');
                    return;
                }

                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet visuel de nuit - fond sombre sans affecter les étoiles/lanterne
                document.body.style.backgroundColor = '#1a1a2e';
                document.body.style.filter = '';

                // Initialiser les éclairs pour le mode nuit
                eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier éclair dans 5-15s
            }

            // Configuration mode briques
            setupBriquesMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // Désactiver la pluie

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;

                // Phase 16 : FORCER mode tir de cœurs
                if (this.currentPhase === 16) {
                    phaseJeu = 'tir_coeurs_haut';console.log('📋 Phase actuelle:', this.getCurrentPhase());

                    // Débloquer les énigmes "Lampe" et "Mur de Peur" au début de la phase 16
                    // Notifications espacées de 3.5 secondes pour se lire l'une après l'autre
                    if (enigmaCollector) {
                        setTimeout(() => {
                            const result1 = enigmaCollector.collecterEnigme('lampe', true);
                            score += 1000;
                            window.score = score;
                        }, 1500);

                        setTimeout(() => {
                            const result2 = enigmaCollector.collecterEnigme('mur_peur', true);
                            score += 1000;
                            window.score = score;
                        }, 5000); // 3.5 secondes après la première (1.5s + 3.5s = 5s)
                    } else {
                        console.error('❌ enigmaCollector NON disponible !');
                    }
                }
                // En mode nuit, alterner entre briques et étoiles après phase 3
                else if(periode === 'nuit') {
                    if(this.currentPhase <= 3) {
                        // Phase 3 et avant : toujours étoiles
                        phaseJeu = 'stars';
                    } else {
                        // Après phase 3 : alterner entre les phases nocturnes restantes
                        // Phase 5 = étoiles | Phase 11 = étoiles | Phase 12 = briques
                        if(this.currentPhase === 12) {
                            phaseJeu = 'lanterne'; // Mode briques en mode nuit
                            balle.visible = true;
                            balle.enAttente = true;
                            balle.dx = 0;
                            balle.dy = 0;
                        } else {
                            phaseJeu = 'stars'; // Mode étoiles tirables pour P5 et P11
                        }
                    }
                } else {
                    phaseJeu = 'lanterne'; // Mode classique casse-briques avec lanterne
                    balle.visible = true;
                    balle.enAttente = true;
                    balle.dx = 0;
                    balle.dy = 0;
                }

                jeu = true;
                initJeu();

                // Phase 16 : Mode texte narratif pur
                if (this.currentPhase === 16) {
                    // Vider tous les éléments de jeu - juste le texte
                    briques = [];
                    petitsCoeurs = [];
                    coeursBateau = [];
                    powerUps = [];
                    starsProjectiles = [];console.log('📜 Phase 16 : Mode texte narratif pur (sans gameplay)');
                    // Le bouton Suivant sera activé dans goToNextPhaseDirect après l'affichage du texte
                } else {
                    dedoublerCoeursEnBriques();
                }

                // Garder l'état de la lanterne de la phase précédente
                // lanterne.active et lanterne.intensite conservés

                // Effet nuit selon la période
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les étoiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les éclairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier éclair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode étoiles
            setupEtoilesMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // Désactiver la pluie

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'stars';
                jeu = true;
                initJeu();

                // Phases 17-22 : créer un mur au lieu des briques normales
                if(this.currentPhase >= 17 && this.currentPhase <= 22) {
                    console.log(`🏔️ Phase ${this.currentPhase} - Création mur (mode tir activé par setupMurMode)`);
                    creerMurDansLaMer();
                    // Note : Le mode tir MUR est activé par setupMurMode(), pas ici
                } else {
                    console.log(`💎 Phase ${this.currentPhase} - Appel dedoublerCoeursEnBriques()`);
                    dedoublerCoeursEnBriques();
                }
            }

            // Configuration mode mur - gameplay de destruction du mur
            setupMurMode() {
                const phaseNum = this.currentPhase; // Numéro de phase (17, 18, 19, etc.)
                desactiverPluie(); // Désactiver la pluie

                // Configuration du mode mur
                periode = 'jour'; // Le mur est en plein jour
                VOYAGE = JOUR;
                phaseJeu = 'mur'; // Définir AVANT initJeu() pour la logique de préservation
                jeu = true;

                // Initialiser le jeu avec des briques en forme de mur
                initJeu(); // Maintenant phaseJeu='mur' est déjà défini, préservera les munitions
                creerMurDansLaMer();
                
                // Définir les munitions pour phases 17-22 (système projectiles progressifs)
                // Phase 23 = fin narrative, pas de tir
                if (phaseNum >= 17 && phaseNum <= 22) {
                    munitions = 9999; // Munitions infinies pour détruire le mur (phases 17-22)
                    console.log(`🎯 setupMurMode() - Phase ${phaseNum} - Mode MUR avec projectiles | munitions=${munitions}`);
                } else {
                    console.log(`⚠️ setupMurMode() - Phase ${phaseNum} - Mode MUR sans tir (phase 23)`);
                }

                // 🎁 Débloquer une énigme unique pour chaque phase du mur (17-22)
                // Chaque énigme explore une facette des murs qui séparent l'humanité
                if (enigmaCollector) {
                    const enigmesParPhase = {
                        17: 'privilege',      // � Orgueil
                        18: 'mur_liberte',    // ⛓️ Prison de Liberté
                        19: 'refus',          // 🚫 Les barbelés du rejet
                        20: 'avarice',        // �💰 Le mur de la cupidité (billets qui explosent)
                        21: 'inegalites',     // La pyramide des destins
                        // 22: espoir_mur est SECRET - A decouvrir via le power-up arc-en-ciel cache !
                    };

                    const enigmeId = enigmesParPhase[phaseNum];
                    if (enigmeId) {
                        setTimeout(() => {
                            enigmaCollector.collecterEnigme(enigmeId, true);
                            score += 1000;
                            window.score = score;
                            console.log(`🔓 Énigme "${enigmeId}" débloquée en phase ${phaseNum} ! +1000 XP`);
                        }, 1500);
                    }
                }
            }

            // Configuration mode transition - texte + bouton continuer
            setupTransitionMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // Désactiver la pluie

                // Mode transition MAIS garder les animations (jeu = true pour que les animations continuent)
                jeu = true; // GARDER LES ANIMATIONS ACTIVES
                phaseJeu = 'transition';

                // Nettoyer les éléments de jeu
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];
                starsProjectiles = [];

                // Initialiser le bouton canvas
                if (!window.boutonContinuer) {
                    window.boutonContinuer = {
                        visible: true,
                        x: 0,
                        y: 0,
                        width: 200,
                        height: 60,
                        pulseTime: 0
                    };
                }
                window.boutonContinuer.visible = true;
                window.boutonContinuer.pulseTime = Date.now();
            }

            // Fonction vide pour compatibilité (le bouton est maintenant dans le canvas)
            showContinueButton() {
                // Le bouton est maintenant dessiné dans le canvas
            }

            // Configuration mode final
            setupFinalMode() {
                const phase = this.getCurrentPhase();
                desactiverPluie(); // Désactiver la pluie

                // Arrêter le jeu et nettoyer
                jeu = false;
                phaseJeu = 'final';

                // Nettoyer tous les éléments de jeu
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                // Passer en mode jour pour la phase finale (fond clair)
                periode = 'jour';

                // Remettre le fond clair
                document.body.style.backgroundColor = '';

                setTimeout(() => {
                    this.finalizeNarration();
                }, phase.duree + 2000);
            }

            // Finaliser la narration
            finalizeNarration() {
                //
                phaseJeu = 'feux_artifice';
                jeu = false;

                // Forcer la mise à jour des dimensions du canvas
                size = setupCanvas();
                C.W = size.width;
                C.H = size.height;
                C.PW = Math.max(size.width * 0.3, 100);
                C.PH = Math.max(size.height * 0.025, 15);
                C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                // Effacer le message narratif de la phase 23
                messageNarratifActif = null;

                // Cacher l'indicateur d'étape
                this.hideStepIndicator();

                C.SP = Math.max(Math.min(size.width, size.height) * 0.0015, 1.2); // Vitesse balle réduite PC

                // Vider les petits cœurs et briques pour éviter qu'ils réapparaissent
                petitsCoeurs = [];
                briques = [];
                coeursBateau = [];

                // Débloquer toutes les énigmes finales en une seule fois
                if (enigmaCollector) {
                    const enigmesFinales = ['mur_humanite', 'mur_maison', 'mur_vie', 'communautarisme', 'coeur_final'];

                    // Débloquer toutes les énigmes sans notification individuelle
                    enigmesFinales.forEach(enigmeId => {
                        enigmaCollector.collecterEnigme(enigmeId, true, true); // true = silencieux
                        score += 1000;
                        window.score = score;
                    });

                    // Notification désactivée
                    // setTimeout(() => {
                    //     afficherMessageNarratifSimple('🏮 Lanterne allumée', 4000);
                    // }, 500);
                }

                // ⚡ OPTIMISATION PHASE 23: Garder traînées mais activer le batching optimisé
                if (droneModule && droneModule.options) {
                    droneModule.options.showTrails = true;  // Garder les traînées
                    droneModule.options.batchTrails = true; // Activer batching optimisé (-90% appels ctx.stroke)
                    droneModule.options.trailLength = 8;    // Réduire longueur (18 → 8 points)
                }

                // Activer l'écouteur de clic immédiatement (à 25s)
                // Chaque clic déclenche une formation différente
                let formationIndex = 0;
                const formations = ['heart', 'star', 'clock', 'star5', 'cross_christian', 'heart', 'double_heart']; // 7 formations (mur retiré)
                // ⚡ OPTIMISATION: Réduction du nombre de drones (-30% charge CPU)
                const dronesNecessaires = {
                    'heart': 20,            // ↓ de 30 à 20 (-33%)
                    'star': 25,             // ↓ de 35 à 25 (-29%)
                    'clock': 40,            // ↓ de 60 à 40 (-33%)
                    'star5': 35,            // ↓ de 50 à 35 (-30%)
                    'cross_christian': 20,  // ↓ de 30 à 20 (-33%)
                    'double_heart': 45      // ↓ de 60 à 45 (-25%)
                };

                const lancerDrones = (e = null) => {
                    // Empêcher le comportement par défaut et la propagation (si événement)
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    // Effacer le message d'instruction au premier lancement
                    if (formationIndex === 0) {
                        messageNarratifActif = null;
                    }

                    if (droneModule) {
                        const formation = formations[formationIndex % formations.length];
                        const nbDrones = dronesNecessaires[formation] || 30;

                        // Position cible au centre-haut de l'écran
                        const x = C.W * 0.5;
                        const y = C.H * 0.4;

                        droneModule.options.droneCount = nbDrones;
                        droneModule.createDrones(); // Recréer les drones avec le bon nombre

                        // Déplacer les drones du bateau vers la position cible
                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        // Traitement spécial pour le double cœur : fusion puis explosion
                        if (formation === 'double_heart') {
                            setTimeout(() => {
                                // Phase 1 : Fusion des deux cœurs (2 secondes)
                                droneModule.fuseDoubleHeart();
                                
                                // Phase 2 : Explosion finale en slow motion (2 secondes plus tard)
                                setTimeout(() => {
                                    droneModule.explodeSlowMotion(x, y); // Explosion spéciale slow motion
                                }, 2000);
                            }, 1000);
                        } else if (formation === 'clock') {
                            // Traitement spécial pour l'horloge : aiguilles animées
                            setTimeout(() => {
                                // Phase 1 : Animer les aiguilles (3 secondes)
                                droneModule.animateClock();
                                
                                // Phase 2 : Explosion après l'animation
                                setTimeout(() => {
                                    droneModule.explode(x, y);
                                }, 3000);
                            }, 1000);
                        } else {
                            // Explosion normale pour les autres formations
                            setTimeout(() => {
                                droneModule.explode(x, y);
                            }, 1000);
                        }

                        formationIndex++;

                        // Après 8 formations, afficher le texte final
                        if (formationIndex === formations.length) {
                            // Faire disparaître les drones après la dernière explosion
                            // Double heart: fusion (2s) + explosion slow motion (durée vie plus longue)
                            // Il faut attendre ~10 secondes pour que l'explosion slow motion se termine complètement
                            setTimeout(() => {
                                if (droneModule) {
                                    droneModule.hide();
                                }
                            }, 10000); // 10 secondes pour laisser l'explosion slow motion se terminer
                            
                            // Afficher le texte final après un délai
                            setTimeout(() => {
                                // Partie 1 : Le mur
                                afficherMessageNarratifSimple(getTranslatedText('narrative.walls_message', 
                                    'Ces murs sont les nôtres,\non les crée par nos conflits,\npar la haine et le racisme,\nl\'intolérance des autres,\nla peur de l\'inconnu.\n\nC\'est nous, par nos silences et nos maux,\npar nos peurs murmurées,\npar nos mots jetés comme des pierres,\nqui les rendons plus solides.\n\nCe sont des murs d\'égoïsme,\nconstruits avec ce qui aurait pu être des toits,\ndes refuges, des foyers.'), 30000);

                                // Partie 2 : Le message d'espoir
                                setTimeout(() => {
                                    const xp = pointsConnaissance || 0;
                                    const scoreJeu = window.score || score;
                                    const scoreTotal = xp + scoreJeu; // XP + Score
                                    const scoreSagesse = Math.round(scoreTotal / 100); // Total / 100 = Sagesse

                                    // Générer un ID unique hexadécimal pour chaque joueur
                                    const timestamp = Date.now().toString(16); // Timestamp en hex
                                    const random = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0'); // Random en hex
                                    const idUnique = `PB${timestamp}${random}`.toUpperCase();

                                    // Afficher le formulaire Supabase avec callback
                                    if (typeof afficherFormulaireFinDeJeuAvecResume === 'function') {
                                        afficherFormulaireFinDeJeuAvecResume(xp, scoreJeu, scoreTotal, scoreSagesse, idUnique, true); // ✅ Phase 23 = true
                                    } else {
                                        // Fallback : ancienne méthode avec prompts
                                        const nom = prompt(getTranslatedText('database_form.prompt_name')) || getTranslatedText('database_form.anonymous');
                                        const ville = prompt(getTranslatedText('database_form.prompt_city')) || getTranslatedText('database_form.unknown_city');
                                        const pays = prompt(getTranslatedText('database_form.prompt_country')) || getTranslatedText('database_form.unknown_country');

                                        afficherMessageNarratifSimple(getTranslatedText('narrative.final_message', 
                                            'L\'humanité n\'a pas besoin de murs pour se protéger,\nmais de ponts pour se rencontrer.\n\nConstruisons avec amour, pas avec peur.\nUn monde uni vaut mieux qu\'un monde cloisonné.\n\n- Emmanuel.gallery') + 
                                            '\n\n[' + getTranslatedText('game.origin_journey', 'Origine : Le voyage d\'une vie') + ']\n\n' + nom + ' - ' + ville + ', ' + pays + '\n' + xp + ' XP + ' + scoreJeu + ' Score = ' + scoreTotal + '\n' + getTranslatedText('game.knowledge_given', 'Connaissance donnée') + '\n' + getTranslatedText('game.wisdom_score', 'Score de Sagesse') + ' : ' + scoreSagesse + '\nID: ' + idUnique + '\n\n[🌍 ' + getTranslatedText('game.share_journey', 'Partager mon voyage') + ']\n\n[' + getTranslatedText('game.restart', 'Recommencer') + ']\n\n#PETITBATEAUROUGE #UnisPourLaPaix', 999999);
                                    }

                                    // Marquer le message comme contenant un bouton restart + lien + partage
                                    if (messageNarratifActif) {
                                        messageNarratifActif.avecRestart = true;
                                        messageNarratifActif.lienLivre = 'https://play.google.com/store/books/details?id=VW42EQAAQBAJ';
                                        messageNarratifActif.avecPartage = true;

                                        // 4 textes de partage différents
                                        const textesPartage = [
                                            `${getTranslatedText('game.share_texts.text1_title', "🌟 J'ai voyagé à travers les frontières de l'humanité !")}\n\n"${getTranslatedText('game.share_texts.text1_quote', "De l'obscurité vers la lumière, j'ai appris que l'amour unit au-delà des différences.")}"\n\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,

                                            `${getTranslatedText('game.share_texts.text2_title', '🕊️ Un voyage vers la vérité...')}\n\n"${getTranslatedText('game.share_texts.text2_quote', "J'ai brisé les murs de la peur pour construire des ponts d'amour.")}"\n\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,

                                            `${getTranslatedText('game.share_texts.text3_title', "🌍 De mur en pont, j'ai découvert l'humanité...")}\n\n"${getTranslatedText('game.share_texts.text3_quote', 'Au-delà des frontières, nos cœurs battent à l\'unisson.')}"\n\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,

                                            `${getTranslatedText('game.share_texts.text4_title', "👁️ J'ai vu la vérité au-delà des préjugés...")}\n\n"${getTranslatedText('game.share_texts.text4_quote', "Nous construisons des murs par peur, mais l'amour les transforme en refuges.")}"\n\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`
                                        ];

                                        // Choisir un texte aléatoire
                                        messageNarratifActif.textePartage = textesPartage[Math.floor(Math.random() * textesPartage.length)];
                                    }

                                    // Redémarrage automatique désactivé - le joueur clique sur [Recommencer]
                                    // setTimeout(() => {
                                    //
                                    //     location.reload();
                                    // }, 40000);
                                }, 30000); // 30 secondes après la partie 1
                            }, 3000); // 3s après la dernière explosion
                        }
                    } else {
                        console.error('❌ droneModule non disponible pour les feux d\'artifice !');
                    }
                };

                // Démarrer les feux d'artifice automatiques
                const lancerFeuxAutomatiques = () => {
                    if (formationIndex < formations.length) {
                        lancerDrones(); // Lancer sans événement
                        
                        // ⚡ OPTIMISATION: Réduit de 4s à 3s (-25% durée totale: 28s → 21s)
                        if (formationIndex < formations.length) {
                            setTimeout(lancerFeuxAutomatiques, 3000);
                        }
                    }
                };

                // Démarrer le premier feu d'artifice après 2 secondes
                setTimeout(lancerFeuxAutomatiques, 2000);

                // Afficher un message d'attente élégant
                afficherMessageNarratifSimple(getTranslatedText('interface.system.fireworks_starting', 'Les feux d\'artifice commencent...'), 6000);
            }

            // Générer un résumé élégant en 3 lignes
            generateElegantSummary() {
                const completedCount = Math.min(this.currentPhase, this.phases.length);
                const progressPercent = Math.round((completedCount / this.phases.length) * 100);

                return `
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05)); border-radius: 12px; border: 1px solid rgba(100,255,218,0.3);">
                        <div style="color: #64ffda; font-size: 16px; font-weight: 600; margin-bottom: 6px;">
                            ✨ ${completedCount}/16 ${getTranslatedText('game.chapters_progress', 'CHAPITRES')} (${progressPercent}%) ✨
                        </div>
                        <div style="color: #ffffff; font-size: 14px; margin: 4px 0; opacity: 0.9;">
                            ${getTranslatedText('game.chapters_subtitle', '📚 De "La Lumière" à "L\'Unité de l\'Humanité"')}
                        </div>
                        <div style="color: #cccccc; font-size: 12px; font-style: italic; opacity: 0.8;">
                            ${getTranslatedText('game.chapters_journey', 'Un voyage à travers la vérité de l\'humanité')}
                        </div>
                    </div>
                `;
            }

            // Afficher le menu final
            showFinalMenu() {
                // Donner le bonus XP et permettre de rejouer
                giveXPBonus(200);
                
                // Afficher message de félicitations
                afficherMessageNarratifSimple(
                    getTranslatedText('end_form.congrats', '🎉 Félicitations !'),
                    getTranslatedText('end_form.journey_complete', 'Votre voyage est terminé'),
                    () => {
                        this.restartKeepScore(); // Rejouer en gardant le score
                    }
                );
            }

            // Redémarrer en gardant le score (pour rejouer après la fin)
            restartKeepScore() {
                cacherMessage();

                // Sauvegarder le score actuel AVANT toute réinitialisation
                const savedScore = score;
                const savedBrises = brises;

                console.log(`💾 Sauvegarde du score: ${savedScore}, brises: ${savedBrises}`);

                // Réinitialiser le jeu
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                vies = 3;
                jeu = false;

                // Réinitialiser les systèmes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les éléments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // Restaurer le score APRÈS toutes les initialisations
                score = savedScore;
                brises = savedBrises;

                console.log(`✅ Score restauré: ${score}, brises: ${brises}`);

                // Redémarrer la phase d'introduction
                phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
                
                // Réinitialiser l'animation du bateau
                animationBateau.active = true;
            }

            // Redémarrer la narration (réinitialisation complète)
            restart() {
                cacherMessage();

                // Réinitialiser complètement
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                score = 0;
                vies = 3;
                brises = 0;
                jeu = false;

                // Réinitialiser les systèmes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les éléments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // 🎬 RETOUR À L'INTRO : Redémarrer l'animation du bateau
                phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
                animationBateau.active = true;
                
                console.log('🔄 Jeu complètement réinitialisé - Retour à l\'intro');
            }

            // Fonction appelée à la fin d'une phase
            onPhaseComplete() {
                if (this.isTransitioning) return;

                // Créer un timer de victoire unique
                const timerId = `victory_${Date.now()}_${Math.random()}`;

                this.victoryTimers.set(timerId, setTimeout(() => {
                    this.victoryTimers.delete(timerId);
                    // Réinitialiser les compteurs pour la prochaine phase
                    brises = 0;

                    if (this.nextPhase()) {
                        this.executeCurrentPhase();
                    } else {
                        this.finalizeNarration();
                    }
                }, 1500));
            }

            // Méthode pour avancer directement à la phase suivante sans narration
            goToNextPhase() {
                if (this.isTransitioning) return;

                //
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    //
                    this.executeCurrentPhase();
                } else {
                    this.finalizeNarration();
                }
            }

            // Progression directe sans narration - pour la fin des modes
            goToNextPhaseDirect() {
                if (this.isTransitioning) {
                    return;
                }

                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    return;
                }
                if (modeSecret) {console.log('🚫 Mode secret actif (fallback), changement de phase bloqué');
                    return;
                }

                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    const phase = this.getCurrentPhase();
                    if (phase) {
                        // 💾 Sauvegarder la progression à chaque changement de phase
                        GameSaveSystem.save();
                        
                        // Afficher le titre du voyage
                        this.afficherTitreVoyage();

                        // Mettre à jour l'indicateur d'étape
                        this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                        //

                        // Configurer directement le mode de jeu
                        this.configureGameMode(phase.mode);

                        // Afficher le texte narratif APRÈS la configuration
                        if (phase.texte) {
                            setTimeout(() => {
                                const texte = typeof phase.texte === 'function' ? phase.texte() : phase.texte;
                                this.afficherMessageAnime(texte, phase.transition, phase.speed);

                                // Phase 16 : Activer le bouton Suivant après l'affichage du texte
                                if (this.currentPhase === 16) {
                                    if (!window.boutonSuivantP16) {
                                        window.boutonSuivantP16 = {
                                            visible: false,
                                            x: 0,
                                            y: 0,
                                            width: 150,
                                            height: 50,
                                            texte: getTranslatedText('ui.next_button')
                                        };
                                    }
                                    window.boutonSuivantP16.visible = true;
                                    window.logBoutonP16 = false; // Reset log
                                }
                            }, 200); // Petit délai pour que le mode soit bien configuré
                        }

                        // Marquer la transition comme terminée après tout
                        setTimeout(() => {
                            this.isTransitioning = false;
                        }, 100);
                    }
                } else {
                    this.finalizeNarration();
                }
            }

            // Alias pour compatibilité avec l'ancien code
            onLevelComplete() {
                this.onPhaseComplete();
            }
        }

        // Instance globale du gestionnaire de narration
        window.narrationManager = new NarrationManager();
        const narrationManager = window.narrationManager; // Alias local pour compatibilité

        // Si i18n est déjà chargé (après DOMContentLoaded), recharger les phases
        if (window.i18n && window.i18n.getCurrentLanguage) {
            setTimeout(() => {
                narrationManager.reloadPhases();
                console.log('🔄 Phases narratives rechargées après création de narrationManager');
            }, 100);
        }

        // ===============================================
        // COMPATIBILITÉ AVEC L'ANCIEN SYSTÈME
        // ===============================================

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.08, // Augmenté de 0.03 à 0.08 pour plus de fluidité
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au début - les drones restent hors écran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors écran à gauche
                        -100, // Commencer hors écran en haut
                        i
                    ));
                }
                
                // ⚡ OPTIMISATION: Initialiser le cache de calculs temporels
                this._cachedFrameTime = 0;
                this._cachedHeartPulse = 1;
                this._cachedClockPulse = 1;
                this._cachedBrightnessPulse = 1;
                this._lastCacheUpdate = 0;
            }

            setFormation(formation) {
                this.currentFormation = formation;
                // Enregistrer le timestamp pour les animations temporelles
                this.formationStartTime = Date.now();
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                        
                        // Appliquer les propriétés spéciales de la formation
                        if (positions[index].forceColor) {
                            drone.originalColor = drone.color; // Sauvegarder couleur originale
                            drone.color = positions[index].forceColor;
                            drone.hasSpecialColor = true;
                        } else if (drone.hasSpecialColor) {
                            // Restaurer couleur originale si plus de couleur forcée
                            drone.color = drone.originalColor || drone.getRandomColor();
                            drone.hasSpecialColor = false;
                        }
                        
                        // Transférer autres propriétés spéciales
                        drone.isStarInner = positions[index].isStarInner || false;
                        drone.isStarMid = positions[index].isStarMid || false;
                        drone.isStar5Outline = positions[index].isStar5Outline || false;
                        drone.isStar5Fill = positions[index].isStar5Fill || false;
                        drone.isCrossVertical = positions[index].isCrossVertical || false;
                        drone.isCrossHorizontal = positions[index].isCrossHorizontal || false;
                        drone.isBrokenBrick = positions[index].isBrokenBrick || false;
                        drone.isLeftSide = positions[index].isLeftSide || false;
                        drone.breakIntensity = positions[index].breakIntensity || 0;
                        drone.brickType = positions[index].brickType || 'normal';
                        drone.wallPhase = positions[index].wallPhase || 'uniform'; // Phase du mur
                        drone.isHeart = positions[index].isHeart || false; // Cœur dans le mur
                        drone.heartType = positions[index].heartType || 'none'; // Type de cœur
                        drone.sizeEffect = positions[index].sizeEffect || 1.0; // Effet de taille pour la croix
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                // 🎆 Son d'explosion - UN SEUL par tir/explosion
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                // 🎆 Son de feux d'artifice - UN SEUL pour tout le groupe
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }

                this.drones.forEach(drone => {
                    drone.firework();
                });

                // Ne plus recréer les drones après l'explosion - fin du spectacle
                // Les drones disparaissent naturellement avec leur animation d'explosion
                // (Commenté pour arrêter le cycle)
                // setTimeout(() => {
                //     this.createDrones();
                //     this.setFormation(this.currentFormation);
                // }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        // ⭐ Étoile colorée et homogène avec 8 branches et dégradé chaud
                        const starBranches = 8; // 8 branches au lieu de contour continu
                        const outlineCount = Math.floor(count * 0.45); // 45% pour le contour
                        const midCount = Math.floor(count * 0.35); // 35% pour la zone intermédiaire
                        const coreCount = count - outlineCount - midCount; // 20% pour le cœur
                        
                        // Palette de couleurs chaudes pour l'étoile
                        const starColors = [
                            '#FFD700', // Or
                            '#FFA500', // Orange
                            '#FF8C00', // Orange foncé
                            '#FFFF00', // Jaune vif
                            '#FFB700', // Ambre
                            '#FFC125'  // Jaune doré
                        ];
                        
                        // 1. Contour : 8 branches étoilées avec couleurs variées et homogènes
                        for (let i = 0; i < outlineCount; i++) {
                            const branchIndex = Math.floor(i / (outlineCount / starBranches));
                            const posInBranch = (i % (outlineCount / starBranches)) / (outlineCount / starBranches);
                            const angle = (branchIndex / starBranches) * Math.PI * 2 - Math.PI / 2;
                            
                            // Rayon varie pour créer des pointes
                            const maxRadius = size * 1.1;
                            const minRadius = size * 0.6;
                            const radius = minRadius + (maxRadius - minRadius) * (1 - posInBranch);
                            
                            // Couleur selon la branche pour homogénéité
                            const colorIndex = branchIndex % starColors.length;
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarOutline: true,
                                forceColor: starColors[colorIndex] // Couleur variée par branche
                            });
                        }
                        
                        // 2. Zone intermédiaire : dégradé orange-ambre homogène
                        for (let i = 0; i < midCount; i++) {
                            const angle = (i / midCount) * Math.PI * 2;
                            const radius = size * 0.45;
                            
                            // Alterner entre orange et ambre pour homogénéité
                            const midColor = i % 2 === 0 ? '#FFA500' : '#FFB700';
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarMid: true,
                                forceColor: midColor // Orange ou ambre alterné
                            });
                        }
                        
                        // 3. Cœur : jaune vif très brillant et dense
                        for (let i = 0; i < coreCount; i++) {
                            const angle = (i / coreCount) * Math.PI * 2;
                            const radius = size * 0.2;
                            
                            // Alterner jaune vif et or pour brillance homogène
                            const coreColor = i % 2 === 0 ? '#FFFF00' : '#FFD700';
                            
                            positions.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius,
                                isStarInner: true,
                                forceColor: coreColor // Jaune ou or alterné
                            });
                        }
                        break;

                    case 'clock':
                        // Horloge avec aiguilles : cercle + aiguille heures (points mobiles) + aiguille minutes (ligne fixe)
                        const clockRadius = size * 0.8;
                        const circleCount = Math.floor(count * 0.6); // 60% pour le cercle
                        const hourHandCount = Math.floor(count * 0.25); // 25% pour aiguille des heures
                        const minuteHandCount = count - circleCount - hourHandCount; // 15% pour aiguille des minutes
                        
                        // 1. Cercle de l'horloge
                        for (let i = 0; i < circleCount; i++) {
                            const angle = (i / circleCount) * Math.PI * 2;
                            positions.push({
                                x: centerX + Math.cos(angle) * clockRadius,
                                y: centerY + Math.sin(angle) * clockRadius,
                                isClockCircle: true
                            });
                        }
                        
                        // 2. Aiguille des heures (points) - initialement à 12h
                        const hourHandLength = clockRadius * 0.5;
                        const hourAngle = -Math.PI / 2; // 12h
                        for (let i = 0; i < hourHandCount; i++) {
                            const progress = (i + 1) / hourHandCount; // Progression sur l'aiguille
                            positions.push({
                                x: centerX + Math.cos(hourAngle) * (progress * hourHandLength),
                                y: centerY + Math.sin(hourAngle) * (progress * hourHandLength),
                                isHourHand: true,
                                handProgress: progress
                            });
                        }
                        
                        // 3. Aiguille des minutes (ligne fixe) - pointant vers 12h
                        const minuteHandLength = clockRadius * 0.8;
                        const minuteAngle = -Math.PI / 2; // 12h fixe
                        for (let i = 0; i < minuteHandCount; i++) {
                            const progress = (i + 1) / minuteHandCount;
                            positions.push({
                                x: centerX + Math.cos(minuteAngle) * (progress * minuteHandLength),
                                y: centerY + Math.sin(minuteAngle) * (progress * minuteHandLength),
                                isMinuteHand: true,
                                isFixed: true // Reste fixe
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'double_heart':
                        // Double cœur simplifié : un gros et un petit cœur
                        const bigHeartCount = Math.floor(count * 0.7); // 70% pour le gros cœur
                        const smallHeartCount = count - bigHeartCount; // 30% pour le petit cœur
                        
                        // Gros cœur (à gauche)
                        for (let i = 0; i < bigHeartCount; i++) {
                            const t = (i / bigHeartCount) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX - size * 0.6 + x * size / 50, // Gros cœur à gauche
                                y: centerY + y * size / 50,
                                isBigHeart: true
                            });
                        }
                        
                        // Petit cœur (à droite)
                        for (let i = 0; i < smallHeartCount; i++) {
                            const t = (i / smallHeartCount) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + size * 0.6 + x * size / 80, // Petit cœur à droite
                                y: centerY + y * size / 80,
                                isSmallHeart: true
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;

                    case 'broken_brick':
                        // 🧱💥 MUR AVEC CŒUR À L'INTÉRIEUR → SE BRISE → EXPLOSE !
                        const heartDrones = Math.floor(count * 0.2); // 20% pour le cœur
                        const wallDrones = count - heartDrones; // 80% pour le mur
                        
                        const brickRows = Math.ceil(Math.sqrt(wallDrones / 2));
                        const bricksPerRow = Math.ceil(wallDrones / brickRows);
                        const brickWidth = (size * 2) / bricksPerRow;
                        const brickHeight = size / brickRows;
                        
                        // Ligne de rupture verticale au centre
                        const breakLineX = centerX;
                        
                        // Phases temporelles (contrôlées par l'âge de la formation)
                        const timeElapsed = Date.now() - (this.formationStartTime || Date.now());
                        const phase1Duration = 2000; // 2s uniforme
                        const phase2Duration = 3000; // 3s brisé
                        // phase3 = explosion (après 5s total)
                        
                        let wallPhase = 'uniform'; // uniform, breaking, exploded
                        if (timeElapsed > phase1Duration + phase2Duration) {
                            wallPhase = 'exploded';
                        } else if (timeElapsed > phase1Duration) {
                            wallPhase = 'breaking';
                        }
                        
                        // 1. CRÉER LE CŒUR AU CENTRE ❤️
                        const heartSize = size * 0.4; // Taille du cœur
                        for (let i = 0; i < heartDrones; i++) {
                            const angle = (i / heartDrones) * Math.PI * 2;
                            
                            // Forme de cœur paramétrique
                            const t = angle;
                            const heartX = centerX + heartSize * (16 * Math.pow(Math.sin(t), 3)) / 16;
                            const heartY = centerY - heartSize * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
                            
                            let heartColor = '#FF1493'; // Rose profond
                            let heartType = 'heart_core';
                            
                            // Animation du cœur selon la phase
                            if (wallPhase === 'uniform') {
                                // Cœur battant doucement
                                heartColor = '#FF69B4'; // Rose vif
                            } else if (wallPhase === 'breaking') {
                                // Cœur qui palpite (danger)
                                heartColor = '#FF0000'; // Rouge intense
                            } else {
                                // Cœur libre (après explosion du mur)
                                heartColor = '#FFD700'; // Or brillant (liberté)
                                heartType = 'heart_free';
                            }
                            
                            positions.push({
                                x: heartX,
                                y: heartY,
                                isHeart: true,
                                heartType: heartType,
                                forceColor: heartColor
                            });
                        }
                        
                        // 2. CRÉER LE MUR AUTOUR
                        for (let row = 0; row < brickRows && positions.length < count; row++) {
                            const rowOffset = (row % 2) * (brickWidth / 2); // Décalage pour effet briques
                            const bricksInRow = row < brickRows - 1 ? bricksPerRow : wallDrones - (positions.length - heartDrones);
                            
                            for (let col = 0; col < bricksInRow && positions.length < count; col++) {
                                const originalBrickX = centerX - size + rowOffset + col * brickWidth;
                                const originalBrickY = centerY - size / 2 + row * brickHeight;
                                
                                // Éviter de placer des briques trop près du cœur
                                const distanceToCenter = Math.sqrt(
                                    Math.pow(originalBrickX - centerX, 2) + 
                                    Math.pow(originalBrickY - centerY, 2)
                                );
                                if (distanceToCenter < heartSize * 1.2) {
                                    continue; // Laisser l'espace pour le cœur
                                }
                                
                                // Position initiale uniforme
                                let finalX = originalBrickX;
                                let finalY = originalBrickY;
                                let brickType = 'normal';
                                let color = '#C0C0C0'; // Gris argent uniforme par défaut
                                
                                // Déterminer de quel côté de la rupture se trouve cette brique
                                const isLeftSide = originalBrickX < breakLineX;
                                const distanceToBreak = Math.abs(originalBrickX - breakLineX);
                                const maxDistance = size;
                                const breakIntensity = Math.max(0, 1 - (distanceToBreak / maxDistance));
                                
                                if (wallPhase === 'uniform') {
                                    // PHASE 1: Mur uniforme gris argent
                                    color = '#C0C0C0'; // Gris argent uniforme
                                    brickType = 'normal';
                                    
                                } else if (wallPhase === 'breaking') {
                                    // PHASE 2: Mur se brise en deux
                                    const separationDistance = size * 0.4; // Plus de séparation
                                    
                                    if (isLeftSide) {
                                        finalX -= separationDistance * breakIntensity;
                                    } else {
                                        finalX += separationDistance * breakIntensity;
                                    }
                                    
                                    // Léger décalage vertical pour effet d'effondrement
                                    const verticalShift = breakIntensity * (Math.random() - 0.5) * 15;
                                    finalY += verticalShift;
                                    
                                    // Couleurs selon la position
                                    if (distanceToBreak < brickWidth) {
                                        brickType = 'crack_edge';
                                        color = '#A9A9A9'; // Gris sombre (ligne de rupture)
                                    } else if (breakIntensity > 0.5) {
                                        brickType = 'crack_near';
                                        color = '#B8B8B8'; // Gris moyen
                                    } else {
                                        brickType = 'normal';
                                        color = '#C0C0C0'; // Gris argent maintenu
                                    }
                                    
                                } else if (wallPhase === 'exploded') {
                                    // PHASE 3: Explosion complète
                                    const explosionRadius = size * 1.5;
                                    const randomAngle = Math.random() * Math.PI * 2;
                                    const randomDistance = Math.random() * explosionRadius;
                                    
                                    finalX += Math.cos(randomAngle) * randomDistance;
                                    finalY += Math.sin(randomAngle) * randomDistance;
                                    
                                    // Couleurs de débris
                                    const debrisColors = ['#A9A9A9', '#808080', '#696969', '#778899'];
                                    color = debrisColors[Math.floor(Math.random() * debrisColors.length)];
                                    brickType = 'debris';
                                }
                                
                                positions.push({
                                    x: finalX,
                                    y: finalY,
                                    isBrokenBrick: true,
                                    isLeftSide: isLeftSide,
                                    breakIntensity: breakIntensity,
                                    brickType: brickType,
                                    wallPhase: wallPhase,
                                    forceColor: color
                                });
                            }
                        }
                        break;

                    case 'circle':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            positions.push({
                                x: centerX + Math.cos(angle) * size,
                                y: centerY + Math.sin(angle) * size
                            });
                        }
                        break;

                    case 'lantern':
                        // Forme de lanterne (rectangle avec haut/bas arrondis)
                        const lanternHeight = size * 1.5;
                        const lanternWidth = size * 0.8;
                        const pointsPerSide = Math.floor(count / 4);

                        // Haut arrondi
                        for (let i = 0; i < pointsPerSide; i++) {
                            const angle = Math.PI + (i / pointsPerSide) * Math.PI;
                            positions.push({
                                x: centerX + Math.cos(angle) * (lanternWidth / 2),
                                y: centerY - lanternHeight / 2 + Math.sin(angle) * (lanternWidth / 4)
                            });
                        }
                        // Côté droit
                        for (let i = 0; i < pointsPerSide; i++) {
                            positions.push({
                                x: centerX + lanternWidth / 2,
                                y: centerY - lanternHeight / 2 + (i / pointsPerSide) * lanternHeight
                            });
                        }
                        // Bas arrondi
                        for (let i = 0; i < pointsPerSide; i++) {
                            const angle = (i / pointsPerSide) * Math.PI;
                            positions.push({
                                x: centerX + Math.cos(angle) * (lanternWidth / 2),
                                y: centerY + lanternHeight / 2 + Math.sin(angle) * (lanternWidth / 4)
                            });
                        }
                        // Côté gauche
                        for (let i = 0; i < count - pointsPerSide * 3; i++) {
                            positions.push({
                                x: centerX - lanternWidth / 2,
                                y: centerY + lanternHeight / 2 - (i / pointsPerSide) * lanternHeight
                            });
                        }
                        break;

                    case 'paix':
                        // Mot PEACE en formation simple
                        const spacing = size / 4;
                        const letterPositions = [
                            // P
                            [0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [2, 0], [2, 1],
                            // E
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 0], [5, 2], [6, 0],
                            // A
                            [8, 0], [8, 1], [8, 2], [8, 3], [9, 0], [9, 2], [10, 0], [10, 1], [10, 2], [10, 3],
                            // C
                            [12, 0], [12, 1], [12, 2], [12, 3], [13, 0], [14, 0],
                            // E
                            [16, 0], [16, 1], [16, 2], [16, 3], [17, 0], [17, 2], [18, 0]
                        ];
                        letterPositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size * 1.5 + pos[0] * spacing,
                                    y: centerY - size * 0.4 + pos[1] * spacing
                                });
                            }
                        });
                        break;

                    case 'respect':
                        // Mot RESPECT (simplifié)
                        const spacingR = size / 5;
                        const respPositions = [
                            // R
                            [0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [2, 0], [2, 1], [2, 3],
                            // E
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 0], [5, 2], [5, 3], [6, 0], [6, 2], [6, 3],
                            // S
                            [8, 0], [8, 1], [8, 2], [8, 3], [9, 0], [9, 2], [10, 0], [10, 2], [10, 3]
                        ];
                        respPositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size + pos[0] * spacingR,
                                    y: centerY - size * 0.3 + pos[1] * spacingR
                                });
                            }
                        });
                        break;

                    case 'unite':
                        // Mot UNITÉ (simplifié)
                        const spacingU = size / 5;
                        const unitePositions = [
                            // U
                            [0, 0], [0, 1], [0, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3],
                            // N
                            [4, 0], [4, 1], [4, 2], [4, 3], [5, 1], [6, 0], [6, 1], [6, 2], [6, 3],
                            // I
                            [8, 0], [8, 1], [8, 2], [8, 3],
                            // T
                            [10, 0], [11, 0], [11, 1], [11, 2], [11, 3], [12, 0]
                        ];
                        unitePositions.forEach((pos, i) => {
                            if (i < count) {
                                positions.push({
                                    x: centerX - size * 0.8 + pos[0] * spacingU,
                                    y: centerY - size * 0.3 + pos[1] * spacingU
                                });
                            }
                        });
                        break;

                    case 'star5':
                        // ⭐ ÉTOILE 5 BRANCHES REMPLIE ! (Étoile classique)
                        const star5Outline = Math.floor(count * 0.4); // 40% pour le contour
                        const star5Fill = count - star5Outline; // 60% pour le remplissage
                        
                        // Points de l'étoile 5 branches
                        const outerRadius = size * 0.8;
                        const innerRadius = size * 0.35;
                        const starPoints = [];
                        
                        // Calculer les 10 points (5 externes + 5 internes)
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI) / 5 - Math.PI / 2; // Commencer par le haut
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            starPoints.push({
                                x: centerX + Math.cos(angle) * radius,
                                y: centerY + Math.sin(angle) * radius
                            });
                        }
                        
                        // 1. Contour de l'étoile (tracer les bords)
                        for (let i = 0; i < star5Outline; i++) {
                            const progress = i / star5Outline;
                            const totalPerimeter = starPoints.length;
                            const segmentIndex = Math.floor(progress * totalPerimeter);
                            const segmentProgress = (progress * totalPerimeter) % 1;
                            
                            const currentPoint = starPoints[segmentIndex];
                            const nextPoint = starPoints[(segmentIndex + 1) % starPoints.length];
                            
                            positions.push({
                                x: currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress,
                                y: currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress,
                                isStar5Outline: true,
                                forceColor: '#FFD700' // Or pour le contour
                            });
                        }
                        
                        // 2. Remplissage de l'étoile (zone intérieure)
                        for (let i = 0; i < star5Fill; i++) {
                            // Méthode de remplissage par échantillonnage aléatoire dans l'étoile
                            let x, y, inside = false;
                            let attempts = 0;
                            
                            while (!inside && attempts < 50) {
                                // Point aléatoire dans le rectangle englobant
                                x = centerX + (Math.random() - 0.5) * size * 1.6;
                                y = centerY + (Math.random() - 0.5) * size * 1.6;
                                
                                // Test si le point est à l'intérieur de l'étoile
                                inside = isPointInStar(x, y, centerX, centerY, outerRadius, innerRadius);
                                attempts++;
                            }
                            
                            if (inside) {
                                positions.push({
                                    x: x,
                                    y: y,
                                    isStar5Fill: true,
                                    forceColor: '#FF6B6B' // Rouge-rose pour le remplissage
                                });
                            }
                        }
                        
                        // Fonction pour tester si un point est dans l'étoile
                        function isPointInStar(px, py, cx, cy, outerR, innerR) {
                            const dx = px - cx;
                            const dy = py - cy;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) + Math.PI / 2; // Ajuster pour commencer par le haut
                            const normalizedAngle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                            
                            // Quel segment de l'étoile (chaque segment = 2π/5)
                            const segmentAngle = (2 * Math.PI) / 5;
                            const segmentIndex = Math.floor(normalizedAngle / segmentAngle);
                            const angleInSegment = normalizedAngle % segmentAngle;
                            
                            // Interpoler entre rayon interne et externe selon la position dans le segment
                            const t = angleInSegment / segmentAngle;
                            const effectiveRadius = t <= 0.5 ? 
                                innerR + (outerR - innerR) * (t * 2) : 
                                outerR + (innerR - outerR) * ((t - 0.5) * 2);
                            
                            return distance <= effectiveRadius;
                        }
                        break;

                    case 'cross_christian':
                        // ✝️ CROIX CHRÉTIENNE PLUS PETITE ET ÉLÉGANTE
                        const crossVertical = Math.floor(count * 0.6); // 60% pour la barre verticale
                        const crossHorizontal = count - crossVertical; // 40% pour la barre horizontale
                        
                        // Dimensions réduites de la croix (taille normale, pas 3x)
                        const crossHeight = size * 1.4; // Réduit de 3.6 à 1.4
                        const crossWidth = size * 1.0; // Réduit de 2.4 à 1.0
                        const beamThickness = size * 0.2; // Réduit de 0.45 à 0.2
                        
                        // Palette arc-en-ciel douce pour effet élégant
                        const rainbowColors = [
                            '#FF6B6B', // Rouge doux
                            '#FFB347', // Orange pêche
                            '#FFD700', // Or
                            '#98FB98', // Vert pâle
                            '#87CEEB', // Bleu ciel
                            '#9370DB', // Violet moyen
                            '#FF69B4'  // Rose
                        ];
                        
                        // 1. Barre verticale (pied + partie haute) - Arc-en-ciel doux
                        for (let i = 0; i < crossVertical; i++) {
                            const progress = i / (crossVertical - 1 || 1);
                            const y = centerY - crossHeight / 2 + progress * crossHeight;
                            
                            // Effet taille subtil : légèrement plus gros au centre
                            const distanceFromCenter = Math.abs(progress - 0.5) * 2;
                            const sizeMultiplier = 1.2 - distanceFromCenter * 0.3; // 1.2 au centre, 0.9 aux bords
                            
                            // Couleur arc-en-ciel selon la position verticale
                            const colorIndex = Math.floor(progress * (rainbowColors.length - 1));
                            const rainbowColor = rainbowColors[colorIndex];
                            
                            // Répartir sur l'épaisseur de la poutre verticale
                            const offsetX = ((i % 3) - 1) * (beamThickness / 3);
                            
                            positions.push({
                                x: centerX + offsetX,
                                y: y,
                                isCrossVertical: true,
                                sizeEffect: sizeMultiplier,
                                forceColor: rainbowColor
                            });
                        }
                        
                        // 2. Barre horizontale (bras de la croix) - Arc-en-ciel doux
                        for (let i = 0; i < crossHorizontal; i++) {
                            const progress = i / (crossHorizontal - 1 || 1);
                            const x = centerX - crossWidth / 2 + progress * crossWidth;
                            
                            // Position à 1/3 du haut (proportion classique croix latine)
                            const horizontalY = centerY - crossHeight / 6;
                            
                            // Effet taille subtil
                            const distanceFromCenter = Math.abs(progress - 0.5) * 2;
                            const sizeMultiplier = 1.2 - distanceFromCenter * 0.3;
                            
                            // Couleur arc-en-ciel selon la position horizontale
                            const colorIndex = Math.floor(progress * (rainbowColors.length - 1));
                            const rainbowColor = rainbowColors[colorIndex];
                            
                            // Répartir sur l'épaisseur de la poutre horizontale
                            const offsetY = ((i % 3) - 1) * (beamThickness / 3);
                            
                            positions.push({
                                x: x,
                                y: horizontalY + offsetY,
                                isCrossHorizontal: true,
                                sizeEffect: sizeMultiplier,
                                forceColor: rainbowColor
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // ⚡ OPTIMISATION: Mettre à jour le cache avant la boucle
                const now = Date.now();
                if (now - (this._lastCacheUpdate || 0) > 16) { // Throttle à 60fps
                    this._cachedFrameTime = now;
                    this._cachedHeartPulse = Math.sin(now * 0.003) * 0.2 + 1;
                    this._cachedClockPulse = Math.sin(now * 0.005) * 0.3 + 1;
                    this._cachedBrightnessPulse = Math.sin(now * 0.005) * 0.2 + 0.7;
                    this._lastCacheUpdate = now;
                }
                
                // Animation séparée pour mise à jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options, this._cachedFrameTime, this._cachedHeartPulse, this._cachedClockPulse, this._cachedBrightnessPulse);
                });
                
                // Mise à jour automatique des formations temporelles
                if (this.currentFormation === 'broken_brick' && this.formationStartTime) {
                    this.updateTemporalFormation();
                }
            }
            
            updateTemporalFormation() {
                // Met à jour les positions pour les formations temporelles (comme broken_brick)
                const positions = this.getFormationPositions(this.currentFormation, this.drones.length, this.options.size);
                
                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        // Mettre à jour la cible progressivement
                        drone.setTarget(positions[index].x, positions[index].y);
                        
                        // Mettre à jour les propriétés temporelles
                        if (positions[index].forceColor && positions[index].forceColor !== drone.color) {
                            drone.color = positions[index].forceColor;
                        }
                        drone.brickType = positions[index].brickType || 'normal';
                        drone.wallPhase = positions[index].wallPhase || 'uniform';
                        drone.heartType = positions[index].heartType || 'none'; // Mise à jour du type de cœur
                    }
                });
            }

            render() {
                // ⚡ OPTIMISATION: Mettre à jour le cache temporel une seule fois par frame
                const now = Date.now();
                if (now - this._lastCacheUpdate > 16) { // Throttle à 60fps
                    this._cachedFrameTime = now;
                    this._cachedHeartPulse = Math.sin(now * 0.003) * 0.2 + 1;
                    this._cachedClockPulse = Math.sin(now * 0.005) * 0.3 + 1;
                    this._cachedBrightnessPulse = Math.sin(now * 0.005) * 0.2 + 0.7;
                    this._lastCacheUpdate = now;
                }
                
                // Rendu séparé à appeler depuis la boucle de jeu
                if (!window.droneRenderLogged) {
                    if (this.drones[0]) {console.log('🎨 Drone 0 pos:', Math.round(this.drones[0].x), Math.round(this.drones[0].y), 'life:', this.drones[0].life.toFixed(2));
                    }
                    window.droneRenderLogged = true;
                }
                
                // ⚡ OPTIMISATION: Rendu avec batching des traînées
                if (this.options.showTrails && this.options.batchTrails) {
                    this.renderTrailsBatched();
                }
                
                // Dessiner les drones (corps seulement)
                this.drones.forEach(drone => {
                    if (drone.life > 0) {
                        drone.draw(this.ctx, this.options, this._cachedFrameTime, this._cachedHeartPulse, this._cachedClockPulse, this._cachedBrightnessPulse);
                    }
                });
            }
            
            renderTrailsBatched() {
                // ⚡ SUPER OPTIMISATION: Dessiner TOUTES les traînées en un seul batch
                const ctx = this.ctx;
                const maxTrailLength = this.options.trailLength || 8;
                
                // Grouper par couleur pour minimiser les changements de state
                const trailsByColor = new Map();
                
                this.drones.forEach(drone => {
                    if (drone.life > 0 && drone.trail && drone.trail.length > 1) {
                        if (!trailsByColor.has(drone.color)) {
                            trailsByColor.set(drone.color, []);
                        }
                        trailsByColor.get(drone.color).push(drone.trail.slice(-maxTrailLength));
                    }
                });
                
                // Dessiner chaque groupe de couleur en un seul path
                trailsByColor.forEach((trails, color) => {
                    ctx.save();
                    ctx.strokeStyle = color + '60'; // 60 = ~38% opacité
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.shadowBlur = 4; // Réduit de 8 à 4
                    ctx.shadowColor = color;
                    
                    // UN SEUL beginPath pour toutes les traînées de cette couleur
                    ctx.beginPath();
                    trails.forEach(trail => {
                        if (trail.length > 1) {
                            ctx.moveTo(trail[0].x, trail[0].y);
                            for (let i = 1; i < trail.length; i++) {
                                ctx.lineTo(trail[i].x, trail[i].y);
                            }
                        }
                    });
                    
                    // UN SEUL stroke pour toutes les traînées
                    ctx.stroke();
                    ctx.restore();
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }

            hide() {
                // Faire disparaître tous les drones progressivement
                this.drones.forEach((drone, index) => {
                    setTimeout(() => {
                        drone.life = 0; // Forcer la disparition
                        drone.exploding = true;
                        drone.explosionLife = 1; // Déjà terminé
                    }, index * 50); // Décalage de 50ms entre chaque drone
                });
                
                // Effacer complètement après 5 secondes
                setTimeout(() => {
                    this.drones = [];
                }, 5000);
            }

            fuseDoubleHeart() {
                // Fusion simple : tous les drones vont vers le centre puis explosent
                const centerX = this.targetX;
                const centerY = this.targetY;
                
                // Animer tous les drones vers le centre
                this.drones.forEach((drone, index) => {
                    // Mouvement vers le centre avec un léger décalage circulaire
                    const angle = (index / this.drones.length) * Math.PI * 2;
                    const smallRadius = 20; // Petit cercle au centre
                    
                    drone.setTarget(
                        centerX + Math.cos(angle) * smallRadius,
                        centerY + Math.sin(angle) * smallRadius
                    );
                    drone.speed = 0.12; // Vitesse rapide pour convergence
                    drone.fusionMode = true; // Mode fusion activé
                });
                
                console.log('💕 Fusion simple des doubles cœurs vers le centre...');
            }

            animateClock() {
                // Animation horloge : aiguille des heures qui bouge, minutes fixe
                const centerX = this.targetX;
                const centerY = this.targetY;
                const clockRadius = this.options.size * 0.8;
                const totalDuration = 3000; // 3 secondes
                const startTime = Date.now();
                
                // Marquer tous les drones pour l'animation
                this.drones.forEach(drone => {
                    drone.clockAnimation = true;
                    drone.animationStartTime = startTime;
                });
                
                // Animation de l'aiguille des heures
                const animateHourHand = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    // L'aiguille des heures fait un tour complet (12h)
                    const hourAngle = -Math.PI / 2 + (progress * Math.PI * 2);
                    const hourHandLength = clockRadius * 0.5;
                    
                    this.drones.forEach((drone, index) => {
                        const originalPos = this.getFormationPositions('clock', this.drones.length, this.options.size)[index];
                        
                        if (originalPos && originalPos.isHourHand) {
                            // Recalculer la position de l'aiguille des heures
                            const newX = centerX + Math.cos(hourAngle) * (originalPos.handProgress * hourHandLength);
                            const newY = centerY + Math.sin(hourAngle) * (originalPos.handProgress * hourHandLength);
                            
                            drone.setTarget(newX, newY);
                            drone.speed = 0.15; // Vitesse rapide pour suivre
                            drone.clockGlow = true;
                        }
                        // Les autres drones (cercle et aiguille minutes) ne bougent pas
                    });
                    
                    // Continuer l'animation si pas terminée
                    if (progress < 1) {
                        setTimeout(animateHourHand, 50); // 50ms
                    }
                };
                
                // Démarrer l'animation
                animateHourHand();
                console.log('🕐 Animation horloge : aiguille des heures en mouvement...');
            }

            explodeSlowMotion(x, y) {
                // Explosion finale en slow motion - plus lente et spectaculaire
                const explosionRadius = 150; // Plus large que normale (120)
                
                // Son d'explosion finale spectaculaire 💥
                if (window.AudioSystem) {
                    window.AudioSystem.playFirework();
                }
                
                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explodeSlowMotion(x, y, explosionRadius);
                    }
                });

                // Temps de reset plus long pour l'effet slow motion
                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 4000); // 4 secondes au lieu de 2
                
                console.log('💥 Explosion finale en slow motion...');
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
                this.inSlowMotion = false; // Mode slow motion pour finale
                this.speed = 0.08; // Vitesse augmentée de 0.03 à 0.08 pour mouvement plus fluide
                this.glowing = false; // Effet lumineux pour la fusion
                this.fusionMode = false; // Mode fusion activé
                this.clockAnimation = false; // Animation horloge
                this.clockGlow = false; // Effet spécial horloge
                this.animationStartTime = 0; // Temps de début d'animation
                this.lightUpDelay = 0; // Délai avant allumage (horloge)
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            explodeSlowMotion(explosionX, explosionY, radius) {
                // Explosion en slow motion - plus lente et spectaculaire
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 12; // Force réduite (18 → 12)

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 4; // Gravité réduite (6 → 4)
                    this.inExplosion = true;
                    this.inSlowMotion = true; // Mode slow motion
                    this.life = 1.0;

                    // Couleurs dorées/roses pour la finale romantique
                    const finaleColors = ['#FFD700', '#FF69B4', '#FFA500', '#FF1493', '#FFFF00'];
                    this.color = finaleColors[Math.floor(Math.random() * finaleColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
                // Le son est joué au niveau du module, pas ici
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options, cachedFrameTime, cachedHeartPulse, cachedClockPulse, cachedBrightnessPulse) {
                if (this.inExplosion) {
                    // Appliquer slow motion si activé
                    const motionFactor = this.inSlowMotion ? 0.4 : 1.0; // 40% de vitesse en slow motion
                    
                    this.x += this.explosionVelX * motionFactor;
                    this.y += this.explosionVelY * motionFactor;
                    this.explosionVelY += 0.3 * motionFactor; // Gravité aussi ralentie
                    
                    // Vie qui diminue plus lentement en slow motion
                    const lifeDecay = this.inSlowMotion ? 0.008 : 0.015;
                    this.life -= lifeDecay;
                    if (this.life <= 0) this.life = 0;
                } else {
                    // Mouvement fluide et relaxant (sauf horloge qui garde sa rapidité)
                    let currentSpeed = this.clockAnimation ? 0.12 : 0.08; // Horloge rapide, autres fluides
                    
                    if (this.fusionMode) {
                        currentSpeed = 0.08; // Fusion fluide
                    }
                    
                    // Interpolation douce avec easing
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Ralentir à l'approche de la cible (easing)
                    const easingFactor = Math.min(1, distance / 100);
                    this.x += dx * currentSpeed * easingFactor;
                    this.y += dy * currentSpeed * easingFactor;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    // ⚡ OPTIMISATION: Longueur adaptative selon batching
                    const maxLength = options.trailLength || (options.batchTrails ? 8 : 18);
                    if (this.trail.length > maxLength) this.trail.shift();
                }

                // ⚡ OPTIMISATION: Utiliser cachedFrameTime au lieu de Date.now()
                const currentTime = cachedFrameTime || Date.now();
                
                // Effets de brillance selon le mode - plus doux
                if (this.fusionMode) {
                    this.brightness = 0.8 + Math.sin(currentTime * 0.01 + this.id) * 0.3; // Pulsation plus lente
                } else if (this.clockAnimation) {
                    // Effet horloge : s'allumer progressivement selon le délai
                    const elapsed = currentTime - this.animationStartTime;
                    if (elapsed >= this.lightUpDelay) {
                        this.clockGlow = true;
                        this.brightness = 1.0; // Pleine brillance quand allumé
                    } else {
                        this.brightness = 0.3; // Faible brillance en attente
                    }
                } else {
                    // ⚡ OPTIMISATION: Utiliser cachedBrightnessPulse
                    this.brightness = cachedBrightnessPulse || (0.7 + Math.sin(currentTime * 0.005 + this.id) * 0.2);
                }
            }

            draw(ctx, options, cachedFrameTime, cachedHeartPulse, cachedClockPulse, cachedBrightnessPulse) {
                if (this.life <= 0) return;

                // ⚡ OPTIMISATION: Traînées gérées par renderTrailsBatched() si batchTrails actif
                if (options.showTrails && !options.batchTrails && this.trail.length > 1) {
                    // Mode classique (non-batched) - Traînée avec dégradé progressif
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = (i / this.trail.length) * 0.7; // Opacité plus forte (0.4 → 0.7)
                        const width = (i / this.trail.length) * 4; // Largeur plus épaisse (3 → 4)
                        
                        // Effet glow sur la traînée
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = this.color;
                        
                        ctx.strokeStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        ctx.lineWidth = width;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.stroke();
                        
                        // Réinitialiser le shadow
                        ctx.shadowBlur = 0;
                    }
                }

                // Effet visuel simplifié selon le mode - GLOW PLUS PETIT ET TAILLES VARIÉES
                let glowSize = 5; // Réduit de 8 à 5 (glow plus petit)
                let coreSize = 1.5 * this.life; // Réduit de 2 à 1.5
                let intensityMultiplier = 1.0;
                
                if (this.fusionMode) {
                    // En mode fusion : plus brillant mais glow réduit
                    glowSize = 8; // Réduit de 12 à 8
                    coreSize = 2.2 * this.life; // Réduit de 3 à 2.2
                    intensityMultiplier = 1.5; // Plus brillant
                } else if (this.inSlowMotion) {
                    // En mode slow motion : très brillant mais glow réduit
                    glowSize = 10; // Réduit de 15 à 10
                    coreSize = 3 * this.life; // Réduit de 4 à 3
                    intensityMultiplier = 2.0; // Très brillant
                } else if (this.clockGlow) {
                    // En mode horloge : brillance moyenne, glow réduit
                    glowSize = 7; // Réduit de 10 à 7
                    coreSize = 1.8 * this.life; // Réduit de 2.5 à 1.8
                    intensityMultiplier = 1.2; // Légèrement plus brillant
                } else if (this.isStar5Outline) {
                    // Contour étoile 5 branches : coloré et homogène
                    glowSize = 9; // Réduit de 12 à 9
                    coreSize = 2.5 * this.life; // Réduit de 3 à 2.5
                    intensityMultiplier = 1.8; // Très brillant et coloré
                } else if (this.isStar5Fill) {
                    // Remplissage étoile 5 branches : homogène
                    glowSize = 7; // Réduit de 9 à 7
                    coreSize = 2 * this.life; // Réduit de 2.3 à 2
                    intensityMultiplier = 1.3; // Plus brillant pour homogénéité
                } else if (this.isStarMid) {
                    // Zone intermédiaire étoile : colorée et homogène
                    glowSize = 8; // Réduit de 11 à 8
                    coreSize = 2.3 * this.life; // Réduit de 2.8 à 2.3
                    intensityMultiplier = 1.5; // Plus brillant pour homogénéité
                } else if (this.isCrossVertical) {
                    // ⚡ OPTIMISATION: Utiliser cachedHeartPulse au lieu de Date.now()
                    const heartPulse = cachedHeartPulse || 1; // Pulsation cardiaque cachée
                    const sizeVariation = 0.8 + Math.random() * 0.6; // Taille variée (0.8-1.4)
                    const sizeMultiplier = (this.sizeEffect || 1.2) * sizeVariation;
                    glowSize = 7 * sizeMultiplier * heartPulse; // Réduit de 10 à 7 + pulse
                    coreSize = 2 * this.life * sizeMultiplier * heartPulse; // Réduit de 2.5 à 2 + pulse
                    intensityMultiplier = 1.7 * heartPulse; // Brillant + pulsation
                } else if (this.isCrossHorizontal) {
                    // ⚡ OPTIMISATION: Utiliser cachedHeartPulse au lieu de Date.now()
                    const heartPulse = cachedHeartPulse || 1; // Pulsation cardiaque cachée
                    const sizeVariation = 0.8 + Math.random() * 0.6; // Taille variée (0.8-1.4)
                    const sizeMultiplier = (this.sizeEffect || 1.2) * sizeVariation;
                    glowSize = 7 * sizeMultiplier * heartPulse; // Réduit de 10 à 7 + pulse
                    coreSize = 2 * this.life * sizeMultiplier * heartPulse; // Réduit de 2.5 à 2 + pulse
                    intensityMultiplier = 1.6 * heartPulse; // Brillant + pulsation
                } else if (this.isHeart) {
                    // ❤️ CŒUR dans le mur : effets selon le type
                    if (this.heartType === 'heart_free') {
                        // Cœur libéré : très brillant et grand
                        glowSize = 18;
                        coreSize = 4 * this.life;
                        intensityMultiplier = 2.2; // Très brillant (liberté)
                    } else if (this.heartType === 'heart_core') {
                        // ⚡ OPTIMISATION: Utiliser cachedClockPulse au lieu de Date.now()
                        const pulsation = cachedClockPulse || 1; // Battement caché
                        glowSize = 12 * pulsation;
                        coreSize = 3 * this.life * pulsation;
                        intensityMultiplier = 1.6 * pulsation; // Pulsation cardiaque
                    } else {
                        // Cœur normal : brillance moyenne
                        glowSize = 10;
                        coreSize = 2.5 * this.life;
                        intensityMultiplier = 1.3; // Brillance chaleureuse
                    }
                } else if (this.isBrokenBrick) {
                    // Briques brisées : brillance selon le type et la phase
                    if (this.brickType === 'debris') {
                        // Phase explosion : débris dispersés
                        glowSize = 6;
                        coreSize = 1.5 * this.life;
                        intensityMultiplier = 0.7; // Moins brillant (débris)
                    } else if (this.brickType === 'crack_edge') {
                        // Briques sur la ligne de rupture : très brillantes
                        glowSize = 14;
                        coreSize = 3.2 * this.life;
                        intensityMultiplier = 1.8; // Très brillant (zone de rupture)
                    } else if (this.brickType === 'crack_near') {
                        // Briques proches de la rupture : moyennement brillantes
                        glowSize = 11;
                        coreSize = 2.5 * this.life;
                        intensityMultiplier = 1.3; // Moyennement brillant (endommagé)
                    } else {
                        // Briques normales (uniform ou breaking) : brillance selon la phase
                        if (this.wallPhase === 'uniform') {
                            // Phase uniforme : brillance argentine
                            glowSize = 9;
                            coreSize = 2.2 * this.life;
                            intensityMultiplier = 1.1; // Brillance métallique
                        } else {
                            // Phase breaking : brillance normale
                            glowSize = 8;
                            coreSize = 2 * this.life;
                            intensityMultiplier = 0.9; // Légèrement moins brillant
                        }
                    }
                }
                
                // Gradient simple avec intensité modifiée
                const adjustedBrightness = this.brightness * intensityMultiplier;
                
                // Convertir la couleur hex en rgba pour l'opacité
                const hex = this.color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${adjustedBrightness * this.life})`);
                gradient.addColorStop(0.8, `rgba(${r}, ${g}, ${b}, 0.19)`); // 30 en hex = 0.19 en alpha
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Cœur du drone avec intensité
                ctx.fillStyle = this.color;
                ctx.globalAlpha = adjustedBrightness * this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Restaurer l'opacité normale
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // INITIALISATION SUPABASE
        // ===============================================
        let supabaseScores = null;
        let leaderboardData = null;
        let loadingLeaderboard = false;
        let userBestScore = null; // Meilleur score de l'utilisateur connecté

        // Initialiser Supabase au démarrage
        setTimeout(async () => {
            if (typeof SupabaseScores !== 'undefined') {
                supabaseScores = new SupabaseScores();

                // Attendre que le client soit prêt (augmentation du délai)
                setTimeout(async () => {
                    // Vérifier que le client est bien initialisé
                    if (supabaseScores && supabaseScores.client) {
                        await supabaseScores.setCurrentGame('Petit Bateau');

                        // Charger le classement initial
                        await chargerClassement();
                    } else {
                        console.warn('⏳ Client Supabase pas encore prêt, nouvelle tentative...');
                        setTimeout(async () => {
                            if (supabaseScores && supabaseScores.client) {
                                await supabaseScores.setCurrentGame('Petit Bateau');
                                await chargerClassement();
                            }
                        }, 2000);
                    }
                }, 3000);
            }
        }, 1000);

        // Fonction pour charger le classement
        async function chargerClassement() {
            if (!supabaseScores) return;

            loadingLeaderboard = true;
            try {
                leaderboardData = await supabaseScores.getLeaderboard(10);
            } catch (error) {
                console.error('❌ Erreur chargement classement:', error);
                leaderboardData = [];
            }
            loadingLeaderboard = false;
        }

        // Système de niveaux de sagesse (15 niveaux thématiques)
        function getNiveauSagesse(scoreSagesse) {
            if (scoreSagesse >= 300) return { titre: getTranslatedText('levels.robe_blanche.name', 'Robe Blanche'), icone: '👼', couleur: '#ffffff', seuil: 300, prochain: null };
            if (scoreSagesse >= 250) return { titre: getTranslatedText('levels.saint_navigator.name', 'Saint Navigateur'), icone: '⛪', couleur: '#e8f4f8', seuil: 250, prochain: 300 };
            if (scoreSagesse >= 200) return { titre: getTranslatedText('levels.prophet.name', 'Prophète des Mers'), icone: '🙏', couleur: '#ffd700', seuil: 200, prochain: 250 };
            if (scoreSagesse >= 175) return { titre: getTranslatedText('levels.illuminated.name', 'Illuminé'), icone: '💫', couleur: '#f1c40f', seuil: 175, prochain: 200 };
            if (scoreSagesse >= 150) return { titre: getTranslatedText('levels.disciple.name', 'Disciple de la Lumière'), icone: '✨', couleur: '#e67e22', seuil: 150, prochain: 175 };
            if (scoreSagesse >= 125) return { titre: getTranslatedText('levels.contemplative.name', 'Contemplatif'), icone: '🧘', couleur: '#9b59b6', seuil: 125, prochain: 150 };
            if (scoreSagesse >= 100) return { titre: getTranslatedText('levels.guardian.name', 'Gardien de la Lumière'), icone: '🕯️', couleur: '#8e44ad', seuil: 100, prochain: 125 };
            if (scoreSagesse >= 80) return { titre: getTranslatedText('levels.meditating.name', 'Méditant'), icone: '🕊️', couleur: '#3498db', seuil: 80, prochain: 100 };
            if (scoreSagesse >= 60) return { titre: getTranslatedText('levels.captain.name', 'Capitaine'), icone: '⛵', couleur: '#2980b9', seuil: 60, prochain: 80 };
            if (scoreSagesse >= 45) return { titre: getTranslatedText('levels.navigator.name', 'Navigateur'), icone: '🧭', couleur: '#16a085', seuil: 45, prochain: 60 };
            if (scoreSagesse >= 30) return { titre: getTranslatedText('levels.enlightened_sailor.name', 'Marin Éclairé'), icone: '⚓', couleur: '#27ae60', seuil: 30, prochain: 45 };
            if (scoreSagesse >= 20) return { titre: getTranslatedText('levels.initiate.name', 'Initié'), icone: '🔍', couleur: '#2ecc71', seuil: 20, prochain: 30 };
            if (scoreSagesse >= 10) return { titre: getTranslatedText('levels.apprentice.name', 'Apprenti'), icone: '🌊', couleur: '#7f8c8d', seuil: 10, prochain: 20 };
            if (scoreSagesse >= 5) return { titre: getTranslatedText('levels.cabin_boy.name', 'Mousse'), icone: '🧙', couleur: '#95a5a6', seuil: 5, prochain: 10 };
            return { titre: getTranslatedText('levels.pilgrim.name', 'Pèlerin'), icone: '⛵', couleur: '#bdc3c7', seuil: 0, prochain: 5 };
        }

        // Fonction pour obtenir les badges spéciaux
        function getBadges(donnees, isTopPlayer, enigmesCollectees) {
            const badges = [];

            // Badge Top 1
            if (isTopPlayer) {
                badges.push({ icone: '👑', titre: getTranslatedText('badges.champion.name', 'Champion') });
            }

            // Badge Perfectionniste (si toutes les énigmes collectées)
            if (enigmesCollectees && enigmesCollectees >= 18) { // Nombre total d'énigmes
                badges.push({ icone: '💎', titre: getTranslatedText('badges.perfectionist.name', 'Perfectionniste') });
            }

            // Badge Contemplatif (si beaucoup de temps passé)
            if (donnees && donnees.temps_jeu && donnees.temps_jeu > 3600) { // Plus d'1h
                badges.push({ icone: '⏳', titre: getTranslatedText('badges.contemplative.name', 'Contemplatif') });
            }

            return badges;
        }

        // Variable pour savoir si le formulaire a été affiché
        let formulaireFinAffiche = false;

        // Fonction pour afficher le formulaire avec résumé (appelée après feux d'artifice)
        // isPhase23Complete = true → Victoire Phase 23 (recommence Phase 2)
        // isPhase23Complete = false → Game Over (peut reprendre sauvegarde)
        function afficherFormulaireFinDeJeuAvecResume(xp, scoreJeu, scoreTotal, scoreSagesse, idUnique, isPhase23Complete = false) {
            console.log('📝 afficherFormulaireFinDeJeuAvecResume appelée', { xp, scoreJeu, scoreTotal, scoreSagesse, idUnique, isPhase23Complete });
            if (formulaireFinAffiche) {
                console.warn('⚠️ Formulaire déjà affiché, on ne l\'affiche pas deux fois');
                return;
            }
            formulaireFinAffiche = true;
            console.log('✅ Affichage du formulaire de fin de jeu...');

            // Récupérer les dimensions du canvas avec fallback
            let canvasWidth, canvasHeight, canvasLeft, canvasTop;
            
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const canvasRect = canvas.getBoundingClientRect();
                canvasWidth = canvasRect.width;
                canvasHeight = canvasRect.height;
                canvasLeft = canvasRect.left;
                canvasTop = canvasRect.top;
            } else {
                // Fallback si le canvas n'est pas disponible
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                canvasLeft = 0;
                canvasTop = 0;
            }

            const html = `
                <div id="formulaire-fin-overlay" style="position: fixed; top: ${canvasTop}px; left: ${canvasLeft}px; width: ${canvasWidth}px; height: ${canvasHeight}px; background: rgba(0,0,0,0.95); z-index: 20000; display: flex; align-items: center; justify-content: center; overflow-y: auto; padding: 10px;">
                    <div style="background: white; padding: 20px; border-radius: 12px; max-width: 95%; width: 420px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); margin: auto; color: #1e293b;">
                        <h2 style="margin: 0 0 12px 0; text-align: center; color: #1e293b; font-family: 'Segoe UI', sans-serif; font-size: 22px; font-weight: 700;">
                            ${isPhase23Complete ? getTranslatedText('ui.journey_completed_title', '🎉 Voyage terminé !') : getTranslatedText('ui.game_over_title', '⚓ Fin du voyage')}
                        </h2>

                        <!-- Résumé des scores - Version compacte -->
                        <div style="background: linear-gradient(135deg, #ec4899 0%, #f43f5e 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; color: white;">
                            <div style="display: flex; justify-content: space-around; gap: 8px; margin-bottom: 10px;">
                                <div style="text-align: center; flex: 1;">
                                    <div style="font-size: 20px;">💡</div>
                                    <div style="font-size: 18px; font-weight: bold;">${xp}</div>
                                    <div style="font-size: 10px; opacity: 0.9;">XP</div>
                                </div>
                                <div style="text-align: center; flex: 1;">
                                    <div style="font-size: 20px;">🎯</div>
                                    <div style="font-size: 18px; font-weight: bold;">${scoreJeu}</div>
                                    <div style="font-size: 10px; opacity: 0.9;">${getTranslatedText('game.score_label', 'Score')}</div>
                                </div>
                                <div style="text-align: center; flex: 1;">
                                    <div style="font-size: 20px;">💎</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${scoreSagesse}</div>
                                    <div style="font-size: 10px; opacity: 0.9;">${getTranslatedText('end_form.wisdom_score', 'Sagesse')}</div>
                                </div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                                <div style="font-size: 11px; opacity: 0.9; margin-bottom: 3px;">${getTranslatedText('end_form.total_label', 'Total')}</div>
                                <div style="font-size: 28px; font-weight: bold;">${scoreTotal}</div>
                                <div style="font-size: 20px; margin-top: 5px;">${(() => { const n = getNiveauSagesse(scoreSagesse); return n.icone; })()}</div>
                                <div style="font-size: 12px; font-weight: 600; margin-top: 2px;">${(() => { const n = getNiveauSagesse(scoreSagesse); return n.titre; })()}</div>
                            </div>
                        </div>

                        <p style="text-align: center; color: #64748b; margin-bottom: 12px; font-size: 13px;">${getTranslatedText('ui.save_score_ranking')}</p>

                        <div style="margin: 10px 0;">
                            <label style="display: block; margin-bottom: 4px; color: #475569; font-size: 13px; font-weight: 600;" data-i18n="ui.form.email_label">Email *</label>
                            <input type="email" id="fin-email" data-i18n-placeholder="ui.form.email_placeholder" placeholder="votre@email.com" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; background: white; border-radius: 8px; font-size: 15px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 10px 0;">
                            <label style="display: block; margin-bottom: 4px; color: #475569; font-size: 13px; font-weight: 600;" data-i18n="ui.form.pseudo_label">Pseudo *</label>
                            <input type="text" id="fin-pseudo" data-i18n-placeholder="ui.form.pseudo_placeholder" placeholder="Votre pseudo" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; background: white; border-radius: 8px; font-size: 15px; pointer-events: auto; touch-action: auto; user-select: text;" required>
                        </div>

                        <div style="margin: 10px 0;">
                            <label style="display: block; margin-bottom: 4px; color: #475569; font-size: 13px; font-weight: 600;" data-i18n="ui.form.avatar_label">Avatar</label>
                            <div id="avatar-selector" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; padding: 8px; background: #f8fafc; border-radius: 8px; max-height: 140px; overflow-y: auto; border: 1px solid #e2e8f0;">
                                <div class="avatar-option" data-avatar="⛵" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">⛵</div>
                                <div class="avatar-option" data-avatar="✝️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">✝️</div>
                                <div class="avatar-option" data-avatar="☮️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">☮️</div>
                                <div class="avatar-option" data-avatar="❤️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">❤️</div>
                                <div class="avatar-option" data-avatar="🌈" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">🌈</div>
                                <div class="avatar-option" data-avatar="⭐" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">⭐</div>
                                <div class="avatar-option" data-avatar="🌙" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">🌙</div>
                                <div class="avatar-option" data-avatar="☀️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent;">☀️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🕊️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🕊️</div>
                                <div class="avatar-option avatar-extra" data-avatar="👼" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">👼</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦁" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦁</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦅" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦅</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦋" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦋</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌸" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌸</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌻" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌻</div>
                                <div class="avatar-option avatar-extra" data-avatar="🍀" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🍀</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌊" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌊</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛰️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛰️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🏝️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🏝️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐱" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐱</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐶" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐶</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐼" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐼</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦊" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦊</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐢" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐢</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦉" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦉</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐉" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐉</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐯" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐯</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌹" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌹</div>
                                <div class="avatar-option avatar-extra" data-avatar="💚" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">💚</div>
                                <div class="avatar-option avatar-extra" data-avatar="💙" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">💙</div>
                                <div class="avatar-option avatar-extra" data-avatar="💛" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">💛</div>
                                <div class="avatar-option avatar-extra" data-avatar="💜" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">💜</div>
                                <div class="avatar-option avatar-extra" data-avatar="🖤" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🖤</div>
                                <div class="avatar-option avatar-extra" data-avatar="🤍" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🤍</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦄" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦄</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐙" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐙</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐝" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐝</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐠" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐠</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦈" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦈</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐬" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐬</div>
                                <div class="avatar-option avatar-extra" data-avatar="🐳" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🐳</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦀" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦀</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦞" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦞</div>
                                <div class="avatar-option avatar-extra" data-avatar="🦐" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🦐</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛪" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛪</div>
                                <div class="avatar-option avatar-extra" data-avatar="🕌" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🕌</div>
                                <div class="avatar-option avatar-extra" data-avatar="🛕" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🛕</div>
                                <div class="avatar-option avatar-extra" data-avatar="🕍" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🕍</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛩️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛩️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🚢" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🚢</div>
                                <div class="avatar-option avatar-extra" data-avatar="🛟" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🛟</div>
                                <div class="avatar-option avatar-extra" data-avatar="⚓" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⚓</div>
                                <div class="avatar-option avatar-extra" data-avatar="🧭" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🧭</div>
                                <div class="avatar-option avatar-extra" data-avatar="🗿" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🗿</div>
                                <div class="avatar-option avatar-extra" data-avatar="🗻" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🗻</div>
                                <div class="avatar-option avatar-extra" data-avatar="🏔️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🏔️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌋" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌋</div>
                                <div class="avatar-option avatar-extra" data-avatar="🏖️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🏖️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🏜️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🏜️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌺" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌺</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌷" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌷</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌼" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌼</div>
                                <div class="avatar-option avatar-extra" data-avatar="☘️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">☘️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌿" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌿</div>
                                <div class="avatar-option avatar-extra" data-avatar="🍃" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🍃</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌴" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌴</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌵" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌵</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌾" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌾</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎋" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎋</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎍" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎍</div>
                                <div class="avatar-option avatar-extra" data-avatar="✨" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">✨</div>
                                <div class="avatar-option avatar-extra" data-avatar="💫" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">💫</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌟" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌟</div>
                                <div class="avatar-option avatar-extra" data-avatar="☄️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">☄️</div>
                                <div class="avatar-option avatar-extra" data-avatar="☁️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">☁️</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛅" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛅</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌤️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌤️</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛈️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛈️</div>
                                <div class="avatar-option avatar-extra" data-avatar="🌩️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🌩️</div>
                                <div class="avatar-option avatar-extra" data-avatar="⚡" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⚡</div>
                                <div class="avatar-option avatar-extra" data-avatar="🔥" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🔥</div>
                                <div class="avatar-option avatar-extra" data-avatar="❄️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">❄️</div>
                                <div class="avatar-option avatar-extra" data-avatar="☃️" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">☃️</div>
                                <div class="avatar-option avatar-extra" data-avatar="⛄" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">⛄</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎨" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎨</div>
                                <div class="avatar-option avatar-extra" data-avatar="📖" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">📖</div>
                                <div class="avatar-option avatar-extra" data-avatar="📚" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">📚</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎭" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎭</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎪" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎪</div>
                                <div class="avatar-option avatar-extra" data-avatar="🎬" style="font-size: 24px; text-align: center; cursor: pointer; padding: 4px; border-radius: 6px; transition: all 0.2s; border: 2px solid transparent; display: none;">🎬</div>
                            </div>
                            <button id="btn-more-avatars" style="width: 100%; margin-top: 6px; padding: 6px; background: #f8fafc; color: #64748b; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s;">+ Plus d'avatars (64)</button>
                            <input type="hidden" id="fin-avatar" value="">
                        </div>

                        <details style="margin: 10px 0; cursor: pointer; pointer-events: auto; background: #f8fafc; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                            <summary style="color: #64748b; font-size: 12px; user-select: none; pointer-events: auto; cursor: pointer; font-weight: 600;" data-i18n="ui.form.optional_info">+ Infos optionnelles</summary>
                            <div style="margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <input type="text" id="fin-ville" data-i18n-placeholder="ui.form.city_placeholder" placeholder="Ville" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: white; border-radius: 6px; font-size: 13px;">
                                <input type="text" id="fin-pays" data-i18n-placeholder="ui.form.country_placeholder" placeholder="Pays" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: white; border-radius: 6px; font-size: 13px;">
                                <input type="number" id="fin-age" data-i18n-placeholder="ui.form.age_placeholder" placeholder="Âge" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: white; border-radius: 6px; font-size: 13px;" min="1" max="150">
                                <select id="fin-genre" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: white; border-radius: 6px; font-size: 13px;">
                                    <option value="">Genre</option>
                                    <option value="Homme">Homme</option>
                                    <option value="Femme">Femme</option>
                                    <option value="Autre">Autre</option>
                                </select>
                            </div>
                        </details>

                        <div style="margin-top: 15px;">
                            <button id="fin-enregistrer" data-i18n="ui.buttons.save_and_discover" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 700; box-shadow: 0 3px 10px rgba(16, 185, 129, 0.3); transition: all 0.2s;">
                                Enregistrer
                            </button>
                        </div>

                        <div style="margin-top: 10px;">
                            <button id="fin-passer" data-i18n="ui.buttons.skip_and_continue" style="width: 100%; padding: 12px; background: transparent; color: #94a3b8; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s;">
                                Passer
                            </button>
                        </div>

                        <div id="fin-message" style="margin-top: 10px; text-align: center; font-size: 13px; font-weight: 600;"></div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);

            // 🌍 Appliquer les traductions aux nouveaux éléments DOM
            if (window.i18n && typeof window.i18n.updateDOM === 'function') {
                window.i18n.updateDOM();
            }

            // ❌ DÉSACTIVÉ : Ne pas permettre de fermer en cliquant sur le fond
            // L'utilisateur doit cliquer sur "Enregistrer" ou "Passer" pour continuer
            // (sinon il ne pourrait pas rouvrir le formulaire)

            // Gestion de la sélection d'avatar
            const avatarOptions = document.querySelectorAll('.avatar-option');
            avatarOptions.forEach(option => {
                option.addEventListener('click', async () => {
                    // Retirer la sélection des autres
                    avatarOptions.forEach(opt => {
                        opt.style.background = 'transparent';
                        opt.style.borderColor = 'transparent';
                        opt.style.transform = 'scale(1)';
                    });

                    // Sélectionner celui-ci (rose)
                    option.style.background = '#ec4899';
                    option.style.borderColor = '#ec4899';
                    option.style.transform = 'scale(1.1)';

                    // Enregistrer la valeur
                    document.getElementById('fin-avatar').value = option.getAttribute('data-avatar');
                });

                // Effet hover
                option.addEventListener('mouseenter', () => {
                    if (!option.style.background || option.style.background === 'transparent') {
                        option.style.background = '#fce7f3';
                    }
                });

                option.addEventListener('mouseleave', () => {
                    if (option.style.borderColor !== 'rgb(236, 72, 153)') { // Pas sélectionné (rose)
                        option.style.background = 'transparent';
                    }
                });
            });

            // Bouton "Plus d'avatars"
            const btnMoreAvatars = document.getElementById('btn-more-avatars');
            let avatarsExpanded = false;
            if (btnMoreAvatars) {
                btnMoreAvatars.addEventListener('click', async () => {
                    const extraAvatars = document.querySelectorAll('.avatar-extra');
                    avatarsExpanded = !avatarsExpanded;

                    extraAvatars.forEach(avatar => {
                        avatar.style.display = avatarsExpanded ? 'block' : 'none';
                    });

                    btnMoreAvatars.textContent = avatarsExpanded ? '- Moins d\'avatars' : '+ Plus d\'avatars';
                    btnMoreAvatars.style.background = avatarsExpanded ? '#fce7f3' : '#f8fafc';
                    btnMoreAvatars.style.color = avatarsExpanded ? '#ec4899' : '#64748b';
                });
            }

            // Fonction pour afficher le message final (closure pour accéder aux variables du parent)
            function afficherMessageFinal(nom, ville, pays) {
                document.getElementById('formulaire-fin-overlay').remove();

                // Les variables xp, scoreJeu, scoreTotal, scoreSagesse, idUnique sont accessibles via closure
                afficherMessageNarratifSimple(getTranslatedText('narrative.final_message', 
                    'L\'humanité n\'a pas besoin de murs pour se protéger,\nmais de ponts pour se rencontrer.\n\nConstruisons avec amour, pas avec peur.\nUn monde uni vaut mieux qu\'un monde cloisonné.\n\n- Emmanuel.gallery') + 
                    '\n\n[' + getTranslatedText('game.origin_journey', 'Origine : Le voyage d\'une vie') + ']\n\n' + nom + ' - ' + ville + ', ' + pays + '\n' + xp + ' XP + ' + scoreJeu + ' Score = ' + scoreTotal + '\n' + getTranslatedText('game.knowledge_given', 'Connaissance donnée') + '\n' + getTranslatedText('game.wisdom_score', 'Score de Sagesse') + ' : ' + scoreSagesse + '\nID: ' + idUnique + '\n\n[🌍 ' + getTranslatedText('game.share_journey', 'Partager mon voyage') + ']\n\n[' + getTranslatedText('game.restart', 'Recommencer') + ']\n\n#PETITBATEAUROUGE #UnisPourLaPaix', 999999);

                // Marquer le message comme contenant un bouton restart + lien + partage
                setTimeout(() => {
                    if (messageNarratifActif) {
                        messageNarratifActif.avecRestart = true;
                        messageNarratifActif.lienLivre = 'https://play.google.com/store/books/details?id=VW42EQAAQBAJ';
                        messageNarratifActif.avecPartage = true;

                        // 4 textes de partage différents
                        const textesPartage = [
                            `${getTranslatedText('game.share_texts.text1_title', "🌟 J'ai voyagé à travers les frontières de l'humanité !")}\n\n"${getTranslatedText('game.share_texts.text1_quote', "De l'obscurité vers la lumière, j'ai appris que l'amour unit au-delà des différences.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,
                            `${getTranslatedText('game.share_texts.text2_title', '🕊️ Un voyage vers la vérité...')}\n\n"${getTranslatedText('game.share_texts.text2_quote', "J'ai brisé les murs de la peur pour construire des ponts d'amour.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,
                            `${getTranslatedText('game.share_texts.text3_title', "🌍 De mur en pont, j'ai découvert l'humanité...")}\n\n"${getTranslatedText('game.share_texts.text3_quote', 'Au-delà des frontières, nos cœurs battent à l\'unisson.')}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`,
                            `${getTranslatedText('game.share_texts.text4_title', "👁️ J'ai vu la vérité au-delà des préjugés...")}\n\n"${getTranslatedText('game.share_texts.text4_quote', "Nous construisons des murs par peur, mais l'amour les transforme en refuges.")}"\n\n${nom} - ${ville}, ${pays}\n${getTranslatedText('game.wisdom_label', '💎 Sagesse')} : ${scoreSagesse}\n${getTranslatedText('game.score_label', '🎯 Score')} : ${scoreTotal}\n\n#UnisPourLaPaix #PETITBATEAU #Emmanuel.gallery\n\n${getTranslatedText('game.share_texts.play_text', 'Jouez à ⛵ PETIT BATEAU 👁️')}`
                        ];

                        const texteChoisi = textesPartage[Math.floor(Math.random() * textesPartage.length)];
                        messageNarratifActif.textePartage = texteChoisi;
                    }
                }, 100);
            }

            // Gestionnaire d'enregistrement ET ouverture emmanuel-artist-module
            document.getElementById('fin-enregistrer').onclick = async () => {
                console.log('🔘 Bouton Enregistrer & Découvrir cliqué');
                const emailInput = document.getElementById('fin-email');
                const pseudoInput = document.getElementById('fin-pseudo');
                
                const email = emailInput ? emailInput.value.trim() : '';
                const pseudo = pseudoInput ? pseudoInput.value.trim() : '';

                // Vérifier que les champs obligatoires sont remplis
                if (!email || !pseudo) {
                    console.log('❌ Champs obligatoires manquants');
                    document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">⚠️ ' + getTranslatedText('database_form.required_fields', 'Email et pseudo sont obligatoires') + '</span>';
                    
                    // Mettre en évidence les champs vides
                    if (!email) emailInput.style.border = '2px solid #ef4444';
                    if (!pseudo) pseudoInput.style.border = '2px solid #ef4444';
                    
                    return;
                }

                // Valider le format de l'email
                if (!email.includes('@')) {
                    console.log('❌ Email invalide');
                    document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">⚠️ ' + getTranslatedText('database_form.invalid_email', 'Email invalide') + '</span>';
                    emailInput.style.border = '2px solid #ef4444';
                    return;
                }

                // Si email et pseudo remplis, enregistrer le score
                if (email && pseudo) {
                    document.getElementById('fin-message').innerHTML = '<span style="color: #3b82f6;">' + getTranslatedText('interface.system.saving', '💾 Enregistrement...') + '</span>';

                    try {
                        // ✅ Vérifier que supabaseScores existe
                        if (!supabaseScores) {
                            throw new Error('Système de sauvegarde non disponible');
                        }

                        console.log('💾 Début enregistrement...');
                        const ville = document.getElementById('fin-ville').value.trim() || 'Inconnue';
                        const pays = document.getElementById('fin-pays').value.trim() || 'Inconnu';
                        const age = parseInt(document.getElementById('fin-age').value) || null;
                        const genre = document.getElementById('fin-genre').value || null;
                        const avatar = document.getElementById('fin-avatar').value || null;

                        // 🔧 S'assurer que le jeu est bien configuré avant de sauvegarder
                        if (!supabaseScores.currentGameId) {
                            console.log('⚠️ currentGameId non défini, configuration du jeu...');
                            await supabaseScores.setCurrentGame('Petit Bateau');
                        }

                        console.log('👤 Création/récupération utilisateur...', { email, pseudo, ville, pays, age, genre, avatar });
                        await supabaseScores.getOrCreateUser(email, pseudo, { ville, pays, age, genre, avatar });

                        // Calculer le niveau de sagesse
                        const niveauSagesse = getNiveauSagesse(scoreSagesse);

                        // ✅ Utiliser la phase actuelle (pas hardcodé à 23)
                        const niveauAtteint = narrationManager.currentPhase || 1;
                        console.log('💾 Envoi du score à Supabase (méthode directe)...', { scoreTotal, xp, scoreJeu, scoreSagesse, niveauAtteint });
                        const resultat = await supabaseScores.saveScoreDirect(scoreTotal, {
                            niveau_atteint: niveauAtteint,  // ✅ Phase réelle atteinte
                            temps_jeu: Math.floor(Date.now() / 1000),
                            donnees_extra: {
                                pseudo: pseudo,
                                avatar: avatar,
                                xp,
                                score: scoreJeu,
                                sagesse: scoreSagesse,
                                niveau: niveauSagesse.titre,
                                niveau_icone: niveauSagesse.icone,
                                enigmes: enigmaCollector ? enigmaCollector.enigmesCollectees.size : 0,
                                id: idUnique
                            }
                        });

                        // ✅ Considérer la sauvegarde réussie si on a un user_id (même si success=false)
                        const saveSuccess = resultat && (resultat.success || resultat.user_id);
                        
                        if (!saveSuccess) {
                            const errorMsg = resultat?.error || 'Échec de la sauvegarde du score';
                            console.error('❌ Échec sauvegarde:', errorMsg, resultat);
                            throw new Error(errorMsg);
                        }

                        // ✅ Afficher si sauvegarde locale ou en ligne
                        const saveMsg = resultat.local 
                            ? '💾 ' + (resultat.message || 'Score sauvegardé localement')
                            : '✅ ' + getTranslatedText('database_form.score_saved', 'Score enregistré !');
                        
                        console.log('✅ Score sauvegardé avec succès:', resultat);
                        document.getElementById('fin-message').innerHTML = '<span style="color: #10b981;">' + saveMsg + '</span>';

                        // Récupérer le meilleur score de l'utilisateur
                        userBestScore = await supabaseScores.getBestScore();
                        await chargerClassement();

                    } catch (error) {
                        console.error('❌ Erreur sauvegarde:', error);
                        document.getElementById('fin-message').innerHTML = '<span style="color: #ef4444;">❌ ' + getTranslatedText('interface.system.error', 'Erreur') + ' : ' + error.message + '</span>';
                        return; // Ne pas continuer si erreur
                    }
                }

                // Fermer le formulaire
                const overlay = document.getElementById('formulaire-fin-overlay');
                if (overlay) overlay.remove();
                
                // Ouvrir la page artiste
                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                window.location.href = `modules/emmanuel-artist-module.html?lang=${currentLang}`;
                
                // 🔄 Comportement selon le contexte
                setTimeout(() => {
                    if (isPhase23Complete) {
                        // ✅ Phase 23 terminée → Recommencer à Phase 2
                        console.log('✅ Phase 23 complétée - Recommencer à Phase 2');
                        recommencerDepuisPhase2();
                    } else {
                        // ❌ Game Over → Recréer la phase actuelle
                        console.log('� Game Over - Recréer la phase actuelle');
                        recreerPhaseActuelle(true);
                    }
                }, 500);
            };

            // Gestionnaire du bouton "Passer & Continuer"
            document.getElementById('fin-passer').onclick = () => {
                console.log('⏭️ Bouton Passer & Continuer cliqué - on saute l\'enregistrement');
                
                // Fermer le formulaire immédiatement
                const overlay = document.getElementById('formulaire-fin-overlay');
                if (overlay) overlay.remove();
                
                // Ouvrir la page artiste
                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                window.location.href = `modules/emmanuel-artist-module.html?lang=${currentLang}`;
                
                // 🔄 Comportement selon le contexte
                setTimeout(() => {
                    if (isPhase23Complete) {
                        // ✅ Phase 23 terminée → Recommencer à Phase 2
                        console.log('✅ Phase 23 complétée - Passer sans enregistrer → Recommencer à Phase 2');
                        recommencerDepuisPhase2();
                    } else {
                        // ❌ Game Over → Recréer la phase actuelle (sans enregistrer)
                        console.log('� Game Over - Passer sans enregistrer → Recréer phase actuelle');
                        recreerPhaseActuelle(true);
                    }
                }, 500);
            };
        }

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapté pour intégration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentIndex = 0;
                this.timeoutId = null;
                this.text = '';
                this.options = {};
            }

            // Configuration des couleurs
            setColors(element, textColor = '#ffffff', effectColor = '#64ffda') {
                element.style.setProperty('--ta-text-color', textColor);
                element.style.setProperty('--ta-effect-color', effectColor);
                element.style.color = textColor;
            }

            // Arrête l'animation
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
            }

            // Reset
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.text = '';
            }

            // Animation machine à écrire avec support HTML complet
            typewriter(element, text, speed = 50, onComplete = null) {console.log('TextAnimationModule.typewriter appelé avec:', {text: text.substring(0, 50), speed, element});
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';
                this.isRunning = true;

                this._typewriterStep(element);
            }

            _typewriterStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    // Gestion des balises HTML et des \n
                    let currentChar = this.text.charAt(this.currentIndex);

                    // Si on trouve une balise HTML, on l'ajoute entièrement
                    if (currentChar === '<') {
                        let tagEnd = this.text.indexOf('>', this.currentIndex);
                        if (tagEnd !== -1) {
                            let fullTag = this.text.substring(this.currentIndex, tagEnd + 1);
                            element.innerHTML += fullTag;
                            this.currentIndex = tagEnd + 1;
                        } else {
                            element.innerHTML += currentChar;
                            this.currentIndex++;
                        }
                    } else if (currentChar === '\n') {
                        // Gérer les sauts de ligne
                        element.innerHTML += '<br>';
                        this.currentIndex++;
                    } else {
                        element.innerHTML += currentChar;
                        this.currentIndex++;
                    }

                    this.timeoutId = setTimeout(() => this._typewriterStep(element), this.options.speed);
                } else {
                    element.style.borderRight = 'none';
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                }
            }

            // Animation fade avec support HTML
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                element.innerHTML = text.replace(/\n/g, '<br>');
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 50);

                setTimeout(() => {
                    element.style.transition = '';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Animation digital avec support HTML
            digital(element, text, speed = 50, onComplete = null) {
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                this.isRunning = true;

                this._digitalStep(element);
            }

            _digitalStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    let displayText = '';
                    let textOnly = this.text.replace(/<[^>]*>/g, '').replace(/\n/g, ' '); // Texte sans balises
                    let currentTextIndex = 0;

                    // Reconstitue le texte avec balises jusqu'à la position actuelle
                    for (let i = 0; i < this.text.length && currentTextIndex < this.currentIndex; i++) {
                        if (this.text.charAt(i) === '<') {
                            let tagEnd = this.text.indexOf('>', i);
                            if (tagEnd !== -1) {
                                displayText += this.text.substring(i, tagEnd + 1);
                                i = tagEnd;
                            }
                        } else if (this.text.charAt(i) === '\n') {
                            displayText += '<br>';
                            currentTextIndex++;
                        } else {
                            displayText += this.text.charAt(i);
                            currentTextIndex++;
                        }
                    }

                    // Ajoute un caractère aléatoire si on n'est pas à la fin
                    if (this.currentIndex < textOnly.length) {
                        const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }

                    element.innerHTML = displayText;

                    setTimeout(() => {
                        this.currentIndex++;
                        if (this.currentIndex < textOnly.length) {
                            this.timeoutId = setTimeout(() => this._digitalStep(element), this.options.speed);
                        } else {
                            element.innerHTML = this.text.replace(/\n/g, '<br>');
                            this.isRunning = false;
                            if (this.options.onComplete) this.options.onComplete();
                        }
                    }, this.options.speed / 2);
                }
            }

            // Animation glitch avec support HTML
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();

                // Effet de glitch en préservant le HTML
                let textOnly = text.replace(/<[^>]*>/g, '').replace(/\n/g, ' ');
                let glitchText = '';
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';

                // Reconstitue le texte avec des caractères glitch
                for (let i = 0; i < text.length; i++) {
                    if (text.charAt(i) === '<') {
                        let tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            glitchText += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text.charAt(i) === '\n') {
                        glitchText += '<br>';
                    } else {
                        if (Math.random() < 0.1 && text.charAt(i) !== ' ') {
                            glitchText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        } else {
                            glitchText += text.charAt(i);
                        }
                    }
                }

                element.innerHTML = glitchText;
                element.style.animation = 'ta-glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas déjà présentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes ta-glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.innerHTML = text.replace(/\n/g, '<br>');
                    element.style.animation = 'none';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Vérifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // 🎬 NOUVELLE CLASSE TEXTANIMATOR OPTIMISÉE
        // ═══════════════════════════════════════════════════════════════════
        class TextAnimator {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('TextAnimator: Element non trouvé:', elementId);
                    return;
                }
                this.reset();
            }

            // État et méthodes utilitaires optimisées
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.element.innerHTML = '';
                // Garder les classes originales du message
                const originalClasses = this.element.className;
                this.element.className = originalClasses.replace(/ta-\w+/g, '').trim();
            }

            stop() {
                this.isRunning = false;
                if (this.timeoutId) clearTimeout(this.timeoutId);
            }

            setColors(textColor = '#ffffff', effectColor = '#64ffda') {
                this.element.style.setProperty('--ta-text-color', textColor);
                this.element.style.setProperty('--ta-effect-color', effectColor);
                this.element.style.color = textColor;
            }

            applyEffect(effect = 'none') {
                const effects = ['shadow3d', 'neon', 'emboss', 'outline', 'fire', 'ice'];
                effects.forEach(e => this.element.classList.remove(`ta-effect-${e}`));
                if (effect !== 'none') this.element.classList.add(`ta-effect-${effect}`);
            }

            // Animation machine à écrire optimisée
            typewriter(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-typewriter');
                this.isRunning = true;
                this._typewriterStep();
            }

            _typewriterStep() {
                if (!this.isRunning || this.currentIndex >= this.text.length) {
                    this.element.classList.remove('ta-typewriter');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                const char = this.text.charAt(this.currentIndex);
                if (char === '<') {
                    const tagEnd = this.text.indexOf('>', this.currentIndex);
                    if (tagEnd !== -1) {
                        this.element.innerHTML += this.text.substring(this.currentIndex, tagEnd + 1);
                        this.currentIndex = tagEnd + 1;
                    } else {
                        this.element.innerHTML += char;
                        this.currentIndex++;
                    }
                } else if (char === '\n') {
                    this.element.innerHTML += '<br>';
                    this.currentIndex++;
                } else {
                    this.element.innerHTML += char;
                    this.currentIndex++;
                }

                this.timeoutId = setTimeout(() => this._typewriterStep(), this.options.speed);
            }

            // Animation code digital optimisée
            digital(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-digital');
                this.isRunning = true;
                this._digitalStep();
            }

            _digitalStep() {
                if (!this.isRunning) return;

                const textOnly = this.text.replace(/<[^>]*>/g, '');
                if (this.currentIndex >= textOnly.length) {
                    this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                let displayText = this._buildHtmlText(this.currentIndex);
                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                displayText += digitalChars[Math.floor(Math.random() * digitalChars.length)];

                this.element.innerHTML = displayText;

                setTimeout(() => {
                    this.currentIndex++;
                    if (this.currentIndex < textOnly.length) {
                        this.timeoutId = setTimeout(() => this._digitalStep(), this.options.speed);
                    } else {
                        this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                        this.isRunning = false;
                        if (this.options.onComplete) this.options.onComplete();
                    }
                }, this.options.speed / 2);
            }

            // Animation fade
            fade(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-fade-in');
                this.element.innerHTML = text.replace(/\n/g, '<br>');

                setTimeout(() => {
                    this.element.classList.remove('ta-fade-in');
                    if (this.options.onComplete) this.options.onComplete();
                }, 1000);
            }

            // Animation glitch optimisée
            glitch(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-glitch');

                const glitchText = this._createGlitchText(text);
                this.element.innerHTML = glitchText;

                this.timeoutId = setTimeout(() => {
                    this.element.innerHTML = text.replace(/\n/g, '<br>');
                    this.element.classList.remove('ta-glitch');
                    if (this.options.onComplete) this.options.onComplete();
                }, this.options.speed * 5);
            }

            // Méthodes utilitaires optimisées
            setupAnimation(text, options) {
                this.text = text;
                this.options = {
                    speed: options.speed || 50,
                    textColor: options.textColor || '#ffffff',
                    effectColor: options.effectColor || '#64ffda',
                    effect: options.effect || 'none',
                    onComplete: options.onComplete
                };
                this.reset();
                this.setColors(this.options.textColor, this.options.effectColor);
                this.applyEffect(this.options.effect);
            }

            _buildHtmlText(index) {
                let result = '';
                let textIndex = 0;
                for (let i = 0; i < this.text.length && textIndex < index; i++) {
                    if (this.text[i] === '<') {
                        const tagEnd = this.text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += this.text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (this.text[i] === '\n') {
                        result += '<br>';
                        textIndex++;
                    } else {
                        result += this.text[i];
                        textIndex++;
                    }
                }
                return result;
            }

            _createGlitchText(text) {
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '<') {
                        const tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text[i] === '\n') {
                        result += '<br>';
                    } else if (Math.random() < 0.1 && text[i] !== ' ') {
                        result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        result += text[i];
                    }
                }
                return result;
            }

            // Vérifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // 🔊 Système Audio - Sons synthétiques calmes et feutrés
        window.AudioSystem = {
            ctx: null,
            masterVolume: 0.3,
            muted: false,
            initialized: false,

            init() {
                if (!this.initialized) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                }
            },

            ensureInit() {
                if (!this.initialized) {
                    this.init();
                }
            },

            // Son de clic doux (UI)
            playClick() {
                this.ensureInit();
                if (this.muted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.frequency.value = 800;
                gain.gain.value = this.masterVolume * 0.1;

                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son de collecte doux - Tock d'amour pour power-ups
            playCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Tock d'amour chaleureux et doux (pas de tinks aigus!)
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(550, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(380, this.ctx.currentTime + 0.25);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.22, this.ctx.currentTime + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.25);
            },

            // Son "Chuchotement" - Murmure feutré pour les cœurs du haut
            playPof() {
                this.ensureInit();
                if (this.muted) return;

                // Chuchotement - Murmure doux et apaisant
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.25, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Créer un chuchotement avec bruit modulé
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const envelope = Math.sin(t * 20) * Math.exp(-t * 6);
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.6;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1200;
                filter.Q.value = 2;

                const gain = this.ctx.createGain();
                gain.gain.value = this.masterVolume * 0.15;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de bulle qui pop (briques qui cassent)
            playExplosion() {
                this.ensureInit();
                if (this.muted) return;

                // Son de "pop" de bulle - fréquence qui descend rapidement
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 1200;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Descente rapide de fréquence pour effet "pop"
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.08);

                // Volume qui chute rapidement
                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son "plouf" très doux pour explosion finale des cœurs
            playExplosionCoeurs() {
                this.ensureInit();
                if (this.muted) return;

                // "Plouf" ultra doux - comme un soupir apaisant
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 300; // Très filtré et grave

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Descente ultra douce et lente
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(120, this.ctx.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.8);

                // Volume ultra doux et très progressif
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.06, this.ctx.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.05, this.ctx.currentTime + 0.4);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.9);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.9);
            },

            // Son de rebond léger et feutré (balle/lanterne)
            playBounce() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 600; // Filtre pour son plus doux

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Petit "boing" doux
                osc.frequency.setValueAtTime(250, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(180, this.ctx.currentTime + 0.05);

                gain.gain.setValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            // Vague douce - Ambiance calme
            playVagueDouce() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 3, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const wave = Math.sin(t * Math.PI / 3) * 0.7 + 0.3;
                    data[i] = (Math.random() * 2 - 1) * wave * 0.6;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 1.5);
                filter.frequency.linearRampToValueAtTime(250, this.ctx.currentTime + 3);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.6, this.ctx.currentTime + 0.8);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.5, this.ctx.currentTime + 2.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Vague puissante - Ambiance intense
            playVaguePuissante() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 4, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const wave = Math.pow(Math.sin(t * Math.PI / 4), 2);
                    data[i] = (Math.random() * 2 - 1) * wave * 0.8;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(500, this.ctx.currentTime + 2);
                filter.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 4);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.7, this.ctx.currentTime + 1.5);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.6, this.ctx.currentTime + 3);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();

                // Résonance grave
                const osc = this.ctx.createOscillator();
                const gainOsc = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(40, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(70, this.ctx.currentTime + 2);
                osc.frequency.linearRampToValueAtTime(35, this.ctx.currentTime + 4);

                gainOsc.gain.setValueAtTime(0, this.ctx.currentTime);
                gainOsc.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 1.2);
                gainOsc.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                osc.connect(gainOsc);
                gainOsc.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 4);
            },

            // Ambiance sonore - Joue vague selon la phase
            playAmbience() {
                this.ensureInit();
                if (this.muted) {
                    return;
                }

                // Alterner entre vague douce et puissante selon la phase
                // Phases paires = douce, impaires = puissante
                const phaseActuelle = (typeof narrationManager !== 'undefined' && narrationManager)
                    ? narrationManager.currentPhase
                    : 0;

                if (phaseActuelle % 2 === 0) {
                    this.playVagueDouce();
                } else {
                    this.playVaguePuissante();
                }
            },

            // Son de gong asiatique (bouton "Passer" NON!)
            playNegative() {
                this.ensureInit();
                if (this.muted) return;

                // Gong asiatique - plusieurs fréquences harmoniques
                const frequencies = [220, 330, 440, 660]; // Harmoniques du gong

                frequencies.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();

                    osc.type = 'sine';
                    filter.type = 'lowpass';
                    filter.frequency.value = 800;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);

                    // Fréquence légèrement variable pour effet métallique
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(freq * 0.98, this.ctx.currentTime + 0.5);

                    // Volume avec attaque et longue résonance
                    const volume = this.masterVolume * (0.15 - index * 0.03); // Harmoniques plus faibles
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(volume, this.ctx.currentTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2.0);

                    osc.start();
                    osc.stop(this.ctx.currentTime + 2.0);
                });
            },

            // Son "feuuuux" - souffle qui s'éteint (pour le corbeau)
            playCrow() {
                this.ensureInit();
                if (this.muted) return;

                // "feuuuux" - souffle long qui s'éteint progressivement
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.5, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit qui décroît très progressivement
                for (let i = 0; i < buffer.length; i++) {
                    const progress = i / buffer.length;
                    // Fade exponentiel pour extinction naturelle
                    const fade = Math.exp(-progress * 4);
                    // Variation pour son organique
                    const variation = Math.sin(i / 500) * 0.2;
                    data[i] = (Math.random() * 2 - 1) * fade * (0.6 + variation);
                }

                noise.buffer = buffer;

                // Filtre qui ferme progressivement (extinction)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 1.5);

                const gain = this.ctx.createGain();

                // Volume : monte, tient, puis s'éteint doucement
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.1, this.ctx.currentTime + 0.08);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.4);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de vol du corbeau - battements d'ailes
            playCrowFly() {
                this.ensureInit();
                if (this.muted) return;

                // Créer 3 battements d'ailes rapides
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const noise = this.ctx.createBufferSource();
                        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);

                        // Bruit de battement - attaque rapide puis decay
                        for (let j = 0; j < buffer.length; j++) {
                            const t = j / buffer.length;
                            const envelope = Math.exp(-t * 8);
                            data[j] = (Math.random() * 2 - 1) * envelope * 0.7;
                        }

                        noise.buffer = buffer;

                        const filter = this.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 400 + Math.random() * 200;

                        const gain = this.ctx.createGain();
                        gain.gain.value = this.masterVolume * (0.12 - i * 0.02);

                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.ctx.destination);

                        noise.start();
                    }, i * 120);
                }
            },

            // Son de rire maléfique du corbeau
            playCrowLaugh() {
                this.ensureInit();
                if (this.muted) return;

                // Rire en 3 phases descendantes "ah-ah-ahhh"
                const frequencies = [600, 500, 400];
                const durations = [0.15, 0.15, 0.3];

                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        const filter = this.ctx.createBiquadFilter();

                        // Mélange de square et sine pour son plus rauque
                        osc.type = 'square';
                        filter.type = 'lowpass';
                        filter.frequency.value = 800;

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.ctx.destination);

                        // Fréquence qui tremble (vibrato) pour effet rire
                        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(freq * 0.9, this.ctx.currentTime + durations[i]);

                        // Volume avec attaque rapide
                        const vol = this.masterVolume * (0.08 - i * 0.01);
                        gain.gain.setValueAtTime(0, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + durations[i]);

                        osc.start();
                        osc.stop(this.ctx.currentTime + durations[i]);
                    }, i * 180);
                });
            },

            // Son d'explosion du corbeau
            playCrowExplosion() {
                this.ensureInit();
                if (this.muted) return;

                // Pff long - expiration après explosion du drone

                // Souffle long et feutré
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / buffer.length;
                    const envelope = Math.exp(-t * 2); // Descente lente
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.3;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 1);
                filter.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 2);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.18, this.ctx.currentTime + 1.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de voile - Vent dans la toile (mouvement du bateau)
            playVoile() {
                this.ensureInit();
                if (this.muted) return;

                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.4, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit avec flutter (effet de toile qui ondule)
                for (let i = 0; i < buffer.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const flutter = Math.sin(t * 12) * 0.3 + 0.7;
                    data[i] = (Math.random() * 2 - 1) * flutter * 0.5;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(700, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(1000, this.ctx.currentTime + 0.2);
                filter.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.4);
                filter.Q.value = 3;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son d'orage - Tonnerre avec grondement
            playOrage() {
                this.ensureInit();
                if (this.muted) return;

                // Grondement grave du tonnerre
                const thunder = this.ctx.createOscillator();
                const thunderGain = this.ctx.createGain();

                thunder.frequency.setValueAtTime(80, this.ctx.currentTime);
                thunder.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 10);
                thunder.type = 'sawtooth';

                thunderGain.gain.setValueAtTime(0, this.ctx.currentTime);
                thunderGain.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 0.1);
                thunderGain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime + 8);
                thunderGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);

                thunder.connect(thunderGain);
                thunderGain.connect(this.ctx.destination);

                thunder.start();
                thunder.stop(this.ctx.currentTime + 10);

                // Pluie d'orage en fond
                const rain = this.ctx.createBufferSource();
                const rainBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 10, this.ctx.sampleRate);
                const rainData = rainBuffer.getChannelData(0);

                for (let i = 0; i < rainBuffer.length; i++) {
                    if (Math.random() < 0.45) {
                        rainData[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                }

                rain.buffer = rainBuffer;

                const rainFilter = this.ctx.createBiquadFilter();
                rainFilter.type = 'bandpass';
                rainFilter.frequency.value = 4000;
                rainFilter.Q.value = 1;

                const rainGain = this.ctx.createGain();
                rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.5);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 9);
                rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);

                rain.connect(rainFilter);
                rainFilter.connect(rainGain);
                rainGain.connect(this.ctx.destination);

                rain.start();
            },

            // Son de casse brique - Tac doux 1
            playBrickBreakToc() {
                this.ensureInit();
                if (this.muted) return;

                // Tac court et sec mais doux
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 700;

                gain.gain.setValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            // Son de casse brique - Tac doux 2
            playBrickBreakGlass() {
                this.ensureInit();
                if (this.muted) return;

                // Tac medium
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 600;

                gain.gain.setValueAtTime(this.masterVolume * 0.23, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.09);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.09);
            },

            // Son de casse brique - Tac doux 3
            playBrickBreakCrack() {
                this.ensureInit();
                if (this.muted) return;

                // Tac grave
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 500;

                gain.gain.setValueAtTime(this.masterVolume * 0.21, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            // Son de pièce - tintement léger et délicat (pour phases 17 & 20)
            playCoin() {
                this.ensureInit();
                if (this.muted) return;

                // Tintement léger - deux notes cristallines
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();
                
                // Note principale - aiguë et légère
                osc1.type = 'sine';
                osc1.frequency.value = 1760; // A6 - aigu
                
                // Harmonique subtile - octave au-dessus
                osc2.type = 'sine';
                osc2.frequency.value = 3520; // A7 - très aigu
                
                // Volume léger et qui disparaît vite
                gain1.gain.setValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                
                gain2.gain.setValueAtTime(this.masterVolume * 0.06, this.ctx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);
                
                // Connexions
                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);
                
                osc2.connect(gain2);
                gain2.connect(this.ctx.destination);
                
                // Démarrage
                osc1.start();
                osc2.start();
                osc1.stop(this.ctx.currentTime + 0.15);
                osc2.stop(this.ctx.currentTime + 0.12);
            },

            // Son "poque" - impact sur le mur (sans le détruire)
            playWallHit() {
                this.ensureInit();
                if (this.muted) return;

                // Petit coup sec - "poque"
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.06);

                gain.gain.setValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.06);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.06);
            },

            // Son de mur qui casse (impact lourd pour briques du mur)
            playWallBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Impact sourd et lourd
                const osc = this.ctx.createOscillator();
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Bruit d'impact
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / buffer.length * 8);
                }
                noise.buffer = buffer;

                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();

                // Composante grave
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.15);

                gain1.gain.setValueAtTime(this.masterVolume * 0.35, this.ctx.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);

                // Composante bruit
                gain2.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);

                osc.connect(gain1);
                gain1.connect(this.ctx.destination);

                noise.connect(gain2);
                gain2.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
                noise.start();
            },

            // Son de tir de projectile (whoosh)
            playShoot() {
                this.ensureInit();
                if (this.muted) return;

                // Whoosh rapide
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.12, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / buffer.length;
                    const envelope = Math.sin(t * Math.PI) * 0.8;
                    data[i] = (Math.random() * 2 - 1) * envelope;
                }
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 800;
                filter.Q.value = 2;

                const gain = this.ctx.createGain();
                gain.gain.value = this.masterVolume * 0.12;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Son de cloche magique (découverte du power-up espoir) 🔔✨
            playChime() {
                this.ensureInit();
                if (this.muted) return;

                // Carillon magique avec 3 notes harmonieuses
                const notes = [880, 1100, 1320]; // A5, C#6, E6 (accord majeur)
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine'; // Son de cloche pure
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.08); // Notes décalées
                    const endTime = startTime + 1.5; // Résonance longue
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Phase 18 : Son de vent/souffle léger (LIBERTÉ) 💨
            playWindBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Souffle aérien
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    const envelope = Math.exp(-i / buffer.length * 5);
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.4;
                }
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800; // Aigu et léger

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            },

            // Phase 19 : Tac grave sec (REFUS) 🧱 - Coup sourd et percutant
            playHammerBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Tac grave et sec - coup de brique
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const noise = this.ctx.createBufferSource();

                // Bruit de cassure grave
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.08, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / buffer.length * 25);
                }
                noise.buffer = buffer;

                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();
                const noiseGain = this.ctx.createGain();

                // Composante grave principale (le tac profond)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(150, this.ctx.currentTime); // Plus grave
                osc1.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.1);

                // Harmonique médium (définition du coup)
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(400, this.ctx.currentTime); // Moins aigu
                osc2.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.06);

                // Attaque rapide, déclin court (tac sec)
                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.35, this.ctx.currentTime + 0.005);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                gain2.gain.setValueAtTime(0, this.ctx.currentTime);
                gain2.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.003);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.06);

                noiseGain.gain.setValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);

                osc1.connect(gain1);
                osc2.connect(gain2);
                noise.connect(noiseGain);
                gain1.connect(this.ctx.destination);
                gain2.connect(this.ctx.destination);
                noiseGain.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                noise.start();
                osc1.stop(this.ctx.currentTime + 0.1);
                osc2.stop(this.ctx.currentTime + 0.06);
                noise.stop(this.ctx.currentTime + 0.08);
            },

            // Phase 21 : Son cristallin/verre (INÉGALITÉS) ✨
            playCrystalBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Éclat cristallin
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const osc3 = this.ctx.createOscillator();

                const gain = this.ctx.createGain();

                // Accord cristallin (notes aiguës)
                osc1.type = 'sine';
                osc1.frequency.value = 1760; // A6
                osc2.type = 'sine';
                osc2.frequency.value = 2217; // C#7
                osc3.type = 'sine';
                osc3.frequency.value = 2637; // E7

                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                osc1.connect(gain);
                osc2.connect(gain);
                osc3.connect(gain);
                gain.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                osc3.start();
                osc1.stop(this.ctx.currentTime + 0.4);
                osc2.stop(this.ctx.currentTime + 0.4);
                osc3.stop(this.ctx.currentTime + 0.4);
            },

            // Phase 22 : Son doux/cœur (ESPOIR) 💓
            playHeartBreak() {
                this.ensureInit();
                if (this.muted) return;

                // Battement de cœur chaleureux
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(220, this.ctx.currentTime); // Note douce
                osc.frequency.exponentialRampToValueAtTime(180, this.ctx.currentTime + 0.2);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.35);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.35);
            },

            // Phase 22 : Toc grave profond (brique espoir) 🎯
            playDeepKnock() {
                this.ensureInit();
                if (this.muted) return;

                // Toc grave et résonnant
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                const gain2 = this.ctx.createGain();

                // Composante très grave (le "toc" profond)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(80, this.ctx.currentTime); // Très grave
                osc1.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.15);

                // Harmonique pour le "claquement"
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(160, this.ctx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);

                // Enveloppe grave (attaque rapide, déclin lent)
                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.4, this.ctx.currentTime + 0.01);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                gain2.gain.setValueAtTime(0, this.ctx.currentTime);
                gain2.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 0.005);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);

                osc1.connect(gain1);
                osc2.connect(gain2);
                gain1.connect(this.ctx.destination);
                gain2.connect(this.ctx.destination);

                osc1.start();
                osc2.start();
                osc1.stop(this.ctx.currentTime + 0.3);
                osc2.stop(this.ctx.currentTime + 0.15);
            },

            // Sons de collecte de power-ups thématiques 🎁

            // Son sombre/lourd (power-ups négatifs : chaînes, barbelés, cœur noir)
            playDarkCollect() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(110, this.ctx.currentTime); // Très grave
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            },

            // Son lumineux/joyeux (cœurs colorés positifs : vert, jaune, bleu)
            playJoyfulCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Arpège joyeux
                const notes = [523, 659, 784]; // C5, E5, G5 (accord majeur)
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.05);
                    const endTime = startTime + 0.3;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.15, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Son doux/apaisant (cœurs empathiques : rose, violet, rouge)
            playSoftCollect() {
                this.ensureInit();
                if (this.muted) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, this.ctx.currentTime); // A4
                osc.frequency.exponentialRampToValueAtTime(330, this.ctx.currentTime + 0.4);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(this.masterVolume * 0.18, this.ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.4);
            },

            // Son pétillant (sourire, liberté retrouvée)
            playSparkleCollect() {
                this.ensureInit();
                if (this.muted) return;

                // Notes pétillantes ascendantes
                const notes = [880, 1100, 1320, 1568]; // A5, C#6, E6, G6
                
                notes.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + (index * 0.04);
                    const endTime = startTime + 0.2;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, endTime);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(startTime);
                    osc.stop(endTime);
                });
            },

            // Son de pluie douce en boucle - très longue et extra douce
            startRainLoop() {
                this.ensureInit();
                if (this.muted || this.rainLoopActive) return;

                // Créer buffer de pluie 2x plus long (16 secondes en boucle)
                const duration = 16;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Pluie très douce avec modulation lente
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    const modulation = Math.sin(t * Math.PI * 2) * 0.4 + 0.6; // Variation plus lente
                    if (Math.random() < 0.1) { // Encore moins dense pour plus de douceur
                        data[i] = (Math.random() * 2 - 1) * 0.18 * modulation; // Volume réduit
                    }
                }

                this.rainSource = this.ctx.createBufferSource();
                this.rainSource.buffer = buffer;
                this.rainSource.loop = true;

                // Triple filtrage pour effet ultra-doux
                const filter1 = this.ctx.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.value = 2000; // Encore plus grave
                filter1.Q.value = 0.4;

                const filter2 = this.ctx.createBiquadFilter();
                filter2.type = 'highpass';
                filter2.frequency.value = 1000;
                filter2.Q.value = 0.3;

                const filter3 = this.ctx.createBiquadFilter();
                filter3.type = 'lowpass';
                filter3.frequency.value = 1800; // Deuxième lowpass pour adoucir
                filter3.Q.value = 0.5;

                this.rainGain = this.ctx.createGain();
                this.rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.12, this.ctx.currentTime + 3); // Volume plus faible

                this.rainSource.connect(filter1);
                filter1.connect(filter2);
                filter2.connect(filter3);
                filter3.connect(this.rainGain);
                this.rainGain.connect(this.ctx.destination);

                this.rainSource.start();
                this.rainLoopActive = true;console.log('[AUDIO] Pluie très douce et longue (16s) démarrée en boucle');
            },

            stopRainLoop() {
                if (!this.rainLoopActive || !this.rainGain || !this.rainSource) return;

                this.rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4); // Fade out 4 secondes
                setTimeout(() => {
                    if (this.rainSource) {
                        this.rainSource.stop();
                        this.rainSource = null;
                        this.rainGain = null;
                        this.rainLoopActive = false;console.log('[AUDIO] Pluie douce arrêtée (fade out 4s)');
                    }
                }, 4000);
            },

            // Son d'averse (pluie forte ponctuelle - plus douce et fade out long)
            playAverse() {
                this.ensureInit();
                if (this.muted) return;

                // Pluie moins dense et plus douce
                const rain = this.ctx.createBufferSource();
                const rainBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 8, this.ctx.sampleRate);
                const rainData = rainBuffer.getChannelData(0);

                for (let i = 0; i < rainBuffer.length; i++) {
                    const t = i / rainBuffer.length;
                    const modulation = Math.sin(t * Math.PI * 2) * 0.3 + 0.7;
                    if (Math.random() < 0.3) { // Moins dense
                        rainData[i] = (Math.random() * 2 - 1) * 0.2 * modulation;
                    }
                }

                rain.buffer = rainBuffer;

                const rainFilter = this.ctx.createBiquadFilter();
                rainFilter.type = 'bandpass';
                rainFilter.frequency.value = 3000;
                rainFilter.Q.value = 1;

                const rainGain = this.ctx.createGain();
                rainGain.gain.setValueAtTime(0, this.ctx.currentTime);
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, this.ctx.currentTime + 0.5); // Montée plus lente
                rainGain.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.ctx.currentTime + 4); // Volume réduit
                rainGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8); // Fade out 4s

                rain.connect(rainFilter);
                rainFilter.connect(rainGain);
                rainGain.connect(this.ctx.destination);

                rain.start();
            },

            // Son d'étincelle magique légère (corbeau/power-up)
            playSparkle() {
                this.ensureInit();
                if (this.muted) return;

                // Étincelle principale - montée rapide
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();

                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(2400, this.ctx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(3600, this.ctx.currentTime + 0.08);
                osc1.frequency.exponentialRampToValueAtTime(1800, this.ctx.currentTime + 0.2);

                gain1.gain.setValueAtTime(0, this.ctx.currentTime);
                gain1.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.ctx.currentTime + 0.04);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);

                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);

                osc1.start();
                osc1.stop(this.ctx.currentTime + 0.2);

                // 2 micro-étincelles en cascade
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const sparkle = this.ctx.createOscillator();
                        const sparkleGain = this.ctx.createGain();

                        sparkle.type = 'sine';
                        sparkle.frequency.value = 3000 + Math.random() * 800;

                        sparkleGain.gain.setValueAtTime(0, this.ctx.currentTime);
                        sparkleGain.gain.linearRampToValueAtTime(this.masterVolume * 0.08, this.ctx.currentTime + 0.02);
                        sparkleGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);

                        sparkle.connect(sparkleGain);
                        sparkleGain.connect(this.ctx.destination);

                        sparkle.start();
                        sparkle.stop(this.ctx.currentTime + 0.12);
                    }, 80 + i * 50);
                }
            },

            // Son de feu d'artifice RÉALISTE 🎆 - WOUUUCHE... PAF!
            playFirework() {
                this.ensureInit();
                if (this.muted) return;

                const now = this.ctx.currentTime;

                // 1. WOUUUCHE - Sifflement de fusée qui monte (bruit blanc modulé)
                const riseNoise = this.ctx.createBufferSource();
                const riseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.7, this.ctx.sampleRate);
                const riseData = riseBuffer.getChannelData(0);
                
                // Bruit blanc avec enveloppe montante
                for (let i = 0; i < riseBuffer.length; i++) {
                    const t = i / riseBuffer.length;
                    const envelope = Math.pow(t, 0.5) * Math.exp(-t * 1.5); // Monte puis diminue
                    riseData[i] = (Math.random() * 2 - 1) * envelope * 0.8;
                }
                riseNoise.buffer = riseBuffer;
                
                // Filtre qui monte pour le sifflement
                const riseFilter = this.ctx.createBiquadFilter();
                riseFilter.type = 'bandpass';
                riseFilter.frequency.setValueAtTime(300, now);
                riseFilter.frequency.exponentialRampToValueAtTime(1200, now + 0.6);
                riseFilter.Q.value = 8; // Filtre étroit pour le sifflement
                
                const riseGain = this.ctx.createGain();
                riseGain.gain.setValueAtTime(0, now);
                riseGain.gain.linearRampToValueAtTime(this.masterVolume * 0.8, now + 0.1); // Plus fort : 0.3 → 0.8
                riseGain.gain.linearRampToValueAtTime(this.masterVolume * 0.9, now + 0.5); // Plus fort : 0.35 → 0.9
                riseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
                
                riseNoise.connect(riseFilter);
                riseFilter.connect(riseGain);
                riseGain.connect(this.ctx.destination);
                
                riseNoise.start(now);
                riseNoise.stop(now + 0.7);

                // 2. PAF! - Explosion massive et grave
                setTimeout(() => {
                    // Choc initial très grave (sub-bass)
                    const subBass = this.ctx.createOscillator();
                    const subGain = this.ctx.createGain();
                    
                    subBass.type = 'sine';
                    subBass.frequency.setValueAtTime(50, this.ctx.currentTime);
                    subBass.frequency.exponentialRampToValueAtTime(25, this.ctx.currentTime + 0.15);
                    
                    subGain.gain.setValueAtTime(0, this.ctx.currentTime);
                    subGain.gain.linearRampToValueAtTime(this.masterVolume * 1.2, this.ctx.currentTime + 0.01); // Plus fort : 0.7 → 1.2 (attaque ultra rapide)
                    subGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                    
                    subBass.connect(subGain);
                    subGain.connect(this.ctx.destination);
                    
                    subBass.start();
                    subBass.stop(this.ctx.currentTime + 0.5);

                    // Explosion (bruit blanc grave)
                    const boom = this.ctx.createBufferSource();
                    const boomBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.8, this.ctx.sampleRate);
                    const boomData = boomBuffer.getChannelData(0);
                    
                    for (let i = 0; i < boomBuffer.length; i++) {
                        const t = i / boomBuffer.length;
                        const envelope = Math.exp(-t * 5); // Déclin rapide
                        boomData[i] = (Math.random() * 2 - 1) * envelope;
                    }
                    boom.buffer = boomBuffer;
                    
                    const boomFilter = this.ctx.createBiquadFilter();
                    boomFilter.type = 'lowpass';
                    boomFilter.frequency.setValueAtTime(300, this.ctx.currentTime);
                    boomFilter.frequency.exponentialRampToValueAtTime(150, this.ctx.currentTime + 0.3);
                    
                    const boomGain = this.ctx.createGain();
                    boomGain.gain.setValueAtTime(this.masterVolume * 1.0, this.ctx.currentTime); // Plus fort : 0.5 → 1.0
                    boomGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
                    
                    boom.connect(boomFilter);
                    boomFilter.connect(boomGain);
                    boomGain.connect(this.ctx.destination);
                    
                    boom.start();
                    
                    // Résonance post-explosion
                    const rumble = this.ctx.createOscillator();
                    const rumbleGain = this.ctx.createGain();
                    
                    rumble.type = 'sine';
                    rumble.frequency.setValueAtTime(40, this.ctx.currentTime + 0.1);
                    rumble.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.6);
                    
                    rumbleGain.gain.setValueAtTime(0, this.ctx.currentTime + 0.1);
                    rumbleGain.gain.linearRampToValueAtTime(this.masterVolume * 0.5, this.ctx.currentTime + 0.15); // Plus fort : 0.2 → 0.5
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.7);
                    
                    rumble.connect(rumbleGain);
                    rumbleGain.connect(this.ctx.destination);
                    
                    rumble.start(this.ctx.currentTime + 0.1);
                    rumble.stop(this.ctx.currentTime + 0.7);
                }, 700);
            },

            toggleMute() {
                this.muted = !this.muted;
                return this.muted;
            }
        };

        // L'audio s'initialise automatiquement au premier son joué

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;

        // Sélecteur de langue au démarrage - BLOQUE LE JEU
        // Si langue déjà choisie (dans localStorage), on skip le sélecteur
        const langueDejaChoisie = localStorage.getItem('petit_bateau_lang') !== null;

        let languageSelector = {
            active: false, // DÉSACTIVÉ - Le nouveau système dans l'onglet langues le remplace
            menuOpen: false, 
            languageChosen: true, // True pour démarrer directement le jeu
            iconButton: {
                x: C.W - 60, 
                y: C.H - 60,
                radius: 25,
                hover: false
            },
            buttons: [
                { code: 'fr', drapeau: '🇫🇷', nom: 'Français' },
                { code: 'en', drapeau: '🇬🇧', nom: 'English' },
                { code: 'es', drapeau: '🇪🇸', nom: 'Español' },
                { code: 'de', drapeau: '🇩🇪', nom: 'Deutsch' },
                { code: 'it', drapeau: '🇮🇹', nom: 'Italiano' },
                { code: 'pt', drapeau: '🇵🇹', nom: 'Português' },
                { code: 'ru', drapeau: '🇷🇺', nom: 'Русский' },
                { code: 'uk', drapeau: '🇺🇦', nom: 'Українська' },
                { code: 'zh', drapeau: '🇨🇳', nom: '中文' },
                { code: 'jp', drapeau: '🇯🇵', nom: '日本語' },
                { code: 'ko', drapeau: '🇰🇷', nom: '한국어' },
                { code: 'rc', drapeau: '🇷🇪', nom: 'Kréol Rényoné' },
                { code: 'lg', drapeau: '🇨🇩', nom: 'Lingala' },
                { code: 'ar', drapeau: '🇸🇦', nom: 'العربية' },
                { code: 'he', drapeau: '🇮🇱', nom: 'עברית' }
            ]
        };

        // 🌍 MINI-JEU "BRISER LES FRONTIÈRES" - Système indépendant
        let briqueLangue = {
            active: false,
            game: null
        };

        // Rendre score accessible globalement pour les modules
        window.score = score;
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (value) => { score = value; }
        });
        let titreVoyage = { active: false, texte: '', fin: 0 }; // Affichage titre voyage
        let raquette = {}, balle = {}, briques = [], particules = [];
        
        // 🚀 SYSTÈME DE GRILLE SPATIALE POUR OPTIMISATION DES COLLISIONS
        let grilleCollision = {
            tailleCellule: 100, // Taille d'une cellule en pixels
            grille: new Map(), // Map des cellules (key: "x,y", value: Set de briques)
            
            // Obtenir la clé de cellule pour une position
            obtenirCle(x, y) {
                const cellX = Math.floor(x / this.tailleCellule);
                const cellY = Math.floor(y / this.tailleCellule);
                return `${cellX},${cellY}`;
            },
            
            // Ajouter une brique à la grille
            ajouterBrique(brique) {
                if (!brique.visible) return;
                
                // Calculer toutes les cellules que touche la brique
                const minX = Math.floor(brique.x / this.tailleCellule);
                const maxX = Math.floor((brique.x + brique.w) / this.tailleCellule);
                const minY = Math.floor(brique.y / this.tailleCellule);
                const maxY = Math.floor((brique.y + brique.h) / this.tailleCellule);
                
                for (let cellX = minX; cellX <= maxX; cellX++) {
                    for (let cellY = minY; cellY <= maxY; cellY++) {
                        const cle = `${cellX},${cellY}`;
                        if (!this.grille.has(cle)) {
                            this.grille.set(cle, new Set());
                        }
                        this.grille.get(cle).add(brique);
                    }
                }
            },
            
            // Supprimer une brique de la grille
            supprimerBrique(brique) {
                for (const [cle, cellule] of this.grille) {
                    cellule.delete(brique);
                    if (cellule.size === 0) {
                        this.grille.delete(cle);
                    }
                }
            },
            
            // Obtenir les briques candidates pour collision avec la balle
            obtenirCandidates(balleX, balleY, rayon) {
                const candidates = new Set();
                
                // Calculer les cellules à vérifier (position balle ± rayon)
                const minX = Math.floor((balleX - rayon) / this.tailleCellule);
                const maxX = Math.floor((balleX + rayon) / this.tailleCellule);
                const minY = Math.floor((balleY - rayon) / this.tailleCellule);
                const maxY = Math.floor((balleY + rayon) / this.tailleCellule);
                
                for (let cellX = minX; cellX <= maxX; cellX++) {
                    for (let cellY = minY; cellY <= maxY; cellY++) {
                        const cle = `${cellX},${cellY}`;
                        const cellule = this.grille.get(cle);
                        if (cellule) {
                            cellule.forEach(brique => {
                                if (brique.visible) candidates.add(brique);
                            });
                        }
                    }
                }
                
                return Array.from(candidates);
            },
            
            // Reconstruire complètement la grille (après changement de phase)
            reconstruire() {
                this.grille.clear();
                briques.forEach(brique => this.ajouterBrique(brique));
            }
        };
        
        // 🔧 Fonction helper pour s'assurer que la grille est mise à jour
        function mettreAJourGrilleSpatiale() {
            if (typeof grilleCollision !== 'undefined') {
                grilleCollision.reconstruire();
            }
        }
        
        let starsProjectiles = []; // Projectiles étoiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles étoiles (phase briques) - commence à 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let laserState = { lastFired: 0, active: false, startTime: 0, duration: 1000 }; // État du laser phase 23
        let coeursBateau = []; // Cœurs lancés par le bateau
        let derniereCreeRafale = 0; // Temps de la dernière rafale
        let petitsCoeurs = []; // Petits cœurs décoratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause après explosion
        let textesVolants = []; // Textes qui montent au ciel
        let gouttesPlui = []; // Gouttes de pluie pour phase 5
        let pluieActive = false; // État de la pluie
        let corbeau = { actif: false, x: 0, y: 0, vx: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000, direction: 1 }; // Corbeau secret (10s pour test)

        // Système de chauve-souris révélée par la lanterne
        let chauveSouris = {
            revelee: false,
            x: 0, y: 0,
            vx: 0, vy: 0,
            active: false,
            tempApparition: 0,
            dureeVie: 5000, // 5 secondes
            collectee: false
        };

        // ⚡ OPTIMISATION: Cache temporel pour chauve-souris (même pattern que drones)
        let chauveSourisCache = {
            frameTime: 0,
            sinValue: 0,
            battement: 0,
            lastUpdate: 0
        };

        // ⚡ OPTIMISATION: Fonction pour mettre à jour le cache chauve-souris
        function updateChauveSourisCache() {
            const now = Date.now();
            // Throttle à 60 FPS (16ms)
            if (now - chauveSourisCache.lastUpdate < 16) return;
            
            chauveSourisCache.frameTime = now;
            chauveSourisCache.sinValue = Math.sin(now * 0.01);
            chauveSourisCache.battement = Math.sin(now * 0.008) * 0.2;
            chauveSourisCache.lastUpdate = now;
        }

        // Animation de l'icône vers le menu énigmes
        let animationIconeMenu = {
            active: false,
            startX: 0, startY: 0,
            targetX: 0, targetY: 0,
            currentX: 0, currentY: 0,
            progress: 0,
            duree: 1500, // 1.5 secondes
            startTime: 0,
            icone: '',
            easing: function(t) {
                // Easing out cubic pour un effet naturel
                return 1 - Math.pow(1 - t, 3);
            }
        };
        let soleil = { clignotement: false, tempsClignotement: 0 }; // État du soleil
        let multiplicateurPuissance = 1; // Cheat code x10 puissance
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition

        // ⚡ OPTIMISATION FOND ANIMÉ - Cache gradients et throttling
        const fondAniméCache = {
            // Gradients mis en cache
            gradients: {
                merJour: null,
                merNuit: null,
                haloLune: null,
                soleilCouchant: null,
                haloSoleilCouchant: null,
                refletSoleil: null,
                languageSelector: null, // Gradient sélecteur langue
                // ⚡ NOUVEAUX: Gradients fond principal
                fondFinale: null,
                fondJour: null,
                fondNuit: null
            },
            // Throttling des vagues
            lastWaveFrame: 0,
            waveThrottle: 2, // Calculer les vagues tous les 2 frames
            wavesPath: null, // Path2D pour les vagues
            // Throttling des requins
            lastSharkFrame: 0,
            sharkThrottle: 3, // Mettre à jour les requins tous les 3 frames
            sharkPositions: [],
            // Throttling des rayons du soleil
            lastSunRaysFrame: 0,
            sunRaysThrottle: 2,
            sunRaysAngles: [],
            // Throttling vagues sélecteur langue
            lastLanguageWaveFrame: 0,
            languageWaveThrottle: 2, // Calculer les vagues tous les 2 frames (30 FPS)
            languageWavesPath: [],
            // Frame counter
            frameCount: 0
        };

        // Fonction pour initialiser les gradients (appelée une fois ou quand période change)
        function initGradientsMer() {
            const merY = C.H - 60;
            
            // Gradient mer jour
            fondAniméCache.gradients.merJour = ctx.createLinearGradient(0, merY, 0, C.H);
            fondAniméCache.gradients.merJour.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
            fondAniméCache.gradients.merJour.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
            fondAniméCache.gradients.merJour.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            
            // Gradient mer nuit
            fondAniméCache.gradients.merNuit = ctx.createLinearGradient(0, merY, 0, C.H);
            fondAniméCache.gradients.merNuit.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
            fondAniméCache.gradients.merNuit.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
            fondAniméCache.gradients.merNuit.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
        }

        function initGradientsSoleilCouchant() {
            const soleilX = C.W * 0.75;
            const merY = C.H - 60;
            const soleilY = merY + 10;
            const rayonSoleil = 60;
            
            // Halo soleil couchant
            fondAniméCache.gradients.haloSoleilCouchant = ctx.createRadialGradient(soleilX, soleilY, 0, soleilX, soleilY, rayonSoleil * 3);
            fondAniméCache.gradients.haloSoleilCouchant.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
            fondAniméCache.gradients.haloSoleilCouchant.addColorStop(0.3, 'rgba(255, 150, 80, 0.2)');
            fondAniméCache.gradients.haloSoleilCouchant.addColorStop(0.7, 'rgba(255, 100, 50, 0.1)');
            fondAniméCache.gradients.haloSoleilCouchant.addColorStop(1, 'rgba(255, 100, 50, 0)');
            
            // Soleil couchant
            fondAniméCache.gradients.soleilCouchant = ctx.createRadialGradient(soleilX, soleilY, 0, soleilX, soleilY, rayonSoleil);
            fondAniméCache.gradients.soleilCouchant.addColorStop(0, '#FFFACD');
            fondAniméCache.gradients.soleilCouchant.addColorStop(0.4, '#FFD700');
            fondAniméCache.gradients.soleilCouchant.addColorStop(0.8, '#FF8C00');
            fondAniméCache.gradients.soleilCouchant.addColorStop(1, '#FF6347');
            
            // Reflet
            fondAniméCache.gradients.refletSoleil = ctx.createLinearGradient(soleilX, merY, soleilX, C.H);
            fondAniméCache.gradients.refletSoleil.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
            fondAniméCache.gradients.refletSoleil.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
            fondAniméCache.gradients.refletSoleil.addColorStop(1, 'rgba(255, 100, 0, 0)');
        }

        // ⚡ OPTIMISATION: Initialiser gradients fond principal
        function initGradientsFond() {
            // ⚡ OPTIMISATION #2 : Cache global pour tous les gradients principaux
            // Évite de recréer les gradients à chaque frame (très coûteux)
            
            // Gradient finale (coucher de soleil)
            fondAniméCache.gradients.fondFinale = ctx.createLinearGradient(0, 0, 0, C.H);
            fondAniméCache.gradients.fondFinale.addColorStop(0, '#FFB347'); // Orange doux en haut
            fondAniméCache.gradients.fondFinale.addColorStop(0.3, '#FF8C69'); // Orange saumon
            fondAniméCache.gradients.fondFinale.addColorStop(0.6, '#FF6B9D'); // Rose-corail
            fondAniméCache.gradients.fondFinale.addColorStop(1, '#4A90E2'); // Bleu ciel en bas
            
            // Gradient jour (ciel diurne)
            fondAniméCache.gradients.fondJour = ctx.createLinearGradient(0, 0, 0, C.H);
            fondAniméCache.gradients.fondJour.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
            fondAniméCache.gradients.fondJour.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
            fondAniméCache.gradients.fondJour.addColorStop(1, 'rgba(240,248,255,0.98)');
            
            // Gradient nuit (ciel nocturne orageux)
            fondAniméCache.gradients.fondNuit = ctx.createLinearGradient(0, 0, 0, C.H);
            fondAniméCache.gradients.fondNuit.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
            fondAniméCache.gradients.fondNuit.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
            fondAniméCache.gradients.fondNuit.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
        }

        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let secretModeModule = null; // Module mode secret
        let musicManager = null; // Gestionnaire de musique gospel
        // let kawaiiObjectsModule = null; // SUPPRIMÉ - utilisation via module secret seulement
        let modeNarration = true; // Mode narration actif au début
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Système de messages narratifs
        let periode = 'jour'; // Période actuelle : 'jour' ou 'nuit'
        let transitionPeriode = { active: false, progression: 0 };
        
        // 🔥 Phase intro : INITIALISÉE À NULL - sera configurée dans le load event
        let phaseIntro = null; // Initialisée plus tard pour éviter les races conditions
        
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de cœurs vers les petits cœurs du haut (phase d'éveil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'étoiles vers les briques en mode nuit (phase de révélation)
         * 4. 'feux_artifice' : Célébration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: langueDejaChoisie, // Actif si langue déjà choisie
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: langueDejaChoisie ? Date.now() : 0,
            dureeArret: 20000 // 20 secondes d'arrêt
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.001, 0.8); // Vitesse balle modérée

            // Les objets kawaii seront activés après l'animation d'intro
            // activerObjetsKawaii(); // Trop tôt, on attend la fin de l'intro

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 38,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Initialiser les gestionnaires d'événements des oiseaux CSS
            setupBirdClickHandlers();

            // Initialiser le module mode secret
            initSecretModeModule();

            // Initialiser le gestionnaire de musique
            initMusicManager();

            // Les objets kawaii sont maintenant gérés par le module secret seulement

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors écran à gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = Date.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            
            // Conserver les munitions pour phases mur 17-21 (mode tir MUR)
            // Phase 22 utilise balle normale donc munitions = 0
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const estPhaseMur17_21 = phaseActuelle >= 17 && phaseActuelle <= 21 && phaseJeu === 'mur';
            const munitionsAvant = munitions;
            
            // 🔫 NE PAS réinitialiser les munitions si on restaure une sauvegarde
            if (window.isRestoringGame) {
                console.log(`🔫 initJeu() - Restauration: munitions conservées (${munitions})`);
            } else if (!estPhaseMur17_21) {
                munitions = 0; // Commencer sans munitions (sauf phases mur 17-21)
                console.log(`🔫 initJeu() - Phase ${phaseActuelle} (${phaseJeu}): munitions ${munitionsAvant} → 0 (normal)`);
            } else {
                console.log(`🔫 initJeu() - Phase ${phaseActuelle} (${phaseJeu}): munitions ${munitionsAvant} → CONSERVÉES (mode mur 17-21)`);
            }
            // Si phase 17-21, garder les munitions (ne pas réinitialiser à 0)
            
            rechargement = 0;

            briques = [];

            // Créer les briques si on est en phase stars (nuit) - FORCÉ
            if(phaseJeu === 'stars') {
                // FORCER l'arrêt de tous les systèmes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                // Introduction terminée

                // Les objets kawaii sont réservés au mode secret seulement
                // activerObjetsKawaii(); // SUPPRIMÉ - uniquement pour mode secret

                // FORCER la création des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Créer
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
                
                // 🚀 OPTIMISATION : Reconstruire la grille spatiale après création des briques
                grilleCollision.reconstruire();
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les cœurs
            const zoneW = C.W - 40;

            // Positions dispersées et tailles différentes pour chaque cœur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront créées à partir des petits cœurs du haut
            // Initialisation vide, elles apparaîtront lors du dédoublement des cœurs
            briques = [];
            particules = [];
            powerUps = [];
            // Garder l'état de la lanterne pendant initJeu() - ne pas la remettre à zéro
            // lanterne conserve son état précédent
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propriétés selon la phase
            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au début
                    dy: 0, // Immobile au début
                    visible: true, // Visible en phase lanterne/mur
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles étoiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Créer les 10 petits cœurs décoratifs en haut (seulement en mode coeurs)
            if(phaseJeu !== 'lanterne' && phaseJeu !== 'stars') {
                creerPetitsCoeurs();
            }

            // Cacher les cœurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'étoile principale - utiliser les projectiles stars

            // Réinitialiser la phase d'intro (activée après l'animation du bateau)
            // 🔥 SAUF si on restaure une sauvegarde OU si la narration a déjà été démarrée OU si on skip l'intro
            if (phaseIntro && (window.isRestoringGame || window.narrationStarted || window.skipIntroAnimation)) {
                // Garder phaseIntro tel quel (déjà initialisé dans le load event)
                console.log('🔄 Restauration/narration/skip active: conservation de phaseIntro', phaseIntro);
            } else if (!phaseIntro || (!window.isRestoringGame && !window.narrationStarted && !window.skipIntroAnimation)) {
                // Créer ou réinitialiser l'intro
                phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
            }
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (!animationBateau.active) return;

            const tempsActuel = Date.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arrivée depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arrivée fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arrivé au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // Intro déjà gérée par gererPhaseIntro()
                        // narrationManager.start();
                    }
                    break;

                case 'arret':
                    // Bateau arrêté, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de départ vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'écran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation terminée, démarrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        // Introduction terminée // Phase de jeu

                        // Les objets kawaii sont réservés au mode secret seulement
                        // activerObjetsKawaii(); // SUPPRIMÉ - uniquement pour mode secret

                        // Repositionner le bateau normalement et démarrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;
                        jeu = true; // Activer le jeu
                        phaseJeu = 'tir_coeurs_haut'; // Commencer par la première phase

                        // Révéler les petits cœurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre à jour l'étoile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            // 🔥 PROTECTION: Si phaseIntro n'est pas encore initialisé, ne rien faire
            if (!phaseIntro) {
                // Log silencieux - normal avant le load event
                return;
            }
            
            // 🔍 DEBUG: Log de l'état de l'intro (une fois seulement)
            if (!window.introStateLogged && phaseIntro.active) {
                window.introStateLogged = true;
                console.log('🎬 État de l\'intro:', {
                    active: phaseIntro.active,
                    etape: phaseIntro.etape,
                    isRestoringGame: window.isRestoringGame,
                    skipNarrationIntro: window.skipNarrationIntro,
                    narrationStarted: window.narrationStarted
                });
            }
            
            if (!phaseIntro.active) {
                // Intro terminée - comportement normal
                return;
            }
            
            // 🔥 Ne pas démarrer l'intro si on restaure une sauvegarde
            if (window.isRestoringGame || window.skipNarrationIntro) {
                console.log('🔄 Skip intro demandé - DÉSACTIVATION');
                phaseIntro.active = false;
                jeu = true;
                return;
            }
            
            // 🔥 Ne pas démarrer l'intro si la narration a déjà été démarrée (sauvegarde chargée)
            if (window.narrationStarted) {
                console.log('📖 Narration déjà active: skip intro');
                phaseIntro.active = false;
                jeu = true;
                return;
            }

            const tempsEcoule = Date.now() - phaseIntro.tempsDebut;
            // Log désactivé : gererPhaseIntro

            if (phaseIntro.etape === 'arrivee_bateau') {
                // Phase d'introduction: Démarrer l'intro très rapidement
                if (tempsEcoule >= 200) { // Réduire à 0.2 seconde
                    // Démarrer le système narratif avec la première phase (une seule fois)
                    if (narrationManager && !window.narrationStarted) {
                        window.narrationStarted = true; // Marquer comme déjà démarré

                        // Attendre les traductions avant de démarrer
                        (async () => {
                            if (window.translationsReady) {
                                await window.translationsReady;
                            }

                            // Forcer l'affichage de l'intro immédiatement
                            if (narrationManager.narrativeData && narrationManager.narrativeData.phases) {
                                narrationManager.start();
                            } else {

                            // Utiliser notre système simple unifié
                            afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.intro_full', "On m'a dit qu'ils étaient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai préféré aller voir\nde mes propres yeux..."), 12000);

                            // Activer le bouton passer pendant l'intro
                            boutonPasser.actif = true;

                            // Désactiver le bouton après l'intro
                            setTimeout(() => {
                                boutonPasser.actif = false;
                            }, 12000);
                            }
                        })(); // Fin fonction async
                    }
                    phaseIntro.etape = 'rafales';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'rafales') {
                // Phase 1: Réduire l'attente pour un flux plus rapide
                if (tempsEcoule >= 1000) { // Réduire de 2s à 1s
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                console.log('🎬 Phase apparition_balle - temps écoulé:', tempsEcoule);
                if (tempsEcoule >= 1000) {
                    console.log('🎬 Fin intro - démarrage jeu et préparation musique');
                    phaseIntro.active = false;
                    jeu = true; // Démarrer le jeu

                    // 🎬 DÉMARRER LA NARRATION APRÈS L'INTRO
                    // 🔥 Mais PAS si on a restauré une sauvegarde
                    if (narrationManager && narrationManager.currentPhase === 0 && !window.narrationStarted) {
                        window.narrationStarted = true;
                        (async () => {
                            if (window.translationsReady) {
                                await window.translationsReady;
                            }
                            narrationManager.start();
                        })();
                    }

                    // 🎵 Préparer le démarrage de la musique au prochain clic
                    console.log('🎵 Début section préparation musique - musicManager existe:', !!musicManager);
                    if (musicManager) {
                        console.log('🎵 État musicManager:', {
                            isPlaying: musicManager.isPlaying,
                            isMuted: musicManager.isMuted,
                            audioContextInitialized: musicManager.audioContextInitialized
                        });
                        
                        if (!musicManager.isPlaying) {
                            console.log('🎵 Musique prête à démarrer');
                            window.musicReadyToStart = true;
                            
                            // Timer automatique supprimé - Musique démarrera au premier clic
                            console.log('🎵 Musique prête - démarrera au premier clic utilisateur');
                            window.musicReadyToStart = true;
                        } else {
                            console.log('🎵 Musique déjà active');
                        }
                    } else {
                        console.log('🎵 MusicManager non trouvé');
                    }

                    // Ne pas forcer le mode - conserver le mode déjà configuré par narrationManager
                    // Message géré par le nouveau système narratif
                }
            }
        }

        // Interface intégrée complète
        function dessinerInterface() {
            ctx.save();

            // Header optimisé très compact - bleu roi
            const headerH = Math.max(C.H * 0.045, 32);
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.fillRect(0, 0, C.W, headerH);

            // Lignes ondulées en fond transparent blanc
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const waveY = headerH * (0.2 + i * 0.3);
                const waveLength = C.W / 8;
                for(let x = 0; x <= C.W; x += 10) {
                    const y = waveY + Math.sin((x / waveLength) * Math.PI * 2) * 3;
                    if(x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();

            // Bordure header
            ctx.strokeStyle = '#3b82f6'; // Bordure bleu plus clair
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre centré en hauteur
            const titleY = headerH / 2 + 4; // Centré verticalement dans le header
            const iconSize = Math.max(C.H * 0.008, 8); // Très petits bateaux

            ctx.save();
            // Titre moderne et plus gros
            ctx.fillStyle = '#ffffff';
            ctx.font = `800 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = '2px';
            
            const titleText = getTranslatedText('ui.game_title', 'PETIT BATEAU');
            ctx.fillText(titleText, C.W/2, titleY);

            // Calculer la largeur du texte pour positionner les bateaux
            const titleWidth = ctx.measureText(titleText).width;
            const boatPadding = 15; // Espace entre le texte et les bateaux
            
            // Très petits bateaux discrets - positionnés selon la largeur du texte
            const leftBoatX = C.W/2 - titleWidth/2 - boatPadding;
            const rightBoatX = C.W/2 + titleWidth/2 + boatPadding;
            drawBoatIcon(ctx, leftBoatX, titleY - iconSize, iconSize, 'red');
            drawBoatIcon(ctx, rightBoatX, titleY - iconSize, iconSize, 'blue');

            // Menu HOME supprimé

            ctx.restore();

            // Afficher le titre du voyage si actif
            if (titreVoyage.active && Date.now() < titreVoyage.fin) {
                const voyageY = Math.max(C.H * 0.10, 70); // Très légèrement plus bas
                ctx.save();

                // Style moderne avec blanc et ombres
                ctx.fillStyle = '#ffffff';
                ctx.font = `700 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', system-ui, sans-serif`;
                ctx.textAlign = 'center';

                // Ombres multiples pour effet profondeur
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 8;

                // Séparer le nom du voyage et la phase
                const lignes = titreVoyage.texte.split('\n');
                const voyageNom = lignes[0];
                const phaseTexte = lignes[1] || '';

                const voyageLabel = getTranslatedText('game.phase_display.voyage', 'Voyage');

                // Première ombre (arrière) pour le titre voyage
                ctx.fillText(`🗺️ ${voyageLabel} — ${voyageNom}`, C.W/2, voyageY);

                // Deuxième couche avec ombre plus subtile pour le titre
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 4;
                ctx.fillText(`🗺️ ${voyageLabel} — ${voyageNom}`, C.W/2, voyageY);

                // Sous-titre phase masqué - déjà affiché dans le header
                // if (phaseTexte) {
                //     ctx.font = `600 ${Math.max(C.H * 0.018, 16)}px 'Segoe UI', system-ui, sans-serif`;
                //     ctx.fillStyle = '#ffffff';
                //     ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                //     ctx.shadowOffsetX = 2;
                //     ctx.shadowOffsetY = 2;
                //     ctx.shadowBlur = 6;
                //     ctx.fillText(phaseTexte, C.W/2, voyageY + Math.max(C.H * 0.035, 28));
                // }

                ctx.restore();
            } else if (titreVoyage.active && Date.now() >= titreVoyage.fin) {
                titreVoyage.active = false; // Désactiver après 4 secondes
            }

            // Stats ligne avec fond blanc plus près du header
            const statsY = Math.max(C.H * 0.045, 30); // Beaucoup plus près du header
            const padding = 8;
            const bgHeight = Math.max(C.H * 0.025, 20);

            // Fond blanc pour toute la barre de stats
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, statsY - bgHeight/2, C.W, bgHeight);

            // Bordure subtile
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, statsY - bgHeight/2, C.W, bgHeight);

            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points XP avec indicateur de langue - centré verticalement dans la barre
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const languageFlag = getCurrentLanguageFlag();
            
            // Effet de survol simple et sûr sur le drapeau
            if (flagHoverAnimation > 0) {
                // Interpolation pour l'animation
                const alpha = flagHoverAnimation;
                
                const x = 8, y = statsY - 16, w = 134, h = 32;
                const radius = 6;
                
                // Rectangle de fond simple avec transparence animée
                ctx.fillStyle = `rgba(74, 144, 226, ${alpha * 0.2})`;
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                ctx.fill();
                
                // Bordure subtile
                ctx.strokeStyle = `rgba(74, 144, 226, ${alpha * 0.4})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Texte avec transition de couleur simple
                const r = Math.round(44 + (74 - 44) * alpha);  // Vers un bleu foncé
                const g = Math.round(62 + (144 - 62) * alpha);
                const b = Math.round(80 + (226 - 80) * alpha);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            } else {
                // État normal
                ctx.fillStyle = '#2c3e50';
            }
            
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`${languageFlag} | ⭐ XP: ${pointsConnaissance}`, 15, statsY);
            } else {
                ctx.fillText(`${languageFlag} | 🕊️ ${score}`, 15, statsY);
            }
            
            // IMPORTANT : Réinitialiser immédiatement l'ombre après le texte du drapeau
            ctx.shadowColor = 'transparent';
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;

            // Progression avec voyage et phase
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            ctx.fillStyle = '#2c3e50'; // S'assurer que la couleur est correcte pour la phase
            let phaseInfo = '';
            if (narrationManager && narrationManager.currentPhase) {
                const phase = narrationManager.currentPhase; // Phase 1 = intro simple
                let voyageIcon = '';
                let voyageName = '';

                if (phase === 1) {
                    voyageIcon = '🌅'; voyageName = getTranslatedText('game.voyage_names.dawn_of_doubts', 'L\'aube des doutes');
                } else if (phase === 2) {
                    voyageIcon = '☀️'; voyageName = getTranslatedText('game.voyage_names.light', 'La lumière');
                } else if (phase >= 3 && phase <= 4) {
                    voyageIcon = '☁️'; voyageName = getTranslatedText('game.voyage_names.shadow_of_clouds', 'L\'ombre des nuages');
                } else if (phase >= 5 && phase <= 6) {
                    voyageIcon = '🤫'; voyageName = getTranslatedText('game.voyage_names.silence_of_soul', 'Le silence de l\'âme');
                } else if (phase >= 7 && phase <= 9) {
                    voyageIcon = '❤️'; voyageName = getTranslatedText('game.voyage_names.humanity_of_hearts', 'L\'humanité des cœurs');
                } else if (phase >= 10 && phase <= 12) {
                    voyageIcon = '🧠'; voyageName = getTranslatedText('game.voyage_names.wisdom_of_differences', 'La sagesse des différences');
                } else if (phase >= 13 && phase <= 15) {
                    voyageIcon = '🌍'; voyageName = getTranslatedText('game.voyage_names.unity', 'L\'unité');
                } else if (phase === 16) {
                    voyageIcon = '🎆'; voyageName = getTranslatedText('game.voyage_names.unity_of_humanity', 'L\'Unité de l\'Humanité');
                } else if (phase >= 17 && phase <= 22) {
                    voyageIcon = '🧱'; voyageName = getTranslatedText('game.voyage_names.wall_of_greed', 'Le Mur d\'avarice');
                } else {
                    voyageIcon = '🗺️'; voyageName = getTranslatedText('game.voyage_names.default', 'Voyage');
                }

                const phaseLabel = getTranslatedText('game.phase_display.phase_counter', 'Phase');
                phaseInfo = `🗺️ ${phaseLabel} ${phase}/23`;
            } else {
                phaseInfo = `🧱 ${brises}/${VOYAGE.length}`;
            }
            ctx.fillText(phaseInfo, C.W/2, statsY);

            // Vies
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const coeurs = vies > 0 ? '❤️'.repeat(vies) : '💔';
            ctx.fillText(coeurs, C.W - 15, statsY);

            // Affichage des commandes mode passe désactivé
            /*
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                '🔑 MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir étoiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();
            */

            ctx.restore();
        }

        // Tirer un projectile étoile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // ⚡ CACHE: Gradients des projectiles stars (créés 1 fois au lieu de 60fps × N projectiles)
        let starsGradientsCache = {
            trainee: null,
            halo: null,
            etoile: null,
            lastSize: 0
        };

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars, feux_artifice ET lanterne (pour Poxerstart)
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice' && phaseJeu !== 'lanterne') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation étoile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de déplacement pour la traînée
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Traînée d'étoile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // ⚡ CACHE: Gradient de la traînée (créé 1 fois)
                if (!starsGradientsCache.trainee || starsGradientsCache.lastSize !== rayonEtoile) {
                    starsGradientsCache.trainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                    starsGradientsCache.trainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                    starsGradientsCache.trainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                    starsGradientsCache.trainee.addColorStop(1, '#FFD700');
                }

                // Dessiner la traînée
                ctx.fillStyle = starsGradientsCache.trainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'étoile elle-même
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // Étoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // ⚡ CACHE: Halo lumineux (créé 1 fois)
                    if (!starsGradientsCache.halo || starsGradientsCache.lastSize !== rayonEtoile) {
                        starsGradientsCache.halo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                        starsGradientsCache.halo.addColorStop(0, '#FFD700');
                        starsGradientsCache.halo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                        starsGradientsCache.halo.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    }

                    ctx.fillStyle = starsGradientsCache.halo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // ⚡ CACHE: Étoile centrale brillante (créé 1 fois)
                    if (!starsGradientsCache.etoile || starsGradientsCache.lastSize !== rayonEtoile) {
                        starsGradientsCache.etoile = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                        starsGradientsCache.etoile.addColorStop(0, '#FFFFFF');
                        starsGradientsCache.etoile.addColorStop(0.3, '#FFD700');
                        starsGradientsCache.etoile.addColorStop(1, 'rgba(255, 215, 0, 0.8)');
                        
                        // Marquer la taille pour invalider le cache si nécessaire
                        starsGradientsCache.lastSize = rayonEtoile;
                    }

                    ctx.fillStyle = starsGradientsCache.etoile;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // Étoile à 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre à jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // Déplacer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'écran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    //
                                    // Phases 17-22 : un mot sur deux s'envole (visible)
                                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                    if(phaseActuelle >= 17 && phaseActuelle <= 22) {
                                        // Un mot sur deux est visible (les autres invisibles)
                                        const estVisible = (Math.random() < 0.5); // 50% de chance
                                        ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2, !estVisible); // false = visible
                                    }

                                    // 🔊 Son d'explosion douce
                                    AudioSystem.playExplosion();
                                    // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // Vérifier la condition de fin après destruction de brique
                                    const briquesRestantes = briques.filter(b => b.visible).length;console.log(`🔍 Vérif briques restantes (étoile): ${briquesRestantes}`);
                                    if(briquesRestantes === 0) {
                                        // 🌈 EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collecté !
                                        const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                        if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                            // Vérifier si le power-up existe et n'est PAS collecté
                                            const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                            if (espoirPresent) {
                                                console.log('🌈 Phase 22 : Mur détruit mais power-up ESPOIR pas encore collecté (étoile) !');
                                                console.log('   → La phase ne se termine pas automatiquement.');
                                                return; // ← Sortir sans transition ET sans animation
                                            }
                                        }

                                        console.log('🎯 Toutes les briques détruites (étoile)! Animation d\'explosion...');

                                        // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                        animerExplosionIconeCollector(() => {
                                            narrationManager.goToNextPhaseDirect();
                                        });
                                    }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // ⚡ OPTIMISATION: Collision avec les petits cœurs - filtrer d'abord
                const coeursVisibles = petitsCoeurs.filter(c => c.visible);
                
                for (let j = 0; j < coeursVisibles.length; j++) {
                    const petitCoeur = coeursVisibles[j];

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // Cœur touché !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        if (petitCoeur.etape && petitCoeur.etape.nom) {
                            if (petitCoeur.etape && petitCoeur.etape.nom) {
                                ajouterTexteVolant(`+${typeof petitCoeur.etape.nom === 'function' ? petitCoeur.etape.nom() : petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);
                            }
                        }

                        // 🔊 Son "pof" doux pour les petits cœurs
                        AudioSystem.playPof();

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // ⚡ OPTIMISATION: Vérifier directement si c'était le dernier
                        if(coeursVisibles.length === 1 && phaseJeu === 'tir_coeurs_haut') {

                            // 🔊 Son "pof" doux pour l'explosion finale
                            AudioSystem.playExplosionCoeurs();

                            // 🎆 ANIMATION D'EXPLOSION PUIS PASSAGE AU MODE LANTERNE
                            animerExplosionIconeCollector(() => {
                                // Passer au mode lanterne (casse-briques)
                                phaseJeu = 'lanterne';
                                balle.visible = true;
                                balle.enAttente = true;
                                balle.dx = 0;
                                balle.dy = 0;
                                
                                // Message de transition
                                afficherMessagePowerupSimple(getTranslatedText('game.messages.lantern_mode_start', '🏮 Mode Lanterne activé !'));
                                
                                narrationManager.goToNextPhaseDirect();
                                // Ne plus créer de cœurs décoratifs - ils réapparaissent à la fin
                            });
                        }
                        break; // Sortir de la boucle for
                    }
                }
            }
        }

        // ⚡ CACHE: Gradient du halo de la lanterne (créé 1 fois au lieu de 60fps)
        let lantherneHaloGradientCache = null;
        let lantherneHaloGradientCacheSize = 0;

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // ⚡ VERSION OPTIMISÉE - Lanterne simplifiée pour performances
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0;
            const posY = balle.y || 0;
            const temps = Date.now() * 0.001;

            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // ⚡ OPTIMISATION: Récupérer paramètres adaptatifs
            const effects = window.getAdaptiveEffectSettings ? window.getAdaptiveEffectSettings() : { 
                particleMultiplier: 1.0, 
                shadows: true,
                shadowBlurMax: 20
            };

            // EFFET TRAÎNÉE VERTE (power-up vitesse) - ADAPTATIF
            if(balle.traineeVerte && balle.vitesseActive) {
                // ⚡ Traînée adaptative selon device (3→2→1)
                const traineeCount = Math.max(1, Math.floor(3 * effects.particleMultiplier));
                for(let i = 0; i < traineeCount; i++) {
                    const alpha = (traineeCount - i) / traineeCount * 0.5;
                    const size = C.BS * (1 - i * 0.2);
                    const offsetX = (balle.dx || 0) * -i * 2;
                    const offsetY = (balle.dy || 0) * -i * 2;

                    ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(posX + offsetX, posY + offsetY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Dimensions simplifiées
            const multiplTaille = balle.multiplicateurTaille || 1;
            const rayon = C.BS * 0.5 * multiplTaille;

            // 1. HALO SIMPLE - ⚡ GRADIENT CACHÉ (créé 1 fois, pas 60fps)
            if(lanterne.active && effects.particleMultiplier >= 0.5) { // Pas de halo sur mobiles low
                const haloSize = rayon * 2;
                
                // ⚡ CACHE: Vérifier si le gradient existe et a la bonne taille
                if (!lantherneHaloGradientCache || lantherneHaloGradientCacheSize !== haloSize) {
                    lantherneHaloGradientCache = ctx.createRadialGradient(0, 0, 0, 0, 0, haloSize);
                    lantherneHaloGradientCache.addColorStop(0, 'rgba(255, 220, 150, 0.4)');
                    lantherneHaloGradientCache.addColorStop(1, 'rgba(255, 100, 30, 0)');
                    lantherneHaloGradientCacheSize = haloSize;
                }
                
                ctx.save();
                ctx.translate(posX, posY);
                ctx.fillStyle = lantherneHaloGradientCache;
                ctx.beginPath();
                ctx.arc(0, 0, haloSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // 2. CORPS DE LA LANTERNE - CERCLE SIMPLE
            if(lanterne.active) {
                // Corps doré simple
                ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
            } else {
                // Corps éteint
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.arc(posX, posY, rayon, 0, Math.PI * 2);
            ctx.fill();

            // Contour simple
            ctx.strokeStyle = lanterne.active ? '#B8860B' : '#654321';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Croix centrale simple
            ctx.beginPath();
            ctx.moveTo(posX, posY - rayon);
            ctx.lineTo(posX, posY + rayon);
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // 3. FLAMME SIMPLIFIÉE
            if(lanterne.active) {
                // Flamme simple sans animation complexe
                const flammeX = posX;
                const flammeY = posY - rayon * 0.3;
                const flammeSize = rayon * 0.4;

                // Flamme simple - cercle doré
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(flammeX, flammeY, flammeSize, 0, Math.PI * 2);
                ctx.fill();

                // Cœur blanc simple
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(flammeX, flammeY, flammeSize * 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Cœur rouge simple quand éteint
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(posX, posY, rayon * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Fonction pour dessiner les icônes de bateaux miniatures
        function drawBoatIcon(ctx, x, y, size, color) {
            ctx.save();

            // Couleurs selon le type
            let coqueColors, borderColor;
            if (color === 'red') {
                coqueColors = ['#ff6b6b', '#e74c3c', '#c0392b'];
                borderColor = '#a93226';
            } else {
                coqueColors = ['#74b9ff', '#0984e3', '#2d3436'];
                borderColor = '#2d3436';
            }

            // Coque simplifiée
            const coqueW = size * 1.5;
            const coqueH = size * 0.8;

            const coqueGrad = ctx.createLinearGradient(x, y, x, y + coqueH);
            coqueGrad.addColorStop(0, coqueColors[0]);
            coqueGrad.addColorStop(0.5, coqueColors[1]);
            coqueGrad.addColorStop(1, coqueColors[2]);

            ctx.fillStyle = coqueGrad;
            ctx.beginPath();
            ctx.ellipse(x, y + coqueH/2, coqueW/2, coqueH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bordure
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Mât
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + coqueH/2);
            ctx.lineTo(x, y - size);
            ctx.stroke();

            // Voile triangulaire
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size/2, y);
            ctx.lineTo(x + size/3, y - size/3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#ced4da';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau élégant géométrique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // EFFET POXERSTART (aura rose pulsante)
            if(raquette.poxerstart && Date.now() < raquette.poxerstartFin) {
                const tempsRestant = (raquette.poxerstartFin - Date.now()) / 7000; // 0 à 1
                const pulsation = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                const alpha = tempsRestant * pulsation * 0.6;

                // Aura rose autour du bateau
                const grad = ctx.createRadialGradient(
                    raquette.x + C.PW/2, raquette.y + C.PH/2, 0,
                    raquette.x + C.PW/2, raquette.y + C.PH/2, C.PW * 1.5
                );
                grad.addColorStop(0, `rgba(255, 105, 180, ${alpha})`);
                grad.addColorStop(0.7, `rgba(255, 105, 180, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 105, 180, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(
                    raquette.x - C.PW * 0.5, raquette.y - C.PH * 0.5,
                    C.PW * 2, C.PH * 2
                );

                // Étoiles qui scintillent autour
                for(let i = 0; i < 3; i++) {
                    const angle = Date.now() * 0.005 + i * Math.PI * 2 / 3;
                    const rayon = C.PW * 0.8;
                    const x = raquette.x + C.PW/2 + Math.cos(angle) * rayon;
                    const y = raquette.y + C.PH/2 + Math.sin(angle) * rayon * 0.5;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('⭐', x, y);
                }
            } else if(raquette.poxerstart) {
                // Nettoyer l'effet quand fini
                raquette.poxerstart = false;
            }

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            // ⚡ CACHE: Gradients du bateau (créés 1 fois au lieu de 60fps)
            if (!window.bateauGradientsCache) {
                window.bateauGradientsCache = {
                    coque: null,
                    reflet: null,
                    voile: null,
                    lastHeight: 0
                };
            }

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec étrave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arrière gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arrière
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arrière droite
                ];

                // Gradient bleu pour la coque
                // Protection contre les valeurs NaN
                const isValid = isFinite(raquette.x) && isFinite(raquette.y) && isFinite(C.PH);

                if (isValid) {
                    // ⚡ CACHE: Gradient coque (créé 1 fois ou si hauteur change)
                    if (!window.bateauGradientsCache.coque || window.bateauGradientsCache.lastHeight !== C.PH) {
                        window.bateauGradientsCache.coque = ctx.createLinearGradient(0, 0, 0, C.PH);
                        window.bateauGradientsCache.coque.addColorStop(0, '#74b9ff'); // Bleu clair
                        window.bateauGradientsCache.coque.addColorStop(0.5, '#0984e3'); // Bleu moyen
                        window.bateauGradientsCache.coque.addColorStop(1, '#2d3436'); // Bleu foncé
                    }
                    
                    ctx.save();
                    ctx.translate(raquette.x, raquette.y);
                    ctx.fillStyle = window.bateauGradientsCache.coque;
                } else {
                    ctx.fillStyle = '#0984e3'; // Couleur de secours
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                if (isValid) ctx.restore();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                if (isValid) {
                    // ⚡ CACHE: Gradient reflet (créé 1 fois ou si hauteur change)
                    if (!window.bateauGradientsCache.reflet || window.bateauGradientsCache.lastHeight !== C.PH) {
                        window.bateauGradientsCache.reflet = ctx.createLinearGradient(0, 0, 0, C.PH*0.4);
                        window.bateauGradientsCache.reflet.addColorStop(0, 'rgba(255,255,255,0.4)');
                        window.bateauGradientsCache.reflet.addColorStop(1, 'rgba(255,255,255,0)');
                    }
                    
                    ctx.save();
                    ctx.translate(raquette.x, raquette.y);
                    ctx.fillStyle = window.bateauGradientsCache.reflet;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();
                if (isValid) ctx.restore();

                // Mât central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du mât
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                if (isFinite(matX) && isFinite(matY) && isValid) {
                    // ⚡ CACHE: Gradient voile (créé 1 fois ou si taille change)
                    if (!window.bateauGradientsCache.voile || window.bateauGradientsCache.lastHeight !== C.PH) {
                        const voileWidth = C.PW * 0.65; // Largeur de la voile
                        window.bateauGradientsCache.voile = ctx.createLinearGradient(-C.PW*0.4, 0, C.PW*0.25, C.PH);
                        window.bateauGradientsCache.voile.addColorStop(0, '#ffffff');
                        window.bateauGradientsCache.voile.addColorStop(0.6, '#f8f9fa');
                        window.bateauGradientsCache.voile.addColorStop(1, '#e9ecef');
                        
                        // Marquer pour invalider le cache si nécessaire
                        window.bateauGradientsCache.lastHeight = C.PH;
                    }
                    
                    ctx.save();
                    ctx.translate(matX, matY);
                    ctx.fillStyle = window.bateauGradientsCache.voile;
                } else {
                    ctx.fillStyle = '#f8f9fa';
                }
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots géométriques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Protection contre les valeurs NaN
                const isValid = isFinite(raquette.x) && isFinite(raquette.y) && isFinite(C.PH);

                // Coque du bateau - forme en V très grosse qui touche le mât
                const coquePoints = [
                    [raquette.x, raquette.y + C.PH * 0.3],               // Arrière gauche (pont plus haut)
                    [raquette.x + C.PW * 0.02, raquette.y + C.PH * 1.3], // Fond gauche (descend en V)
                    [raquette.x + C.PW * 0.5, raquette.y + C.PH * 1.5],  // Point le plus bas du V (quille)
                    [raquette.x + C.PW * 0.98, raquette.y + C.PH * 1.3], // Fond droit (remonte du V)
                    [raquette.x + C.PW, raquette.y + C.PH * 0.3]         // Arrière droite (pont plus haut)
                ];

                // Gradient rouge pour la coque
                if (isValid) {
                    const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                    coqueGrad.addColorStop(0, '#ff6b6b');
                    coqueGrad.addColorStop(0.5, '#e74c3c');
                    coqueGrad.addColorStop(1, '#c0392b');
                    ctx.fillStyle = coqueGrad;
                } else {
                    ctx.fillStyle = '#e74c3c';
                }

                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                if (isValid) {
                    const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                    refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                    refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = refletGrad;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                }
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Mât central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du mât
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots géométriques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 🌊 SILLAGE BLANC ANIMÉ - Deux lignes centrées qui dépassent du bateau
            if (!modeSecret) {
                const time = Date.now() * 0.003;
                const baseY = raquette.y + C.PH * 1.3;
                const centerX = raquette.x + C.PW * 0.5; // Centre du bateau
                
                // Dessiner 2 lignes horizontales ondulantes superposées
                for (let wave = 0; wave < 2; wave++) {
                    const waveOffset = wave * 8;
                    const alpha = 0.5 - wave * 0.15;
                    const waveY = baseY + waveOffset;
                    
                    // Première ligne plus petite que la deuxième
                    const largeurLigne = wave === 0 ? C.PW * 1.05 : C.PW * 1.3;
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 3 - wave * 0.5;
                    ctx.beginPath();
                    
                    // Ligne horizontale avec minimum de points (5)
                    const startX = centerX - largeurLigne / 2;
                    for (let i = 0; i <= 5; i++) {
                        const t = i / 5;
                        const x = startX + t * largeurLigne;
                        const y = waveY + Math.sin(t * Math.PI * 4 + time + wave) * 3;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // Vraies briques avec cœurs à l'intérieur pour le casse-brique
        function dessinerPrejuges() {
            // ⚡ OPTIMISATION: Ne pas calculer si pas de briques visibles
            const briquesVisibles = briques.filter(b => b.visible);
            if (briquesVisibles.length === 0) return;
            
            // Mot-clé qui se révèle en cassant les briques (phases 17-22)
            if(narrationManager && narrationManager.currentPhase >= 17 && narrationManager.currentPhase <= 22) {
                // Mots-clés pour chaque phase
                const motsEnigmes = {
                    17: 'AVARICE',
                    18: 'LIBERTÉ',
                    19: 'REFUS',
                    20: 'ORGUEIL',
                    21: 'INÉGALITÉS',
                    22: 'ESPOIR'
                };

                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 17;
                const motComplet = motsEnigmes[phaseActuelle] || 'ÉNIGME';

                // Calculer progression : nombre de briques détruites / total
                const totalBriques = briques.length;
                const briquesDetruites = briques.filter(b => !b.visible).length;
                const progression = totalBriques > 0 ? briquesDetruites / totalBriques : 0;

                // Nombre de lettres à révéler
                const nbLettresARévéler = Math.floor(progression * motComplet.length);

                // Texte révélé progressivement
                let texteRévélé = '';
                for(let i = 0; i < motComplet.length; i++) {
                    if(i < nbLettresARévéler) {
                        texteRévélé += motComplet[i]; // Lettre révélée
                    } else {
                        texteRévélé += '_'; // Lettre cachée
                    }
                }

                ctx.save();
                ctx.globalAlpha = 0.2; // Transparence
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 70px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Ombre fine
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 3;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillText(texteRévélé, C.W / 2, C.H * 0.45); // Déplacé plus bas (45% au lieu de 32%)
                ctx.restore();
            }

            // ⚡ OPTIMISATION: Pré-calculer phase actuelle et mode
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const afficherTexte = phaseActuelle < 17 || phaseActuelle > 22;
            const modeStars = phaseJeu === 'stars';
            const modeLanterne = phaseJeu === 'lanterne';

            // ⚡ OPTIMISATION: Boucle sur briques visibles uniquement
            briquesVisibles.forEach((brique, index) => {

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec état de dégâts
                ctx.save();

                // Style différent pour les briques de mur (phases 17-22)
                const estBriqueMur = brique.type === 'mur';

                if (estBriqueMur) {
                    // STYLE MUR : Simple, trait blanc épais, couleur mate
                    ctx.fillStyle = couleur;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 4; // Trait blanc épais

                    // Rectangle simple
                    ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                    ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);

                    // Léger effet poncé (transparence sur les bords)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(brique.x + 2, brique.y + 2, brique.w - 4, brique.h * 0.3);
                } else {
                    // STYLE NORMAL : Briques classiques avec effets 3D
                    // ⚡ OPTIMISATION: Utiliser globalAlpha au lieu de recalculer RGBA
                    ctx.fillStyle = couleur;
                    
                    // Calculer l'opacité selon les dégâts
                    if (brique.vieMax === 2 && brique.vie === 1) {
                        ctx.globalAlpha = 0.6; // Phase lanterne endommagée
                    } else if (brique.vieMax === 3 && brique.vie === 2) {
                        ctx.globalAlpha = 0.8; // Phase stars légèrement endommagée
                    } else if (brique.vie === 1) {
                        ctx.globalAlpha = 0.5; // Très endommagée
                    } else {
                        ctx.globalAlpha = 1.0; // Intacte
                    }

                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;

                    // Clignotement si récemment touchée
                    if (brique.clignotement > 0) {
                        ctx.fillStyle = '#FFFFFF';
                        brique.clignotement--;
                    }

                    // Rectangle de brique
                    ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                    ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);

                    // ⚡ OPTIMISATION: Effet 3D simplifié (pas en mode lanterne)
                    if (!modeLanterne) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; // Réduit de 0.3 à 0.2
                        ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.25); // Réduit de 0.3 à 0.25
                    }
                }

                // ⚡ OPTIMISATION ULTRA: Fissures simplifiées (économie sin/cos)
                if (!estBriqueMur && ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2))) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    
                    // Toujours utiliser fissure simple (plus de zigzag coûteux)
                    ctx.beginPath();
                    ctx.moveTo(brique.x + brique.w * 0.3, brique.y);
                    ctx.lineTo(brique.x + brique.w * 0.2, brique.y + brique.h);
                    ctx.stroke();
                }

                if (!estBriqueMur && brique.vie <= 1) {
                    // Deuxième fissure simple toujours
                    ctx.beginPath();
                    ctx.moveTo(brique.x + brique.w * 0.7, brique.y);
                    ctx.lineTo(brique.x + brique.w * 0.8, brique.y + brique.h);
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le cœur à l'intérieur de la brique (pas pour les murs ni les drapeaux)
                if (!estBriqueMur && brique.type !== 'drapeau') {
                    dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);
                }

                // Dessiner le drapeau pour les briques drapeaux
                if (brique.type === 'drapeau' && brique.drapeau) {
                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ffffff';
                    // ⚡ OPTIMISATION: Pas de shadowBlur (trop coûteux)
                    ctx.fillText(brique.drapeau, centreX, centreY);
                }

                // En phase stars (nuit), afficher les mots pour guider le joueur
                // ⚡ OPTIMISATION: Pas de texte en mode lanterne (déjà calculé au début)
                if(modeStars && brique.etape && (typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom) && afficherTexte) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // ⚡ OPTIMISATION: Un seul fillText (pas de strokeText pour économiser)
                    const nomBrique = typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom;
                    // Ombre simple au lieu de strokeText
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.fillText(nomBrique, centreX, centreY + brique.h * 0.3);
                    ctx.shadowBlur = 0;
                }

                // En phase lanterne, le texte reste caché - il n'apparaît que lors de l'explosion
                // Le mystère reste entier jusqu'à la libération du cœur !
            });
        }

        // Messages simples centrés pour powerups et narratifs
        let messagePowerupActif = null;
        let messageNarratifActif = null;
        let dernierMessageXP = 0; // Throttle pour messages +100 XP

        // Système d'éclairs pour le mode nuit
        let eclairNuit = {
            actif: false,
            flashBlanc: false,
            intensite: 0,
            duree: 0,
            tempsProchainEclair: 0,
            delaiMinimum: 8000,  // 8 secondes minimum entre les éclairs
            delaiMaximum: 20000  // 20 secondes maximum entre les éclairs
        };

        // Bouton simple "Passer" avec juste texte et ombre
        let boutonPasser = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 150, // Ajusté pour le texte encore plus gros
            hauteur: 50,  // Ajusté pour le texte encore plus gros
            getTexte: () => getTranslatedText('ui.skip_button', 'Passer'),
            hover: false,
            pulse: 0 // Animation de pulsation
        };

        // Bouton simple "Continuer" pour phase 16
        let boutonContinuer = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 150,
            hauteur: 40,
            texte: () => getTranslatedText('ui.continue_button', 'Continuer'),
            hover: false
        };

        function afficherMessagePowerupSimple(texte) {
            messagePowerupActif = {
                texte: texte,
                temps: Date.now() + 4000, // 4 secondes (augmenté de 2s)
                alpha: 1.0
            };
        }

        // Afficher une modal avec les détails philosophiques d'Emmanuel pour une énigme
        function afficherModalEnigme(enigme) {
            // Récupérer les traductions ou utiliser les textes français
            const nom = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.description`, enigme.nom);
            const mystere = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.mystery`, enigme.mystere);
            const revelation = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.revelation`, enigme.revelation);
            const sagesse = getTranslatedText(`philosophical_content.mysteries.${enigme.id}.wisdom`, enigme.sagesse);

            // Créer la modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 20000;
                backdrop-filter: blur(5px);
                animation: modalFadeIn 0.3s ease-out;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                border: 3px solid #4a90e2;
                border-radius: 20px;
                padding: 30px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                animation: modalSlideIn 0.3s ease-out;
            `;

            modalContent.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 20px;">${enigme.icone}</div>
                <h2 style="color: #4a90e2; margin-bottom: 25px; font-size: 28px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${nom}</h2>
                
                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #ff6b6b;">
                    <h3 style="color: #ff6b6b; margin-bottom: 15px; font-size: 20px;">🤔 ${getTranslatedText('interface.labels.mystery', 'Mystère')}</h3>
                    <p style="font-size: 18px; line-height: 1.6; font-style: italic;">"${mystere}"</p>
                </div>

                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; border-left: 4px solid #4ecdc4;">
                    <h3 style="color: #4ecdc4; margin-bottom: 15px; font-size: 20px;">💡 ${getTranslatedText('interface.labels.revelation', 'Révélation')}</h3>
                    <p style="font-size: 18px; line-height: 1.6;">${revelation}</p>
                </div>

                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 30px; border-left: 4px solid #feca57;">
                    <h3 style="color: #feca57; margin-bottom: 15px; font-size: 20px;">✨ ${getTranslatedText('interface.labels.wisdom', 'Sagesse')}</h3>
                    <p style="font-size: 18px; line-height: 1.6; font-style: italic; color: #feca57;">"${sagesse}"</p>
                </div>

                <button id="closeEnigmaModal" style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 25px;
                    font-size: 18px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">${getTranslatedText('interface.buttons.close', 'Fermer')}</button>
            `;

            modal.appendChild(modalContent);

            // Ajouter les styles CSS pour les animations
            if (!document.querySelector('#enigma-modal-styles')) {
                const style = document.createElement('style');
                style.id = 'enigma-modal-styles';
                style.textContent = `
                    @keyframes modalFadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes modalSlideIn {
                        from { transform: translateY(-50px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }

            // Gestionnaire de fermeture
            const closeModal = () => {
                modal.style.animation = 'modalFadeIn 0.2s ease-in reverse';
                modalContent.style.animation = 'modalSlideIn 0.2s ease-in reverse';
                setTimeout(() => modal.remove(), 200);
                AudioSystem.playClick();
            };

            // Events de fermeture
            modal.addEventListener('click', async (e) => {
                if (e.target === modal) closeModal();
            });
            modalContent.querySelector('#closeEnigmaModal').addEventListener('click', closeModal);

            // Ajouter à la page
            document.body.appendChild(modal);
            AudioSystem.playClick();
        }

        function afficherMessageNarratifSimple(texte, duree = 12000) {
            messageNarratifActif = {
                texte: texte,
                temps: Date.now() + duree,
                tempsDebut: Date.now(),
                alpha: 1.0
            };
        }

        // Fonctions pour les éclairs en mode nuit
        function initierEclairNuit() {
            if (periode !== 'nuit') return;

            const maintenant = Date.now();
            if (maintenant >= eclairNuit.tempsProchainEclair) {
                // Déclencher un éclair
                eclairNuit.actif = true;
                eclairNuit.flashBlanc = true;
                eclairNuit.intensite = 1.0;
                eclairNuit.duree = maintenant + 150; // Flash blanc de 150ms

                // Programmer le prochain éclair
                const delai = eclairNuit.delaiMinimum + Math.random() * (eclairNuit.delaiMaximum - eclairNuit.delaiMinimum);
                eclairNuit.tempsProchainEclair = maintenant + delai;
            }
        }

        function mettreAJourEclairNuit() {
            if (!eclairNuit.actif) return;

            const maintenant = Date.now();

            if (eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase de flash blanc - intensité maximale
                eclairNuit.intensite = 1.0;
            } else if (eclairNuit.flashBlanc && maintenant > eclairNuit.duree) {
                // Fin du flash blanc, commencer l'éclair bleu
                eclairNuit.flashBlanc = false;
                eclairNuit.duree = maintenant + 300; // Éclair bleu de 300ms
                eclairNuit.intensite = 0.7;
            } else if (!eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase d'éclair bleu qui s'estompe
                const progression = (eclairNuit.duree - maintenant) / 300;
                eclairNuit.intensite = 0.7 * progression;
            } else {
                // Fin de l'éclair
                eclairNuit.actif = false;
                eclairNuit.intensite = 0;
            }
        }

        function dessinerEclairNuit() {
            if (!eclairNuit.actif || periode !== 'nuit') return;

            ctx.save();

            if (eclairNuit.flashBlanc) {
                // Flash blanc aveuglant
                ctx.fillStyle = `rgba(255, 255, 255, ${eclairNuit.intensite * 0.8})`;
                ctx.fillRect(0, 0, C.W, C.H);
            } else {
                // Éclair bleu-électrique
                ctx.fillStyle = `rgba(173, 216, 230, ${eclairNuit.intensite * 0.4})`;
                ctx.fillRect(0, 0, C.W, C.H);

                // Dessiner quelques éclairs en zigzag
                ctx.strokeStyle = `rgba(255, 255, 255, ${eclairNuit.intensite})`;
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Éclair principal diagonal
                const startX = Math.random() * C.W;
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H * 0.3);
                ctx.lineTo(startX + (Math.random() - 0.5) * 150, C.H * 0.6);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H);

                ctx.stroke();
            }

            ctx.restore();
        }

        // Fonction pour dessiner le message powerup simple sous les titres narratifs
        function dessinerMessagePowerupSimple() {
            if (!messagePowerupActif) return;

            const maintenant = Date.now();
            if (maintenant > messagePowerupActif.temps) {
                messagePowerupActif = null;
                return;
            }

            // Fade out dans les dernières 500ms
            const tempsRestant = messagePowerupActif.temps - maintenant;
            if (tempsRestant < 500) {
                messagePowerupActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messagePowerupActif.alpha;

            // Position centrée en haut pour meilleure visibilité (20% au lieu de 40%)
            const posY = C.H * 0.20; // 20% de la hauteur (haut de l'écran)

            // Mesurer le texte pour dimensionner le fond
            ctx.font = '14px Arial';
            const textMetrics = ctx.measureText(messagePowerupActif.texte);
            const textWidth = textMetrics.width;
            const padding = 10; // Réduit de 15 à 10
            
            // Fond rose moins translucide et plus compact
            ctx.fillStyle = 'rgba(255, 182, 193, 0.8)'; // Moins transparent (0.8 au lieu de 0.5)
            ctx.beginPath();
            ctx.roundRect(
                C.W/2 - textWidth/2 - padding, 
                posY - padding/2, // Hauteur réduite
                textWidth + padding * 2, 
                24, // Hauteur fixe plus petite (30 + padding devient 24)
                8 // Coins un peu moins arrondis
            );
            ctx.fill();

            // Texte blanc avec ombre
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Ombre fine pour lisibilité
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.fillText(messagePowerupActif.texte, C.W/2, posY);

            ctx.restore();
        }

        // Fonction pour dessiner le message narratif discret (en bas, sans fond)
        function dessinerMessageNarratifSimple() {
            if (!messageNarratifActif) return;

            const maintenant = Date.now();
            if (maintenant > messageNarratifActif.temps) {
                messageNarratifActif = null;
                return;
            }

            // Log pour phase 16
            if (narrationManager && narrationManager.currentPhase === 16) {
                if (!window.logP16Done) {console.log('🖼️ Dessin message narratif P16:', messageNarratifActif.texte.substring(0, 30));
                    window.logP16Done = true;
                }
            }

            // Fade out dans les dernières 500ms
            const tempsRestant = messageNarratifActif.temps - maintenant;
            if (tempsRestant < 500) {
                messageNarratifActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messageNarratifActif.alpha;

            // Position selon la phase
            let posY = C.H * 0.70; // 70% de la hauteur par défaut - près du bateau

            // Intro : Texte au centre pendant l'animation du bateau
            if(narrationManager && narrationManager.currentPhase === 1) {
                posY = C.H * 0.40; // 40% de la hauteur - centré pour l'intro
            }

            // Phase 16 : Texte au milieu
            if(narrationManager && narrationManager.currentPhase === 16) {
                posY = C.H * 0.45; // 45% de la hauteur - au milieu
            }

            // Texte centré fixe pour la phase finale
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                posY = C.H * 0.50; // Texte toujours centré, sans défilement
            }

            // Dessiner l'icône lanterne si demandée
            if (messageNarratifActif.avecIcone) {
                const iconX = C.W / 2 - 60;
                const iconY = posY - 40;

                // Corps de la lanterne (orange lumineux)
                const grad = ctx.createRadialGradient(iconX, iconY, 0, iconX, iconY, 20);
                grad.addColorStop(0, '#FFD700');
                grad.addColorStop(0.5, '#FF8C00');
                grad.addColorStop(1, '#FF6B00');
                ctx.fillStyle = grad;
                ctx.fillRect(iconX - 12, iconY - 15, 24, 30);

                // Lueur de la flamme
                const lueurGrad = ctx.createRadialGradient(iconX, iconY, 0, iconX, iconY, 35);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 140, 0, 0.4)');
                lueurGrad.addColorStop(1, 'rgba(255, 107, 0, 0)');
                ctx.fillStyle = lueurGrad;
                ctx.beginPath();
                ctx.arc(iconX, iconY, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            // Diviser le texte en lignes pour les longs messages
            const lignes = messageNarratifActif.texte.split('\n');

            // Pas de fond - style discret mais bien visible
            // Texte blanc bold avec ombre noire marquée
            ctx.fillStyle = '#FFFFFF';

            // Texte selon la phase
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                ctx.font = 'bold 20px Arial'; // Texte simple pour phase finale
            } else if(narrationManager && narrationManager.currentPhase === 16) {
                ctx.font = 'bold 24px Arial'; // Texte PLUS GROS pour phase 16
            } else {
                ctx.font = 'bold 20px Arial'; // Texte normal
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Ombre selon la phase
            if(narrationManager && narrationManager.currentPhase === 16) {
                // Phase 16 : Ombre très fine
                ctx.shadowColor = '#000000';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
            } else {
                // Autres phases : Ombre subtile
                ctx.shadowColor = '#000000';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
            }

            // Traiter chaque ligne pour un formatage optimal
            const hauteurLigne = 26;
            // Phase 16 : Marges réduites pour texte sur toute la largeur
            const margeHorizontale = (narrationManager && narrationManager.currentPhase === 16) ? 20 : 40;
            const largeurMax = C.W - (margeHorizontale * 2);

            let lignesFinales = [];

            // Pré-traiter toutes les lignes pour gérer le retour à la ligne intelligent
            lignes.forEach(ligne => {
                const largeurTexte = ctx.measureText(ligne).width;

                if (largeurTexte > largeurMax) {
                    // Diviser intelligemment la ligne trop longue
                    const mots = ligne.split(' ');
                    let ligneActuelle = '';

                    for (let mot of mots) {
                        const testLigne = ligneActuelle + (ligneActuelle ? ' ' : '') + mot;
                        const testLargeur = ctx.measureText(testLigne).width;

                        if (testLargeur > largeurMax && ligneActuelle !== '') {
                            lignesFinales.push(ligneActuelle);
                            ligneActuelle = mot;
                        } else {
                            ligneActuelle = testLigne;
                        }
                    }

                    if (ligneActuelle) {
                        lignesFinales.push(ligneActuelle);
                    }
                } else {
                    lignesFinales.push(ligne);
                }
            });

            // Calculer la position de départ pour centrer verticalement le bloc de texte
            const hauteurTotale = lignesFinales.length * hauteurLigne;
            const yDebut = posY - hauteurTotale / 2;

            // Dessiner toutes les lignes finales
            lignesFinales.forEach((ligne, index) => {
                const y = yDebut + (index + 1) * hauteurLigne;

                // Détecter [Origine : Le voyage d'une vie] et le rendre cliquable
                if (ligne.includes('[Origine :')) {
                    const largeurLien = ctx.measureText('Origine du voyage').width;

                    // Dessiner le lien cliquable
                    const btnX = C.W/2 - largeurLien/2 - 10;
                    const btnY = y - 18;
                    const btnW = largeurLien + 20;
                    const btnH = 30;

                    // Stocker la zone cliquable du lien
                    if (messageNarratifActif.lienLivre) {
                        messageNarratifActif.lienZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du lien (bleu clair)
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du lien
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('game.canvas.voyage_origin', 'Origine du voyage'), C.W/2, y);
                }
                // Détecter [Recommencer] et le rendre cliquable
                else if (ligne.includes('[Recommencer]')) {
                    const texteAvant = ligne.substring(0, ligne.indexOf('[Recommencer]'));
                    const largeurAvant = ctx.measureText(texteAvant).width;
                    const largeurBouton = ctx.measureText('Recommencer').width;

                    // Dessiner le texte avant
                    if (texteAvant) {
                        ctx.fillText(texteAvant, C.W/2 - largeurBouton/2 - 20, y);
                    }

                    // Dessiner le bouton Recommencer
                    const btnX = C.W/2 - largeurBouton/2 - 10;
                    const btnY = y - 18;
                    const btnW = largeurBouton + 20;
                    const btnH = 30;

                    // Stocker la zone cliquable
                    if (messageNarratifActif.avecRestart) {
                        messageNarratifActif.restartZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du bouton
                    ctx.fillStyle = 'rgba(30, 58, 138, 0.8)'; // Bleu roi
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du bouton
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('interface.buttons.restart', 'Recommencer'), C.W/2, y);
                }
                // Détecter [🌍 Partager mon voyage] et le rendre cliquable
                else if (ligne.includes('[🌍 Partager mon voyage]')) {
                    const largeurPartage = ctx.measureText('🌍 Partager mon voyage').width;

                    // Dessiner le bouton de partage
                    const btnX = C.W/2 - largeurPartage/2 - 15;
                    const btnY = y - 20;
                    const btnW = largeurPartage + 30;
                    const btnH = 35;

                    // Stocker la zone cliquable
                    if (messageNarratifActif.avecPartage) {
                        messageNarratifActif.partageZone = { x: btnX, y: btnY, w: btnW, h: btnH };
                    }

                    // Fond du bouton (vert uni)
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.9)'; // Vert émeraude
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    // Bordure dorée
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    // Texte du bouton
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(getTranslatedText('interface.buttons.share_journey', '🌍 Partager mon voyage'), C.W/2, y);
                } else {
                    ctx.fillText(ligne, C.W/2, y);
                }
            });

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Continuer" dans le canvas (Phase 16)
        function dessinerBoutonContinuer() {
            if (!window.boutonContinuer || !window.boutonContinuer.visible) return;
            if (!narrationManager || narrationManager.currentPhase !== 16) return;

            const btn = window.boutonContinuer;

            // Position centrée, milieu-bas de l'écran - PLUS PETIT
            btn.width = 200;
            btn.height = 50;
            btn.x = (C.W - btn.width) / 2;
            btn.y = C.H * 0.60; // 60% de la hauteur (milieu-bas, bien visible)

            ctx.save();

            // Animation de pulsation
            const temps = (Date.now() - btn.pulseTime) * 0.002;
            const scale = 1 + Math.sin(temps) * 0.05;

            ctx.translate(btn.x + btn.width/2, btn.y + btn.height/2);
            ctx.scale(scale, scale);
            ctx.translate(-(btn.x + btn.width/2), -(btn.y + btn.height/2));

            // Ombre
            ctx.shadowColor = 'rgba(30, 58, 138, 0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 6;

            // Fond bleu roi
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.beginPath();
            ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 25);
            ctx.fill();

            // Bordure rouge
            ctx.strokeStyle = '#ef4444'; // Rouge vif
            ctx.lineWidth = 3;
            ctx.stroke();

            // Texte
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(getTranslatedText('game.canvas.continue_button', '➜ Continuer'), btn.x + btn.width/2, btn.y + btn.height/2);

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Passer" simple
        function dessinerBoutonPasser() {
            if (!boutonPasser.actif) return;

            // Animation de pulsation
            boutonPasser.pulse += 0.03; // 5x plus lent (0.15 / 5 = 0.03)
            const scale = 1 + Math.sin(boutonPasser.pulse) * 0.15; // Pulsation entre 0.85 et 1.15
            const alpha = 0.8 + Math.sin(boutonPasser.pulse) * 0.2; // Alpha entre 0.6 et 1.0

            // Position en bas du texte d'intro
            boutonPasser.x = C.W/2 - boutonPasser.largeur/2;
            boutonPasser.y = C.H * 0.55; // Positionné sous le texte d'intro (40% + espace)

            ctx.save();

            // Appliquer la transformation de pulsation
            const centerX = boutonPasser.x + boutonPasser.largeur/2;
            const centerY = boutonPasser.y + boutonPasser.hauteur/2;
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            // Juste du texte avec ombre - pas de fond ni bordure
            ctx.globalAlpha = alpha;
            ctx.fillStyle = boutonPasser.hover ? '#ff6666' : '#ff0000';
            ctx.font = 'bold 32px "Orbitron", "Exo 2", "Rajdhani", monospace'; // Police futuriste encore plus grosse
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre fine et moderne
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;

            ctx.fillText(boutonPasser.getTexte(), centerX, centerY);

            ctx.restore();
        }

        // Fonction pour vérifier si on clique sur le bouton Passer
        function verifierClicBoutonPasser(x, y) {
            if (!boutonPasser.actif) return false;

            return x >= boutonPasser.x && x <= boutonPasser.x + boutonPasser.largeur &&
                   y >= boutonPasser.y && y <= boutonPasser.y + boutonPasser.hauteur;
        }

        // Fonction pour dessiner le bouton "Suivant" simple pour phase 16
        function dessinerBoutonSuivantP16() {
            if (!window.boutonSuivantP16 || !window.boutonSuivantP16.visible) {
                return;
            }
            if (narrationManager && narrationManager.currentPhase !== 16) {
                return;
            }

            const btn = window.boutonSuivantP16;
            // Centrer le texte
            const centerX = C.W / 2;
            const centerY = C.H * 0.83; // Un peu plus bas (83% de la hauteur)

            // Mettre à jour la position pour le clic (zone autour du texte)
            btn.x = centerX - btn.width / 2;
            btn.y = centerY - btn.height / 2;

            ctx.save();

            // Texte blanc en gras avec ombre
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre plus visible
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.shadowBlur = 4;

            ctx.fillText(getTranslatedText('game.canvas.next_button', '➜ Suivant'), centerX, centerY);

            ctx.restore();
        }

        // Power-Up Bleu Étincelant
        function creerPowerUp(x, y, typeSpecifique = null) {
            // Si un type spécifique est fourni, l'utiliser, sinon choisir aléatoirement
            let typeFinal;
            if (typeSpecifique) {
                // Si c'est un tableau (phase 17 avec plusieurs types possibles), choisir aléatoirement
                if (Array.isArray(typeSpecifique)) {
                    typeFinal = typeSpecifique[Math.floor(Math.random() * typeSpecifique.length)];
                } else {
                    typeFinal = typeSpecifique;
                }
            } else {
                // allume_lanterne n'apparaît pas aléatoirement - seulement via creerPowerUpLanterne()
                const types = ['etoile_montante', 'poxerstart', 'vitesse', 'bonus_points'];
                typeFinal = types[Math.floor(Math.random() * types.length)];
            }

            const nouveauPowerUp = {
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: typeFinal,
                temps: 0,
                etincelles: []
            };

            powerUps.push(nouveauPowerUp);console.log(`🎯 Power-up créé: ${typeFinal} à (${x}, ${y}), total: ${powerUps.length}`);
        }

        function dessinerPowerUps() {
            if(powerUps.length === 0) return; // ⚡ Retour anticipé
            
            // ⚡ OPTIMISATION: Pré-calculer mode lanterne
            const modeLanterne = phaseJeu === 'lanterne';
            
            powerUps.forEach(power => {
                // 🔔 Vérifier AVANT tout si le power-up rainbow_hope doit être découvert (Phase 22)
                if (power.type === 'rainbow_hope' && !power.decouvert) {
                    // ⚡ OPTIMISATION: Calculer seulement toutes les 10 frames (au lieu de chaque frame)
                    if (!power.lastCheckFrame) power.lastCheckFrame = 0;
                    const currentFrame = Date.now();
                    
                    if (currentFrame - power.lastCheckFrame < 166) { // ~10 frames à 60fps
                        return; // Pas encore découvert, skip
                    }
                    power.lastCheckFrame = currentFrame;
                    
                    // Compter combien de briques autour du power-up ont été détruites
                    let briquesAutourDetruites = 0;
                    let totalBriquesAutour = 0;
                    
                    briques.forEach(brique => {
                        // Vérifier si la brique est proche du power-up (dans un rayon de 80px)
                        const dx = (brique.x + brique.w/2) - (power.x + power.w/2);
                        const dy = (brique.y + brique.h/2) - (power.y + power.h/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 80) {
                            totalBriquesAutour++;
                            if (!brique.visible) {
                                briquesAutourDetruites++;
                            }
                        }
                    });
                    
                    // Si au moins 50% des briques autour sont détruites, le power-up est découvert !
                    if (totalBriquesAutour > 0 && (briquesAutourDetruites / totalBriquesAutour) >= 0.5) {
                        power.decouvert = true;
                        AudioSystem.playChime(); // 🔔 Son de cloche magique !
                        console.log('🔔✨ Power-up ESPOIR découvert ! Son de cloche joué.');
                        
                        // Explosion de particules arc-en-ciel pour marquer la découverte
                        const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                        for (let c = 0; c < 7; c++) {
                            setTimeout(() => {
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, rainbowColors[c], 8);
                            }, c * 30);
                        }
                    } else {
                        // Pas encore découvert, ne pas dessiner
                        return;
                    }
                }
                
                ctx.save();

                // ⚡ ANIMATION SIMPLE: Pulsation légère optimisée (même en mode lanterne)
                const pulsation = 1 + Math.sin(power.temps * 0.1) * 0.08; // ±8% de variation, lent
                ctx.translate(power.x + power.w/2, power.y + power.h/2);
                ctx.scale(pulsation, pulsation);
                ctx.translate(-(power.x + power.w/2), -(power.y + power.h/2));

                // ⚡ OPTIMISATION: Ombre simplifiée en mode lanterne
                if (!modeLanterne) {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);
                }

                // Couleur selon le type
                let couleur1, couleur2, couleur3;
                switch(power.type) {
                    case 'etoile_montante':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Doré
                        
                        // ⚡ ANIMATION SPÉCIALE: Scintillement pour étoile montante
                        const scintillement = 0.7 + Math.sin(power.temps * 0.2) * 0.3; // Scintillement
                        ctx.globalAlpha = scintillement;
                        break;
                    case 'poxerstart':
                        couleur1 = '#FF69B4'; couleur2 = '#FF1493'; couleur3 = '#DC143C'; // Rose/Rouge
                        break;
                    case 'vitesse':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert
                        break;
                    case 'bonus_points':
                        couleur1 = '#9400D3'; couleur2 = '#8A2BE2'; couleur3 = '#7B68EE'; // Violet
                        break;
                    case 'allume_lanterne':
                        couleur1 = '#FFA500'; couleur2 = '#FF8C00'; couleur3 = '#FF6347'; // Orange/Rouge (feu)
                        break;
                    case 'red_cross':
                        couleur1 = '#FF0000'; couleur2 = '#CC0000'; couleur3 = '#990000'; // Rouge vif
                        break;
                    case 'broken_heart':
                        couleur1 = '#8B0000'; couleur2 = '#660000'; couleur3 = '#440000'; // Rouge sombre
                        break;
                    case 'gray_heart':
                        couleur1 = '#A9A9A9'; couleur2 = '#808080'; couleur3 = '#696969'; // Gris (crise)
                        break;
                    case 'black_heart':
                        couleur1 = '#2C2C2C'; couleur2 = '#1C1C1C'; couleur3 = '#0C0C0C'; // Noir
                        break;
                    case 'chain':
                        couleur1 = '#708090'; couleur2 = '#556B76'; couleur3 = '#3D4E5C'; // Gris acier (chaînes)
                        break;
                    case 'barbed_wire':
                        couleur1 = '#C0C0C0'; couleur2 = '#A8A8A8'; couleur3 = '#808080'; // Argent/Métal
                        break;
                    case 'red_heart':
                        couleur1 = '#FF0000'; couleur2 = '#DC143C'; couleur3 = '#B22222'; // Rouge vif (amour)
                        break;
                    case 'open_hands':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Or (générosité)
                        break;
                    case 'green_heart':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert (nature/espoir)
                        break;
                    case 'yellow_heart':
                        couleur1 = '#FFFF00'; couleur2 = '#FFD700'; couleur3 = '#FFA500'; // Jaune (joie)
                        break;
                    case 'blue_heart':
                        couleur1 = '#0000FF'; couleur2 = '#4169E1'; couleur3 = '#1E90FF'; // Bleu (paix)
                        break;
                    case 'purple_heart':
                        couleur1 = '#9400D3'; couleur2 = '#8B00FF'; couleur3 = '#6A0DAD'; // Violet (spiritualité)
                        break;
                    case 'vibrant_heart':
                        couleur1 = '#FF1493'; couleur2 = '#FF69B4'; couleur3 = '#FF85C1'; // Rose vibrant (espoir)
                        break;
                    case 'smile':
                        couleur1 = '#FFD700'; couleur2 = '#FFED4E'; couleur3 = '#FFF68F'; // Jaune lumineux (joie)
                        break;
                    case 'rainbow_hope':
                        // Arc-en-ciel animé pour le power-up Espoir (Phase 22)
                        const rainbowIndex = Math.floor((power.temps / 5) % 7);
                        const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                        couleur1 = rainbowColors[rainbowIndex];
                        couleur2 = rainbowColors[(rainbowIndex + 1) % 7];
                        couleur3 = rainbowColors[(rainbowIndex + 2) % 7];
                        
                        // ⚡ ANIMATION SPÉCIALE: Rotation légère pour rainbow_hope
                        const rotationEspoir = Math.sin(power.temps * 0.05) * 0.1; // Rotation très légère
                        ctx.translate(power.x + power.w/2, power.y + power.h/2);
                        ctx.rotate(rotationEspoir);
                        ctx.translate(-(power.x + power.w/2), -(power.y + power.h/2));
                        break;
                    default:
                        couleur1 = '#00aaff'; couleur2 = '#0099dd'; couleur3 = '#0088cc'; // Bleu
                }

                // ⚡ OPTIMISATION: Gradient simplifié en mode lanterne (couleur unie)
                if (modeLanterne) {
                    ctx.fillStyle = couleur1; // Couleur unie au lieu de gradient
                } else {
                    const grad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                    grad.addColorStop(0, couleur1);
                    grad.addColorStop(0.5, couleur2);
                    grad.addColorStop(1, couleur3);
                    ctx.fillStyle = grad;
                }
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // ⚡ OPTIMISATION: Bordure sans shadowBlur en mode lanterne
                if (modeLanterne) {
                    ctx.strokeStyle = couleur1;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(power.x, power.y, power.w, power.h);
                } else {
                    ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(power.x, power.y, power.w, power.h);
                    ctx.shadowBlur = 0;
                }

                // Icône selon le type
                if (power.type === 'red_cross') {
                    // Dessiner une croix rouge ❌
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = power.w * 0.15;
                    ctx.lineCap = 'round';
                    
                    const centerX = power.x + power.w/2;
                    const centerY = power.y + power.h/2;
                    const crossSize = power.w * 0.4;
                    
                    // Ligne diagonale \
                    ctx.beginPath();
                    ctx.moveTo(centerX - crossSize, centerY - crossSize);
                    ctx.lineTo(centerX + crossSize, centerY + crossSize);
                    ctx.stroke();
                    
                    // Ligne diagonale /
                    ctx.beginPath();
                    ctx.moveTo(centerX + crossSize, centerY - crossSize);
                    ctx.lineTo(centerX - crossSize, centerY + crossSize);
                    ctx.stroke();
                } else if (power.type === 'broken_heart') {
                    // Dessiner un cœur brisé 💔
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💔', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'gray_heart') {
                    // Dessiner un cœur gris (crise) 🤍
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🤍', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'black_heart') {
                    // Dessiner un cœur noir 🖤
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🖤', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'chain') {
                    // Dessiner des chaînes 🔗
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🔗', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'barbed_wire') {
                    // Dessiner des barbelés 🚧
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🚧', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'red_heart') {
                    // Dessiner un cœur rouge ❤️
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('❤️', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'open_hands') {
                    // Dessiner des mains tendues 🤲
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🤲', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'green_heart') {
                    // Dessiner un cœur vert 💚
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💚', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'yellow_heart') {
                    // Dessiner un cœur jaune 💛
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💛', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'blue_heart') {
                    // Dessiner un cœur bleu 💙
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💙', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'purple_heart') {
                    // Dessiner un cœur violet 💜
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💜', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'vibrant_heart') {
                    // Dessiner un cœur vibrant 💗
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('💗', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'smile') {
                    // Dessiner un sourire 😊
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('😊', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'allume_lanterne') {
                    // Icône lanterne 🏮
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${power.h * 0.6}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('🏮', power.x + power.w/2, power.y + power.h*0.7);
                } else if (power.type === 'rainbow_hope') {
                    // 🌈 Power-up Espoir arc-en-ciel (Phase 22)
                    // ⚡ OPTIMISATION: Animation simplifiée en mode lanterne
                    if (modeLanterne) {
                        // Version simple sans shadowBlur ni scale
                        ctx.font = `${power.h * 1.2}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(power.emoji, power.x + power.w/2, power.y + power.h/2);
                    } else {
                        // Version complète avec animations
                        const colorIndex = Math.floor((power.temps / 5) % power.colors.length);
                        const currentColor = power.colors[colorIndex];
                        
                        ctx.shadowBlur = 30 + Math.sin(power.temps * 0.1) * 10;
                        ctx.shadowColor = currentColor;
                        
                        const scale = 1 + Math.sin(power.temps * 0.08) * 0.15;
                        ctx.save();
                        ctx.translate(power.x + power.w/2, power.y + power.h/2);
                        ctx.scale(scale, scale);
                        ctx.font = `${power.h * 1.2}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(power.emoji, 0, 0);
                        ctx.restore();
                        
                        ctx.shadowBlur = 0;
                    }
                }

                // ⚡ OPTIMISATION: Pas d'étincelles en mode lanterne
                if (!modeLanterne) {
                    for(let i = 0; i < 3; i++) {
                        const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                        const dist = power.w * 0.8;
                        const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                        const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                        ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                        ctx.beginPath();
                        ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // 🌈 EXCEPTION : Ne pas incrémenter le temps pour le power-up Espoir (ne doit jamais expirer)
                if (power.type !== 'rainbow_hope') {
                    power.temps += 1;
                }
                
                // Restaurer alpha normal pour animations spéciales
                ctx.globalAlpha = 1.0;
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                if(powerUps.length > 0) {
                    //console.log(`🔍 Vérif collision balle(${balle.x.toFixed(1)}, ${balle.y.toFixed(1)}) avec ${powerUps.length} power-ups`);
                }
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Effets selon le type de power-up
                    switch(power.type) {
                        case 'etoile_montante':
                            // Créer une étoile qui monte au ciel + 1000 XP
                            creerEtoileMontante(power.x + power.w/2, power.y + power.h/2);
                            score += 1000;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 8);

                            // 🔊 Son de collecte power-up
                            AudioSystem.playCollect();

                            // Message simple avec traduction
                            const message = getTranslatedText('powerups.star_rising', '⭐ Étoile montante +1000 XP');
                            afficherMessagePowerupSimple(message);
                            break;

                        case 'poxerstart':
                            // Active le mode tir étoiles POXERSTART pendant 7 secondes
                            // Système séparé du mode tir MUR (phases 17-22)
                            if(!window.modeTirStars || !window.modeTirStars.actif) {
                                const finTirStars = Date.now() + 7000;
                                window.modeTirStars = { actif: true, fin: finTirStars };
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 8);
                                console.log('🌟 Mode tir étoiles POXERSTART activé (7s)');

                                // 🔊 Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple avec traduction
                                const message = getTranslatedText('powerups.poxerstart', '🌟 Poxerstart activé - 7 secondes');
                                afficherMessagePowerupSimple(message);

                                // Indicateur visuel sur la raquette
                                raquette.poxerstart = true;
                                raquette.poxerstartFin = finTirStars;
                            } else {
                                console.log('⚠️ Poxerstart déjà actif');
                            }
                            break;

                        case 'vitesse':
                            // Balle plus rapide pendant 60 secondes (ne pas cumuler)
                            if(!balle.vitesseActive) {
                                balle.multiplicateurVitesse = 1.8; // Fixe à 1.8x pour éviter l'accumulation
                                balle.vitesseActive = true;
                                balle.vitesseFinTime = Date.now() + 60000; // 60s (1 minute complète)

                                // Effet visuel de traînée verte
                                balle.traineeVerte = true;

                                setTimeout(() => {
                                    balle.multiplicateurVitesse = 1; // Reset à 1 au lieu de diviser
                                    balle.vitesseActive = false;
                                    balle.traineeVerte = false;
                                }, 60000);

                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 15);console.log('💨 Mode vitesse TURBO activé (60s) - 1.8x plus rapide!');

                                // 🔊 Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple
                                afficherMessagePowerupSimple(getTranslatedText('powerups.turbo_speed', '💨 Vitesse turbo activée !'));
                            } else {
                            }
                            break;

                        case 'red_cross':
                            // Croix rouge : Frontières (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF0000', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('❌ 🗺️ 📏');
                            break;

                        case 'broken_heart':
                            // Cœur brisé : Refus et espoir brisé (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#8B0000', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('💔 🚫 😢');
                            break;

                        case 'gray_heart':
                            // Cœur gris : Liberté vs Prison (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#A9A9A9', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('🤍 🕊️ ⛓️');
                            break;

                        case 'black_heart':
                            // Cœur noir : Enfermement (très sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#2C2C2C', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('🖤 🌑 🔒');
                            break;

                        case 'chain':
                            // Chaînes : Pauvreté emprisonne (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#708090', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('🔗 💸 🚫');
                            break;

                        case 'barbed_wire':
                            // Barbelés : Frontières blessent (sombre)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#C0C0C0', 15);
                            AudioSystem.playDarkCollect(); // 🔊 Son sombre
                            afficherMessagePowerupSimple('🚧 🩸 ✋');
                            break;

                        case 'green_heart':
                            // Cœur vert : Nature, vie, espoir (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 15);
                            AudioSystem.playJoyfulCollect(); // 🔊 Son joyeux
                            afficherMessagePowerupSimple('💚 🌱 🌍');
                            break;

                        case 'yellow_heart':
                            // Cœur jaune : Joie, lumière, amitié (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFFF00', 15);
                            AudioSystem.playJoyfulCollect(); // 🔊 Son joyeux
                            afficherMessagePowerupSimple('💛 ☀️ 😊');
                            break;

                        case 'blue_heart':
                            // Cœur bleu : Paix, confiance, sérénité (joyeux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#0000FF', 15);
                            AudioSystem.playJoyfulCollect(); // 🔊 Son joyeux
                            afficherMessagePowerupSimple('💙 🕊️ 🌊');
                            break;

                        case 'purple_heart':
                            // Cœur violet : Spiritualité, sagesse, unité (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 15);
                            AudioSystem.playSoftCollect(); // 🔊 Son doux
                            afficherMessagePowerupSimple('💜 🔮 ✨');
                            break;

                        case 'vibrant_heart':
                            // Cœur vibrant : Espoir qui bat (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF1493', 15);
                            AudioSystem.playSoftCollect(); // 🔊 Son doux
                            afficherMessagePowerupSimple('💗 🌊 💪');
                            break;

                        case 'smile':
                            // Sourire : Joie et liberté retrouvée (pétillant)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 15);
                            AudioSystem.playSparkleCollect(); // 🔊 Son pétillant
                            afficherMessagePowerupSimple('😊 ☀️ 🕊️');
                            break;

                        case 'red_heart':
                            // Cœur rouge : Compassion refusée (doux)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF0000', 15);
                            AudioSystem.playSoftCollect(); // 🔊 Son doux
                            afficherMessagePowerupSimple('❤️ 💔 �');
                            break;

                        case 'open_hands':
                            // Mains transaction : Argent et privilèges (pièce)
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 15);
                            AudioSystem.playCoin(); // 🔊 Son de pièce (argent)
                            afficherMessagePowerupSimple('🤲 💰 �');
                            break;

                        case 'bonus_points':
                            // Points bonus (toujours cumulable) - augmenté !
                            score += 500; // 500 au lieu de 200
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 10);

                            // 🔊 Son de collecte power-up
                            AudioSystem.playCollect();

                            // Message simple
                            afficherMessagePowerupSimple(getTranslatedText('powerups.bonus_points', '💎 Bonus points +500'));
                            break;

                        case 'allume_lanterne':
                            // Allumer la lanterne si elle est éteinte
                            if(!lanterne.active) {
                                lanterne.active = true;
                                lanterne.intensite = 1.0;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 12);

                                // 🔊 Son de collecte power-up
                                AudioSystem.playCollect();

                                // Message simple
                                afficherMessagePowerupSimple(getTranslatedText('powerups.lantern_lit', '🏮 Lanterne allumée !'));
                            } else {
                                // Si déjà allumée, donner des points bonus
                                score += 300;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 8);

                                // 🔊 Son de collecte power-up
                                AudioSystem.playCollect();

                                afficherMessagePowerupSimple(getTranslatedText('powerups.lantern_bonus', '🏮 Lanterne +300 bonus'));
                            }
                            break;

                        case 'coeur':
                        default:
                            // Cœurs et autres types : +100 XP
                            score += 100;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 8);

                            // 🔊 Son de collecte
                            AudioSystem.playCollect();

                            // Message
                            afficherMessagePowerupSimple(getTranslatedText('powerups.heart_collected', '❤️ Cœur collecté !'));
                            break;
                    }

                    // Toujours supprimer le power-up après contact (même si effet ignoré)
                    powerUps.splice(i, 1);
                    }
                }
            }

            // Vérifier l'expiration des power-ups (4 secondes = 240 frames à 60fps)
            for(let i = powerUps.length - 1; i >= 0; i--) {
                const power = powerUps[i];
                
                // 🌈 EXCEPTION : Le power-up Espoir (Phase 22) ne doit JAMAIS expirer !
                if (power.type === 'rainbow_hope') {
                    continue; // Skip l'expiration pour ce power-up spécial
                }
                
                // ⏱️ TIMING CONDITIONNEL : Expiration uniquement pour phases 17-22 (mode mur)
                // Avant la phase 17, les power-ups restent jusqu'à être récupérés
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const phaseAvecTiming = phaseActuelle >= 17 && phaseActuelle <= 22;
                
                // Si le power-up a vécu plus de 4 secondes ET qu'on est en mode mur (phases 17-22)
                if(phaseAvecTiming && power.temps > 240) {
                    // Explosion visuelle
                    ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 20);
                    
                    // Donner 100 XP
                    score += 100;
                    
                    // Message d'expiration (throttle : max 1 toutes les 3 secondes)
                    const maintenant = Date.now();
                    if (maintenant - dernierMessageXP > 3000) {
                        afficherMessagePowerupSimple('💫 +100 XP');
                        dernierMessageXP = maintenant;
                    }
                    
                    // Supprimer le power-up
                    powerUps.splice(i, 1);
                    console.log(`⏱️ Power-up expiré après 4s (Phase ${phaseActuelle}) - +100 XP`);
                }
            }
        }

        // Fonction spéciale pour créer le power-up lanterne sur la première brique en bas
        function creerPowerUpLanterne() {
            // Trouver la brique la plus en bas (plus grand Y)
            let briqueLoPlus = null;
            let yMax = -1;

            briques.forEach(brique => {
                if(brique.visible && brique.y > yMax) {
                    yMax = brique.y;
                    briqueLoPlus = brique;
                }
            });

            // Si on a trouvé une brique en bas, y placer le power-up lanterne
            if(briqueLoPlus) {
                const powerUpLanterne = {
                    x: briqueLoPlus.x + briqueLoPlus.w/2 - C.BS * 0.75,
                    y: briqueLoPlus.y + briqueLoPlus.h/2 - C.BS * 0.75,
                    w: C.BS * 1.5,
                    h: C.BS * 1.5,
                    type: 'allume_lanterne',
                    temps: 0,
                    etincelles: [],
                    special: true // Marquer comme power-up spécial
                };

                powerUps.push(powerUpLanterne);
            }
        }

        // Créer une étoile qui monte vers le ciel
        function creerEtoileMontante(x, y) {
            // Créer l'étoile montante
            const etoile = {
                x: x,
                y: y,
                taille: 30,
                vitesseY: -3,
                temps: 0,
                alpha: 1,
                particules: []
            };

            // Animation de l'étoile qui monte
            const animer = () => {
                etoile.y += etoile.vitesseY;
                etoile.temps += 1;
                etoile.alpha = Math.max(0, 1 - etoile.temps / 120); // Disparaît en 2 secondes à 60fps

                // Dessiner l'étoile
                ctx.save();
                ctx.globalAlpha = etoile.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.font = `${etoile.taille}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('⭐', etoile.x, etoile.y);

                // Effet de traînée dorée
                for(let i = 0; i < 3; i++) {
                    const particuleX = etoile.x + (Math.random() - 0.5) * 20;
                    const particuleY = etoile.y + i * 15;
                    ctx.globalAlpha = etoile.alpha * (1 - i * 0.3);
                    ctx.fillStyle = `hsl(45, 100%, ${70 - i * 10}%)`;
                    ctx.font = `${etoile.taille * (1 - i * 0.2)}px serif`;
                    ctx.fillText('✨', particuleX, particuleY);
                }
                ctx.restore();

                // Continuer l'animation si l'étoile est encore visible
                if(etoile.alpha > 0 && etoile.y > -50) {
                    requestAnimationFrame(animer);
                }
            };

            requestAnimationFrame(animer);
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise à jour pendant l'animation
            if(lanterne.active && phaseJeu === 'lanterne') {
                // Effet de pulsation encore plus douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.001);

                // ⚡ OPTIMISATION: Créer des particules dorées BEAUCOUP plus rarement (0.5% au lieu de 2%)
                if(Math.random() < 0.005) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1 // Réduit à 1 particule au lieu de par défaut
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Créer une rafale de 1-3 cœurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // Éventail 40°
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // Départ légèrement dispersé
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, très grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // Délai entre chaque cœur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            // Optimisation pour vieux téléphones : calculs simplifiés
            
            // Mettre à jour les cœurs de lumière
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Montée rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Ondulation simple comme des bulles (droite à gauche)
                if(coeur.tempsOndulation === undefined) {
                    coeur.tempsOndulation = 0;
                }
                coeur.tempsOndulation += 0.02; // Vitesse d'ondulation ultra-lente (0.03 → 0.02)
                coeur.x += Math.cos(coeur.tempsOndulation) * 2; // Amplitude de 2 pixels

                // Supprimer si sort de l'écran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits cœurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // Vérifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // Cœur touché !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            if (petitCoeur.etape && petitCoeur.etape.nom) {
                                ajouterTexteVolant(`+${typeof petitCoeur.etape.nom === 'function' ? petitCoeur.etape.nom() : petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);
                            }

                            // 🔊 Son "pof" doux pour les petits cœurs
                            AudioSystem.playPof();

                            // Supprimer le cœur du bateau
                            coeursBateau.splice(i, 1);

                            // Vérifier si tous les cœurs du haut sont touchés
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // 🔊 Son "pof" doux pour l'explosion finale
                                AudioSystem.playExplosionCoeurs();

                                // 🎆 ANIMATION D'EXPLOSION PUIS PASSAGE AU MODE LANTERNE
                                animerExplosionIconeCollector(() => {
                                    // Passer au mode lanterne (casse-briques)
                                    phaseJeu = 'lanterne';
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    
                                    // Message de transition
                                    afficherMessagePowerupSimple(getTranslatedText('game.messages.lantern_mode_start', '🏮 Mode Lanterne activé !'));
                                    
                                    narrationManager.goToNextPhaseDirect();
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // Garder l'état de la lanterne de la phase précédente
                                    // lanterne.active et lanterne.intensite conservés
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    // Message géré par le nouveau système narratif

                                    // Créer quelques cœurs décoratifs qui flottent (différents de ceux du haut)
                                    setTimeout(() => {
                                        // Créer des cœurs décoratifs flottants au lieu de recréer les cœurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

    
                                        // Transition vers le jeu de briques après 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                });
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                // Bloquer complètement les collisions pendant le mode secret
                if (secretModeModule && secretModeModule.isActive) {
                    return; // Pas de collision avec les briques en mode secret
                }
                if (modeSecret) {
                    return; // Pas de collision avec les briques en mode secret (fallback)
                }

                // Vérifier d'abord s'il reste plus d'une brique pour éviter le passage automatique
                const briquesRestantes = briques.filter(b => b.visible).length;

                briques.forEach(brique => {
                    if(!brique.visible) return;

                    // Si il ne reste qu'une brique, les cœurs ne peuvent plus la casser
                    if(briquesRestantes <= 1 && (phaseJeu === 'lanterne' || phaseJeu === 'stars')) {
                        return; // Arrêter les collisions pour éviter la transition automatique
                    }

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // Délai anti-collision multiple (500ms)
                        const tempsActuel = Date.now();
                        if(brique.dernierCoup && tempsActuel - brique.dernierCoup < 500) {
                            return; // Ignorer si collision trop récente
                        }

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Supprimer le cœur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est détruite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // 🔊 Son de casse brique (aléatoire entre 3 sons)
                            const sonAleatoire = Math.random();
                            if (sonAleatoire < 0.33) {
                                AudioSystem.playBrickBreakToc();
                            } else if (sonAleatoire < 0.66) {
                                AudioSystem.playBrickBreakGlass();
                            } else {
                                AudioSystem.playBrickBreakCrack();
                            }

                            // ⚡ OPTIMISATION: En mode lanterne, réduire les particules de cœurs (1 au lieu de 3)
                            const nombreCoeurs = phaseJeu === 'lanterne' ? 1 : 3;
                            for(let j = 0; j < nombreCoeurs; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du cœur qui grossit et monte au ciel
                            // En mode lanterne : afficher seulement 1 texte sur 6 pour éviter la surcharge (optimisé de 1/4 à 1/6)
                            if (phaseJeu !== 'lanterne' || Math.random() < 0.17) {
                                ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                            }

                            // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        // Vérifier la condition de fin selon le mode de jeu
                        if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                            // Mode briques : vérifier si presque toutes les briques sont détruites (garder la dernière)
                            const briquesRestantes = briques.filter(b => b.visible).length;console.log(`🔍 Vérif briques restantes (collectePowerup): ${briquesRestantes}, phase: ${phaseJeu}`);
                            // Ne pas déclencher automatiquement si il reste seulement 1 brique
                            // Le joueur doit décider quand passer à la phase suivante
                            if(briquesRestantes === 0) {
                                // 🌈 EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collecté !
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                    // Vérifier si le power-up existe et n'est PAS collecté
                                    const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                    if (espoirPresent) {
                                        console.log('🌈 Phase 22 : Mur détruit mais power-up ESPOIR pas encore collecté (collectePowerup) !');
                                        console.log('   → La phase ne se termine pas automatiquement.');
                                        return; // ← Sortir sans transition ET sans animation
                                    }
                                }

                                console.log('🎆 TOUTES LES BRIQUES DÉTRUITES (collectePowerup)! Animation d\'explosion !');

                                // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    narrationManager.goToNextPhaseDirect();
                                });
                            }
                        } else if(brises >= VOYAGE.length) {
                            // Mode cœurs : progression classique basée sur VOYAGE

                            // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante après animation
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit délai supplémentaire après l'animation
                            });
                        }
                    }
                });
            }
        }

        // 🎆 ANIMATION D'EXPLOSION DE L'ICÔNE COLLECTOR ET COLLECTION AUTOMATIQUE D'ÉNIGME
        function animerExplosionIconeCollector(callback = null) {

            // Position de l'icône centrale thématique
            const centralIcon = menuEnigmesCanvas.centralIcon;

            // Si l'icône n'est pas encore positionnée, utiliser le centre de l'écran
            let explosionX, explosionY;
            if (centralIcon.x === 0 && centralIcon.y === 0) {
                explosionX = C.W / 2;
                explosionY = C.H / 2;
            } else {
                explosionX = centralIcon.x + centralIcon.width / 2;
                explosionY = centralIcon.y + centralIcon.height / 2;
            }

            // Animation d'explosion avec particules dorées
            if (typeof ajouterParticules === 'function') {
                ajouterParticules(explosionX, explosionY, '#FFD700', 15); // Explosion dorée
                ajouterParticules(explosionX, explosionY, '#FFA500', 10); // Explosion orange
                ajouterParticules(explosionX, explosionY, '#FFFF00', 8); // Explosion jaune
                ajouterParticules(explosionX, explosionY, '#FF4500', 5); // Explosion rouge-orange
            }

            // 🌧️ Pluie de célébration lors des transitions de phase
            setTimeout(() => {
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }, 1000); // Déclencher après 1 seconde d'explosion

            // Collection automatique d'énigme basée sur la phase actuelle
            if (enigmaCollector) {
                let enigmeAColleter = null;

                // Déterminer quelle énigme collecter selon la phase
                // Vérifier si on est dans les phases de mur (17-22)
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const estPhaseMur = phaseActuelle >= 17 && phaseActuelle <= 22;

                if (estPhaseMur) {
                    // Phases 17-22 : Collecter les énigmes du mur
                    const enigmesMur = ['avarice', 'mur_liberte', 'refus', 'privilege', 'inegalites', 'espoir_mur'];
                    enigmeAColleter = enigmesMur.find(id => !enigmaCollector.enigmesCollectees.has(id));
                } else {
                    switch(phaseJeu) {
                        case 'tir_coeurs_haut':
                        case 'petits_coeurs':
                        case 'coeurs':
                            // Phase cœurs - collecter une énigme de type "coeurs"
                            const enigmesCoeurs = ['humanite', 'diversite', 'respect', 'restauration'];
                            enigmeAColleter = enigmesCoeurs.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        case 'lanterne':
                            // Phase lanterne - collecter les énigmes de type "briques"
                            const enigmesBriques = ['paix', 'foi', 'hopital'];
                            enigmeAColleter = enigmesBriques.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        case 'stars':
                        case 'nuit_coeurs':
                            // Phase nuit cœurs - collecter les énigmes correspondantes
                            const enigmesNuit = ['liberte', 'entraide'];
                            enigmeAColleter = enigmesNuit.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;

                        default:
                            // Fallback - collecter n'importe quelle énigme disponible
                            const toutesEnigmes = Object.keys(ENIGMES_DATABASE).filter(id => id !== 'ange');
                            enigmeAColleter = toutesEnigmes.find(id => !enigmaCollector.enigmesCollectees.has(id));
                            break;
                    }
                }

                // Collecter l'énigme avec animation
                if (enigmeAColleter) {
                    //console.log(`🧩 TENTATIVE COLLECTION: ${enigmeAColleter} (phase: ${phaseJeu})`);
                    setTimeout(() => {
                        const success = enigmaCollector.collecterEnigme(enigmeAColleter, true);
                        //
                        if (success) {
                            //
                            // Message simple d'explosion - utilise la notification au lieu du gros afficherMessage
                            const enigme = ENIGMES_DATABASE[enigmeAColleter];
                            // La notification sera affichée par afficherNotificationCollection() automatiquement
                        } else {
                            //
                        }
                    }, 200);
                }
            }

            // Animation d'explosion plus visible avec flash et zoom dramatique
            let animationFrame = 0;
            const maxFrames = 300; // 5 secondes à 60 FPS - animation encore plus lente

            // Créer un flash blanc sur tout l'écran
            const createFlash = () => {
                const flashDiv = document.createElement('div');
                flashDiv.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: white;
                    z-index: 9999;
                    opacity: 0.8;
                    pointer-events: none;
                `;
                document.body.appendChild(flashDiv);

                // Fade out du flash
                let opacity = 0.8;
                const fadeFlash = () => {
                    opacity -= 0.05;
                    flashDiv.style.opacity = opacity;
                    if (opacity <= 0) {
                        document.body.removeChild(flashDiv);
                    } else {
                        requestAnimationFrame(fadeFlash);
                    }
                };
                requestAnimationFrame(fadeFlash);
            };

            // Flash immédiat
            createFlash();

            const animer = () => {
                if (animationFrame < maxFrames) {
                    animationFrame++;

                    // Effet de zoom plus dramatique
                    const progress = animationFrame / maxFrames;
                    let zoom;
                    if (progress < 0.2) {
                        // Implosion rapide
                        zoom = 1 - progress * 2;
                    } else if (progress < 0.6) {
                        // Explosion dramatique
                        zoom = 0.6 + (progress - 0.2) * 5;
                    } else {
                        // Retour normal avec oscillation
                        const oscillation = Math.sin((progress - 0.6) * Math.PI * 4) * 0.2;
                        zoom = 1.2 - (progress - 0.6) * 0.5 + oscillation;
                    }

                    // Sauvegarder l'état original de l'icône
                    if (animationFrame === 1) {
                        menuEnigmesCanvas.centralIcon.originalSize = menuEnigmesCanvas.centralIcon.width;
                    }

                    // Modifier la taille de l'icône
                    const newSize = Math.max(5, menuEnigmesCanvas.centralIcon.originalSize * zoom); // Minimum 5px
                    menuEnigmesCanvas.centralIcon.width = newSize;
                    menuEnigmesCanvas.centralIcon.height = newSize;

                    // Debug désactivé pour réduire les logs

                    requestAnimationFrame(animer);
                } else {
                    // Restaurer la taille originale
                    if (menuEnigmesCanvas.centralIcon.originalSize) {
                        menuEnigmesCanvas.centralIcon.width = menuEnigmesCanvas.centralIcon.originalSize;
                        menuEnigmesCanvas.centralIcon.height = menuEnigmesCanvas.centralIcon.originalSize;
                        delete menuEnigmesCanvas.centralIcon.originalSize;
                    }

                    // Exécuter le callback après l'animation avec un délai pour les textes narratifs
                    if (callback && typeof callback === 'function') {
                        setTimeout(() => {
                            callback();
                        }, 500); // Délai de 500ms pour permettre aux textes narratifs de s'afficher
                    }
                }
            };

            animer();
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';
                const t = coeur.taille;
                
                // Forme de cœur simplifiée (moins de points que l'original)
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1; // Contour blanc fin
                
                ctx.beginPath();
                ctx.moveTo(coeur.x, coeur.y + t * 0.3); // Pointe du bas
                
                // Côté gauche simplifié
                ctx.lineTo(coeur.x - t * 0.15, coeur.y);
                ctx.lineTo(coeur.x - t * 0.2, coeur.y - t * 0.1);
                ctx.lineTo(coeur.x - t * 0.1, coeur.y - t * 0.15);
                
                // Haut centre
                ctx.lineTo(coeur.x, coeur.y - t * 0.05);
                
                // Côté droit simplifié
                ctx.lineTo(coeur.x + t * 0.1, coeur.y - t * 0.15);
                ctx.lineTo(coeur.x + t * 0.2, coeur.y - t * 0.1);
                ctx.lineTo(coeur.x + t * 0.15, coeur.y);
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke(); // Contour blanc fin
            });
        }

        // Petits cœurs décoratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];

            // Vérifier que VOYAGE est initialisé
            if (!VOYAGE || VOYAGE.length === 0) {console.log('⏳ creerPetitsCoeurs() - Attente initialisation tableaux (VOYAGE:', VOYAGE.length, 'JOUR:', JOUR.length, 'NUIT:', NUIT.length, ')');
                return;
            }

            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Créer un visage rond avec les cœurs - PLUS GRAND
            const centreX = C.W / 2;
            // Position différente en mode mur : juste sous le header (10%)
            const centreY = (phaseJeu === 'mur') ? C.H * 0.10 : C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.22; // Rayon du visage agrandi (0.22 au lieu de 0.15)

            for(let i = 0; i < 40; i++) { // 40 cœurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles variées

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // Répartir sur 360°
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // Légère variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // Légère variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut être cassé
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une étape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.012, // ✅ Augmenté de 0.008 à 0.012 (un peu plus rapide)
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02,
                });
            }
        }

        // 🧱 Mots philosophiques pour les phases mur (17-22)
        const MOTS_MUR = {
            17: ['cupidité', 'avarice', 'égoïsme', 'richesse', 'accumulation', 'profit', 'matériel', 'possession', 'avidité', 'convoitise'],
            18: ['racisme', 'génocide', 'esclavage', 'manipulation', 'abus', 'oppression', 'haine', 'violence', 'discrimination', 'cruauté'],
            19: ['refus', 'rejet', 'exclusion', 'fermeture', 'déni', 'blocage', 'opposition', 'résistance', 'négation', 'abandon'],
            20: ['orgueil', 'ego', 'arrogance', 'fierté', 'vanité', 'supériorité', 'mépris', 'hautain', 'dominance', 'prétention'],
            21: ['inégalité', 'injustice', 'privilège', 'pauvreté', 'richesse', 'écart', 'discrimination', 'déséquilibre', 'oppression', 'exploitation'],
            22: ['espoir', 'rêve', 'promesse', 'avenir', 'liberté', 'bonheur', 'paix', 'unité', 'horizon', 'lumière']
        };

        // 🧱 Créer un mur vertical dans la mer - UN SEUL BLOC avec dessin pixel art dedans
        function creerMurDansLaMer() {
            // Cacher/supprimer tous les petits cœurs et éléments précédents
            petitsCoeurs = [];
            coeursBateau = [];

            // Configuration selon la phase actuelle
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 17;

            // Obtenir les mots philosophiques pour cette phase
            const motsPhase = MOTS_MUR[phaseActuelle] || MOTS_MUR[17];
            let forme = 'mur';
            let couleurMur = '#888888';

            switch(phaseActuelle) {
                case 17: forme = 'montagne'; couleurMur = '#6B5B5B'; break;
                case 18: forme = 'prison'; couleurMur = '#3A3A3A'; break;
                case 19: forme = 'barbeles'; couleurMur = '#8B4513'; break;
                case 20: forme = 'porte'; couleurMur = '#DAA520'; break;
                case 21: forme = 'pyramide'; couleurMur = '#696969'; break;
                case 22: forme = 'fissure'; couleurMur = '#7B8A9E'; break;
            }

            // UN SEUL BLOC : du header (15%) au centre (50%)
            const zoneHauteur = C.H * 0.35; // 35% de hauteur (de 15% à 50%)
            const zoneDebut = C.H * 0.15; // Commence après le header

            // Grille pixel art avec briques RECTANGULAIRES (format réel 2:1)
            const nbColonnes = 13; // 13 colonnes pour tenir dans les bords
            const nbLignes = 12; // 12 lignes
            const largeurBrique = C.W * 0.8 / nbColonnes; // Rectangle
            const hauteurBrique = largeurBrique / 2; // Hauteur = moitié de la largeur (ratio 2:1)
            const startX = C.W * 0.1; // Commence à 10% (centré)
            const startY = zoneDebut;

            // Créer les briques - BLOC PLEIN avec motif pixel art coloré dedans
            let briqueIndex = 0;
            const totalBriques = nbColonnes * nbLignes; // 40×30 = 1200

            for(let ligne = 0; ligne < nbLignes; ligne++) {
                for(let col = 0; col < nbColonnes; col++) {
                    // TOUJOURS dessiner un bloc (mur plein)
                    const centre = Math.floor(nbColonnes / 2);
                    const hauteurDepuisBas = nbLignes - ligne - 1;

                    // Déterminer la couleur selon la forme et la position
                    let couleurBrique = couleurMur; // Couleur de base
                    let estMotif = false; // Pour savoir si c'est un motif spécial

                    if(forme === 'montagne') {
                        // Montagne triangulaire avec neige (grille 13×12)
                        const largeur = Math.floor(hauteurDepuisBas * 0.65);
                        const dansTriangle = (col >= centre - largeur && col <= centre + largeur);

                        if(dansTriangle) {
                            // Gradient vertical dans la montagne
                            if(ligne <= 2) couleurBrique = '#FFFFFF'; // Neige
                            else if(ligne <= 5) couleurBrique = '#B0B0B0';
                            else if(ligne <= 8) couleurBrique = '#808080';
                            else couleurBrique = '#6B5B5B';
                        } else {
                            couleurBrique = '#1a1a2e'; // Ciel sombre autour
                        }

                    } else if(forme === 'prison') {
                        // Barreaux noirs sur fond gris (grille 13×12)
                        if(col % 3 === 0) {
                            couleurBrique = '#1A1A1A'; // Barreaux noirs
                            estMotif = true;
                        } else {
                            couleurBrique = '#505050'; // Mur gris
                        }

                    } else if(forme === 'barbeles') {
                        // Lignes de barbelés (grille 13×12)
                        const lignes = [2, 5, 8, 11];
                        if(lignes.includes(ligne)) {
                            couleurBrique = '#A0522D'; // Fil rouille
                            estMotif = true;
                        } else if(lignes.includes(ligne - 1) && col % 2 === 0) {
                            couleurBrique = '#5A3010'; // Pics
                            estMotif = true;
                        } else if(lignes.includes(ligne + 1) && col % 2 === 1) {
                            couleurBrique = '#5A3010'; // Pics
                            estMotif = true;
                        } else {
                            couleurBrique = '#2a2a2a'; // Fond sombre
                        }

                    } else if(forme === 'porte') {
                        // Mur doré avec porte noire et colonnes oranges (grille 13×12)
                        const dansPorte = (col >= centre - 2 && col <= centre + 2) && (ligne >= 5);
                        const colonneOrange = (col >= 5 && col <= 7); // Colonnes 5, 6, 7

                        if(dansPorte) {
                            couleurBrique = '#1a1a1a'; // Porte (passage noir)
                        } else if(colonneOrange) {
                            couleurBrique = '#FF8C00'; // Orange vif
                        } else if(col <= centre - 3 || col >= centre + 3) {
                            couleurBrique = '#FFD700'; // Or brillant
                        } else {
                            couleurBrique = '#DAA520'; // Or normal
                        }

                    } else if(forme === 'pyramide') {
                        // Escalier avec gradient social (grille 13×12)
                        const marche = Math.floor(col * 0.7);
                        const dansEscalier = (ligne >= nbLignes - marche - 1);

                        if(dansEscalier) {
                            // Gradient vertical
                            if(ligne <= 3) couleurBrique = '#D3D3D3'; // Riches
                            else if(ligne <= 6) couleurBrique = '#A0A0A0';
                            else if(ligne <= 9) couleurBrique = '#808080';
                            else couleurBrique = '#696969'; // Pauvres
                        } else {
                            couleurBrique = '#1a1a1a'; // Vide noir
                        }

                    } else if(forme === 'fissure') {
                        // Mur avec fissure noire (grille 13×12)
                        const estFissure = (col === centre) && (ligne >= 3);
                        if(estFissure) {
                            couleurBrique = '#000000'; // Fissure noire
                        } else {
                            // Gradient d'usure
                            if(ligne <= 4) couleurBrique = '#9BA5B0';
                            else if(ligne <= 8) couleurBrique = '#8595A5';
                            else couleurBrique = '#7B8A9E';
                        }
                    }

                    // Utiliser les mots philosophiques pour les briques du mur
                    const motPhilo = motsPhase[briqueIndex % motsPhase.length];
                    const etape = {
                        nom: motPhilo,
                        msg: motPhilo // Message simple
                    };

                    // POSE EN QUINCONCE : décalage d'une demi-brique pour lignes impaires
                    const decalage = (ligne % 2 === 1) ? largeurBrique / 2 : 0;

                    briques.push({
                        x: startX + col * largeurBrique + decalage,
                        y: startY + ligne * hauteurBrique,
                        largeur: largeurBrique,
                        hauteur: hauteurBrique,
                        w: largeurBrique,
                        h: hauteurBrique,
                        couleur: couleurBrique,
                        visible: true,
                        etape: etape,
                        vie: 1,
                        scintillement: Math.random() * Math.PI * 2,
                        type: 'mur'
                    });

                    briqueIndex++;
                }
            }

            // 🌈 Phase 22 UNIQUEMENT : Créer un power-up ESPOIR caché derrière le mur
            if (narrationManager && narrationManager.currentPhase === 22) {
                // ✅ PROTECTION : Ne créer le rainbow_hope que s'il n'existe pas déjà !
                // Évite la duplication quand le mur se recrée (après destruction mais avant collecte)
                if (!powerUps) powerUps = [];
                const espoirExiste = powerUps.some(p => p.type === 'rainbow_hope');
                
                if (!espoirExiste) {
                    // Positionner au centre, dans la 3e ligne du mur (ligne index 2) - plus profond !
                    const ligneCache = 2; // Troisième ligne (index 2) - plus caché !
                    const yPowerUp = startY + (ligneCache * hauteurBrique) + (hauteurBrique / 2) - 15; // -15 pour centrer (30/2)
                    
                    const powerUpEspoir = {
                        x: C.W / 2 - 15, // Centre horizontal (décalé de la moitié de la largeur - 30/2)
                        y: yPowerUp, // Dans la 3e ligne du mur, au centre vertical de la brique
                        w: 30, // ← Plus discret ! (réduit de 60)
                        h: 30, // ← Plus discret ! (réduit de 60)
                        type: 'rainbow_hope', // Type spécial arc-en-ciel
                        emoji: '🌈',
                        visible: true,
                        temps: 0,
                        collected: false,
                        decouvert: false, // ← Nouveau : pour détecter la première découverte
                        colorIndex: 0,
                        colors: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3']
                    };
                    
                    powerUps.push(powerUpEspoir);
                    
                    console.log('🌈 Power-up ESPOIR créé dans le mur en phase 22 (ligne 2, centre) !');
                    console.log('   Position:', powerUpEspoir.x.toFixed(1), powerUpEspoir.y.toFixed(1));
                    console.log('   StartY du mur:', startY.toFixed(1));
                    console.log('   Hauteur brique:', hauteurBrique.toFixed(1));
                    console.log('   Type:', powerUpEspoir.type);
                    console.log('   Total power-ups:', powerUps.length);
                } else {
                    console.log('🌈 Power-up ESPOIR déjà présent - pas de duplication !');
                }
            }
        }

        // Générer des positions en forme de cœur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du cœur

            // Générer des positions selon l'équation paramétrique d'un cœur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Paramètre de 0 à 2π

                // Équation paramétrique d'un cœur : x = 16sin³(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise à l'échelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function creerBriquesDrapeaux() {
            // Nettoyer les éléments précédents
            petitsCoeurs = [];
            coeursBateau = [];

            // Taille des briques
            const largeurBrique = 80;
            const hauteurBrique = 40;
            const rows = 5;
            const cols = Math.floor(C.W / largeurBrique);
            const startX = (C.W - (cols * largeurBrique)) / 2;
            const startY = 80;

            // Drapeaux disponibles
            const drapeaux = languageSelector.buttons;

            // Créer les briques drapeaux
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const drapeau = drapeaux[Math.floor(Math.random() * drapeaux.length)];

                    briques.push({
                        x: startX + col * largeurBrique,
                        y: startY + row * hauteurBrique,
                        w: largeurBrique - 5,
                        h: hauteurBrique - 5,
                        largeur: largeurBrique - 5,
                        hauteur: hauteurBrique - 5,
                        visible: true,
                        drapeau: drapeau.drapeau,
                        langCode: drapeau.code,
                        langNom: drapeau.nom,
                        couleur: 'rgba(255, 255, 255, 0.2)',
                        vie: 1,
                        type: 'drapeau'
                    });
                }
            }
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits cœurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les cœurs résiduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le cœur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // Générer les positions en forme de cœur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Créer les briques selon la disposition en cœur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: 2,     // 2 vies pour toutes les briques
                    vie: 2,        // Vie actuelle
                    clignotement: 0, // Animation quand touchée
                    // Animation de dédoublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }
            
            // 🚀 OPTIMISATION : Reconstruire la grille spatiale après création des briques
            mettreAJourGrilleSpatiale();

            // Placer automatiquement le power-up lanterne sur la première brique en bas
            // Mais seulement en phase lanterne et si la lanterne n'est pas déjà allumée
            if(phaseJeu === 'lanterne' && !lanterne.active) {
                setTimeout(() => {
                    creerPowerUpLanterne();
                }, 500); // Petit délai pour laisser les briques se placer
            }
        }

        function libererVaguesAmour() {
            // Ne libérer des vagues d'amour que si le jeu est actif
            if (!jeu || (phaseIntro && phaseIntro.active)) return;

            const tempsActuel = Date.now();

            // Mode étoile cœur activé par power-up
            if(window.modeEtoileCoeur && window.modeEtoileCoeur.actif) {
                if(Date.now() > window.modeEtoileCoeur.fin) {
                    window.modeEtoileCoeur.actif = false;
                } else if(tempsActuel - derniereCreeRafale >= 200) { // Plus fréquent pendant le power-up
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
            // Mode normal
            else if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : libérer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : libérer l'amour seulement pour la dernière brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        // ⚡ OPTIMISATION: Limiter les updates d'animation à 60fps
        let _derniereUpdateCoeurs = 0;
        const _intervalUpdateCoeurs = 16; // 60fps (16ms)

        function mettreAJourPetitsCoeurs() {
            // ⚡ Skip si pas assez de temps écoulé (throttling à 60fps)
            const now = Date.now();
            if (now - _derniereUpdateCoeurs < _intervalUpdateCoeurs) return;
            _derniereUpdateCoeurs = now;

            petitsCoeurs.forEach((coeur, index) => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;

            });
        }

        // Fonction pour dessiner des cœurs avec 20 triangles (pour les briques)
        // ⚡ CACHE pour optimiser dessinerCoeurPixelArt
        let _coeurPixelCache = {
            lastUpdate: 0,
            pulsation: 1,
            updateInterval: 50 // Mise à jour toutes les 50ms (20fps) au lieu de 60fps
        };

        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            
            // ⚡ OPTIMISATION: Cache pulsation (20fps au lieu de 60fps)
            const now = Date.now();
            if (now - _coeurPixelCache.lastUpdate > _coeurPixelCache.updateInterval) {
                _coeurPixelCache.pulsation = 1 + Math.sin(now * 0.003) * 0.1; // Réduit de 0.15 à 0.1
                _coeurPixelCache.lastUpdate = now;
            }

            // Appliquer la pulsation cachée
            ctx.scale(_coeurPixelCache.pulsation, _coeurPixelCache.pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            // ⚡ CŒUR SIMPLIFIÉ: Forme basique (moins de points)
            ctx.beginPath();
            
            // Forme simplifiée avec seulement 8 points
            ctx.moveTo(-t * 0.25, 0);
            ctx.lineTo(-t * 0.15, -t * 0.15);
            ctx.lineTo(0, -t * 0.05);
            ctx.lineTo(t * 0.15, -t * 0.15);
            ctx.lineTo(t * 0.25, 0);
            ctx.lineTo(t * 0.1, t * 0.15);
            ctx.lineTo(0, t * 0.3);
            ctx.lineTo(-t * 0.1, t * 0.15);
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // ⚡ OPTIMISATION: Pas de détails intérieurs (trop coûteux pour des briques)
            // Supprimé: petits cœurs intérieurs et point lumineux

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // Cœur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // Côtés qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        // ⚡ VERSION OPTIMISÉE sans save/restore individuel (appelée dans un batch)
        function dessinerCoeurPolygonalOptimise(x, y, taille, couleur, rotation = 0, intensite = 1) {
            const t = taille;

            // ⚡ Sauvegarder l'état seulement si rotation nécessaire
            const needTransform = rotation !== 0;
            if (needTransform) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
            }

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // ⚡ Utiliser translate au lieu de save/restore si pas de rotation
            const offsetX = needTransform ? 0 : x;
            const offsetY = needTransform ? 0 : y;

            // Cœur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche
            ctx.moveTo(offsetX + -t * 0.3, offsetY + -t * 0.05);
            ctx.lineTo(offsetX + -t * 0.2, offsetY + -t * 0.2);
            ctx.lineTo(offsetX + -t * 0.1, offsetY + -t * 0.15);
            ctx.lineTo(offsetX + -t * 0.05, offsetY + -t * 0.05);

            // Lobe droit
            ctx.lineTo(offsetX + t * 0.05, offsetY + -t * 0.05);
            ctx.lineTo(offsetX + t * 0.1, offsetY + -t * 0.15);
            ctx.lineTo(offsetX + t * 0.2, offsetY + -t * 0.2);
            ctx.lineTo(offsetX + t * 0.3, offsetY + -t * 0.05);

            // Côtés qui descendent vers la pointe
            ctx.lineTo(offsetX + t * 0.15, offsetY + t * 0.1);
            ctx.lineTo(offsetX + 0, offsetY + t * 0.4);
            ctx.lineTo(offsetX + -t * 0.15, offsetY + t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            if (needTransform) {
                ctx.restore();
            }
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits cœurs pendant l'animation du bateau, la phase lanterne, stars, final ou feux d'artifice
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'final' || phaseJeu === 'feux_artifice') return;

            // ⚡ OPTIMISATION: Batching - un seul save/restore pour tous les cœurs
            ctx.save();
            
            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // ⚡ OPTIMISATION: Calculs d'animation simplifiés
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le cœur polygonal sans save/restore individuel
                dessinerCoeurPolygonalOptimise(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });
            
            ctx.restore();

            // Dessiner l'icône thématique au centre du cercle de cœurs
            dessinerIconeThematique();
        }

        // ⚡ OPTIMISATION ULTRA: Variables de cache pour l'animation
        let _iconeTempsCached = 0;
        let _iconePulsationCached = 1;
        let _iconeRotationCached = 0;
        let _iconeLastUpdate = 0;
        let _iconeCache = {
            icone: '💖',
            font: '28px Arial',
            hover: false,
            needsUpdate: true
        };

        // Fonction optimisée pour dessiner l'icône centrale
        function dessinerIconeCentrale(isPhase23 = false) {
            // Ne pas afficher l'icône si l'animation est en cours (sauf Phase 23)
            if (!isPhase23 && animationIconeMenu.active) return;

            // Position selon la phase (cachée)
            const centerX = C.W / 2;
            const centerY = isPhase23 ? 60 : C.H * 0.30;
            const iconSize = 60;

            // Zone cliquable mise à jour seulement si nécessaire
            if (_iconeCache.needsUpdate) {
                menuEnigmesCanvas.centralIcon.x = centerX - iconSize / 2;
                menuEnigmesCanvas.centralIcon.y = centerY - iconSize / 2;
                menuEnigmesCanvas.centralIcon.width = iconSize;
                menuEnigmesCanvas.centralIcon.height = iconSize;
                _iconeCache.needsUpdate = false;
            }

            // ⚡ OPTIMISATION: Recalculer l'animation à 30fps au lieu de 60fps (économie CPU)
            const now = Date.now();
            if (now - _iconeLastUpdate > 33) { // 30fps = 33ms
                _iconeTempsCached = now * 0.003;
                const pulsationBase = menuEnigmesCanvas.centralIcon.hover ? 0.2 : 0.1; // Réduit de 25%/15% à 20%/10%
                _iconePulsationCached = 1 + Math.sin(_iconeTempsCached) * pulsationBase;
                _iconeRotationCached = Math.sin(_iconeTempsCached * 0.5) * 0.05; // Réduit de 0.08 à 0.05
                _iconeLastUpdate = now;
            }

            // Déterminer l'icône (avec cache)
            if (_iconeCache.needsUpdate || _iconeCache.hover !== menuEnigmesCanvas.centralIcon.hover) {
                if (!isPhase23) {
                    const iconesThematiques = {
                        'humanite': '🤝', 'paix': '🕊️', 'diversite': '🌈', 'liberte': '🗽',
                        'foi': '🙏', 'respect': '🤲', 'entraide': '💞', 'hopital': '🏥',
                        'restauration': '🌱', 'coeurs': '💖', 'liberation': '🕊️',
                        'guerison': '✨', 'renaissance': '🌸', 'transformation': '🦋',
                        'elevation': '🌟', 'illumination': '💫'
                    };
                    _iconeCache.icone = iconesThematiques[phaseJeu] || '💖';
                    _iconeCache.font = '28px Arial';
                } else {
                    _iconeCache.icone = '❤️';
                    _iconeCache.font = '50px Arial';
                }
                _iconeCache.hover = menuEnigmesCanvas.centralIcon.hover;
                detecterFinNiveau();
            }

            // Rendu optimisé avec un seul save/restore
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Bordure hover simplifiée (sans shadowBlur coûteux)
            if (menuEnigmesCanvas.centralIcon.hover) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2; // Réduit de 3 à 2
                ctx.beginPath();
                ctx.arc(0, 0, 30 * _iconePulsationCached, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.rotate(_iconeRotationCached);
            ctx.scale(_iconePulsationCached, _iconePulsationCached);

            // Affichage de l'icône (optimisé)
            ctx.font = _iconeCache.font;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            
            // Effet de lueur simplifié (sans shadowBlur)
            ctx.fillText(_iconeCache.icone, 0, 0);

            ctx.restore();
        }

        // Alias pour compatibilité
        function dessinerIconeCentraleP23() {
            dessinerIconeCentrale(true);
        }

        function dessinerIconeThematique() {
            dessinerIconeCentrale(false);
        }

        // Détecter quand un niveau est terminé
        function detecterFinNiveau() {
            let niveauTermine = false;

            // Pour les phases de cœurs : quand tous les cœurs sont cassés
            if (phaseJeu === 'petits_coeurs') {
                const coeursVisibles = petitsCoeurs.filter(coeur => coeur.visible).length;
                niveauTermine = coeursVisibles === 0;
            }

            // Pour les phases de briques : quand toutes les briques sont cassées
            else if (phaseJeu === 'briques' || phaseJeu === 'lanterne') {
                const briquesVisibles = briques.filter(brique => brique.visible).length;
                niveauTermine = briquesVisibles === 0;
            }

            // Pour les autres phases basées sur la variable brises
            else if (phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'coeurs' || phaseJeu === 'stars' || phaseJeu === 'nuit_coeurs') {
                niveauTermine = brises >= VOYAGE.length;
            }

            // 🎆 Si le niveau est terminé, déclencher l'animation d'explosion
            if (niveauTermine && !window.niveauTermineDejaDeclenche) {

                // Éviter les déclenchements multiples
                window.niveauTermineDejaDeclenche = true;

                // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante après animation
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                        // Réinitialiser le flag pour le prochain niveau
                        window.niveauTermineDejaDeclenche = false;
                    }, 500);
                });
            }

            return niveauTermine;
        }

        // Système de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // ⚡ OPTIMISATION MODE LANTERNE: Réduire drastiquement les particules
            if (phaseJeu === 'lanterne') {
                nombre = Math.ceil(nombre * 0.3); // 70% de réduction !
            }
            
            // Limite stricte pour éviter les bugs de performance
            const maxParticules = phaseJeu === 'lanterne' ? 60 : 120; // Encore plus strict en mode lanterne
            if(particules.length + nombre > maxParticules) {
                const aSupprimer = (particules.length + nombre) - maxParticules;
                particules.splice(0, aSupprimer); // Supprimer les plus anciennes
            }

            // Ralentir 3x dans les phases lanterne et stars
            const vitesseFactor = (phaseJeu === 'lanterne' || phaseJeu === 'stars') ? 1.33 : 4;

            for(let i = 0; i < nombre; i++) {
                // 10% étoiles, 30% ronds, 60% traits lumineux
                const rand = Math.random();
                let typeParticule;
                if(rand < 0.1) typeParticule = 'etoile';
                else if(rand < 0.4) typeParticule = 'rond';
                else typeParticule = 'trait_lumineux';

                // Direction plus aléatoire pour les ronds
                const angleAleatoire = Math.random() * Math.PI * 2;
                const vitesseAleatoire = Math.random() * vitesseFactor * 1.5;

                particules.push({
                    x, y,
                    vx: typeParticule === 'rond' ? Math.cos(angleAleatoire) * vitesseAleatoire : (Math.random() - 0.5) * vitesseFactor,
                    vy: typeParticule === 'rond' ? Math.sin(angleAleatoire) * vitesseAleatoire : (Math.random() - 0.5) * vitesseFactor,
                    couleur,
                    vie: Math.random() * 40 + 20, // Réduit : 20-60 au lieu de 30-90
                    taille: Math.random() * 6 + 2, // Plus grosses
                    type: typeParticule,
                    rotation: 0, // ⚡ Rotation fixe (0 au lieu de random)
                    rotationSpeed: 0.03, // ⚡ Vitesse fixe (au lieu de random)
                    longueur: Math.random() * 30 + 15, // Pour les traits lumineux
                    angle: Math.random() * Math.PI * 2 // Angle du trait
                });
            }
        }

        // ✨ PLUIE RÊVEUSE - Traits blancs lumineux avec traînées fines
        function declencherPluieLumineuse() {
            // 🔊 Son d'averse (pluie forte courte)
            AudioSystem.playAverse();

            for(let i = 0; i < 50; i++) { // Réduit de 80 à 50
                setTimeout(() => {
                    // Créer des traits blancs oniriques
                    particules.push({
                        x: Math.random() * C.W,
                        y: -30,
                        vx: 0, // Pas de dérive horizontale
                        vy: Math.random() * 2 + 4, // Chute verticale pure
                        couleur: ['#FFFFFF', '#F8F8FF', '#FFFACD'][Math.floor(Math.random() * 3)], // Blancs nuancés
                        vie: 100, // Réduit de 120 à 100
                        taille: 2, // Plus épais pour être visible
                        type: 'trait_lumineux',
                        longueur: Math.random() * 35 + 30, // Traînées plus longues
                        angle: Math.PI / 2, // Parfaitement vertical
                        rotation: 0,
                        rotationSpeed: 0,
                        opacity: Math.random() * 0.4 + 0.6 // Plus opaque
                    });
                }, i * 80); // Plus espacé dans le temps
            }
        }

        // 🌧️ DEUX TYPES DE PLUIE :
        // 1. declencherPluieLumineuse() - Pluie d'AVERSE (80 traits lumineux blancs, gros, rapide, ponctuel)
        // 2. Pluie DOUCE ci-dessous - Pluie continue légère (gouttes bleues fines, permanente en phase 5)

        function activerParticulesP5() {
            // Activer la pluie douce continue pour la phase 5
            pluieActive = true;

            // 🔊 Démarrer le son de pluie en boucle
            AudioSystem.startRainLoop();
        }

        function desactiverPluie() {
            pluieActive = false;
            gouttesPlui = [];

            // 🔊 Arrêter le son de pluie
            AudioSystem.stopRainLoop();
        }

        // Créer des gouttes de pluie douce (continue)
        function creerGouttesPluie() {
            if (!pluieActive) return;

            // Créer 2-3 gouttes par frame pour un effet continu mais léger
            const nbGouttes = Math.random() < 0.7 ? 2 : 3;

            for (let i = 0; i < nbGouttes; i++) {
                gouttesPlui.push({
                    x: Math.random() * C.W,
                    y: -10,
                    vitesse: 3 + Math.random() * 2, // Vitesse entre 3 et 5
                    longueur: 8 + Math.random() * 8, // Longueur entre 8 et 16
                    alpha: 0.3 + Math.random() * 0.3 // Transparence variable
                });
            }

            // Limiter le nombre de gouttes pour les performances
            if (gouttesPlui.length > 150) {
                gouttesPlui = gouttesPlui.slice(-150);
            }
        }

        // Mettre à jour les gouttes de pluie
        function mettreAJourPluie() {
            if (!pluieActive) return;

            for (let i = gouttesPlui.length - 1; i >= 0; i--) {
                const goutte = gouttesPlui[i];
                goutte.y += goutte.vitesse;

                // Retirer les gouttes qui sortent de l'écran
                if (goutte.y > C.H + 20) {
                    gouttesPlui.splice(i, 1);
                }
            }
        }

        // Dessiner les gouttes de pluie
        function dessinerPluie() {
            if (!pluieActive || gouttesPlui.length === 0) return;

            ctx.save();
            ctx.strokeStyle = '#A0C4E0'; // Bleu clair
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';

            for (const goutte of gouttesPlui) {
                ctx.globalAlpha = goutte.alpha;
                ctx.beginPath();
                ctx.moveTo(goutte.x, goutte.y);
                ctx.lineTo(goutte.x, goutte.y + goutte.longueur);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Particules en forme de petits cœurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // ⚡ OPTIMISATION MODE LANTERNE: Réduire drastiquement les particules de cœurs
            if (phaseJeu === 'lanterne') {
                nombre = Math.ceil(nombre * 0.25); // 75% de réduction !
            }
            
            // Limiter le nombre total de particules pour les performances
            const maxParticules = phaseJeu === 'lanterne' ? 100 : 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 2, // Dispersion horizontale réduite
                    vy: -(Math.random() * 3 + 2),  // Vitesse verticale réduite
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            // Permettre la pluie émotionnelle même pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIMÉ - autoriser les particules

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                // 🌟 Rotation optimisée - uniquement pour emoji et étoiles
                if(p.rotation !== undefined && (p.type === 'emoji' || p.type === 'etoile')) {
                    p.rotation += p.rotationSpeed;
                }

                if(p.type === 'coeur') {
                    // Cœurs : pas de gravité, continuent vers le haut
                    p.vy *= 0.99; // Légère décélération
                } else if(p.type === 'etoile') {
                    // Étoiles : mouvement flottant avec scintillement
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.vy += Math.sin(Date.now() * 0.005 + i) * 0.1; // Mouvement ondulant
                } else if(p.type === 'trait_lumineux') {
                    // ✨ Traits rêveurs : chute verticale pure
                    p.vy += 0.05; // Gravité très légère
                    // Pas d'oscillation horizontale - pluie droite
                    // Angle reste vertical
                    p.angle = Math.PI / 2;
                } else {
                    // Particules normales : gravité
                    p.vy += 0.15;
                }

                // Système de vie normalisé
                p.vie -= (p.type === 'coeur' ? 0.8 : 0.6); // Cœurs durent plus longtemps

                // Supprimer les particules qui sortent de l'écran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            // Permettre la pluie émotionnelle même pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIMÉ - autoriser les particules

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = Math.max(0.1, p.vie * 0.8); // Minimum d'opacité pour voir les particules
                ctx.fillStyle = p.couleur;

                // Appliquer l'effet de lueur AVANT le dessin
                if(p.type !== 'trait_lumineux') {
                    ctx.shadowColor = p.couleur;
                    ctx.shadowBlur = p.taille * 1.5;
                }

                if(p.type === 'coeur') {
                    // Dessiner petit cœur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du cœur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du cœur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du cœur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else if(p.type === 'etoile') {
                    // 🌟 Étoile simple sans rotation
                    ctx.translate(p.x, p.y);
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angleExt = (i * 2 * Math.PI) / 5;
                        const angleInt = ((i + 0.5) * 2 * Math.PI) / 5;
                        const xExt = Math.cos(angleExt) * p.taille;
                        const yExt = Math.sin(angleExt) * p.taille;
                        const xInt = Math.cos(angleInt) * p.taille * 0.5;
                        const yInt = Math.sin(angleInt) * p.taille * 0.5;

                        if(i === 0) ctx.moveTo(xExt, yExt);
                        else ctx.lineTo(xExt, yExt);
                        ctx.lineTo(xInt, yInt);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if(p.type === 'trait_lumineux') {
                    // ✨ Trait lumineux fin et simple
                    ctx.lineWidth = Math.max(1, p.taille * 0.3); // Plus fin
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = p.couleur;

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(
                        p.x - Math.cos(p.angle) * p.longueur * 0.5, // Plus court
                        p.y - Math.sin(p.angle) * p.longueur * 0.5
                    );
                    ctx.stroke();
                } else if(p.type === 'emoji') {
                    // 💰 Particule emoji (billets de banque phase 20)
                    // ⚡ OPTIMISATION: 1 énorme emoji toutes les 7 briques seulement
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    
                    // Font dynamique basée sur la taille de la particule
                    ctx.font = `${p.taille}px Arial`;
                    
                    // ⚡ Fade ultra-rapide basé sur la vie restante (12 frames)
                    ctx.globalAlpha = Math.min(1, p.vie / 12);
                    
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 0; // Pas de flou pour les emojis (performance)
                    ctx.fillText(p.emoji, 0, 0);
                    
                    ctx.globalAlpha = 1; // Reset opacity
                    // ⚡ Rotation gérée dans mettreAJourParticules() (ligne 15262)
                } else {
                    // Particule ronde simple
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions - DÉSACTIVÉ (interface simplifiée)
        function afficherMunitions() {
            // Fonction désactivée - plus d'affichage de munitions en mode étoiles
            return;
        }

        // Dessiner les projectiles étoiles
        function dessinerProjectiles() {
            // Dessiner les projectiles étoiles pendant la phase stars, lanterne ET mur (phases 17-23)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur';

            // 🔍 DEBUG Phase 22
            if(phaseActuelle === 22) {
                console.log(`🔍 dessinerProjectiles() DEBUG - phaseJeu=${phaseJeu}, isWallPhase=${isWallPhase}, projectiles.length=${projectiles.length}`);
            }

            if(phaseJeu !== 'stars' && phaseJeu !== 'lanterne' && !isWallPhase) {
                if(phaseActuelle === 22) console.log(`❌ dessinerProjectiles() BLOQUÉ par return - phaseJeu=${phaseJeu}`);
                return;
            }

            if(projectiles.length > 0) {
                console.log(`🎨 dessinerProjectiles() - ${projectiles.length} projectiles à dessiner (phase ${phaseActuelle}, phaseJeu=${phaseJeu})`);
            }

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;

                // Utiliser la config du projectile si disponible
                const config = projectile.config || getProjectileConfig(18); // Par défaut: étoiles
                const rayonEtoile = config.size / 2 || 8;

                // 🔍 DEBUG Phase 22 - Vérifier la config (premier projectile seulement)
                if(phaseActuelle === 22 && projectiles.indexOf(projectile) === 0) {
                    console.log(`🔍 Projectile config:`, {
                        type: config.type,
                        emoji: config.emoji,
                        size: config.size,
                        trailType: config.trailType,
                        colors: config.color
                    });
                }

                // ✨ PAILLETTES MAGIQUES AUTOUR DU PROJECTILE ✨
                // ⚡ OPTIMISATION: Adaptatif selon qualité device (4→2→1 paillettes)
                const effects = window.getAdaptiveEffectSettings ? window.getAdaptiveEffectSettings() : { particleMultiplier: 1.0 };
                const sparkleCount = Math.max(1, Math.floor(4 * effects.particleMultiplier));
                const sparkleTime = Date.now() * 0.005;
                for (let s = 0; s < sparkleCount; s++) {
                    const angle = (s / sparkleCount) * Math.PI * 2 + sparkleTime;
                    const distance = rayonEtoile * 2 + Math.sin(sparkleTime + s) * 5;
                    const sparkleX = posX + Math.cos(angle) * distance;
                    const sparkleY = posY + Math.sin(angle) * distance;
                    const sparkleSize = 2 + Math.sin(sparkleTime * 2 + s) * 1;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.6 + Math.sin(sparkleTime * 3 + s) * 0.3;
                    // ⚡ OPTIMISATION: shadowBlur adaptatif selon device
                    if (effects.shadows) {
                        ctx.shadowBlur = Math.min(8, effects.shadowBlurMax);
                        ctx.shadowColor = '#FFFFFF';
                    }
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Dessiner la traînée lumineuse si configurée
                if (config.trail && projectile.dx && projectile.dy) {
                    const trailLength = config.trailLength || 15;
                    
                    // Phase 22 : Traînée de paillettes arc-en-ciel ✨
                    if (config.trailType === 'sparkle') {
                        // ⚡ OPTIMISATION: Adaptatif selon qualité device (~8→4→2 paillettes)
                        const effects = window.getAdaptiveEffectSettings ? window.getAdaptiveEffectSettings() : { particleMultiplier: 1.0 };
                        const baseSparkleCount = Math.floor(trailLength / 3);
                        const sparkleCount = Math.max(2, Math.floor(baseSparkleCount * effects.particleMultiplier));
                        for (let s = 0; s < sparkleCount; s++) {
                            const sparkleRatio = s / sparkleCount;
                            const sparkleX = posX - projectile.dx * (sparkleRatio * trailLength / config.speed);
                            const sparkleY = posY - projectile.dy * (sparkleRatio * trailLength / config.speed);

                            // Couleur arc-en-ciel cyclique - chaque paillette a sa propre couleur
                            const colorIndex = (s + Math.floor(Date.now() / 150)) % config.color.length;
                            const sparkleColor = config.color[colorIndex];

                            // Dessiner une étoile scintillante plus grande et plus visible
                            ctx.save();
                            ctx.globalAlpha = 0.9 - sparkleRatio * 0.6; // Plus opaque au début
                            // ⚡ OPTIMISATION: shadowBlur adaptatif selon device
                            if (effects.shadows) {
                                ctx.shadowBlur = Math.min(20, effects.shadowBlurMax);
                                ctx.shadowColor = sparkleColor;
                            }
                            ctx.fillStyle = sparkleColor;

                            ctx.translate(sparkleX, sparkleY);
                            ctx.rotate((Date.now() * 0.008) + s); // Rotation plus rapide

                            // Étoile à 4 branches plus grande
                            const sparkleSize = 8 - sparkleRatio * 4; // Taille variable (8px → 4px)
                            ctx.beginPath();
                            for (let p = 0; p < 4; p++) {
                                const angle = (p * Math.PI) / 2;
                                const x = Math.cos(angle) * sparkleSize;
                                const y = Math.sin(angle) * sparkleSize;
                                if (p === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();

                            // Ajouter un second glow pour plus d'éclat (si shadows activés)
                            if (effects.shadows) {
                                ctx.shadowBlur = Math.min(30, effects.shadowBlurMax * 1.5);
                                ctx.globalAlpha = 0.6 - sparkleRatio * 0.4;
                            }
                            ctx.fill();

                            ctx.restore();
                        }
                    } else {
                        // ✨ Traînée améliorée avec BLUR et dégradé
                        const trailSteps = 20;
                        for (let t = 0; t < trailSteps; t++) {
                            const ratio = t / trailSteps;
                            const trailX = posX - projectile.dx * (ratio * trailLength / config.speed);
                            const trailY = posY - projectile.dy * (ratio * trailLength / config.speed);
                            
                            const currentColor = Array.isArray(config.color) ? config.color[projectile.colorIndex || 0] : config.color[0];
                            
                            ctx.save();
                            ctx.globalAlpha = (1 - ratio) * 0.7;
                            ctx.shadowBlur = 15 * (1 - ratio);
                            ctx.shadowColor = currentColor;
                            ctx.fillStyle = currentColor;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, rayonEtoile * (1 - ratio * 0.5), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }

                // Calcul pour l'effet de rotation scintillante
                const rotation = config.rotation ? (projectile.rotation || 0) : Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner le projectile avec effet de lueur (couleur selon le type)
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const currentColor = Array.isArray(config.color) ? config.color[projectile.colorIndex || 0] : config.color[0];
                    
                    // Si un emoji est configuré, dessiner UNIQUEMENT l'emoji avec un glow
                    if (config.emoji) {
                        // 💖 CŒUR GÉOMÉTRIQUE BRILLANT (si c'est un emoji cœur)
                        if (config.emoji === '💖' || config.emoji === '💛' || config.emoji === '💚' || config.emoji === '💙' || config.emoji === '💜' || config.emoji === '❤️') {
                            // Dessiner un cœur géométrique vectoriel au lieu de l'emoji
                            const size = rayonEtoile * 2;
                            
                            // Multi-couches de blur pour effet magique
                            for (let layer = 3; layer >= 0; layer--) {
                                ctx.save();
                                ctx.globalAlpha = 0.3 + (layer * 0.15);
                                ctx.shadowBlur = 30 - (layer * 7);
                                ctx.shadowColor = currentColor;
                                ctx.fillStyle = currentColor;
                                
                                // Cœur géométrique avec courbes de Bézier
                                const scale = 1 + (layer * 0.05);
                                ctx.scale(scale, scale);
                                ctx.beginPath();
                                ctx.moveTo(0, size * 0.3);
                                // Lobe gauche
                                ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                                // Lobe droit
                                ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                                ctx.closePath();
                                ctx.fill();
                                
                                ctx.restore();
                            }
                            
                            // Contour brillant
                            ctx.save();
                            ctx.strokeStyle = '#FFFFFF';
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#FFFFFF';
                            ctx.beginPath();
                            ctx.moveTo(0, size * 0.3);
                            ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                            ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                            ctx.closePath();
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            // Autre emoji : glow intense derrière l'emoji pour le rendre bien visible
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = currentColor;
                            
                            ctx.font = `${rayonEtoile * 3}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const emoji = Array.isArray(config.emoji) ? config.emoji[projectile.colorIndex % config.emoji.length] : config.emoji;
                            ctx.fillText(emoji, 0, 0);
                            
                            ctx.shadowBlur = 0;
                        }
                    } else {
                        // Pas d'emoji : dessiner un CŒUR GÉOMÉTRIQUE par défaut avec blur intense
                        const size = rayonEtoile * 2;
                        
                        // Multi-couches de blur pour effet magique maximum
                        for (let layer = 4; layer >= 0; layer--) {
                            ctx.save();
                            ctx.globalAlpha = 0.25 + (layer * 0.12);
                            ctx.shadowBlur = 40 - (layer * 8);
                            ctx.shadowColor = currentColor;
                            ctx.fillStyle = currentColor;
                            
                            const scale = 1 + (layer * 0.08);
                            ctx.scale(scale, scale);
                            ctx.beginPath();
                            ctx.moveTo(0, size * 0.3);
                            ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                            ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.restore();
                        }
                        
                        // Éclat central blanc brillant
                        ctx.save();
                        ctx.globalAlpha = 0.8;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.scale(0.3, 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, size * 0.3);
                        ctx.bezierCurveTo(-size * 0.5, -size * 0.3, -size * 0.8, size * 0.1, 0, size * 0.9);
                        ctx.bezierCurveTo(size * 0.8, size * 0.1, size * 0.5, -size * 0.3, 0, size * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                }

                ctx.restore();
            });
        }

        // Configuration des projectiles par phase
        function getProjectileConfig(phase) {
            const configs = {
                17: {
                    type: 'coin',
                    emoji: '🪙',
                    color: ['#FFD700', '#FFA500'],
                    size: 20,
                    trail: true,
                    trailLength: 15,
                    particles: false,
                    cadence: 30, // ⚡ ANTI-SPAM: 15→30 frames (500ms)
                    speed: 2.5,
                    powerup: ['red_cross', 'broken_heart'] // Deux types aléatoires
                },
                18: {
                    type: 'cloud',
                    emoji: '☁️',
                    color: ['#B0B0B0', '#808080'],
                    size: 22,
                    trail: true,
                    trailLength: 18,
                    particles: false,
                    cadence: 30, // ⚡ ANTI-SPAM: 15→30 frames (500ms)
                    speed: 2.8,
                    powerup: ['gray_heart', 'black_heart'] // Deux types aléatoires
                },
                19: {
                    type: 'hammer',
                    emoji: '⚒️',
                    color: ['#708090', '#556B2F', '#8B4513'],
                    size: 20,
                    trail: true,
                    trailLength: 16,
                    particles: false,
                    cadence: 30, // ⚡ ANTI-SPAM: 12→30 frames (500ms)
                    speed: 3.2,
                    powerup: ['chain', 'barbed_wire'] // Prison/Barbelés
                },
                20: {
                    type: 'money',
                    emoji: '💵',
                    color: ['#85BB65', '#2E7D32', '#1B5E20'],
                    size: 28,
                    trail: true,
                    trailLength: 45,
                    colorChange: false,
                    particles: true,
                    particleCount: 3, // ⚡ OPTIMISATION ULTIME: Réduit de 6 à 3 (max absolu)
                    particleEmoji: '💰',
                    cadence: 36, // ⚡ ANTI-SPAM: 12→36 frames (600ms au lieu de 200ms)
                    speed: 3.5,
                    powerup: ['red_heart', 'open_hands'] // Solidarité/Compassion
                },
                21: {
                    type: 'star',
                    emoji: '⭐',
                    color: ['#FFD700', '#FFFF00', '#FFA500'],
                    size: 22,
                    trail: true,
                    trailLength: 20,
                    particles: false,
                    cadence: 24, // ⚡ ANTI-SPAM: 8→24 frames (400ms)
                    speed: 3.8,
                    doubleShot: false,
                    powerup: ['green_heart', 'yellow_heart', 'blue_heart', 'purple_heart'] // Diversité
                },
                22: {
                    type: 'big_heart',
                    emoji: '💖',
                    color: ['#FF1493'], // Rose vif - couleur fixe
                    size: 26,
                    trail: true,
                    trailLength: 25,
                    particles: true,
                    particleCount: 8,
                    cadence: 30, // ⚡ ANTI-SPAM: 10→30 frames (500ms)
                    speed: 3.0,
                    powerup: ['vibrant_heart', 'smile'] // Espoir
                },
                23: {
                    type: 'rotating_hearts',
                    emoji: ['💖', '💛', '💚', '💙', '💜'],
                    color: ['#FF1493', '#FFD700', '#00FF00', '#1E90FF', '#9370DB'],
                    size: 20,
                    trail: true,
                    trailLength: 20,
                    particles: true,
                    particleCount: 12,
                    rotation: true,
                    cadence: 30, // ⚡ ANTI-SPAM: 15→30 frames (500ms)
                    speed: 9,
                    laser: true,
                    laserInterval: 20000,
                    powerup: null
                }
            };
            
            return configs[phase] || configs[18]; // Par défaut : étoiles
        }

        // Tirer un projectile étoile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne ou mur (phases 17-22, pas 23 = fin)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur';
            
            console.log(`🎯 tirerProjectile() - Phase ${phaseActuelle}, phaseJeu=${phaseJeu}, isWallPhase=${isWallPhase}, munitions=${munitions}, rechargement=${rechargement}`);
            
            if (rechargement > 0) {
                // Rechargement normal - ne pas afficher de log (trop de spam)
                return;
            }
            
            if (phaseJeu !== 'lanterne' && !isWallPhase) {
                console.log(`⛔ tirerProjectile() - BLOQUÉ : Mauvaise phase (phaseJeu=${phaseJeu}, phase=${phaseActuelle})`);
                return;
            }

            // Obtenir la configuration pour la phase actuelle (nécessaire pour rechargement)
            const config = getProjectileConfig(phaseActuelle);

            // Tant qu'il y a des munitions, tirer des étoiles
            if (munitions > 0) {
                console.log(`🚀 tirerProjectile() - TIR! Config type=${config.type}, emoji=${config.emoji}`);
                
                // Tir d'étoiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = config.speed || 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;

                // Projectile principal
                // Pour phase 19 (multicolor), choisir une couleur aléatoire
                const randomColorIndex = (config.type === 'multicolor' && Array.isArray(config.color)) 
                    ? Math.floor(Math.random() * config.color.length) 
                    : 0;
                
                const projectile = {
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY,
                    phase: phaseActuelle,
                    config: config,
                    colorIndex: randomColorIndex,
                    rotation: 0,
                    creationTime: Date.now()
                };
                
                projectiles.push(projectile);
                console.log(`✨ Projectile créé! Total: ${projectiles.length}, emoji: ${config.emoji}, color: ${config.color[0]}`);
                
                // Son de tir
                AudioSystem.playShoot();
                
                // Double tir pour phase 21 (si activé)
                if (config.doubleShot && window.doubleShotActive) {
                    const angle = Math.atan2(velY, velX);
                    const offset = 0.3; // 30 degrés de décalage
                    
                    const velX2 = Math.cos(angle + offset) * vitesse;
                    const velY2 = Math.sin(angle + offset) * vitesse;
                    
                    // Couleur aléatoire aussi pour le 2e projectile en multicolor
                    const randomColorIndex2 = (config.type === 'multicolor' && Array.isArray(config.color)) 
                        ? Math.floor(Math.random() * config.color.length) 
                        : 0;
                    
                    projectiles.push({
                        x: startX,
                        y: startY,
                        dx: velX2,
                        dy: velY2,
                        phase: phaseActuelle,
                        config: config,
                        colorIndex: randomColorIndex2,
                        rotation: 0,
                        creationTime: Date.now()
                    });
                }

                // MUNITIONS INFINIES - ne pas décrémenter
                // munitions--;

                // Plus besoin de vérifier la dernière munition (infinies)
            }

            rechargement = config ? config.cadence : 20; // Délai entre les tirs selon la phase
        }

        // Mettre à jour les projectiles
        function mettreAJourProjectiles() {
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            const isWallPhase = phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur';
            
            if (animationBateau.active || (phaseJeu !== 'lanterne' && !isWallPhase)) {
                // Nettoyer les projectiles si on n'est pas en phase lanterne ou mur
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // Déplacer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;
                
                // Mettre à jour les effets spéciaux
                if (proj.config) {
                    // Rotation pour phase 23 - ⚡ Simplifiée (0.1 → 0.05)
                    if (proj.config.rotation) {
                        proj.rotation += 0.05;
                    }
                    
                    // Changement de couleur pour phase 20 (rainbow)
                    if (proj.config.colorChange) {
                        const elapsed = Date.now() - proj.creationTime;
                        proj.colorIndex = Math.floor(elapsed / 100) % proj.config.color.length;
                    }
                }

                // Supprimer les projectiles qui sortent de l'écran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // 🌈 Phase 22 : Collision avec le power-up Espoir caché
                if (powerUps && powerUps.length > 0) {
                    for (let pIndex = powerUps.length - 1; pIndex >= 0; pIndex--) {
                        const power = powerUps[pIndex];
                        if (power.type === 'rainbow_hope' && !power.collected) {
                            // Vérifier collision projectile avec power-up (30×30 - plus discret)
                            const dx = proj.x - (power.x + power.w/2);
                            const dy = proj.y - (power.y + power.h/2);
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            
                            if (distance < power.w/2 + 12) { // Rayon adapté (15 + 12 = 27px)
                                // Power-up Espoir collecté ! 🌈
                                power.collected = true;
                                powerUps.splice(pIndex, 1);
                                projectiles.splice(i, 1);
                                
                                // Explosion arc-en-ciel massive
                                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                                for (let c = 0; c < 7; c++) {
                                    ajouterParticules(power.x + power.w/2, power.y + power.h/2, rainbowColors[c], 15);
                                }
                                
                                // Bonus énorme
                                score += 5000;
                                window.score = score;
                                
                                // Triple son de cloche pour la collecte ! 🔔🔔🔔
                                AudioSystem.playChime();
                                setTimeout(() => AudioSystem.playCoin(), 100);
                                setTimeout(() => AudioSystem.playCoin(), 200);
                                
                                // Message spécial
                                afficherMessagePowerupSimple('🌈 ✨ ESPOIR RÉVÉLÉ ! ✨ 🌈\n+5000 XP');
                                
                                console.log('🌈 Power-up ESPOIR collecté en phase 22 ! +5000 XP');
                                console.log('   → Le joueur peut maintenant finir les briques restantes pour passer à la phase suivante.');
                                
                                // NE PAS déclencher de transition ici !
                                // Le power-up débloque juste la possibilité de finir la phase
                                // La transition se fera quand TOUTES les briques seront détruites
                                
                                break;
                            }
                        }
                    }
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;
                            
                            // Son "poque" à chaque impact
                            AudioSystem.playWallHit();
                            
                            // Créer des particules pour les phases 20, 22-23
                            if (proj.config && proj.config.particles) {
                                // 📱 Adapter nombre de particules selon qualité
                                const effects = window.getAdaptiveEffectSettings();
                                const baseParticleCount = proj.config.particleCount || 8;
                                const particleCount = Math.max(1, Math.floor(baseParticleCount * effects.particleMultiplier));
                                const colors = proj.config.color;
                                
                                // Phase 20 : 💰 EMOJI TOUTES LES 7 BRIQUES (ultra-optimisé)
                                if (proj.config.particleEmoji) {
                                    // ⚡ ULTRA OPTIMISATION: 1 seul emoji GROS toutes les 7 briques
                                    // Afficher sur 1ère brique (brises === 0) puis toutes les 7 (brises % 7 === 0)
                                    if (brises === 0 || brises % 7 === 0) {
                                        particules.push({
                                            x: proj.x,
                                            y: proj.y,
                                            vx: 0, // Statique
                                            vy: -1.5, // Monte plus vite
                                            couleur: '#FFD700',
                                            vie: 12, // ⚡ Disparaît ultra-rapide (12 frames = 0.2s au lieu de 0.33s)
                                            taille: 32, // ⚡ ÉNORME (32 au lieu de 24)
                                            type: 'emoji',
                                            emoji: proj.config.particleEmoji,
                                            rotation: 0,
                                            rotationSpeed: 0
                                        });
                                    }
                                    // Sinon: pas d'emoji du tout (économie GPU massive)
                                } else {
                                    // Autres phases : particules colorées normales
                                    for (let p = 0; p < particleCount; p++) {
                                        const angle = (Math.PI * 2 * p) / particleCount;
                                        const speed = 2 + Math.random() * 3;
                                        if (window.ajouterParticules) {
                                            const color = Array.isArray(colors) ? colors[p % colors.length] : colors[0];
                                            ajouterParticules(proj.x, proj.y, color, 1);
                                        }
                                    }
                                }
                            }

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est détruite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Son thématique selon la phase
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                switch(phaseActuelle) {
                                    case 17: // AVARICE 🪙
                                        AudioSystem.playCoin();
                                        break;
                                    case 18: // LIBERTÉ ☁️
                                        AudioSystem.playWindBreak();
                                        break;
                                    case 19: // REFUS ⚒️
                                        AudioSystem.playHammerBreak();
                                        break;
                                    case 20: // ORGUEIL 💵
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 21: // INÉGALITÉS ⭐
                                        AudioSystem.playHeartBreak();
                                        break;
                                    case 22: // ESPOIR 💖
                                        AudioSystem.playDeepKnock();
                                        break;
                                    case 19: // REFUS ⚒️
                                        AudioSystem.playHammerBreak();
                                        break;
                                    case 20: // ORGUEIL 💵
                                        AudioSystem.playHeartBreak();
                                        break;
                                    case 21: // INÉGALITÉS ⭐
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 22: // ESPOIR 💖
                                        AudioSystem.playCoin();
                                        break;
                                    case 20: // ORGUEIL �
                                        AudioSystem.playCoin();
                                        break;
                                    case 21: // INÉGALITÉS ⭐
                                        AudioSystem.playCrystalBreak();
                                        break;
                                    case 22: // ESPOIR 💖
                                        AudioSystem.playHeartBreak();
                                        break;
                                    default:
                                        AudioSystem.playWallBreak();
                                }

                                // ⚡ OPTIMISATION: En mode lanterne, réduire les particules de cœurs (1 au lieu de 3)
                                const nombreCoeurs = phaseJeu === 'lanterne' ? 1 : 3;
                                for(let j = 0; j < nombreCoeurs; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                // Phase 22 : taux réduit à 5% pour ne pas masquer le rainbow_hope
                                const tauxPowerup = (phaseActuelle === 22) ? 0.05 : 0.3;
                                if(Math.random() < tauxPowerup) {
                                    // 🌈 PROTECTION Phase 22 : Ne pas créer de power-up aléatoire trop proche du rainbow_hope
                                    let peutCreerPowerup = true;
                                    if (phaseActuelle === 22) {
                                        const espoirPresent = powerUps.find(p => p.type === 'rainbow_hope' && !p.collected);
                                        if (espoirPresent) {
                                            const distance = Math.sqrt(
                                                Math.pow(brique.x + brique.w/2 - espoirPresent.x, 2) + 
                                                Math.pow(brique.y + brique.h/2 - espoirPresent.y, 2)
                                            );
                                            // Ne pas créer si trop proche du rainbow_hope (moins de 60px)
                                            if (distance < 60) {
                                                console.log(`🚫 Power-up aléatoire annulé - trop proche du rainbow_hope (distance: ${distance.toFixed(1)}px)`);
                                                peutCreerPowerup = false;
                                            }
                                        }
                                    }
                                    
                                    if (peutCreerPowerup) {
                                        // Utiliser le power-up spécifique de la phase si configuré
                                        const phasePowerup = proj.config && proj.config.powerup ? proj.config.powerup : null;
                                        creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2, phasePowerup);
                                    }
                                }

                                // Vérifier si toutes les briques sont détruites
                                if(briques.every(b => !b.visible)) {
                                    // 🌈 EXCEPTION PHASE 22 : Ne pas terminer automatiquement !
                                    // Le joueur doit collecter le power-up Espoir caché avant de continuer
                                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                    let peutTerminerPhase = true; // Variable de contrôle
                                    
                                    if (phaseActuelle === 22) {
                                        // Vérifier si le power-up existe et n'est PAS collecté
                                        const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                        if (espoirPresent) {
                                            console.log('🌈 Phase 22 : Mur détruit mais power-up ESPOIR pas encore collecté !');
                                            console.log('   → La phase ne se termine pas automatiquement.');
                                            peutTerminerPhase = false; // ← Bloquer la fin automatique SANS return
                                        } else {
                                            console.log('✅ Phase 22 : Mur détruit ET power-up ESPOIR collecté → Transition !');
                                        }
                                    }

                                    // Terminer la phase uniquement si autorisé
                                    if (peutTerminerPhase) {
                                        // Auto-récupérer les powerups restants (sauf rainbow_hope qui doit être collecté manuellement)
                                        if(powerUps && powerUps.length > 0) {
                                            powerUps.forEach(powerup => {
                                                // Ne pas auto-collecter le rainbow_hope en Phase 22
                                                if (powerup.type === 'rainbow_hope' && phaseActuelle === 22) {
                                                    return; // Skip
                                                }
                                                // Déclencher les effets selon le type
                                                switch(powerup.type) {
                                                    case 'etoile_montante':
                                                        score += 1000;
                                                        break;
                                                    case 'bonus_points':
                                                        score += 500;
                                                        break;
                                                    case 'allume_lanterne':
                                                        lanterne.active = true;
                                                        lanterne.intensite = 1.0;
                                                        break;
                                                }
                                                // Particules d'effet
                                                if(window.ajouterParticules) {
                                                    ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                                }
                                            });
                                            powerUps = powerUps.filter(p => p.type === 'rainbow_hope' && phaseActuelle === 22); // Garder rainbow_hope en Phase 22
                                        }

                                        phaseJeu = 'fin_niveau';
                                        // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                        animerExplosionIconeCollector(() => {
                                            narrationManager.goToNextPhaseDirect();
                                        });
                                    }
                                }
                            }
                        }
                    }
                });

                // 🌈 Collision avec le power-up Espoir (Phase 22 uniquement)
                if (powerUps && powerUps.length > 0) {
                    for (let p = powerUps.length - 1; p >= 0; p--) {
                        const powerup = powerUps[p];
                        
                        // Vérifier uniquement le power-up Espoir arc-en-ciel
                        if (powerup.type === 'rainbow_hope' && !powerup.collected) {
                            const distance = Math.sqrt(
                                Math.pow(proj.x - (powerup.x + powerup.w/2), 2) +
                                Math.pow(proj.y - (powerup.y + powerup.h/2), 2)
                            );
                            
                            // Collision détectée (rayon du power-up)
                            if (distance < (powerup.w / 2 + 15)) {
                                // ✅ MARQUER COMME COLLECTÉ (ne pas supprimer du tableau !)
                                powerup.collected = true;
                                
                                // 🎆 EXPLOSION ARC-EN-CIEL MASSIVE !
                                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                                rainbowColors.forEach((color, index) => {
                                    setTimeout(() => {
                                        if (window.ajouterParticules) {
                                            ajouterParticules(powerup.x, powerup.y, color, 15);
                                        }
                                    }, index * 50);
                                });
                                
                                // 🏆 ÉNORME BONUS
                                score += 5000;
                                window.score = score;
                                
                                // 🔓 Débloquer l'énigme Espoir
                                if (enigmaCollector) {
                                    setTimeout(() => {
                                        enigmaCollector.collecterEnigme('espoir_mur', true);
                                        score += 1000; // Bonus énigme
                                        window.score = score;
                                        console.log('🌈 Énigme ESPOIR débloquée par collecte du power-up !');
                                    }, 500);
                                }
                                
                                // 🔊 Son de collecte magique (triple)
                                if (AudioSystem && AudioSystem.playCoin) {
                                    AudioSystem.playCoin();
                                    setTimeout(() => AudioSystem.playCoin(), 150);
                                    setTimeout(() => AudioSystem.playCoin(), 300);
                                }
                                
                                // 💬 Message spectaculaire
                                afficherMessagePowerupSimple('🌈 ✨ ESPOIR RÉVÉLÉ ! ✨ 🌈\n+6000 XP');
                                
                                // ⛔ NE PAS SUPPRIMER le power-up du tableau (juste marqué collected = true)
                                // powerUps.splice(p, 1); ← SUPPRIMÉ
                                
                                // Supprimer le projectile
                                projectiles.splice(i, 1);
                                
                                console.log('🌈💫 Power-up ESPOIR collecté ! +6000 XP (5000 + 1000 énigme) !');
                                console.log('✅ Power-up reste dans le tableau avec collected = true');
                                
                                // ✅ Phase 22 : Vérifier si on peut passer à la phase suivante
                                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                                if (phaseActuelle === 22) {
                                    // Vérifier s'il reste des briques
                                    const briquesRestantes = briques.filter(b => b.visible).length;
                                    
                                    if (briquesRestantes === 0) {
                                        console.log('✨ Phase 22 complétée : ESPOIR collecté + TOUTES les briques détruites → Transition !');
                                        // Attendre un peu pour laisser voir l'explosion et le message
                                        setTimeout(() => {
                                            phaseJeu = 'fin_niveau';
                                            animerExplosionIconeCollector(() => {
                                                narrationManager.goToNextPhaseDirect();
                                            });
                                        }, 2000); // 2 secondes pour profiter du moment
                                    } else {
                                        console.log(`✨ ESPOIR collecté mais il reste ${briquesRestantes} briques → Continue de jouer !`);
                                        // Ne pas déclencher de transition - le joueur doit finir les briques
                                    }
                                }
                                
                                break;
                            }
                        }
                    }
                }
            }

            // Réduire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Système de laser pour phase 23
        function activerLaser() {
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle !== 23) return;
            
            const now = Date.now();
            const config = getProjectileConfig(23);
            
            // Vérifier si on peut tirer (tous les 20s)
            if (now - laserState.lastFired >= config.laserInterval) {
                laserState.active = true;
                laserState.startTime = now;
                laserState.lastFired = now;
                
                // Message d'activation
                afficherMessagePowerupSimple(getTranslatedText('game.messages.laser_activated', '⚡ RAYON LASER ACTIVÉ !'));
                
                // Détruire toutes les briques sur une ligne horizontale (au niveau du milieu)
                const laserY = C.H * 0.3;
                const laserHeight = 40;
                
                briques.forEach(brique => {
                    if (brique.visible && brique.y >= laserY - laserHeight && brique.y <= laserY + laserHeight) {
                        brique.visible = false;
                        briques = briques.filter(b => b !== brique || b.visible);
                        
                        // Particules d'explosion
                        if (window.ajouterParticules) {
                            const colors = ['#FF1493', '#FFD700', '#00FF00', '#1E90FF', '#9370DB'];
                            for (let i = 0; i < 20; i++) {
                                ajouterParticules(
                                    brique.x + brique.w / 2,
                                    brique.y + brique.h / 2,
                                    colors[i % colors.length],
                                    1
                                );
                            }
                        }
                        
                        // Score
                        score += 100;
                        brises++;
                    }
                });
            }
        }
        
        // Mettre à jour et dessiner le laser
        function mettreAJourLaser() {
            if (!laserState.active) return;
            
            const now = Date.now();
            const elapsed = now - laserState.startTime;
            
            // Désactiver après la durée
            if (elapsed >= laserState.duration) {
                laserState.active = false;
                return;
            }
            
            // Dessiner le rayon laser
            ctx.save();
            
            const laserY = C.H * 0.3;
            const progress = elapsed / laserState.duration;
            const alpha = Math.sin(progress * Math.PI); // Fade in/out
            
            // Effet néon électrique
            ctx.globalAlpha = alpha * 0.6;
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#00FFFF';
            
            // Rayon principal
            const gradient = ctx.createLinearGradient(0, laserY - 20, 0, laserY + 20);
            gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 255, 1)');
            gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, laserY - 20, C.W, 40);
            
            // Éclairs électriques
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(0, laserY + (Math.random() - 0.5) * 30);
                const segments = 10;
                for (let j = 1; j <= segments; j++) {
                    const x = (C.W * j) / segments;
                    const y = laserY + (Math.random() - 0.5) * 30;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // Déclarer phaseActuelle en début de fonction pour la rendre accessible partout
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            
            // Gérer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // Vérifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqué
            }

            // Appliquer le multiplicateur de vitesse s'il existe
            let vitesseMulti = balle.multiplicateurVitesse || 1;
            
            // 🔥 Mode lanterne : vitesse × 1.5
            if(phaseJeu === 'lanterne') {
                vitesseMulti *= 1.5;
            }
            
            // Mouvement de la balle (vitesse fixe classique casse-briques)
            balle.x += balle.dx * vitesseMulti;
            balle.y += balle.dy * vitesseMulti;

            // Mode casse-briques : rebonds classiques (lanterne et mur)
            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                    // 🔊 Son de rebond sur les murs
                    AudioSystem.playBounce();
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                    // 🔊 Son de rebond sur le haut
                    AudioSystem.playBounce();
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' || phaseJeu === 'mur' ? C.SP * 1.5 : C.SP) * ecart * 0.8 * multiplicateurPuissance;

                    // 🔊 Son de rebond sur le bateau (raquette)
                    AudioSystem.playBounce();
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode étoiles : traverser les bords avec téléportation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // Réapparaît à droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // Réapparaît à gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // Téléportation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // Réapparaît en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de vérité (bas) - seulement dans les phases où la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'étoile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'étoile continue sa trajectoire
            }

            // 🚀 OPTIMISATION : Collision balle-briques avec grille spatiale
            let briqueTouchee = false;
            
            // Obtenir seulement les briques candidates (performance O(1) au lieu de O(n))
            const briquesCandidates = grilleCollision.obtenirCandidates(balle.x, balle.y, C.BS);
            
            // Statistiques de performance (en mode debug temporaire)
            if (briquesCandidates.length < briques.length) {
                console.log(`🚀 Optimisation grille spatiale: ${briquesCandidates.length}/${briques.length} briques testées (${Math.round((1 - briquesCandidates.length/briques.length) * 100)}% économisé)`);
            }
            
            briquesCandidates.forEach(brique => {
                if(briqueTouchee) return; // Arrêter si on a déjà touché une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Bloquer les collisions pendant le mode secret
                        if (secretModeModule && secretModeModule.isActive) {
                            return; // Pas de collision avec les briques en mode secret
                        }
                        if (modeSecret) {
                            return; // Pas de collision avec les briques en mode secret (fallback)
                        }

                        // Marquer qu'on a touché une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond sur la brique
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // Déterminer si le rebond est horizontal ou vertical
                        const deltaX = Math.abs(centreBalleX - centreBriqueX);
                        const deltaY = Math.abs(centreBalleY - centreBriqueY);

                        if (deltaX > deltaY) {
                            // Rebond horizontal (côtés gauche/droite)
                            balle.dx = -balle.dx;
                        } else {
                            // Rebond vertical (haut/bas)
                            balle.dy = -balle.dy;
                        }

                        // 🔊 Son de rebond sur brique
                        AudioSystem.playBounce();

                        // Si la brique est détruite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;
                        
                        // 🚀 OPTIMISATION : Supprimer la brique de la grille spatiale
                        grilleCollision.supprimerBrique(brique);

                        // 🔊 Son de casse brique (aléatoire entre 3 sons)
                        const sonAleatoire = Math.random();
                        if (sonAleatoire < 0.33) {
                            AudioSystem.playBrickBreakToc();
                        } else if (sonAleatoire < 0.66) {
                            AudioSystem.playBrickBreakGlass();
                        } else {
                            AudioSystem.playBrickBreakCrack();
                        }

                        // Explosion en 3 petits cœurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: Math.random() * 30 + 40, // 40-70 frames (2.3-4s à 60fps)
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du cœur qui grossit et monte au ciel
                        // En mode lanterne : afficher seulement 1 texte sur 6 pour éviter la surcharge (optimisé de 1/4 à 1/6)
                        if (phaseJeu !== 'lanterne' || Math.random() < 0.17) {
                            ajouterTexteVolant(typeof brique.etape.nom === 'function' ? brique.etape.nom() : brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                        }

                        // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // Désactivé : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de créer un power-up bleu
                        // Phase 22 : taux réduit à 5% pour ne pas masquer le rainbow_hope
                        // phaseActuelle est déjà déclarée en début de fonction
                        const tauxPowerupBalle = (phaseActuelle === 22 && phaseJeu === 'mur') ? 0.05 : 0.3;
                        if(Math.random() < tauxPowerupBalle) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    // Vérifier la condition de fin selon le mode de jeu
                    if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                        // Mode briques : vérifier si toutes les briques sont détruites
                        const briquesRestantes = briques.filter(b => b.visible).length;console.log(`🔍 Vérif briques restantes (balle): ${briquesRestantes}, phase: ${phaseJeu}`);
                        if(briquesRestantes === 0) {
                            // 🌈 EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collecté !
                            if (phaseActuelle === 22 && phaseJeu === 'mur') {
                                // Vérifier si le power-up existe et n'est PAS collecté
                                const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                                if (espoirPresent) {
                                    console.log('🌈 Phase 22 : Mur détruit mais power-up ESPOIR pas encore collecté (collision balle) !');
                                    console.log('   → La phase ne se termine pas automatiquement.');
                                    // Ne rien faire - attendre la collecte du power-up
                                    return; // ← Sortir sans transition ET sans animation
                                }
                            }

                            console.log('🎯 Toutes les briques détruites (balle)! Transition vers phase suivante...');

                            // Auto-récupérer les powerups restants
                            if(powerUps && powerUps.length > 0) {console.log(`🎁 Auto-récupération de ${powerUps.length} powerups restants (balle)`);
                                powerUps.forEach(powerup => {
                                    switch(powerup.type) {
                                        case 'etoile_montante': score += 1000; break;
                                        case 'bonus_points': score += 500; break;
                                        case 'allume_lanterne': lanterne.active = true; lanterne.intensite = 1.0; break;
                                    }
                                    if(window.ajouterParticules) {
                                        ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                    }
                                });
                                powerUps = [];
                            }

                            if(!modeEtoileLance) {
                                // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    narrationManager.goToNextPhaseDirect();
                                });

                                // La fin sera gérée par finalizeNarration() automatiquement
                            } else if(modeEtoileLance) {
                                // Mode étoile infini : relancer le même niveau stars
                                jeu = false;
                                relancerModeEtoileInfini();
                            } else {
                                veriteLiberee();
                            }
                        }
                    } else if(brises >= VOYAGE.length) {
                        if(!modeEtoileLance) {
                            // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante après animation
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit délai supplémentaire après l'animation
                            });

                            // La fin sera gérée par finalizeNarration() automatiquement
                        } else if(modeEtoileLance) {
                            // Mode étoile infini : relancer le même niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // Événements
        function perdreVie() {
            vies--;
            
            // En phase mur, perdre 1000 points quand la balle est perdue
            if(phaseJeu === 'mur') {
                window.score = Math.max(0, (window.score || 0) - 1000);
                afficherMessagePowerupSimple(getTranslatedText('game.messages.wall_resists_minus_1000', '🧱 Le mur résiste ! -1000 points'));
            }
            
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position à l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                // En phase lanterne/mur, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                // Message déjà affiché plus haut pour phase mur (avec -1000 points)
                if(phaseJeu === 'lanterne') {
                    afficherMessagePowerupSimple(getTranslatedText('system.keep_searching_truth', '💔 Continue à chercher la vérité !'));
                }
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                balle.dy = -C.SP * multiplicateurPuissance;
                afficherMessagePowerupSimple(getTranslatedText('system.keep_searching_truth', '💔 Continue à chercher la vérité !'));
            }
        }

        function finDuVoyage() {
            console.log('🏁 FIN DU VOYAGE - Game Over');
            jeu = false;
            
            // Réinitialiser le flag pour permettre l'affichage du formulaire
            formulaireFinAffiche = false;

            // Afficher le formulaire de sauvegarde du score
            if (typeof afficherFormulaireFinDeJeuAvecResume === 'function') {
                console.log('✅ Fonction afficherFormulaireFinDeJeuAvecResume trouvée');
                // Calculer les scores
                const xp = pointsConnaissance || 0;
                const scoreJeu = window.score || score || 0;
                const scoreTotal = xp + scoreJeu;
                const scoreSagesse = Math.round(scoreTotal / 100);

                // Générer un ID unique
                const timestamp = Date.now().toString(16);
                const random = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                const idUnique = `PB${timestamp}${random}`.toUpperCase();

                console.log('📊 Scores calculés:', { xp, scoreJeu, scoreTotal, scoreSagesse, idUnique });
                afficherFormulaireFinDeJeuAvecResume(xp, scoreJeu, scoreTotal, scoreSagesse, idUnique, false); // ❌ Game Over = false
            } else {
                console.error('❌ Fonction afficherFormulaireFinDeJeuAvecResume introuvable');
                // Fallback si la fonction n'existe pas
                afficherMessage(`
                    <div style="font-weight: bold; font-size: 17px; text-align: center;">
                        ${getTranslatedText('game.journey_continues', '😢 Le voyage vers la vérité continue...')}<br><br>
                        "${getTranslatedText('game.truth_triumphs', 'La vérité finit toujours par triompher !')}"<br><br>
                        <button onclick="recommencerJeuGameOver()" 
                                style="background: linear-gradient(45deg, #4169E1, #1E90FF); 
                                       color: white; border: none; padding: 15px 30px; 
                                       border-radius: 25px; font-size: 18px; font-weight: bold; 
                                       cursor: pointer; box-shadow: 0 4px 15px rgba(65,105,225,0.4);
                                       transition: all 0.3s ease;
                                       margin: 10px;"
                                onmouseover="this.style.transform='scale(1.05)'"
                                onmouseout="this.style.transform='scale(1)'">
                            ${getTranslatedText('ui.restart_journey')}
                        </button>
                    </div>
                `, 0);
            }
        }

        function recommencerJeuGameOver() {
            cacherMessage();
            
            // Redémarrage à la phase actuelle (pas depuis le début)
            // Réinitialiser les variables de jeu mais garder la progression
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false;

            // Nettoyer les éléments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Redémarrer la phase courante (pas depuis le début)
            setTimeout(() => {
                if (narrationManager) {
                    narrationManager.restart(); // restart() = phase courante, pas start() = début
                }
            }, 1000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // Délai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(periode === 'jour') {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    // Message géré par le nouveau système narratif
                } else {
                    // Fin du chapitre 2 : déclencher la séquence finale des feux d'artifice
                    // Phase finale : séquence complète avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARRÊT DU SYSTÈME NARRATIF pour éviter les interférences
                    phaseIntro.active = false;
                    // Introduction terminée

                    // ÉTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = Date.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // ÉTAPE 2 : Feux d'artifice 5s
                        animationBateau.active = false;

                        // Créer des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // ÉTAPE 3 : Lever de soleil + fin normale via finalizeNarration
                            leverSoleilFinal();
                            setTimeout(() => {
                                narrationManager.finalizeNarration();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de délai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le début pour éviter les problèmes
            chapitre = 1;
            VOYAGE = JOUR;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            // Bloquer les changements de phase si le mode secret est actif
            if (secretModeModule && secretModeModule.isActive) {
                return;
            }
            if (modeSecret) {console.log('🚫 Mode secret actif (fallback), recommencer bloqué');
                return;
            }

            // Vérifier la condition de fin selon le mode de jeu
            if(phaseJeu === 'lanterne' || phaseJeu === 'stars' || phaseJeu === 'mur') {
                // Mode briques : vérifier si toutes les briques sont détruites
                const briquesRestantes = briques.filter(b => b.visible).length;
                if(briquesRestantes === 0) {
                    // � EXCEPTION PHASE 22 : Ne pas terminer automatiquement !
                    // Le joueur doit collecter le power-up Espoir caché avant de continuer
                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                    if (phaseActuelle === 22 && phaseJeu === 'mur') {
                        // Vérifier si le power-up existe et n'est PAS collecté
                        const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                        if (espoirPresent) {
                            // ❌ NE RIEN FAIRE - attendre la collecte du power-up
                            // Ne pas logger à chaque frame pour éviter de spammer la console
                            return; // ← SORTIR COMPLÈTEMENT sans transition
                        } else {
                            // Espoir déjà collecté, on peut passer à la suite
                            animerExplosionIconeCollector(() => {
                                console.log('🎆 Animation briques terminée - Phase 22 avec ESPOIR collecté');
                                narrationManager.goToNextPhaseDirect();
                            });
                        }
                    } else {
                        // Autres phases : transition normale
                        animerExplosionIconeCollector(() => {
                            console.log('🎆 Animation briques terminée (lanterne/stars/mur), passage à la phase suivante');
                            narrationManager.goToNextPhaseDirect();
                        });
                    }
                }
            } else if(brises >= VOYAGE.length) {
                // 🎆 ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante après animation
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                    }, 500); // Petit délai supplémentaire après l'animation
                });
            }

            // Forcer l'affichage des briques
            briques.forEach(brique => {
                brique.visible = true;
            });

            // Forcer la visibilité de la balle et activer le jeu
            if(balle) {
                balle.visible = true;
            }
            jeu = true;

            cacherMessage();
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            // Mode passe phase désactivé - fonction entièrement désactivée
            return;
            
            /* CODE MORT - Ne sera jamais exécuté
            if(periode === 'jour') {
                periode = 'nuit';
                VOYAGE = NUIT;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Créer les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilité de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
            } else {
                periode = 'jour';
                VOYAGE = JOUR;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recréer les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits cœurs visibles et désactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
            }
            */
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessagePowerupSimple(getTranslatedText('system.no_bricks_found', '❌ Aucune brique trouvée'));
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessagePowerupSimple(getTranslatedText('system.fast_mode_activated', `⚡ Mode rapide activé - ${briquesModifiees} briques`));
            } else {
                afficherMessagePowerupSimple(getTranslatedText('system.all_bricks_one_life', 'ℹ️ Toutes les briques déjà à 1 vie'));
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // Désactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessagePowerupSimple(getTranslatedText('system.star_shooting_disabled', '⭐ Tir étoiles désactivé'));
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessagePowerupSimple(getTranslatedText('system.auto_star_shooting_enabled', '🌟 Tir étoiles automatique activé'));

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si nécessaire
                        if(!jeu) jeu = true;

                        // Viser une brique aléatoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Libérer les cœurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise à jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode étoile test

            // Configuration pour mode étoile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = NUIT;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode étoile depuis le menu

            // Forcer l'arrêt des systèmes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'étoiles automatique en mode étoile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les éléments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Créer les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessagePowerupSimple(getTranslatedText('system.infinite_star_mode', '🌟 Mode étoile infini activé'));
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones à chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centrée
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion après 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // Délai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le même niveau stars infini
                phaseJeu = 'stars';
                periode = 'nuit';
                VOYAGE = NUIT;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessagePowerupSimple(getTranslatedText('system.level_completed_new_stars', '🌟 Niveau terminé - Nouveau niveau stars'));

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'étoiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // Délai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // Séquence finale : 3 formations aléatoires avec explosions

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations aléatoires différentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // Séquence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position aléatoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);console.log(`Formation ${index + 1}: ${formation} à (${x}, ${y})`);

                        // Explosion après formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu après la séquence complète (3 × 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arrêter le tir automatique à la fin du mode étoile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard correct
            narrationManager.showFinalMenu();
        }


        function afficherMenuFinal() {
            // Fermer le formulaire s'il est ouvert
            const formulaire = document.getElementById('formulaire-fin-overlay');
            if (formulaire) {
                formulaire.remove();
            }

            // ✅ Ouvrir automatiquement le menu Info/Énigmes sur l'onglet INFO
            ouvrirMenuEnigmesCanvas();
            menuEnigmesCanvas.ongletActif = 'info'; // Activer l'onglet Info
            menuEnigmesCanvas.scrollY = 0; // Reset scroll
            menuEnigmesCanvas.projectButtons = null; // 🔥 FORCE le rafraîchissement pour Firefox

            // ❌ NE PAS redémarrer automatiquement - laisser le joueur sur la phase 23 finale
            // Le bouton [Recommencer] dans le message final fera le restart si le joueur le souhaite
        }

        // Lancer la phase bonus
        // Données du livre blanc moderne
        const livreBonus = {
            currentPage: 0,
            animation: 0,
            pages: [
                {
                    title: "Partie 1 - Le Mur",
                    text: `Au loin… je vois un mur.
Un mur dressé dans la mer comme une cicatrice.
Un mur qui n'est pas fait de pierres,
mais de lois, de papiers et de regards fermés.`
                },
                {
                    title: "Partie 2 - La Prison",
                    text: `Ce mur est la prison de la liberté des hommes.
Il sépare ceux qui peuvent courir sans chaînes,
et ceux qu'on enferme dans des frontières invisibles.`
                },
                {
                    title: "Partie 3 - Les Pauvres",
                    text: `Pour les pauvres, il est barbelé de refus,
fermé comme une porte rouillée.
Ils y frappent de leurs mains nues,
leurs rêves brisés par le silence des gardiens.`
                },
                {
                    title: "Partie 4 - Les Riches",
                    text: `Pour les riches, il est une porte d'or.
Elle s'ouvre sans effort,
et les laisse circuler comme le vent qui n'a pas de patrie.`
                },
                {
                    title: "Partie 5 - La Question",
                    text: `Alors je me demande…
La liberté est-elle vraiment un droit,
ou est-elle devenue un privilège vendu aux plus offrants ?`
                },
                {
                    title: "Partie 6 - L'Espoir",
                    text: `Mais dans le cœur des vagues,
la mer murmure une vérité :
aucun mur n'est éternel.

Ces murs sont les nôtres,
on les crée par nos peurs et nos divisions.
Mais l'humanité n'a pas besoin de murs.
Elle a besoin de ponts.`
                }
            ]
        };

        function dessinerLivreBonus() {
            livreBonus.animation += 0.02;

            // Fond blanc moderne avec subtil gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, C.H);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#f8f9fa');
            gradient.addColorStop(1, '#ffffff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, C.W, C.H);

            // Dimensions de la page
            const pageWidth = C.W * 0.88;
            const pageHeight = C.H * 0.80;
            const pageX = (C.W - pageWidth) / 2;
            const pageY = (C.H - pageHeight) / 2;

            // Ombre subtile de la page
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 25;
            ctx.shadowOffsetY = 10;

            // Page unique blanche avec coins arrondis
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(pageX + 8, pageY);
            ctx.lineTo(pageX + pageWidth - 8, pageY);
            ctx.quadraticCurveTo(pageX + pageWidth, pageY, pageX + pageWidth, pageY + 8);
            ctx.lineTo(pageX + pageWidth, pageY + pageHeight - 8);
            ctx.quadraticCurveTo(pageX + pageWidth, pageY + pageHeight, pageX + pageWidth - 8, pageY + pageHeight);
            ctx.lineTo(pageX + 8, pageY + pageHeight);
            ctx.quadraticCurveTo(pageX, pageY + pageHeight, pageX, pageY + pageHeight - 8);
            ctx.lineTo(pageX, pageY + 8);
            ctx.quadraticCurveTo(pageX, pageY, pageX + 8, pageY);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;

            // Bordure subtile grise
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Page actuelle
            const page = livreBonus.pages[livreBonus.currentPage];

            // Titre
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 22px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(page.title, C.W / 2, pageY + 50);

            // Ligne décorative sous le titre
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(C.W / 2 - 80, pageY + 65);
            ctx.lineTo(C.W / 2 + 80, pageY + 65);
            ctx.stroke();

            // Numéro de page
            ctx.fillStyle = '#95a5a6';
            ctx.font = 'italic 13px Georgia';
            ctx.fillText(`Page ${livreBonus.currentPage + 1} / ${livreBonus.pages.length}`, C.W / 2, pageY + 90);

            // Texte centré sur la page
            ctx.fillStyle = '#34495e';
            ctx.font = '16px Georgia';
            ctx.textAlign = 'center';
            
            const lines = page.text.split('\n');
            const lineHeight = 28;
            const startY = pageY + 130;

            lines.forEach((line, i) => {
                ctx.fillText(line, C.W / 2, startY + i * lineHeight);
            });

            // Boutons de navigation modernes
            const buttonY = pageY + pageHeight + 30;

            // Bouton Précédent
            if (livreBonus.currentPage > 0) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('◄', C.W / 2 - 90, buttonY);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '15px Georgia';
                ctx.fillText('Précédent', C.W / 2 - 90, buttonY + 22);
            }

            // Bouton Suivant
            if (livreBonus.currentPage < livreBonus.pages.length - 1) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('►', C.W / 2 + 90, buttonY);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '15px Georgia';
                ctx.fillText('Suivant', C.W / 2 + 90, buttonY + 22);
            }

            // Bouton Fermer
            ctx.fillStyle = '#95a5a6';
            ctx.font = '15px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('✕ Fermer', C.W / 2, buttonY + 8);
        }

        function lancerPhaseBonus() {
            // Donner le bonus XP
            giveXPBonus(200);
            
            // Passer en mode livre bonus
            jeu = false;
            phaseJeu = 'bonus_livre';
            livreBonus.currentPage = 0;
        }

        function demarrerPhaseBonus() {
            lancerPhaseBonus();
        }

        // Fonction dédiée pour donner XP bonus (simple avec score)
        function giveXPBonus(amount) {
            try {

                // Ajouter au score directement
                score += amount;

                // Message simple
                afficherMessagePowerupSimple(getTranslatedText('system.bonus_points_endgame', `🌟 +${amount} Points bonus fin de jeu`));

                return true;
            } catch (error) {
                console.error('❌ Erreur attribution bonus score:', error);
                return false;
            }
        }

        function afficherCreditsFinaux() {
            const msg = document.getElementById('message');
            msg.innerHTML = `
                <div style="text-align: center; background: linear-gradient(135deg, #8B4513, #A0522D); padding: 25px; border-radius: 15px; margin: 20px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 20px; color: #ffffff;">📜 Menu Artistique Emmanuel 📜</h2>
                    <p style="color: #ffd700; margin-bottom: 20px;"><strong>✨ Signature Artistique :</strong> Dreamer Unisona</p>

                    <!-- Section Crédits avec style amélioré -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FFD700; text-align: center; margin-bottom: 15px;">🎨 Création Artistique</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>🎮 Création & Développement :</strong> Emmanuel Payet</p>
                            <p><strong>🎨 Design & Concept :</strong> Emmanuel Payet</p>
                            <p><strong>✍️ Narration & Poésie :</strong> Emmanuel Payet</p>
                            <p><strong>🎵 Vision Artistique :</strong> Emmanuel Payet</p>
                        </div>
                    </div>

                    <!-- Section Projet avec icônes -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #87CEEB; text-align: center; margin-bottom: 15px;">🌟 Fable Interactive</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>💝 Projet :</strong> "PETIT BATEAU"</p>
                            <p><strong>🌟 Message :</strong> Une fable interactive sur les préjugés</p>
                            <p><strong>📅 Année :</strong> 2025</p>
                            <p><strong>🏷️ Copyright :</strong> © Emmanuel Payet - Tous droits réservés</p>
                        </div>
                    </div>

                    <!-- Section Systèmes de Jeu -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FF6B35; text-align: center; margin-bottom: 15px;">📊 Systèmes Implémentés</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>⭐ XP :</strong> Points de Connaissance (phase d'apprentissage)</p>
                            <p><strong>🕊️ Score d'Ange :</strong> Performance de jeu principal</p>
                            <p><strong>❤️ Vies :</strong> Système de survie (3 maximum)</p>
                            <p><strong>🧱 Briques :</strong> Progression par niveau</p>
                            <p><strong>📜 Énigmes :</strong> 10 révélations poétiques débloquables</p>
                            <p><strong>🎮 Mode Secret :</strong> Mini-jeu kawaii caché</p>
                        </div>
                    </div>

                    <!-- Section Énigmes Collectables -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #8A2BE2; text-align: center; margin-bottom: 15px;">📜 Collection d'Énigmes</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>💖 Phase Cœurs :</strong> Humanité, Diversité, Respect, Restauration</p>
                            <p><strong>🧱 Phase Briques :</strong> Paix, Foi, Guérison</p>
                            <p><strong>🌙💖 Phase Nuit Cœurs :</strong> Liberté, Entraide</p>
                            <p><strong>🏮 Phase Lanterne :</strong> Ange Gardien (spéciale)</p>
                        </div>
                    </div>

                    <!-- Citation Poétique améliorée -->
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1)); border: 3px solid #FFD700; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: center;">
                        <p style="font-style: italic; color: #ffd700; font-size: 1.1rem; line-height: 1.5;">
                            "Aucun mur n'est éternel.<br>
                            Car l'eau finit toujours par user la pierre,<br>
                            et la liberté reprendra son chemin."
                        </p>
                        <p style="font-style: italic; color: #87CEEB; margin-top: 15px; font-size: 1rem;">
                            — Dreamer Unisona
                        </p>
                        <hr style="margin: 15px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p style="font-style: italic; color: #ffffff; font-size: 0.9rem;">
                            "Dans chaque énigme se cache une vérité,<br>
                            dans chaque vérité se révèle notre humanité."
                        </p>
                    </div>

                    <!-- Boutons de navigation améliorés -->
                    <div style="margin-top: 25px;">
                        <button onclick="const lang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr'; window.location.href = 'modules/emmanuel-artist-module.html?lang=' + lang"
                                style="background: linear-gradient(145deg, #4169E1, #1E90FF); border: none; border-radius: 25px; padding: 12px 25px; margin: 8px; color: white; font-size: 14px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            📜 Voir Collection Complète
                        </button>
                        <br>
                        <button onclick="narrationManager.showFinalMenu()"
                                style="background: linear-gradient(145deg, #2E8B57, #3CB371); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            ← Retour au Menu Principal
                        </button>
                    </div>
                </div>
            `;
        }

        function recommencerJeu() {
            // Réinitialiser complètement le jeu
            hardResetGame();
        }

        // � Recommencer à la phase 2 (après avoir terminé le jeu)
        function recommencerDepuisPhase2() {
            console.log('🔄 Redémarrage depuis la phase 2...');
            
            // Réinitialiser les variables de jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'briques'; // ✅ Phase 2 = mode briques
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false; // ✅ Sera mis à true après l'init
            formulaireFinAffiche = false;
            
            // Réinitialiser les systèmes
            animationBateau.active = false;
            phaseIntro = { active: false, etape: 'complete', tempsDebut: 0 }; // ✅ Pas d'intro
            
            // Nettoyer les éléments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];
            coeurs = [];
            petitsCoeurs = [];
            
            // Réinitialiser le narration manager
            if (narrationManager) {
                narrationManager.reset(); // ✅ Reset complet
            }
            
            // Fermer tous les menus/overlays
            const overlay = document.getElementById('formulaire-fin-overlay');
            if (overlay) overlay.remove();
            
            if (menuEnigmesCanvas) {
                menuEnigmesCanvas.visible = false;
            }
            
            // Cacher tous les messages
            cacherMessage();
            if (messageNarratifActif) {
                messageNarratifActif = null;
            }
            if (messagePowerupActif) {
                messagePowerupActif = null;
            }
            
            // Relancer l'initialisation
            initJeu();
            dedoublerCoeursEnBriques(); // ✅ Créer les briques pour la phase 2
            
            // ✅ Démarrer directement à la phase 2
            setTimeout(() => {
                narrationManager.currentPhase = 2; // Positionner sur phase 2
                narrationManager.executeCurrentPhase(true); // Exécuter avec texte narratif
                jeu = true; // ✅ IMPORTANT: Démarrer le jeu
                console.log('🎮 Jeu redémarré à la phase 2, jeu =', jeu);
            }, 500);
            
            // Démarrer directement à la phase 2 (sauter l'intro)
            setTimeout(() => {
                if (narrationManager) {
                    narrationManager.currentPhase = 1; // Index 1 = Phase 2
                    narrationManager.goToNextPhaseDirect(); // Passe à la phase 2
                    jeu = true; // Activer le jeu
                }
                console.log('✅ Jeu redémarré à la phase 2');
            }, 500);
        }

        // 🔄 RECRÉER PHASE ACTUELLE - Sans intro ni narration
        function recreerPhaseActuelle(redonnerVies = false) {
            console.log('🔄 Recréation de la phase actuelle sans intro...');
            
            // Récupérer la phase en cours
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 2;
            
            // Redonner 3 vies si demandé (pour "Passer & Continuer" et "Enregistrer")
            if (redonnerVies) {
                vies = 3;
                console.log('💝 3 vies redonnées');
            }
            
            // Nettoyer SANS toucher au score/progression
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];
            petitsCoeurs = [];
            
            // ✅ Nettoyer les états temporaires (power-ups, modes spéciaux)
            if (window.modeTirStars) {
                window.modeTirStars = { actif: false, fin: 0 };
            }
            if (raquette) {
                raquette.poxerstart = false;
                raquette.poxerstartFin = 0;
            }
            
            // ✅ Définir un flag AVANT de désactiver l'intro pour éviter que initJeu() la réactive
            window.skipIntroAnimation = true;
            
            // ✅ Désactiver l'animation du bateau (intro)
            animationBateau.active = false;
            animationBateau.phase = 'complete';
            
            // ✅ Désactiver la phase d'intro
            phaseIntro = { active: false, etape: 'complete', tempsDebut: 0 };
            
            // Cacher les messages narratifs
            cacherMessage();
            messageNarratifActif = null;
            
            // Fermer tous les overlays (formulaires, etc.)
            const overlay = document.getElementById('formulaire-fin-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // ✅ NE PAS créer les briques maintenant, laisser executeCurrentPhase() le faire
            // après avoir configuré le bon mode de jeu
            
            // ✅ Forcer la reconfiguration en réinitialisant phaseJeu
            phaseJeu = '';
            
            // ✅ Désactiver temporairement le jeu pendant la reconfiguration
            jeu = false;
            
            // ✅ Ré-exécuter la configuration complète de la phase (mode de jeu, briques, etc.)
            if (narrationManager && phaseActuelle > 0) {
                // ✅ Récupérer la phase par son numéro (pas par index)
                const phase = narrationManager.getCurrentPhase();
                if (phase && phase.mode) {
                    console.log(`🔧 Configuration directe du mode: ${phase.mode} pour phase ${phaseActuelle} (${phase.titre})`);
                    
                    // Appeler directement la méthode de configuration appropriée
                    narrationManager.configureGameMode(phase.mode);
                } else {
                    console.error(`❌ Phase ${phaseActuelle} non trouvée !`);
                }
                
                // ✅ Réactiver le jeu APRÈS configuration
                setTimeout(() => {
                    jeu = true;
                    console.log(`✅ Phase ${phaseActuelle} recréée avec mode ${phaseJeu} (score: ${score}, vies: ${vies})`);
                    
                    // ✅ Nettoyer le flag après la recréation
                    window.skipIntroAnimation = false;
                }, 50);
            }
        }

        // �🔥 HARD RESET COMPLET - Efface TOUT
        function hardResetGame() {
            console.log('🔥 HARD RESET - Effacement complet du jeu...');
            
            // 1. Effacer TOUT le localStorage
            try {
                localStorage.clear();
                console.log('✅ localStorage effacé');
            } catch(e) {
                console.warn('⚠️ Erreur effacement localStorage:', e);
            }
            
            // 2. Effacer TOUT le sessionStorage
            try {
                sessionStorage.clear();
                console.log('✅ sessionStorage effacé');
            } catch(e) {
                console.warn('⚠️ Erreur effacement sessionStorage:', e);
            }
            
            // 3. Effacer les cookies
            try {
                document.cookie.split(";").forEach(function(c) { 
                    document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
                });
                console.log('✅ Cookies effacés');
            } catch(e) {
                console.warn('⚠️ Erreur effacement cookies:', e);
            }
            
            // 4. Effacer le cache du Service Worker
            if ('caches' in window) {
                caches.keys().then(function(names) {
                    for (let name of names) {
                        caches.delete(name);
                    }
                    console.log('✅ Cache Service Worker effacé');
                });
            }
            
            // 5. Réinitialiser les variables globales du jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false;
            formulaireFinAffiche = false;
            
            // 6. Réinitialiser les systèmes
            animationBateau.active = false;
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
            
            // 7. Nettoyer les éléments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];
            coeurs = [];
            
            // 8. Réinitialiser le narration manager
            if (narrationManager) {
                narrationManager.reset();
            }
            
            // 9. Réinitialiser l'énigme collector
            if (enigmaCollector) {
                enigmaCollector.enigmesCollectees.clear();
                enigmaCollector.enigmesVues.clear();
            }
            
            // 10. Fermer tous les menus/overlays
            const overlay = document.getElementById('formulaire-fin-overlay');
            if (overlay) overlay.remove();
            
            if (menuEnigmesCanvas) {
                menuEnigmesCanvas.visible = false;
            }
            
            // 11. Cacher tous les messages
            cacherMessage();
            if (messageNarratifActif) {
                messageNarratifActif = null;
            }
            if (messagePowerupActif) {
                messagePowerupActif = null;
            }
            
            // 12. Relancer l'initialisation complète
            initJeu();
            creerPetitsCoeurs();
            
            // 13. Redémarrer la narration depuis le début
            setTimeout(() => {
                if (narrationManager) {
                    narrationManager.start();
                }
                console.log('🎮 HARD RESET terminé - Jeu redémarré');
            }, 1000);
            
            // 14. Recharger la page après un court délai pour être sûr
            setTimeout(() => {
                console.log('🔄 Rechargement de la page pour reset total...');
                window.location.reload(true); // force=true pour ignorer le cache
            }, 2000);
        }

        // 🎭 MESSAGES AVEC ANIMATIONS TYPEWRITER - Pour mode secret et effets spéciaux
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du cœur en rouge au début si spécifié
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">💔 ${motRouge.toUpperCase()} 💔</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il apparaît dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Callback pour gérer la fin de l'animation et le timing de disparition
            const onComplete = () => {
                // Attendre un peu après la fin de l'animation avant de faire disparaître
                setTimeout(() => {
                    cacherMessage();
                }, Math.max(1000, duree * 0.2)); // Au moins 1s d'attente après l'animation
            };

            // Créer une nouvelle instance TextAnimator avec le nouveau code optimisé
            const anim = new TextAnimator('message');

            switch(animation) {
                case 'typewriter':
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'digital':
                    anim.digital(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fade':
                    anim.fade(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'glitch':
                    anim.glitch(texteComplet, {
                        duration: Math.max(2000, duree * 0.3),
                        onComplete: onComplete
                    });
                    break;
                case 'emboss':
                    anim.setColors('#ffffff', '#666666');
                    anim.applyEffect('emboss');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'neon':
                    anim.setColors('#64ffda', '#64ffda');
                    anim.applyEffect('neon');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'shadow3d':
                    anim.setColors('#ffffff', '#333333');
                    anim.applyEffect('shadow3d');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fire':
                    anim.setColors('#ff4444', '#ff8800');
                    anim.applyEffect('fire');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'ice':
                    anim.setColors('#ffffff', '#ffffff');
                    anim.applyEffect('none');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'outline':
                    anim.setColors('#ffffff', '#000000');
                    anim.applyEffect('outline');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                default:
                    msg.innerHTML = texteComplet.replace(/\n/g, '<br>');
                    onComplete();
            }
        }

        // 📝 FONCTION PRINCIPALE D'AFFICHAGE - Messages standard blancs centrés
        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du cœur en rouge au début si spécifié
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">💔 ${motRouge.toUpperCase()} 💔</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il apparaît dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            // Garder le texte à sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    msg.style.display = 'none'; // Remettre display none après la durée
                }, duree);
            }
        }

        // Fonction pour afficher les messages narratifs de phase (style cinématique)
        function afficherMessageNarratifPhase(texte, duree) {
            const msg = document.getElementById('message');

            // AJOUTER la classe narratif pour le style cinématique
            msg.classList.add('narratif');

            msg.innerHTML = texte;
            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            // Garder le texte à sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    msg.classList.remove('narratif'); // Retirer la classe après
                    msg.style.display = 'none';
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Créer le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        ${getTranslatedText('ui.replay_button')}
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ➡️ Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte à sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }


        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifié et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;
            
            // ⚡ OPTIMISATION: Incrémenter le compteur de frames
            fondAniméCache.frameCount++;

            // ⚡ OPTIMISATION: Initialiser les gradients si nécessaire
            if (!fondAniméCache.gradients.merJour || !fondAniméCache.gradients.merNuit) {
                initGradientsMer();
            }

            // ⚡ OPTIMISATION: Utiliser le gradient en cache
            ctx.fillStyle = periode === 'jour' ? fondAniméCache.gradients.merJour : fondAniméCache.gradients.merNuit;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // ✨ VAGUES FLUIDES: Calculer chaque frame avec interpolation optimisée
            // Vagues selon le chapitre
            if(periode === 'jour') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues - rendu fluide avec interpolation quadratique
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = periode === 'jour' ? (8 - ligne * 2) : (12 - ligne * 3);
                const fréquence = 0.01 + ligne * 0.005;
                const vitesse = periode === 'jour' ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                // ⚡ Pas de 15 (compromis fluidité/performance) avec courbes de Bézier
                let prevX = 0;
                let prevY = y + Math.sin(0 * fréquence + offset) * amplitude;
                ctx.moveTo(prevX, prevY);
                
                for(let x = 15; x <= C.W; x += 15) {
                    const currentY = y + Math.sin(x * fréquence + offset) * amplitude;
                    // Interpolation quadratique pour courbes lisses
                    const cpX = prevX + 7.5; // Point de contrôle au milieu
                    const cpY = (prevY + currentY) / 2;
                    ctx.quadraticCurveTo(cpX, cpY, x, currentY);
                    prevX = x;
                    prevY = currentY;
                }
                ctx.stroke();
            }

            // ⚡ OPTIMISATION: Mettre à jour les requins tous les N frames
            if(periode === 'nuit' && !leverSoleil.active && phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                if (fondAniméCache.frameCount - fondAniméCache.lastSharkFrame >= fondAniméCache.sharkThrottle) {
                    fondAniméCache.lastSharkFrame = fondAniméCache.frameCount;
                    
                    const requins = [
                        { x: 0.2, vitesse: 0.3, taille: 1.0 },
                        { x: 0.6, vitesse: 0.5, taille: 0.8 },
                        { x: 0.9, vitesse: 0.4, taille: 1.2 }
                    ];

                    fondAniméCache.sharkPositions = requins.map(requin => {
                        const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                        const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                        const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;
                        return { reqX, reqY, taille };
                    });
                }
                
                // Dessiner les requins avec positions en cache
                fondAniméCache.sharkPositions.forEach(({reqX, reqY, taille}) => {
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8);
                    ctx.lineTo(reqX, reqY - taille);
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // Déclarer les variables pour éviter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(periode === 'jour') {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% à 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui évolue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // ⚡ OPTIMISATION: Rayons du soleil avec throttling et cache
                const frameCount = Date.now();
                if (frameCount - fondAniméCache.lastSunRaysFrame > fondAniméCache.sunRaysThrottle * 16) { // ~30fps
                    const rotationSoleil = frameCount * 0.0005; // Rotation lente cachée
                    const nbRayons = leverSoleil.active ? 12 : 6; // Réduit: 16→12, 8→6
                    
                    // Précalculer les angles des rayons
                    fondAniméCache.sunRaysAngles = [];
                    for(let i = 0; i < nbRayons; i++) {
                        fondAniméCache.sunRaysAngles.push((i / nbRayons) * Math.PI * 2 + rotationSoleil);
                    }
                    fondAniméCache.lastSunRaysFrame = frameCount;
                }
                
                // Dessiner les rayons avec les angles cachés
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3; // ✅ Épaisseur originale restaurée
                
                fondAniméCache.sunRaysAngles.forEach(angle => {
                    const longueurRayon = leverSoleil.active ? 20 : 12; // Réduit: 25→20, 15→12
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                });
            } else {
                // CHAPITRE 2: Lune inquiétante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(periode === 'jour') {
                // Vérifier si le soleil fait un clin d'œil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'œil pendant 2 secondes

                // Arrêter le clignotement après 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant à la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et fermés (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux fermés paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et modéré
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence à sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'œil ! Œil gauche fermé, œil droit ouvert
                        // Œil gauche fermé (clin d'œil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // Œil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'œil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au début
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inquiétante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre (désactivés en phase finale et feux d'artifice)
            if(phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                if(periode === 'jour') {
                    // Nuages blancs paisibles
                    const nuages = [
                        { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                        { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                        { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                    ];

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                    ctx.lineWidth = 2;

                    nuages.forEach(nuage => {
                        const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                        const nuageY = C.H * nuage.y;
                        const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                        for(let i = 0; i < 3; i++) {
                            const offsetX = (i - 1) * taille * 0.8;
                            const rayonNuage = taille * (0.8 + i * 0.1);
                            ctx.beginPath();
                            ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                } else {
                    // Nuages d'orage gris avec éclairs
                    const nuagesOrage = [
                        { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                        { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                        { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                    ];

                    nuagesOrage.forEach(nuage => {
                        const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                        const nuageY = C.H * nuage.y;
                        const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                        // Nuages gris menaçants
                        ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                        ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                        ctx.lineWidth = 2;

                        for(let i = 0; i < 4; i++) {
                            const offsetX = (i - 1.5) * taille * 0.6;
                            const rayonNuage = taille * (0.7 + i * 0.1);
                            ctx.beginPath();
                            ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }

                        // Éclairs occasionnels
                        if(Math.random() < 0.02) {
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(nuageX, nuageY + taille);
                            ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                            ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                            ctx.stroke();
                        }
                    });
                }
            }
        }

        // Rendu principal
        function dessiner() {
            // ⚡ OPTIMISATION #6 : Clear canvas au début du rendu principal
            // Évite accumulation et ghosting des éléments dessinés
            // (Note: boucleJeu() fait aussi un clear, mais dessiner() peut être appelé seul)
            ctx.clearRect(0, 0, C.W, C.H);

            // 📱 Appliquer l'inertie du bateau (après touch)
            appliquerInertieBateau();

            // ⚡ OPTIMISATION: Initialiser les gradients fond si nécessaire
            if (!fondAniméCache.gradients.fondFinale || !fondAniméCache.gradients.fondJour || !fondAniméCache.gradients.fondNuit) {
                initGradientsFond();
            }

            // Fond dégradé selon le chapitre (utiliser gradients en cache)
            // Protection contre les valeurs non finies
            if (!isFinite(C.H) || C.H <= 0) {
                console.error('Erreur: C.H non valide:', C.H);
                return;
            }

            // ⚡ OPTIMISATION: Utiliser gradients en cache au lieu de les recréer
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                ctx.fillStyle = fondAniméCache.gradients.fondFinale;
            } else if(periode === 'jour') {
                ctx.fillStyle = fondAniméCache.gradients.fondJour;
            } else {
                ctx.fillStyle = fondAniméCache.gradients.fondNuit;
            }
            ctx.fillRect(0, 0, C.W, C.H);

            // Phase finale : soleil couchant derrière la mer
            if(phaseJeu === 'feux_artifice' || phaseJeu === 'final') {
                // ⚡ OPTIMISATION: Initialiser les gradients si nécessaire
                if (!fondAniméCache.gradients.soleilCouchant) {
                    initGradientsSoleilCouchant();
                }
                
                // Position du soleil (à moitié immergé dans la mer)
                const soleilX = C.W * 0.75;
                const merY = C.H - 60;
                const soleilY = merY + 10;
                const rayonSoleil = 60;

                // ⚡ OPTIMISATION: Utiliser gradients en cache
                ctx.fillStyle = fondAniméCache.gradients.haloSoleilCouchant;
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, rayonSoleil * 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = fondAniméCache.gradients.soleilCouchant;
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, rayonSoleil, 0, Math.PI * 2);
                ctx.fill();

                // ⚡ OPTIMISATION: Reflet avec gradient en cache
                ctx.fillStyle = fondAniméCache.gradients.refletSoleil;
                ctx.fillRect(soleilX - 40, merY, 80, C.H - merY);

                // Dessiner la mer par-dessus (pour masquer la partie basse du soleil)
                dessinerMer();

                // Quelques nuages légers
                const temps = Date.now() * 0.0002;
                for(let i = 0; i < 3; i++) {
                    const nuageX = (C.W * (0.1 + i * 0.3) + temps * 15 * (i + 1)) % (C.W + 200) - 100;
                    const nuageY = C.H * 0.2 + i * 50;
                    const nuageW = 100 + i * 30;
                    const nuageH = 30;

                    ctx.fillStyle = `rgba(255, 180, 180, ${0.25 - i * 0.05})`;
                    ctx.beginPath();
                    ctx.ellipse(nuageX, nuageY, nuageW, nuageH, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                dessinerCiel();
                dessinerMer();
            }

            // Effet d'éclairs en mode nuit
            if (periode === 'nuit') {
                dessinerEclairNuit();
            }

            dessinerInterface();
            dessinerPowerUps();    // ← Power-ups d'abord (cachés derrière)
            dessinerPrejuges();    // ← Briques par-dessus (cachent les power-ups)
            dessinerCoeursBateau();
            
            // Désactiver petits cœurs décoratifs pour phases 17-23 (système de projectiles progressifs)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (!(phaseActuelle >= 17 && phaseActuelle <= 23 && phaseJeu === 'mur')) {
                dessinerPetitsCoeurs();
            }
            
            dessinerBateau();
            afficherMunitions();
            dessinerStarsProjectiles(); // Étoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // Étoiles (phase briques)
            // Mode secret - désactivé en phase finale
            if (phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                if (secretModeModule && secretModeModule.isActive) {
                    secretModeModule.render();
                } else if (modeSecret) {
                    // Fallback si le module n'est pas disponible
                    dessinerProjectilesSecret();
                }
            }
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret
            dessinerChauveSouris(); // Chauve-souris révélée
            // Animation d'icône supprimée - les icônes en haut servent de menu direct
            // Les icônes en haut servent maintenant de menu direct

            // Obstacles gérés par le module secret seulement

            // Objets kawaii réservés au mode secret uniquement
            // (Les objets kawaii sont maintenant dans le module secret)

            dessinerParticules();
            dessinerPluie(); // Dessiner la pluie (phase 5)

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
            dessinerEtoileCompteur(); // Étoile avec compteur de clics corbeau
            dessinerMessagePowerupSimple(); // Messages simples des powerups en haut
            dessinerMessageNarratifSimple(); // Messages narratifs centrés
            dessinerBoutonPasser(); // Bouton passer simple en haut

            // ⚡ OPTIMISATION: Menu énigmes - N'appeler que si visible
            if (menuEnigmesCanvas.visible) {
                dessinerMenuEnigmesCanvas();
            }

            // Bouton plein écran retiré - Plein écran automatique sur mobile

            // 🌍 Ancien icône de langue désactivé - remplacé par l'onglet langues intégré
            // Le sélecteur de langue est maintenant dans le menu énigmes (onglet Langues)
            if (false && languageSelector.languageChosen) {
                const langIconX = C.W - 35;
                const langIconY = 70;
                const langIconRadius = 18;

                ctx.save();
                // Cercle de fond blanc arrondi
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(langIconX, langIconY, langIconRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Drapeau de la langue actuelle
                const currentLangBtn = languageSelector.buttons.find(b => b.code === currentLang);
                const drapeau = currentLangBtn ? currentLangBtn.drapeau : '🇫🇷';
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(drapeau, langIconX, langIconY);
                ctx.restore();

                // Stocker pour détection de clic
                languageSelector.iconButton.x = langIconX;
                languageSelector.iconButton.y = langIconY;
                languageSelector.iconButton.radius = langIconRadius;

                // Menu déroulant (si ouvert)
                if (languageSelector.menuOpen) {
                    const menuWidth = 150;
                    const menuItemHeight = 40;
                    const menuHeight = languageSelector.buttons.length * menuItemHeight;
                    const menuX = langIconX - menuWidth - 10;
                    const menuY = langIconY - menuHeight / 2;

                    // Fond du menu
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.roundRect(menuX, menuY, menuWidth, menuHeight, 8);
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Liste des langues
                    languageSelector.buttons.forEach((btn, index) => {
                        const itemY = menuY + (index * menuItemHeight);
                        const isActive = btn.code === currentLang;

                        // Stocker position pour clic
                        btn.menuX = menuX;
                        btn.menuY = itemY;
                        btn.menuWidth = menuWidth;
                        btn.menuHeight = menuItemHeight;

                        // Fond de l'item (si actif)
                        if (isActive) {
                            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                            ctx.fillRect(menuX, itemY, menuWidth, menuItemHeight);
                        }

                        // Drapeau
                        ctx.save();
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(btn.drapeau, menuX + 15, itemY + menuItemHeight / 2);

                        // Nom
                        ctx.font = 'bold 14px "Segoe UI", Arial, sans-serif';
                        ctx.fillStyle = isActive ? '#3b82f6' : '#1e293b';
                        ctx.fillText(btn.nom, menuX + 50, itemY + menuItemHeight / 2);
                        ctx.restore();
                    });
                }
            }

            // Bouton continuer EN DERNIER pour être au premier plan (Phase 16)
            dessinerBoutonContinuer();

            // Bouton Suivant simple pour phase 16
            dessinerBoutonSuivantP16();

            // 🔊 Menu audio en haut à droite : volume +/-
            const menuX = C.W - 50; // 50px du bord droit
            const menuY = 8;

            ctx.save();
            ctx.font = '18px Arial';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 3;

            // Volume − (diminuer)
            const prevBtn = { x: menuX - 10, y: menuY - 5, w: 26, h: 30 };
            window.prevSongZone = prevBtn;
            ctx.fillText('−', menuX, menuY);

            // Volume + (augmenter)
            const nextBtn = { x: menuX + 10, y: menuY - 5, w: 26, h: 30 };
            window.nextSongZone = nextBtn;
            ctx.fillText('+', menuX + 20, menuY);

            ctx.restore();

            // Rendu des drones feux d'artifice EN DERNIER pour être visible
            if (droneModule) {
                try {
                    droneModule.render();
                } catch (error) {
                    console.error('❌ Erreur rendu drones:', error);
                }
            }

            // Menu de langue en jeu (désactivé - ce code n'est plus utilisé)
            // Le sélecteur de langue s'affiche uniquement au premier démarrage (voir plus bas)
            /*
            if (languageSelector.active) {
                const elapsed = Date.now() - languageSelector.debut;

                // Si langue pas choisie, ouvrir automatiquement le menu
                if (!languageSelector.languageChosen && !languageSelector.menuOpen) {
                    languageSelector.menuOpen = true;
                }

                if (elapsed > languageSelector.duree && languageSelector.languageChosen) {
                    languageSelector.active = false;
                } else {
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Position du bouton principal (centré en haut)
                    languageSelector.mainButton.x = (C.W - languageSelector.mainButton.width) / 2;
                    // Y reste à 20 (défini dans la variable)

                    // Bouton principal 🌍
                    const mainBtn = languageSelector.mainButton;
                    const isHovered = mainBtn.hover;

                    // Fond du bouton (ROND)
                    ctx.fillStyle = isHovered ? '#ffffff' : 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = isHovered ? '#3b82f6' : '#cbd5e1';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height / 2, mainBtn.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Drapeau de la langue actuelle
                    const currentLangBtn = languageSelector.buttons.find(b => b.code === currentLang);
                    const drapeau = currentLangBtn ? currentLangBtn.drapeau : '🇫🇷';
                    ctx.font = '32px Arial';
                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(drapeau, mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height / 2);

                    // Texte "Choose language" si pas encore choisi
                    if (!languageSelector.languageChosen) {
                        ctx.font = 'bold 16px "Segoe UI", system-ui, sans-serif';
                        ctx.fillStyle = '#3b82f6';
                        const langText = currentLang === 'fr' ? 'Choisir la langue' :
                                       currentLang === 'en' ? 'Choose language' :
                                       currentLang === 'jp' ? '言語を選択' : 'Оберіть мову';
                        ctx.fillText(langText, mainBtn.x + mainBtn.width / 2, mainBtn.y + mainBtn.height + 20);
                    }

                    // Menu ouvert : afficher les choix (vers le bas)
                    if (languageSelector.menuOpen) {
                        const totalWidth = (languageSelector.buttons.length * 70) + ((languageSelector.buttons.length - 1) * 10);
                        let startX = (C.W - totalWidth) / 2;
                        const menuY = mainBtn.y + mainBtn.height + 15; // En dessous du bouton

                        // Fond du menu
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.strokeStyle = '#cbd5e1';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(startX - 10, menuY - 10, totalWidth + 20, 100, 12);
                        ctx.fill();
                        ctx.stroke();

                        // Dessiner les boutons de langue
                        languageSelector.buttons.forEach((btn, index) => {
                            btn.x = startX + (index * 80);
                            btn.y = menuY;

                            const isActive = currentLang === btn.code;
                            const isBtnHovered = btn.hover;

                            // Fond du bouton
                            ctx.fillStyle = isActive ? '#3b82f6' : (isBtnHovered ? '#e2e8f0' : '#f8fafc');
                            ctx.strokeStyle = isActive ? '#2563eb' : '#cbd5e1';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 8);
                            ctx.fill();
                            ctx.stroke();

                            // Drapeau
                            ctx.font = '28px Arial';
                            ctx.fillText(btn.drapeau, btn.x + btn.width / 2, btn.y + 25);

                            // Nom de la langue
                            ctx.font = 'bold 10px "Segoe UI", system-ui, sans-serif';
                            ctx.fillStyle = isActive ? '#ffffff' : '#1e293b';
                            ctx.fillText(btn.nom, btn.x + btn.width / 2, btn.y + 52);
                        });
                    }

                    ctx.restore();
                }
            }
            */

            // 🌍 MINI-JEU "BRISER LES FRONTIÈRES" - Par-dessus tout
            if (briqueLangue.active) {
                ctx.save();

                // Dimensions sécurisées - utiliser les dimensions du canvas réel
                const canvasW = canvas.width && isFinite(canvas.width) ? canvas.width : 800;
                const canvasH = canvas.height && isFinite(canvas.height) ? canvas.height : 600;

                // Vérification de sécurité
                if (!isFinite(canvasW) || !isFinite(canvasH) || canvasW <= 0 || canvasH <= 0) {
                    ctx.restore();
                    return;
                }

                // Fond dégradé bleu roi -> blanc -> rouge
                const gradient = ctx.createLinearGradient(0, 0, 0, canvasH);
                gradient.addColorStop(0, '#0055A4');      // Bleu roi
                gradient.addColorStop(0.5, '#ffffff');    // Blanc
                gradient.addColorStop(1, '#EF4135');      // Rouge
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvasW, canvasH);

                // Vagues animées en fond
                const time = Date.now() / 1000;
                ctx.save();

                // Vague 1 (arrière)
                ctx.globalAlpha = 0.15;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.3 + Math.sin(x * 0.01 + time * 0.5) * 40 + Math.cos(x * 0.02 + time * 0.3) * 20;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 2 (milieu)
                ctx.globalAlpha = 0.2;
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.5 + Math.sin(x * 0.015 + time * 0.7) * 50 + Math.cos(x * 0.025 + time * 0.5) * 25;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Vague 3 (avant)
                ctx.globalAlpha = 0.25;
                ctx.lineWidth = 5;
                ctx.beginPath();
                for (let x = 0; x < canvasW; x += 5) {
                    const y = canvasH * 0.7 + Math.sin(x * 0.02 + time * 1) * 60 + Math.cos(x * 0.03 + time * 0.8) * 30;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.restore();

                // Particules décoratives (réduites)
                for (let i = 0; i < 15; i++) {
                    const x = (i * canvasW / 15) + (Math.sin(time + i) * 50);
                    const y = (i * canvasH / 15) + (Math.cos(time + i) * 30);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.15 + Math.sin(time + i) * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // NUAGE DE TRADUCTIONS "PETIT BATEAU"
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;

                const margin = 100;
                const translations = [
                    { text: '⛵', x: canvasW/2, y: canvasH/2 - 310, size: 64, opacity: 1 },
                    { text: 'PETIT BATEAU', x: canvasW/2, y: canvasH/2 - 180, size: 48, opacity: 1 },
                    { text: 'LITTLE BOAT', x: Math.max(margin, canvasW/2 - 200), y: canvasH/2 - 220, size: 36, opacity: 0.85 },
                    { text: '小さな船', x: Math.min(canvasW - margin, canvasW/2 + 220), y: canvasH/2 - 210, size: 32, opacity: 0.8 },
                    { text: 'МАЛЕНЬКИЙ ЧОВЕН', x: Math.max(margin + 50, canvasW/2 - 180), y: canvasH/2 - 130, size: 28, opacity: 0.75 },
                    { text: 'قارب صغير', x: Math.min(canvasW - margin, canvasW/2 + 200), y: canvasH/2 - 140, size: 30, opacity: 0.7 },
                    { text: 'छोटी नाव', x: Math.max(margin, canvasW/2 - 250), y: canvasH/2 - 170, size: 24, opacity: 0.65 },
                    { text: 'PEQUEÑO BARCO', x: Math.min(canvasW - margin - 50, canvasW/2 + 180), y: canvasH/2 - 170, size: 26, opacity: 0.7 },
                    { text: 'PICCOLA BARCA', x: Math.max(margin + 30, canvasW/2 - 140), y: canvasH/2 - 90, size: 22, opacity: 0.6 },
                    { text: '작은 배', x: Math.min(canvasW - margin, canvasW/2 + 240), y: canvasH/2 - 100, size: 28, opacity: 0.65 },
                ];

                translations.forEach(trans => {
                    ctx.font = `bold ${trans.size}px "Segoe UI", Arial, sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${trans.opacity})`;
                    ctx.fillText(trans.text, trans.x, trans.y);
                });

                ctx.shadowBlur = 0;

                // Initialiser le jeu si nécessaire
                if (!briqueLangue.game) {
                    briqueLangue.game = {
                        bricks: [],
                        projectiles: [], // Lanternes tirées
                        bateau: { x: canvasW/2, y: canvasH - 80, width: 60, height: 40 }
                    };

                    // Tous les drapeaux du monde
                    const tousLesDrapeaux = [
                        { drapeau: '🇫🇷', code: 'fr', nom: 'Français' },
                        { drapeau: '🇬🇧', code: 'en', nom: 'English' },
                        { drapeau: '🇯🇵', code: 'jp', nom: '日本語' },
                        { drapeau: '🇺🇦', code: 'uk', nom: 'Українська' },
                        { drapeau: '🇪🇸', code: 'es', nom: 'Español' },
                        { drapeau: '🇩🇪', code: 'de', nom: 'Deutsch' },
                        { drapeau: '🇮🇹', code: 'it', nom: 'Italiano' },
                        { drapeau: '🇵🇹', code: 'pt', nom: 'Português' },
                        { drapeau: '🇷🇺', code: 'ru', nom: 'Русский' },
                        { drapeau: '🇨🇳', code: 'zh', nom: '中文' },
                        { drapeau: '🇰🇷', code: 'ko', nom: '한국어' },
                        { drapeau: '🇸🇦', code: 'ar', nom: 'العربية' },
                        { drapeau: '🇮🇳', code: 'hi', nom: 'हिन्दी' },
                        { drapeau: '🇧🇷', code: 'br', nom: 'Brasil' },
                        { drapeau: '🇲🇽', code: 'mx', nom: 'México' },
                        { drapeau: '🇨🇦', code: 'ca', nom: 'Canada' },
                        { drapeau: '🇦🇺', code: 'au', nom: 'Australia' },
                        { drapeau: '🇿🇦', code: 'za', nom: 'South Africa' },
                        { drapeau: '🇪🇬', code: 'eg', nom: 'مصر' },
                        { drapeau: '🇳🇬', code: 'ng', nom: 'Nigeria' },
                        { drapeau: '🇰🇪', code: 'ke', nom: 'Kenya' },
                        { drapeau: '🇹🇷', code: 'tr', nom: 'Türkiye' },
                        { drapeau: '🇮🇷', code: 'ir', nom: 'فارسی' },
                        { drapeau: '🇹🇭', code: 'th', nom: 'ไทย' },
                        { drapeau: '🇻🇳', code: 'vn', nom: 'Việt Nam' },
                        { drapeau: '🇵🇭', code: 'ph', nom: 'Philippines' },
                        { drapeau: '🇮🇩', code: 'id', nom: 'Indonesia' },
                        { drapeau: '🇲🇾', code: 'my', nom: 'Malaysia' },
                        { drapeau: '🇸🇬', code: 'sg', nom: 'Singapore' }
                    ];

                    // Créer les briques drapeaux (4 lignes)
                    const brickW = 70;
                    const brickH = 45;
                    const cols = Math.floor(canvasW / brickW);
                    const startX = (canvasW - (cols * brickW)) / 2;
                    const startY = 80;

                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < cols; col++) {
                            const randomDrapeau = tousLesDrapeaux[Math.floor(Math.random() * tousLesDrapeaux.length)];
                            briqueLangue.game.bricks.push({
                                x: startX + col * brickW,
                                y: startY + row * brickH,
                                width: brickW - 6,
                                height: brickH - 6,
                                flag: randomDrapeau.drapeau,
                                code: randomDrapeau.code,
                                nom: randomDrapeau.nom,
                                alive: true
                            });
                        }
                    }
                }

                const game = briqueLangue.game;

                // Vérifier victoire
                const brickesRestantes = game.bricks.filter(b => b.alive).length;
                if (brickesRestantes === 0) {
                    briqueLangue.active = false;
                    const totalScore = game.bricks.length * 3;
                    afficherMessagePowerupSimple(getTranslatedText('system.victory_points', `🎉 Victoire ! +${totalScore} points`));
                    ctx.restore();
                    return;
                }

                // Mettre à jour projectiles (lanternes)
                for (let i = game.projectiles.length - 1; i >= 0; i--) {
                    const proj = game.projectiles[i];
                    proj.y -= 6; // Vitesse vers le haut

                    // Supprimer si hors écran
                    if (proj.y < -20) {
                        game.projectiles.splice(i, 1);
                        continue;
                    }

                    // Collision avec briques
                    let hit = false;
                    game.bricks.forEach(brick => {
                        if (!brick.alive || hit) return;
                        if (proj.x > brick.x && proj.x < brick.x + brick.width &&
                            proj.y > brick.y && proj.y < brick.y + brick.height) {
                            brick.alive = false;
                            hit = true;

                            // Cœurs
                            for (let j = 0; j < 3; j++) {
                                powerUps.push({
                                    x: brick.x + brick.width/2,
                                    y: brick.y + brick.height/2,
                                    dx: (Math.random() - 0.5) * 2,
                                    dy: Math.random() * 2 + 1,
                                    type: 'coeur',
                                    taille: 20,
                                    w: 20,
                                    h: 20,
                                    temps: 0
                                });
                            }

                            // Particules
                            for (let j = 0; j < 15; j++) {
                                particules.push({
                                    x: brick.x + brick.width/2,
                                    y: brick.y + brick.height/2,
                                    dx: (Math.random() - 0.5) * 5,
                                    dy: (Math.random() - 0.5) * 5,
                                    vie: 30,
                                    taille: Math.random() * 5 + 2,
                                    couleur: `hsl(${Math.random() * 360}, 70%, 60%)`
                                });
                            }
                        }
                    });

                    if (hit) {
                        game.projectiles.splice(i, 1);
                    }
                }

                // Dessiner briques
                game.bricks.forEach(brick => {
                    if (!brick.alive) return;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                    ctx.font = '36px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillText(brick.flag, brick.x + brick.width/2, brick.y + brick.height/2 - 5);

                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(brick.nom, brick.x + brick.width/2, brick.y + brick.height/2 + 15);
                });

                // Dessiner projectiles (lanternes)
                game.projectiles.forEach(proj => {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);

                    // Lanterne brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                    gradient.addColorStop(0, 'rgba(255, 220, 100, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 180, 50, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0.3)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // Emoji lanterne
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('🏮', 0, 0);

                    ctx.restore();
                });

                // Dessiner bateau
                ctx.save();
                ctx.translate(game.bateau.x, game.bateau.y);

                // Bateau emoji
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('⛵', 0, 0);
                ctx.shadowBlur = 0;

                ctx.restore();

                // Instructions
                const instructionOpacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.3;
                ctx.font = 'bold 22px "Segoe UI", Arial, sans-serif';
                ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity})`;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.fillText(getTranslatedText('game.frontiers.title', '🧱 Frontières'), canvasW/2, canvasH - 30);
                ctx.font = 'bold 16px "Segoe UI", Arial, sans-serif';
                ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity * 0.8})`;
                ctx.fillText(getTranslatedText('game.frontiers.subtitle', 'Échapper aux frontières'), canvasW/2, canvasH - 8);

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // Contrôles tactiles et souris unifiés avec support pixel ratio
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            
            // Calculer la position relative au canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Position ajustée pour le pixel ratio sur mobile
            const x = (touch.clientX - rect.left) * (isMobile ? 1 : scaleX / (window.devicePixelRatio || 1));
            const y = (touch.clientY - rect.top) * (isMobile ? 1 : scaleY / (window.devicePixelRatio || 1));
            
            return { x, y };
        }

        // Variable pour throttle du son de voile
        let dernierSonVoile = 0;
        const delaiSonVoile = 600; // 600ms entre chaque son

        // Variables pour l'inertie du bateau
        let vitesseBateau = 0; // Vitesse actuelle
        let dernierePositionX = 0; // Dernière position du bateau
        let dernierTemps = 0; // Dernier timestamp

        function deplacerRaquette(x) {
            if(!jeu) return;
            const ancienX = raquette.x;
            
            // 📱 CONTRÔLE SIMPLIFIÉ : Le bateau se centre sur le doigt
            // Centrer le bateau sur la position X du touch
            raquette.x = x - C.PW / 2;
            
            // Limites du canvas
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));

            // Calculer la vitesse pour l'inertie (uniquement en tactile)
            if (isTouchDevice) {
                const maintenant = Date.now();
                const deltaTemps = maintenant - dernierTemps;
                if (deltaTemps > 0) {
                    vitesseBateau = (raquette.x - dernierePositionX) / deltaTemps * 7; // Inertie réduite pour meilleur contrôle
                }
                dernierePositionX = raquette.x;
                dernierTemps = maintenant;
            }

            // 🔊 Son de voile quand le bateau bouge (avec throttle)
            const now = Date.now();
            if (Math.abs(raquette.x - ancienX) > 5 && now - dernierSonVoile > delaiSonVoile) {
                AudioSystem.playVoile();
                dernierSonVoile = now;
            }
        }

        // Fonction d'inertie appelée dans la boucle de jeu
        async function appliquerInertieBateau() {
            if (!jeu || !isTouchDevice || tactile) return; // Pas d'inertie si le doigt est sur l'écran
            
            if (Math.abs(vitesseBateau) > 0.1) {
                raquette.x += vitesseBateau;
                
                // Limites du canvas
                raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));
                
                // Friction pour ralentir progressivement
                vitesseBateau *= 0.92; // Décélération douce
                
                // Arrêter si vitesse très faible
                if (Math.abs(vitesseBateau) < 0.1) {
                    vitesseBateau = 0;
                }
            }
        }

        // Événements tactiles - REFONTE SIMPLIFIÉE
        canvas.addEventListener('touchstart', async e => {
            e.preventDefault();
            tactile = true;

            const pos = obtenirPosition(e);
            const x = pos.x;
            const y = pos.y || 0;
            
            // ═══════════════════════════════════════════════════════════════
            // 🎯 PRIORITÉ 1: MENU ÉNIGMES OUVERT
            // ═══════════════════════════════════════════════════════════════
            if (menuEnigmesCanvas.visible) {
                const menuPadding = 40;
                const menuWidth = C.W - 2 * menuPadding;
                const menuHeight = C.H - 2 * menuPadding;
                const menuX = menuPadding;
                const menuY = menuPadding;
                
                // Bouton fermer (X)
                const closeBtn = menuEnigmesCanvas.closeButton;
                if (closeBtn && x >= closeBtn.x && x <= closeBtn.x + closeBtn.width &&
                    y >= closeBtn.y && y <= closeBtn.y + closeBtn.height) {
                    if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Clic en dehors du menu → fermer
                if (x < menuX || x > menuX + menuWidth ||
                    y < menuY || y > menuY + menuHeight) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Onglets
                const onglets = menuEnigmesCanvas.onglets;
                if (onglets) {
                    // Onglet Énigmes
                    if (onglets.enigmes && x >= onglets.enigmes.x && x <= onglets.enigmes.x + onglets.enigmes.width &&
                        y >= onglets.enigmes.y && y <= onglets.enigmes.y + onglets.enigmes.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'enigmes';
                        menuEnigmesCanvas.scrollY = 0;
                        menuEnigmesCanvas.needsRecalculation = true; // Invalidate cache
                        return;
                    }
                    
                    // Onglet Classement
                    if (onglets.classement && x >= onglets.classement.x && x <= onglets.classement.x + onglets.classement.width &&
                        y >= onglets.classement.y && y <= onglets.classement.y + onglets.classement.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'classement';
                        menuEnigmesCanvas.scrollY = 0;
                        menuEnigmesCanvas.needsRecalculation = true; // Invalidate cache
                        return;
                    }
                    
                    // Onglet Langues
                    if (onglets.langues && x >= onglets.langues.x && x <= onglets.langues.x + onglets.langues.width &&
                        y >= onglets.langues.y && y <= onglets.langues.y + onglets.langues.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'langues';
                        menuEnigmesCanvas.scrollY = 0;
                        menuEnigmesCanvas.needsRecalculation = true; // Invalidate cache
                        return;
                    }
                    
                    // Onglet Info
                    if (onglets.info && x >= onglets.info.x && x <= onglets.info.x + onglets.info.width &&
                        y >= onglets.info.y && y <= onglets.info.y + onglets.info.height) {
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        menuEnigmesCanvas.ongletActif = 'info';
                        menuEnigmesCanvas.scrollY = 0;
                        menuEnigmesCanvas.projectButtons = null; // Réinitialiser pour recréation
                        menuEnigmesCanvas.needsRecalculation = true; // Invalidate cache
                        return;
                    }
                }
                
                // Boutons de langue (onglet langues)
                if (menuEnigmesCanvas.ongletActif === 'langues' && menuEnigmesCanvas.langueButtons) {
                    for (const btn of menuEnigmesCanvas.langueButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            if (window.i18n && btn.code !== window.i18n.getCurrentLanguage()) {
                                if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                                
                                const languageNames = {
                                    'fr': 'Français', 'en': 'English', 'es': 'Español',
                                    'de': 'Deutsch', 'it': 'Italiano', 'pt': 'Português',
                                    'ru': 'Русский', 'uk': 'Українська', 'zh': '中文',
                                    'jp': '日本語', 'ko': '한국어', 'rc': 'Kréol Rényoné',
                                    'lg': 'Lingala', 'ar': 'العربية', 'he': 'עברית'
                                };
                                
                                // Messages de confirmation dans chaque langue
                                const confirmMessages = {
                                    'fr': '🌍 Changer la langue vers {language} ?\n\nLa page sera rechargée pour appliquer les traductions.',
                                    'en': '🌍 Change language to {language}?\n\nThe page will be reloaded to apply translations.',
                                    'es': '🌍 ¿Cambiar idioma a {language}?\n\nLa página se recargará para aplicar las traducciones.',
                                    'de': '🌍 Sprache zu {language} ändern?\n\nDie Seite wird neu geladen, um die Übersetzungen anzuwenden.',
                                    'it': '🌍 Cambiare lingua in {language}?\n\nLa pagina verrà ricaricata per applicare le traduzioni.',
                                    'pt': '🌍 Mudar idioma para {language}?\n\nA página será recarregada para aplicar as traduções.',
                                    'ru': '🌍 Изменить язык на {language}?\n\nСтраница будет перезагружена для применения переводов.',
                                    'uk': '🌍 Змінити мову на {language}?\n\nСторінку буде перезавантажено для застосування перекладів.',
                                    'zh': '🌍 切换语言到{language}？\n\n页面将重新加载以应用翻译。',
                                    'jp': '🌍 言語を{language}に変更しますか？\n\n翻訳を適用するためにページが再読み込みされます。',
                                    'ko': '🌍 언어를 {language}(으)로 변경하시겠습니까?\n\n번역을 적용하기 위해 페이지가 새로고침됩니다.',
                                    'rc': '🌍 Shanzé lang vèr {language}?\n\nLa paz va rasharze pou apliké tradixion.',
                                    'lg': '🌍 Kobongola monoko na {language}?\n\nLokasa ekozonga mpo na kotalisa batraduction.',
                                    'ar': '🌍 تغيير اللغة إلى {language}؟\n\nسيتم إعادة تحميل الصفحة لتطبيق الترجمات.',
                                    'he': '🌍 לשנות שפה ל-{language}?\n\nהדף יטען מחדש כדי להחיל את התרגומים.'
                                };
                                
                                const newLangName = languageNames[btn.code] || btn.code.toUpperCase();
                                const confirmMessage = (confirmMessages[btn.code] || confirmMessages['fr']).replace('{language}', newLangName);
                                
                                // Mapping des drapeaux par code langue
                                const flagMap = {
                                    'fr': '🇫🇷', 'en': '🇬🇧', 'es': '🇪🇸', 'de': '🇩🇪',
                                    'it': '🇮🇹', 'pt': '🇵🇹', 'ru': '🇷🇺', 'uk': '🇺🇦',
                                    'zh': '🇨🇳', 'jp': '🇯🇵', 'ko': '🇰🇷', 'ar': '🇸🇦',
                                    'he': '🇮🇱', 'rc': '🇷🇪', 'lg': '🇨🇩'
                                };
                                const targetFlag = flagMap[btn.code] || '🌍';
                                
                                // Vérifier s'il y a une sauvegarde en cours
                                const savedData = localStorage.getItem('petit_bateau_save');
                                const hasSave = !!savedData;
                                
                                // 🎨 Popup unique avec icônes design (pas de texte à traduire)
                                const choice = await CustomPopup.chooseLanguageAction(targetFlag, hasSave);
                                
                                if (choice === 'cancel') {
                                    // ❌ Utilisateur a annulé
                                    console.log('❌ Changement de langue annulé');
                                    return;
                                }
                                
                                // ✅ Bloquer la sauvegarde pendant le changement de langue
                                window.isChangingLanguage = true;
                                console.log('🌍 Changement de langue - sauvegarde bloquée');
                                
                                // 🗑️ VIDER LE CACHE DES TRADUCTIONS
                                if (typeof clearTranslationCache === 'function') {
                                    clearTranslationCache();
                                }
                                
                                window.i18n.setLanguage(btn.code).then(async () => {
                                    console.log('✅ Langue chargée avec succès:', btn.code);
                                    currentLang = btn.code;
                                    localStorage.setItem('petit_bateau_lang', btn.code);
                                    
                                    // 🔄 RECHARGER LES PHASES NARRATIVES avec la nouvelle langue
                                    if (window.narrationManager && window.narrationManager.reloadPhases) {
                                        window.narrationManager.reloadPhases();
                                        console.log('✅ Phases narratives rechargées dans la nouvelle langue');
                                    }
                                    
                                    // ⚡ OPTIMISATION: Invalider cache textes énigmes lors changement langue
                                    if (menuEnigmesCanvas && menuEnigmesCanvas.enigmeTextesCache) {
                                        menuEnigmesCanvas.enigmeTextesInitialized = false;
                                        initEnigmeTextesCache();
                                        console.log('⚡ Cache énigmes recalculé pour nouvelle langue');
                                    }
                                    
                                    // Gérer la sauvegarde selon le choix
                                    if (choice === 'restart') {
                                        // 🔴 Redémarrer : effacer la sauvegarde
                                        GameSaveSystem.clear();
                                        console.log('🌍 Langue changée → Sauvegarde effacée → Redémarrage à l\'intro');
                                        console.log('🔄 RECHARGEMENT IMMÉDIAT pour restart...');
                                        // Rechargement immédiat avec forçage complet du cache
                                        window.location.href = window.location.pathname + '?lang=' + btn.code + '&reload=' + Date.now();
                                        return; // Sortir immédiatement
                                    } else if (choice === 'continue' && hasSave) {
                                        // 🔵 Continuer : mettre à jour la langue dans la sauvegarde
                                        const save = JSON.parse(savedData);
                                        save.language = btn.code;
                                        localStorage.setItem('petit_bateau_save', JSON.stringify(save));
                                        console.log('🌍 Langue changée → Progression conservée');
                                    } else {
                                        console.log('🌍 Langue changée → Pas de sauvegarde');
                                    }
                                    
                                    console.log('🔄 RECHARGEMENT dans 300ms...');
                                    setTimeout(() => {
                                        console.log('🔄 RECHARGEMENT MAINTENANT !');
                                        // Rechargement forcé du serveur (bypass cache complet)
                                        location.reload(true);
                                    }, 300);
                                }).catch(err => {
                                    console.error('❌ ERREUR changement langue:', err);
                                    // Recharger quand même pour éviter l'état incohérent
                                    console.log('🔄 Rechargement forcé après erreur...');
                                    setTimeout(() => location.reload(), 500);
                                });
                            }
                            return;
                        }
                    }
                }
                
                // Boutons de projets (onglet info)
                if (menuEnigmesCanvas.ongletActif === 'info' && menuEnigmesCanvas.projectButtons) {
                    for (const btn of menuEnigmesCanvas.projectButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            
                            let projectUrl = btn.link;
                            
                            // Lien externe → ouvrir directement
                            if (projectUrl.startsWith('http')) {
                                window.open(projectUrl, '_blank');
                            } else {
                                // Lien interne → ajouter la langue actuelle
                                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                                projectUrl += projectUrl.includes('?') ? `&lang=${currentLang}` : `?lang=${currentLang}`;
                                window.open(projectUrl, '_blank');
                            }
                            
                            console.log(`🚀 Ouverture du projet: ${btn.title}`);
                            return;
                        }
                    }
                }
                
                // ✅ Titre cliquable "Scores" (onglet classement) 
                if (menuEnigmesCanvas.ongletActif === 'classement') {
                    console.log('🔍 Clic sur onglet classement:', { x, y, onglet: menuEnigmesCanvas.ongletActif });
                    
                    if (menuEnigmesCanvas.titleLeaderboard) {
                        const title = menuEnigmesCanvas.titleLeaderboard;
                        console.log('🎯 Zone titre disponible:', title);
                        
                        const inZone = (x >= title.x && x <= title.x + title.width &&
                                       y >= title.y && y <= title.y + title.height);
                        console.log('🎯 Clic dans zone?', inZone);
                        
                        if (inZone) {
                            console.log('✅ CLIC VALIDE - Ouverture module Emmanuel');
                            if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                            
                            // Ouvrir emmanuel-artist-module.html
                            ouvrirInfoArtiste();
                            return;
                        }
                    } else {
                        console.log('⚠️ titleLeaderboard non défini');
                    }
                }
                
                // Touch dans le menu mais pas sur élément interactif → ne rien faire
                return;
            }
            
            // ═══════════════════════════════════════════════════════════════
            // 🎯 PRIORITÉ 2: BOUTONS D'INTERFACE (menu fermé)
            // ═══════════════════════════════════════════════════════════════
            
            // Zone drapeau (en haut à gauche) → ouvre menu langues
            const statsY = Math.max(C.H * 0.045, 30);
            const flagZone = { x: 10, y: statsY - 15, width: 130, height: 30 };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                if (!menuEnigmesCanvas.visible && typeof ouvrirMenuEnigmesCanvas === 'function') {
                    ouvrirMenuEnigmesCanvas();
                }
                menuEnigmesCanvas.ongletActif = 'langues';
                menuEnigmesCanvas.scrollY = 0;
                return;
            }
            
            // ═══════════════════════════════════════════════════════════════
            // 🎯 PRIORITÉ 3: BOUTON "PASSER" (si visible)
            // ═══════════════════════════════════════════════════════════════
            if (verifierClicBoutonPasser && verifierClicBoutonPasser(x, y)) {
                if (AudioSystem && AudioSystem.playNegative) AudioSystem.playNegative();
                afficherMessagePowerupSimple(getTranslatedText('interface.system.no_exclamation', 'NON!'));
                return;
            }
            
            // ═══════════════════════════════════════════════════════════════
            // 🎯 PRIORITÉ 4: INTERACTIONS DE JEU
            // ═══════════════════════════════════════════════════════════════
            
            // Bloquer si animation ou transition
            if (animationBateau.active || narrationManager.isTransitioning) {
                return;
            }
            
            // Phase STARS → tir d'étoiles
            if (phaseJeu === 'stars') {
                tirerStarsProjectile(x, y);
                if (typeof libererVaguesAmour === 'function') libererVaguesAmour();
                return;
            }
            
            // Phase LANTERNE ou MUR → casse-briques
            if (phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                if (balle.enAttente) {
                    // Lancer la balle - vitesse standard casse-briques (5 px/frame)
                    balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                    balle.dy = -C.SP * multiplicateurPuissance;
                    balle.enAttente = false;
                    const msg = phaseJeu === 'mur' 
                        ? getTranslatedText('game.messages.attack_launched', '🧱 Attaque lancée !')
                        : getTranslatedText('game.messages.lantern_launched', '🏮 Lanterne lancée !');
                    afficherMessagePowerupSimple(msg);
                } else if (window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir étoiles (power-up)
                    if (Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        tirerStarsProjectile(x, y);
                    }
                } else {
                    // Déplacer la raquette
                    deplacerRaquette(x);
                }
                return;
            }
            
            // Autres phases → déplacer bateau + amour
            deplacerRaquette(x);
            if (typeof libererVaguesAmour === 'function') libererVaguesAmour();
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // Système de tir continu
        let tirEnCours = false;
        let dernierTir = 0;
        const delaiTir = 150; // Délai entre chaque tir en ms

        // Système de swipe pour le menu
        let swipeStartY = 0;
        let isSwipingMenu = false;

        // Événements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 🌍 Vérifier le survol du drapeau en haut
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            const wasHovering = flagHover;
            flagHover = (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                        y >= flagZone.y && y <= flagZone.y + flagZone.height);
            
            // Changer le curseur
            if (flagHover && !wasHovering) {
                canvas.style.cursor = 'pointer';
            } else if (!flagHover && wasHovering) {
                canvas.style.cursor = 'default';
            }

            // Contrôler le bateau du mini-jeu "Briser les Frontières"
            if (briqueLangue.active && briqueLangue.game) {
                const game = briqueLangue.game;
                game.bateau.x = x;
                game.bateau.x = Math.max(30, Math.min(C.W - 30, game.bateau.x));
            }

            // Menu HOME supprimé

            // Vérifier le survol des icônes en haut
            verifierSurvolIconesHaut(x, y);

            // Vérifier le survol des cartes d'énigmes
            verifierSurvolCartes(x, y);

            // Swipe dans le menu énigmes
            if (isSwipingMenu && menuEnigmesCanvas.visible) {
                const deltaY = swipeStartY - y;
                menuEnigmesCanvas.scrollY += deltaY * 0.5;
                menuEnigmesCanvas.scrollY = Math.max(0, Math.min(menuEnigmesCanvas.scrollY, menuEnigmesCanvas.maxScrollY));
                swipeStartY = y;
            } else {
                deplacerRaquette(e.clientX - rect.left);

                // Tir continu si bouton maintenu
                if(tirEnCours && (phaseJeu === 'lanterne' || phaseJeu === 'mur' || phaseJeu === 'stars')) {
                    const now = Date.now();
                    if(now - dernierTir > delaiTir) {
                        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                        if(phaseJeu === 'stars') {
                            tirerStarsProjectile(mouseX, mouseY);
                        } else if(phaseJeu === 'mur') {
                            // Mode tir MUR (système projectiles progressifs phases 17-22)
                            tirerProjectile(mouseX, mouseY);
                        } else if(window.modeTirStars && window.modeTirStars.actif) {
                            // Mode tir étoiles POXERSTART (power-up 7s)
                            tirerStarsProjectile(mouseX, mouseY);
                        } else {
                            // Tir normal
                            tirerProjectile(mouseX, mouseY);
                        }
                        dernierTir = now;
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Gestion des clics sur le livre bonus (priorité absolue)
            if (phaseJeu === 'bonus_livre') {
                const pageHeight = C.H * 0.80;
                const pageY = (C.H - pageHeight) / 2;
                const buttonY = pageY + pageHeight + 30;

                // Clic sur Précédent
                if (Math.abs(x - (C.W / 2 - 90)) < 60 && Math.abs(y - buttonY) < 35) {
                    if (livreBonus.currentPage > 0) {
                        livreBonus.currentPage--;
                    }
                    return;
                }
                // Clic sur Suivant
                else if (Math.abs(x - (C.W / 2 + 90)) < 60 && Math.abs(y - buttonY) < 35) {
                    if (livreBonus.currentPage < livreBonus.pages.length - 1) {
                        livreBonus.currentPage++;
                    }
                    return;
                }
                // Clic sur Fermer
                else if (Math.abs(x - C.W / 2) < 60 && Math.abs(y - (buttonY + 8)) < 25) {
                    // Redémarrer en gardant le score
                    if (narrationManager && narrationManager.restartKeepScore) {
                        narrationManager.restartKeepScore();
                    }
                    return;
                }
                return; // Ignorer tous les autres clics en mode livre
            }

            // 🌍 Vérifier le clic sur le drapeau en haut (priorité absolue)
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                // Ne pas traiter comme swipe ou tir
                return;
            }

            // ✅ DETECTION CLIC TITRE "SCORES MONDIAL" (dans mousedown)
            if (menuEnigmesCanvas.visible && menuEnigmesCanvas.ongletActif === 'classement') {
                console.log('🖱️ MOUSEDOWN - Clic sur onglet classement:', { x, y });
                
                if (menuEnigmesCanvas.titleLeaderboard) {
                    const title = menuEnigmesCanvas.titleLeaderboard;
                    console.log('🎯 Zone titre (mousedown):', title);
                    
                    const inZone = (x >= title.x && x <= title.x + title.width &&
                                   y >= title.y && y <= title.y + title.height);
                    console.log('🎯 Clic dans zone? (mousedown)', inZone);
                    
                    if (inZone) {
                        console.log('✅ CLIC MOUSEDOWN VALIDE - Ouverture module Emmanuel');
                        if (AudioSystem && AudioSystem.playClick) AudioSystem.playClick();
                        
                        // Ouvrir emmanuel-artist-module.html
                        ouvrirInfoArtiste();
                        return;
                    }
                }
            }

            if (menuEnigmesCanvas.visible) {
                isSwipingMenu = true;
                swipeStartY = y;
            } else {
                tirEnCours = true;
                dernierTir = 0; // Reset pour tir immédiat au premier clic
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            tirEnCours = false;
            isSwipingMenu = false;
        });

        canvas.addEventListener('mouseleave', (e) => {
            tirEnCours = false;
            isSwipingMenu = false;
        });

        // Scroll dans le menu énigmes
        canvas.addEventListener('wheel', (e) => {
            if (menuEnigmesCanvas.visible) {
                e.preventDefault();
                const scrollAmount = e.deltaY * 0.5; // Vitesse de scroll
                menuEnigmesCanvas.scrollY += scrollAmount;

                // Limiter le scroll
                menuEnigmesCanvas.scrollY = Math.max(0, Math.min(menuEnigmesCanvas.scrollY, menuEnigmesCanvas.maxScrollY));
            }
        }, { passive: false });

        // Ancien système de swipe pour le sélecteur de langue - DÉSACTIVÉ
        canvas.addEventListener('mousedown', (e) => {
            // Ancien système désactivé
            if (false && !languageSelector.active) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Zone de swipe (drapeaux au centre)
            const flagY = C.H/2;
            const onFlags = y >= flagY - 60 && y <= flagY + 60;

            if (onFlags) {
                languageSelector.isSwipingLang = true;
                languageSelector.swipeStartX = x;
                languageSelector.swipeOffset = 0;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            // Ancien système de swipe désactivé
            if (false && !languageSelector.active || !languageSelector.isSwipingLang) return;

            languageSelector.isSwipingLang = false;

            const spacing = 80;
            const offset = languageSelector.swipeOffset || 0;

            // Calculer le changement de langue basé sur le swipe
            let languageChange = 0;
            if (Math.abs(offset) > spacing / 2) {
                languageChange = Math.round(offset / spacing);
            }

            if (languageChange !== 0) {
                // Trouver l'index actuel et calculer le nouvel index
                const currentIndex = languageSelector.buttons.findIndex(b => b.code === currentLang);
                let newIndex = currentIndex - languageChange; // Inversion pour swipe naturel

                // Boucler si on dépasse les limites
                if (newIndex < 0) newIndex = languageSelector.buttons.length - 1;
                if (newIndex >= languageSelector.buttons.length) newIndex = 0;

                const newLang = languageSelector.buttons[newIndex];

                // Charger la nouvelle langue AVEC rafraîchissement
                loadTranslations(newLang.code).then(() => {
                    console.log('🌍 Langue changée vers:', newLang.code);
                    console.log('🔄 Rafraîchissement de la page pour appliquer les traductions...');
                    
                    // 🔄 RAFRAÎCHIR LA PAGE pour recharger tous les textes
                    setTimeout(() => {
                        location.reload();
                    }, 500); // Petit délai pour voir le message
                });
            } else {
                // Réinitialiser l'offset si le swipe n'était pas assez grand
                languageSelector.swipeOffset = 0;
            }
        });

        // Gestionnaire prioritaire pour le drapeau (capture = true pour priorité absolue)
        // 📖 Gestion des clics sur le livre de la phase bonus
        canvas.addEventListener('click', async (e) => {
            if (phaseJeu === 'bonus_mur' && window.phaseBonusMur) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const centerX = canvas.width / 2;
                const bookWidth = canvas.width * 0.85;
                const bookHeight = canvas.height * 0.75;
                const bookY = canvas.height / 2 - bookHeight / 2;
                const buttonY = bookY + bookHeight + 15;

                // Bouton Précédent
                if (Math.abs(x - (centerX - 60)) < 40 && Math.abs(y - buttonY) < 20) {
                    window.phaseBonusMur.previousPage();
                    e.preventDefault();
                    return;
                }

                // Bouton Suivant
                if (Math.abs(x - (centerX + 60)) < 40 && Math.abs(y - buttonY) < 20) {
                    window.phaseBonusMur.nextPage();
                    e.preventDefault();
                    return;
                }

                // Bouton Fermer
                if (Math.abs(x - centerX) < 40 && Math.abs(y - (buttonY + 10)) < 15) {
                    window.phaseBonusMur.closePage();
                    e.preventDefault();
                    return;
                }
            }
        }, { capture: true });

        canvas.addEventListener('click', async (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 🌍 Zone du drapeau - priorité absolue
            const statsY = Math.max(canvas.height * 0.045, 30);
            const flagZone = {
                x: 10,
                y: statsY - 15,
                width: 130,
                height: 30
            };
            
            if (x >= flagZone.x && x <= flagZone.x + flagZone.width &&
                y >= flagZone.y && y <= flagZone.y + flagZone.height) {
                
                // Empêcher complètement la propagation
                e.preventDefault();
                e.stopImmediatePropagation();
                
                // 🔊 Son de clic
                AudioSystem.playClick();
                
                // Ouvrir le menu énigme sur l'onglet langues
                if (!menuEnigmesCanvas.visible) {
                    ouvrirMenuEnigmesCanvas();
                }
                menuEnigmesCanvas.ongletActif = 'langues';
                menuEnigmesCanvas.scrollY = 0;
                
                return false; // Empêcher tout traitement ultérieur
            }
        }, { capture: true }); // Capture = priorité absolue

        canvas.addEventListener('click', async (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Le drapeau est géré par le gestionnaire prioritaire ci-dessus

            // Tirer une lanterne du mini-jeu "Briser les Frontières"
            if (briqueLangue.active && briqueLangue.game) {
                const game = briqueLangue.game;
                // Créer une nouvelle lanterne à la position du bateau
                game.projectiles.push({
                    x: game.bateau.x,
                    y: game.bateau.y - 20
                });
                return;
            }

            // 🌍 Ancien système de clic sur l'icône de langue - DÉSACTIVÉ
            // Le nouveau système est dans l'onglet langues du menu énigmes
            if (false && languageSelector.languageChosen && languageSelector.iconButton) {
                // Clic sur un item du menu (si ouvert)
                if (languageSelector.menuOpen) {
                    for (const btn of languageSelector.buttons) {
                        if (btn.menuX && x >= btn.menuX && x <= btn.menuX + btn.menuWidth &&
                            y >= btn.menuY && y <= btn.menuY + btn.menuHeight) {
                            // Charger les nouvelles traductions AVEC rafraîchissement
                            loadTranslations(btn.code).then(() => {
                                console.log('🌍 Langue changée vers:', btn.code);
                                console.log('🔄 Rafraîchissement de la page pour appliquer les traductions...');
                                
                                // 🔄 RAFRAÎCHIR LA PAGE
                                setTimeout(() => {
                                    location.reload();
                                }, 500);
                            });
                            return;
                        }
                    }

                    // Fermer le menu si clic en dehors
                    const distance = Math.sqrt(
                        Math.pow(x - languageSelector.iconButton.x, 2) +
                        Math.pow(y - languageSelector.iconButton.y, 2)
                    );
                    if (distance > languageSelector.iconButton.radius) {
                        languageSelector.menuOpen = false;console.log('🌍 Menu fermé (clic en dehors)');
                        return;
                    }
                }

                // Clic sur l'icône elle-même
                const distance = Math.sqrt(
                    Math.pow(x - languageSelector.iconButton.x, 2) +
                    Math.pow(y - languageSelector.iconButton.y, 2)
                );
                if (distance <= languageSelector.iconButton.radius) {
                    // Ouvrir/fermer menu pour changer de langue
                    languageSelector.menuOpen = !languageSelector.menuOpen;
                    return;
                }
            }

            // 🎵 Démarrer la musique au premier clic (autoplay policy)
            if (window.musicReadyToStart && musicManager && !window.musicStartedOnce) {
                console.log('✅ Premier clic détecté - Démarrage musique...');
                musicManager.play('normal');
                window.musicReadyToStart = false;
                window.musicStartedOnce = true; // Marquer comme lancée une fois
                console.log('🎵 Musique démarrée avec succès au clic utilisateur');
            } else if (!window.musicStartedOnce) {
                // Seulement logger si la musique n'a pas encore démarré
                console.log('🎵 En attente du premier clic - Conditions:', {
                    musicReadyToStart: window.musicReadyToStart,
                    musicManager: !!musicManager,
                    musicStartedOnce: window.musicStartedOnce
                });
            }

            // 🔊 Vérifier les clics sur les boutons audio
            
            // Volume − (diminuer)
            if (window.prevSongZone) {
                const btn = window.prevSongZone;
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    if (musicManager) {
                        const volumes = [0, 0.25, 0.5, 0.75, 1.0];
                        const currentVol = musicManager.volume.master;
                        
                        // Trouver l'index actuel
                        let currentIndex = -1;
                        for (let i = 0; i < volumes.length; i++) {
                            if (Math.abs(volumes[i] - currentVol) < 0.05) {
                                currentIndex = i;
                                break;
                            }
                        }
                        
                        // Si pas trouvé, trouver le niveau le plus proche
                        if (currentIndex === -1) {
                            for (let i = volumes.length - 1; i >= 0; i--) {
                                if (currentVol >= volumes[i]) {
                                    currentIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Diminuer le volume
                        const newIndex = Math.max(0, currentIndex - 1);
                        const newVol = volumes[newIndex];
                        
                        musicManager.setVolume(newVol);
                        
                        // Si on passe à 0, muter
                        if (newVol === 0 && !musicManager.isMuted) {
                            musicManager.toggleMute();
                        }
                        
                        AudioSystem.playClick();
                        console.log(`🔉 Volume: ${Math.round(newVol * 100)}%`);
                    }
                    return;
                }
            }

            // Volume + (augmenter)
            if (window.nextSongZone) {
                const btn = window.nextSongZone;
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    if (musicManager) {
                        const volumes = [0, 0.25, 0.5, 0.75, 1.0];
                        const currentVol = musicManager.volume.master;
                        
                        // Si muté, démuter d'abord
                        if (musicManager.isMuted) {
                            musicManager.toggleMute();
                            console.log('🔊 Démute automatique');
                        }
                        
                        // Trouver l'index actuel
                        let currentIndex = -1;
                        for (let i = 0; i < volumes.length; i++) {
                            if (Math.abs(volumes[i] - currentVol) < 0.05) {
                                currentIndex = i;
                                break;
                            }
                        }
                        
                        // Si pas trouvé, trouver le niveau le plus proche
                        if (currentIndex === -1) {
                            for (let i = 0; i < volumes.length; i++) {
                                if (currentVol <= volumes[i]) {
                                    currentIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Augmenter le volume
                        const newIndex = Math.min(volumes.length - 1, currentIndex + 1);
                        const newVol = volumes[newIndex];
                        
                        musicManager.setVolume(newVol);
                        AudioSystem.playClick();
                        console.log(`🔊 Volume: ${Math.round(newVol * 100)}%`);
                    }
                    return;
                }
            }

            // 🔊 Son de clic sur tout clic
            AudioSystem.playClick();

            // Vérifier le clic sur les onglets du menu énigmes
            if (menuEnigmesCanvas.visible) {
                // Calculer les dimensions du menu pour vérifier si le clic est à l'intérieur
                const menuPadding = 40;
                const menuWidth = canvas.width - 2 * menuPadding;
                const menuHeight = canvas.height - 2 * menuPadding;
                const menuX = menuPadding;
                const menuY = menuPadding;
                
                // Vérifier le clic sur le bouton de fermeture (X)
                const closeBtn = menuEnigmesCanvas.closeButton;
                if (x >= closeBtn.x && x <= closeBtn.x + closeBtn.width &&
                    y >= closeBtn.y && y <= closeBtn.y + closeBtn.height) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Si le clic est en dehors du menu, le fermer
                if (x < menuX || x > menuX + menuWidth ||
                    y < menuY || y > menuY + menuHeight) {
                    fermerMenuEnigmesCanvas();
                    return;
                }
                
                // Onglet Énigmes
                const ongletEnigmes = menuEnigmesCanvas.onglets.enigmes;
                if (x >= ongletEnigmes.x && x <= ongletEnigmes.x + ongletEnigmes.width &&
                    y >= ongletEnigmes.y && y <= ongletEnigmes.y + ongletEnigmes.height) {
                    menuEnigmesCanvas.ongletActif = 'enigmes';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Onglet Classement
                const ongletClassement = menuEnigmesCanvas.onglets.classement;
                if (x >= ongletClassement.x && x <= ongletClassement.x + ongletClassement.width &&
                    y >= ongletClassement.y && y <= ongletClassement.y + ongletClassement.height) {
                    menuEnigmesCanvas.ongletActif = 'classement';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Onglet Langues
                const ongletLangues = menuEnigmesCanvas.onglets.langues;
                if (x >= ongletLangues.x && x <= ongletLangues.x + ongletLangues.width &&
                    y >= ongletLangues.y && y <= ongletLangues.y + ongletLangues.height) {
                    menuEnigmesCanvas.ongletActif = 'langues';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    return;
                }

                // Clic sur les boutons de langue dans l'onglet langues
                if (menuEnigmesCanvas.ongletActif === 'langues' && menuEnigmesCanvas.langueButtons) {
                    for (const btn of menuEnigmesCanvas.langueButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            // Changer la langue AVEC rafraîchissement complet
                            if (window.i18n && btn.code !== window.i18n.getCurrentLanguage()) {
                                // Demander confirmation avant de recharger
                                const languageNames = {
                                    'fr': 'Français', 'en': 'English', 'es': 'Español',
                                    'de': 'Deutsch', 'it': 'Italiano', 'pt': 'Português',
                                    'ru': 'Русский', 'uk': 'Українська', 'zh': '中文',
                                    'jp': '日本語', 'ko': '한국어', 'rc': 'Kréol Rényoné',
                                    'lg': 'Lingala', 'ar': 'العربية', 'he': 'עברית'
                                };
                                
                                // Messages de confirmation dans chaque langue
                                const confirmMessages = {
                                    'fr': '🌍 Changer la langue vers {language} ?\n\nLa page sera rechargée pour appliquer les traductions.',
                                    'en': '🌍 Change language to {language}?\n\nThe page will be reloaded to apply translations.',
                                    'es': '🌍 ¿Cambiar idioma a {language}?\n\nLa página se recargará para aplicar las traducciones.',
                                    'de': '🌍 Sprache zu {language} ändern?\n\nDie Seite wird neu geladen, um die Übersetzungen anzuwenden.',
                                    'it': '🌍 Cambiare lingua in {language}?\n\nLa pagina verrà ricaricata per applicare le traduzioni.',
                                    'pt': '🌍 Mudar idioma para {language}?\n\nA página será recarregada para aplicar as traduções.',
                                    'ru': '🌍 Изменить язык на {language}?\n\nСтраница будет перезагружена для применения переводов.',
                                    'uk': '🌍 Змінити мову на {language}?\n\nСторінку буде перезавантажено для застосування перекладів.',
                                    'zh': '🌍 切换语言到{language}？\n\n页面将重新加载以应用翻译。',
                                    'jp': '🌍 言語を{language}に変更しますか？\n\n翻訳を適用するためにページが再読み込みされます。',
                                    'ko': '🌍 언어를 {language}(으)로 변경하시겠습니까?\n\n번역을 적용하기 위해 페이지가 새로고침됩니다.',
                                    'rc': '🌍 Shanzé lang vèr {language}?\n\nLa paz va rasharze pou apliké tradixion.',
                                    'lg': '🌍 Kobongola monoko na {language}?\n\nLokasa ekozonga mpo na kotalisa batraduction.',
                                    'ar': '🌍 تغيير اللغة إلى {language}؟\n\nسيتم إعادة تحميل الصفحة لتطبيق الترجمات.',
                                    'he': '🌍 לשנות שפה ל-{language}?\n\nהדף יטען מחדש כדי להחיל את התרגומים.'
                                };
                                
                                const newLangName = languageNames[btn.code] || btn.code.toUpperCase();
                                const confirmMessage = (confirmMessages[btn.code] || confirmMessages['fr']).replace('{language}', newLangName);
                                
                                // Mapping des drapeaux par code langue
                                const flagMap = {
                                    'fr': '🇫🇷', 'en': '🇬🇧', 'es': '🇪🇸', 'de': '🇩🇪',
                                    'it': '🇮🇹', 'pt': '🇵🇹', 'ru': '🇷🇺', 'uk': '🇺🇦',
                                    'zh': '🇨🇳', 'jp': '🇯🇵', 'ko': '🇰🇷', 'ar': '🇸🇦',
                                    'he': '🇮🇱', 'rc': '🇷🇪', 'lg': '🇨🇩'
                                };
                                const targetFlag = flagMap[btn.code] || '🌍';
                                
                                // Vérifier s'il y a une sauvegarde en cours
                                const savedData = localStorage.getItem('petit_bateau_save');
                                const hasSave = !!savedData;
                                
                                // 🎨 Popup unique avec icônes design (pas de texte à traduire)
                                const choice = await CustomPopup.chooseLanguageAction(targetFlag, hasSave);
                                
                                if (choice === 'cancel') {
                                    // ❌ Utilisateur a annulé
                                    console.log('❌ Changement de langue annulé');
                                    break;
                                }
                                
                                // ✅ Bloquer la sauvegarde pendant le changement de langue
                                window.isChangingLanguage = true;
                                console.log('🌍 Changement de langue - sauvegarde bloquée');
                                
                                // 🗑️ VIDER LE CACHE DES TRADUCTIONS
                                if (typeof clearTranslationCache === 'function') {
                                    clearTranslationCache();
                                }
                                
                                window.i18n.setLanguage(btn.code).then(async () => {
                                    console.log('✅ Langue chargée avec succès:', btn.code);
                                    console.log('🌍 Langue changée vers:', btn.code);
                                    
                                    // Synchroniser currentLang et sauvegarder
                                    currentLang = btn.code;
                                    localStorage.setItem('petit_bateau_lang', btn.code);
                                    
                                    // 🔄 RECHARGER LES PHASES NARRATIVES avec la nouvelle langue
                                    if (window.narrationManager && window.narrationManager.reloadPhases) {
                                        window.narrationManager.reloadPhases();
                                        console.log('✅ Phases narratives rechargées dans la nouvelle langue');
                                    }
                                    
                                    // ⚡ OPTIMISATION: Invalider cache textes énigmes lors changement langue
                                    if (menuEnigmesCanvas && menuEnigmesCanvas.enigmeTextesCache) {
                                        menuEnigmesCanvas.enigmeTextesInitialized = false;
                                        initEnigmeTextesCache();
                                        console.log('⚡ Cache énigmes recalculé pour nouvelle langue');
                                    }
                                    
                                    // Gérer la sauvegarde selon le choix
                                    if (choice === 'restart') {
                                        // 🔴 Redémarrer : effacer la sauvegarde
                                        GameSaveSystem.clear();
                                        console.log('🌍 Langue changée → Sauvegarde effacée → Redémarrage à l\'intro');
                                        console.log('🔄 RECHARGEMENT IMMÉDIAT pour restart...');
                                        // Rechargement immédiat avec forçage complet du cache
                                        window.location.href = window.location.pathname + '?lang=' + btn.code + '&reload=' + Date.now();
                                        return; // Sortir immédiatement
                                    } else if (choice === 'continue' && hasSave) {
                                        // 🔵 Continuer : mettre à jour la langue dans la sauvegarde
                                        try {
                                            const save = JSON.parse(savedData);
                                            save.language = btn.code;
                                            localStorage.setItem('petit_bateau_save', JSON.stringify(save));
                                            console.log('🌍 Langue changée → Progression conservée');
                                        } catch(e) {
                                            console.error('❌ Erreur mise à jour langue sauvegarde:', e);
                                        }
                                    } else {
                                        console.log('🌍 Langue changée → Pas de sauvegarde');
                                    }
                                    
                                    console.log('🔄 Rafraîchissement de la page pour appliquer les traductions...');
                                    console.log('🔄 RECHARGEMENT dans 300ms...');
                                    
                                    // 🔄 RAFRAÎCHIR LA PAGE pour recharger tous les textes
                                    setTimeout(() => {
                                        console.log('🔄 RECHARGEMENT MAINTENANT !');
                                        // Rechargement avec forçage du cache
                                        window.location.href = window.location.pathname + '?lang=' + btn.code + '&reload=' + Date.now();
                                    }, 300);
                                }).catch(err => {
                                    console.error('❌ ERREUR changement langue:', err);
                                    // Recharger quand même pour éviter l'état incohérent
                                    console.log('🔄 Rechargement forcé après erreur...');
                                    setTimeout(() => location.reload(), 500);
                                });
                            }
                            // Ne pas fermer le menu - pas de return qui sortirait de la fonction
                            break; // Sortir de la boucle mais rester dans le menu
                        }
                    }
                }

                // Onglet Info
                const ongletInfo = menuEnigmesCanvas.onglets.info;
                if (x >= ongletInfo.x && x <= ongletInfo.x + ongletInfo.width &&
                    y >= ongletInfo.y && y <= ongletInfo.y + ongletInfo.height) {
                    menuEnigmesCanvas.ongletActif = 'info';
                    menuEnigmesCanvas.scrollY = 0; // Reset scroll
                    // Réinitialiser les boutons de projets pour qu'ils soient recréés
                    menuEnigmesCanvas.projectButtons = null;
                    return;
                }

                // Clic sur les boutons de projets dans l'onglet Info
                if (menuEnigmesCanvas.ongletActif === 'info' && menuEnigmesCanvas.projectButtons) {
                    for (const btn of menuEnigmesCanvas.projectButtons) {
                        if (x >= btn.x && x <= btn.x + btn.width &&
                            y >= btn.y && y <= btn.y + btn.height) {
                            
                            let projectUrl = btn.link;
                            
                            // Vérifier si c'est un lien externe (commence par http)
                            if (projectUrl.startsWith('http')) {
                                // Lien externe - ouvrir directement
                                window.open(projectUrl, '_blank');
                            } else {
                                // Lien interne - ajouter la langue actuelle
                                const currentLang = window.i18n ? window.i18n.getCurrentLanguage() : 'fr';
                                
                                if (projectUrl.includes('?')) {
                                    projectUrl += `&lang=${currentLang}`;
                                } else {
                                    projectUrl += `?lang=${currentLang}`;
                                }
                                
                                window.open(projectUrl, '_blank');
                            }
                            
                            console.log(`🚀 Ouverture du projet: ${btn.title}`);
                            return;
                        }
                    }
                }

            }

            // Vérifier le clic sur le lien "Le voyage d'une vie"
            if (messageNarratifActif && messageNarratifActif.lienLivre && messageNarratifActif.lienZone) {
                const zone = messageNarratifActif.lienZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {
                    window.open(messageNarratifActif.lienLivre, '_blank');
                    return;
                }
            }

            // Vérifier le clic sur le bouton de partage
            if (messageNarratifActif && messageNarratifActif.avecPartage && messageNarratifActif.partageZone) {
                const zone = messageNarratifActif.partageZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {

                    // Utiliser l'API Web Share si disponible, sinon copier dans le presse-papiers
                    if (navigator.share) {
                        navigator.share({
                            title: 'PETIT BATEAU - Mon Voyage',
                            text: messageNarratifActif.textePartage
                        }).then(() => {
                        }).catch(err => {
                        });
                    } else {
                        // Fallback : copier dans le presse-papiers
                        navigator.clipboard.writeText(messageNarratifActif.textePartage).then(async () => {
                            await customAlert(getTranslatedText('interface.system.text_copied_clipboard', '✅ Texte copié dans le presse-papiers !\n\nPartagez-le sur vos réseaux sociaux 🌍'));
                        }).catch(err => {
                            console.error('❌ Erreur copie:', err);
                        });
                    }
                    return;
                }
            }

            // Vérifier le clic sur le bouton Recommencer (message final)
            if (messageNarratifActif && messageNarratifActif.avecRestart && messageNarratifActif.restartZone) {
                const zone = messageNarratifActif.restartZone;
                if (x >= zone.x && x <= zone.x + zone.w &&
                    y >= zone.y && y <= zone.y + zone.h) {
                    console.log('🔄 Bouton [Recommencer] cliqué - Recréer la phase actuelle avec 3 vies');
                    // ✅ Recréer la phase sans refaire l'intro, avec 3 vies
                    recreerPhaseActuelle(true);
                    return;
                }
            }

            // Vérifier le clic sur le bouton Suivant (Phase 16)
            if (window.boutonSuivantP16 && window.boutonSuivantP16.visible) {
                const btn = window.boutonSuivantP16;
                if (x >= btn.x && x <= btn.x + btn.width &&
                    y >= btn.y && y <= btn.y + btn.height) {
                    window.boutonSuivantP16.visible = false;
                    if (narrationManager) {
                        narrationManager.goToNextPhaseDirect();
                    }
                    return;
                }
            }

            // Clic sur le mur en phases 17-22 : activer mode tir lanterne (phase 23 = fin)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur') {
                // En mode mur phases 17-22, les munitions sont automatiquement définies
                // Plus besoin d'activer un mode tir spécial
            }

            // Vérifier le clic sur le bouton Continuer (Phase 16)
            if (window.boutonContinuer && window.boutonContinuer.visible) {
                const btn = window.boutonContinuer;
                if (x >= btn.x && x <= btn.x + btn.width &&
                    y >= btn.y && y <= btn.y + btn.height) {
                    window.boutonContinuer.visible = false;
                    if (narrationManager) {
                        narrationManager.goToNextPhaseDirect();
                    }
                    return;
                }
            }

            // Vérifier d'abord les clics sur l'icône centrale thématique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                // Clic sur l'icône centrale - ouvrir le menu énigmes
                ouvrirMenuEnigmesCanvas();
                return;
            }

            // Vérifier les clics sur les icônes en haut (si elles existent)
            if (menuEnigmesCanvas.topIcons && menuEnigmesCanvas.topIcons.length > 0) {
                for (let icon of menuEnigmesCanvas.topIcons) {
                    if (x >= icon.x && x <= icon.x + icon.width &&
                        y >= icon.y && y <= icon.y + icon.height) {
                        // Clic sur une icône en haut - ouvrir le menu énigmes
                        ouvrirMenuEnigmesCanvas();
                        return;
                    }
                }
            }

            // Vérifier les clics dans le menu énigmes si ouvert
            if (menuEnigmesCanvas.visible) {
                // 🎯 EXCEPTION : En phases mur 17-22, fermer le menu et permettre de tirer
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                if (phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur') {
                    console.log('🎯 Phase mur 17-22 : Fermeture auto du menu énigmes pour permettre de tirer');
                    fermerMenuEnigmesCanvas();
                    // Ne pas return - laisser le clic passer pour tirer
                } else {
                    // Bouton de fermeture du menu principal
                    if (x >= menuEnigmesCanvas.closeButton.x &&
                        x <= menuEnigmesCanvas.closeButton.x + menuEnigmesCanvas.closeButton.width &&
                        y >= menuEnigmesCanvas.closeButton.y &&
                        y <= menuEnigmesCanvas.closeButton.y + menuEnigmesCanvas.closeButton.height) {
                        fermerMenuEnigmesCanvas();
                        return;
                    }

                // Clics sur les cartes d'énigmes - système de liste déroulante
                for (let card of menuEnigmesCanvas.enigmaCards) {
                    const cardY = card.y - menuEnigmesCanvas.scrollY;
                    if (x >= card.x && x <= card.x + card.width &&
                        y >= cardY && y <= cardY + card.height) {

                        const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                        if (isCollected) {
                            // Toggle : déplier/replier la carte
                            if (menuEnigmesCanvas.expandedCard === card.id) {
                                menuEnigmesCanvas.expandedCard = null; // Replier
                            } else {
                                menuEnigmesCanvas.expandedCard = card.id; // Déplier
                                // Regénérer les positions pour mettre à jour les hauteurs
                                genererPositionsCartesEnigmes();
                            }
                        } else {
                            // Énigme non collectée - afficher juste qu'elle n'est pas découverte
                            afficherMessagePowerupSimple('🔒 ' + getTranslatedText('interface.system.enigma_not_discovered', 'Énigme non découverte'));
                        }
                        return;
                    }
                }

                    // Clic en dehors du menu centré = fermer
                    const menuWidth = Math.min(C.W - 80, 600);
                    const menuHeight = Math.min(C.H - 80, 500);
                    const menuX = (C.W - menuWidth) / 2;
                    const menuY = (C.H - menuHeight) / 2;

                    if (x < menuX || x > menuX + menuWidth || y < menuY || y > menuY + menuHeight) {
                        fermerMenuEnigmesCanvas();
                    }
                    return; // Ne pas traiter d'autres clics si le menu est ouvert
                }
            }

            // L'ancien bouton menu énigmes est remplacé par les icônes en haut

            // Vérifier le clic sur le bouton passer
            if (verifierClicBoutonPasser(x, y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                // 🔊 Son de refus
                AudioSystem.playNegative();
                afficherMessagePowerupSimple(getTranslatedText('interface.system.no_exclamation', 'NON!'));
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            
            // Redémarrage automatique supprimé - utiliser le bouton dans le message de Game Over
            
            if(phaseJeu === 'stars') {
                // Phase stars : tir d'étoiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Libérer les cœurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne' || phaseJeu === 'mur') {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // PRIORITÉ : Mode mur phases 17-22 tire des projectiles, phase 23 fin
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                const estPhaseMur17_22 = phaseActuelle >= 17 && phaseActuelle <= 22 && phaseJeu === 'mur';

                console.log(`🖱️ MOUSEDOWN - Phase ${phaseActuelle}, phaseJeu=${phaseJeu}, estPhaseMur17_22=${estPhaseMur17_22}, balle.enAttente=${balle.enAttente}`);

                // Mode MUR en phases 17-22 : tire des projectiles (munitions infinies)
                if(estPhaseMur17_22) {
                    console.log(`🎯 APPEL tirerProjectile() pour phase mur ${phaseActuelle}`);
                    tirerProjectile(mouseX, mouseY);  // Système progressif phases 17-22
                }
                // Lancer la balle si en attente (phases lanterne normales)
                else if(balle.enAttente) {
                    console.log(`⚽ Lancer la balle`);
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance;
                    balle.enAttente = false;
                    afficherMessagePowerupSimple(phaseJeu === 'mur' ? getTranslatedText('game.messages.attack_launched', '🧱 Attaque lancée !') : getTranslatedText('game.messages.lantern_launched', '🏮 Lanterne lancée !'));
                }
                // Mode tir POXERSTART (power-up 7s)
                else if(window.modeTirStars && window.modeTirStars.actif) {
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        tirerStarsProjectile(mouseX, mouseY);  // Ancien système stars
                    }
                }
                // Tir normal (phases lanterne, ou mur hors 17-22)
                else {
                    tirerProjectile(mouseX, mouseY);
                }
            } else {
                // Le système de clic sur les oiseaux est maintenant géré par les événements CSS
                // Voir la fonction setupBirdClickHandlers() plus bas

                // Clic normal sur canvas pour libérer l'amour
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, utiliser le module
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                    const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                    
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.createProjectile(mouseX, mouseY);
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        creerProjectile();
                    }
                }
            }
        });

        // Redimensionnement responsive avec gestion orientation mobile
        let resizeTimer;
        window.addEventListener('resize', () => {
            // Débounce pour éviter trop d'appels
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                size = setupCanvas();
                // Mettre à jour l'objet C avec les nouvelles dimensions
                C.W = size.width;
                C.H = size.height;
                C.PW = Math.max(size.width * 0.3, 100);
                C.PH = Math.max(size.height * 0.025, 15);
                C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                C.SP = Math.max(Math.min(size.width, size.height) * 0.0015, 1.2); // Vitesse balle réduite PC
                
                // ⚡ OPTIMISATION: Invalider cache gradients pour recréer avec nouvelles dimensions
                fondAniméCache.gradients.fondFinale = null;
                fondAniméCache.gradients.fondJour = null;
                fondAniméCache.gradients.fondNuit = null;
                fondAniméCache.gradients.soleilCouchant = null;
                fondAniméCache.gradients.haloSoleilCouchant = null;
                fondAniméCache.gradients.refletSoleil = null;
                fondAniméCache.gradients.merJour = null;
                fondAniméCache.gradients.merNuit = null;
                
                if(!jeu) initJeu();
            }, 100);
        });
        
        // Gestion changement d'orientation sur mobile
        if (isMobile) {
            // Fonction pour vérifier et afficher/masquer le message d'orientation
            function checkOrientation() {
                const orientationWarning = document.querySelector('.orientation-warning');
                const gameContainer = document.querySelector('.game-container');
                
                if (!orientationWarning || !gameContainer) return;
                
                // Détecter l'orientation réelle
                const isLandscape = window.innerWidth > window.innerHeight;
                const isVerySmallHeight = window.innerHeight < 500;
                
                // Bloquer UNIQUEMENT les paysages sur très petits écrans (< 500px hauteur)
                if (isLandscape && isVerySmallHeight && window.innerWidth < 900) {
                    // Mode paysage problématique (trop petit verticalement)
                    orientationWarning.style.display = 'flex';
                    gameContainer.style.display = 'none';
                    console.warn('⚠️ Écran trop petit en paysage - Jeu masqué');
                } else {
                    // Mode portrait ou paysage avec hauteur suffisante
                    orientationWarning.style.display = 'none';
                    gameContainer.style.display = 'flex';
                }
            }
            
            // Vérifier au chargement
            checkOrientation();
            
            // Event orientationchange (API standard)
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    checkOrientation();
                    size = setupCanvas();
                    C.W = size.width;
                    C.H = size.height;
                    C.PW = Math.max(size.width * 0.3, 100);
                    C.PH = Math.max(size.height * 0.025, 15);
                    C.BS = Math.max(Math.min(size.width, size.height) * 0.025, 10);
                    C.SP = Math.max(Math.min(size.width, size.height) * 0.0015, 1.2); // Vitesse balle réduite PC
                    if(!jeu) initJeu();
                }, 300); // Délai pour laisser le temps au navigateur de se repositionner
            });
            
            // Event resize (backup pour PWA qui n'utilisent pas orientationchange)
            window.addEventListener('resize', () => {
                checkOrientation();
            });
        }

        // ========== MODULE MODE SECRET - INITIALISATION ==========
        function initSecretModeModule() {
            if (!canvas || !ctx) {
                console.error('Canvas ou contexte non disponible pour le module secret');
                return;
            }

            // Vérifier si la classe SecretModeModule est disponible
            if (typeof SecretModeModule === 'undefined') {
                console.warn('⚠️ SecretModeModule non trouvé - Utilisation du mode secret intégré');
                secretModeModule = null;
                return;
            }

            try {
                // Créer l'instance du module avec un objet gameState plus simple
                const gameStateRef = {
                    get modeSecret() { return modeSecret; },
                    set modeSecret(val) { modeSecret = val; },
                    get jeu() { return jeu; },
                    set jeu(val) { jeu = val; },
                    get score() { return score; },
                    set score(val) { score = val; },
                    get raquette() { return raquette; },
                    get C() { return C; },
                    get phaseJeu() { return phaseJeu; },
                    set phaseJeu(val) { phaseJeu = val; },
                    get animationBateau() { return animationBateau; },
                    afficherMessage: (msg, duree) => afficherMessage(msg, duree),
                    afficherMessagePowerupSimple: (msg) => afficherMessagePowerupSimple(msg),
                    ajouterParticules: (x, y, couleur, nb) => ajouterParticules(x, y, couleur, nb)
                };

                secretModeModule = new SecretModeModule(canvas, ctx, gameStateRef);
                //
            } catch (error) {
                console.error('❌ Erreur initialisation module secret:', error);
                secretModeModule = null;
            }
        }

        // ========== GESTIONNAIRE AUDIO - INITIALISATION ==========
        function initMusicManager() {
            if (typeof AudioManager === 'undefined') {
                console.error('❌ AudioManager non trouvé - Pas de son'); // ✅ Garder en erreur même en production
                return;
            }

            console.log('✅ Initialisation AudioManager...'); // ✅ Logger l'init audio
            try {
                musicManager = new AudioManager();
                console.log('🎵 Gestionnaire audio initialisé');
                
                // ✅ Activer immédiatement la musique au clic (pas besoin d'attendre l'intro)
                window.musicReadyToStart = true;
                console.log('🎵 Musique prête - démarrera au premier clic utilisateur');
            } catch (error) {
                console.error('❌ Erreur initialisation gestionnaire audio:', error);
                musicManager = null;
            }
        }

        // ========== MODULE OBJETS KAWAII - INITIALISATION ==========
        // Les objets kawaii sont maintenant gérés uniquement par le module secret DOM
        // Plus besoin d'initialisation séparée

        // ========== MODULE OBJETS KAWAII - SUPPRIMÉ ==========
        // Les objets kawaii sont maintenant gérés uniquement par le module secret
        function activerObjetsKawaii() {
        }

        function desactiverObjetsKawaii() {
        }

        function configurerObjetsKawaii(config) {
        }

        // ========== MODULE OISEAUX CSS - GESTIONNAIRE ÉVÉNEMENTS ==========
        function setupBirdClickHandlers() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            // Clic sur le corbeau
            crowElement.addEventListener('click', async function(e) {
                e.stopPropagation(); // Empêcher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'corbeau') {
                    handleBirdClick();
                }
            });

            // Clic sur la colombe
            doveElement.addEventListener('click', async function(e) {
                e.stopPropagation(); // Empêcher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'colombe') {
                    handleBirdClick();
                }
            });
        }

        function handleBirdClick() {
            corbeau.touches++;
            score += 100; // Points bonus pour toucher l'oiseau

            // 🔊 Son d'étincelle magique légère (plus lumineux si lanterne allumée)
            if (lanterne.active) {
                AudioSystem.playSparkle();
                // Particules dorées supplémentaires avec la lanterne
                ajouterParticules(corbeau.x, corbeau.y, '#FFA500', 4);
            } else {
                AudioSystem.playSparkle();
            }

            // Effet visuel
            ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

            // Afficher l'étoile avec le compteur de clics
            afficherEtoileCompteur();

            if (corbeau.touches >= 3 && corbeau.type === 'corbeau') {
                // Vérifier si on est en phases 1 ou 2 - pas de transformation
                const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                if (phaseActuelle === 1 || phaseActuelle === 2) {
                    console.log('🚫 Transformation corbeau bloquée en phases 1 et 2');
                    afficherMessagePowerupSimple(getTranslatedText('game.messages.bird_no', '🐦 NON !'));
                    // Réinitialiser les touches pour qu'il puisse réessayer plus tard
                    corbeau.touches = 0;
                    return;
                }

                // Transformer en colombe !
                corbeau.type = 'colombe';
                score += 1000; // Gros bonus pour la transformation

                // Débloquer le niveau secret !
                niveauSecretDebloque = true;

                afficherMessagePowerupSimple(getTranslatedText('game.messages.crow_transformed', '🕊️ Corbeau transformé en Colombe!'));

                // Le soleil fait un clin d'œil
                soleil.clignotement = true;
                soleil.tempsClignotement = Date.now();

                // Déclencher le niveau secret après un délai
                setTimeout(() => {
                    if (secretModeModule) {
                        secretModeModule.activate();
                    } else {
                        console.error('Module secret non initialisé !');
                        lancerNiveauSecret(); // Fallback vers l'ancien système
                    }
                }, 4000);
            } else {
                // Message discret en bas à droite
                const message = getTranslatedText('game.messages.crow_hit', '🐦 Corbeau touché {count}/7 fois')
                    .replace('{count}', corbeau.touches);
                afficherMessageCorbeauBas(message, 1000);
            }
        }

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        // Variables pour l'étoile compteur
        let etoileCompteur = {
            actif: false,
            x: 0,
            y: 0,
            tempsFin: 0,
            alpha: 1
        };

        function afficherEtoileCompteur() {
            // Positionner l'étoile près du corbeau
            etoileCompteur.x = corbeau.x + 30;
            etoileCompteur.y = corbeau.y - 20;
            etoileCompteur.actif = true;
            etoileCompteur.tempsFin = Date.now() + 2000; // Afficher 2 secondes
            etoileCompteur.alpha = 1;
        }

        function mettreAJourEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            const tempsRestant = etoileCompteur.tempsFin - Date.now();
            if (tempsRestant <= 0) {
                etoileCompteur.actif = false;
                return;
            }

            // Fade out progressif
            if (tempsRestant < 500) {
                etoileCompteur.alpha = tempsRestant / 500;
            }
        }

        function dessinerEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            ctx.save();
            ctx.globalAlpha = etoileCompteur.alpha;

            // Dessiner l'étoile blanche
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;

            const x = etoileCompteur.x;
            const y = etoileCompteur.y;
            const rayon = 15;

            // Forme d'étoile à 5 branches
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const x1 = x + Math.cos(angle) * rayon;
                const y1 = y + Math.sin(angle) * rayon;

                const angleInterne = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                const x2 = x + Math.cos(angleInterne) * (rayon * 0.4);
                const y2 = y + Math.sin(angleInterne) * (rayon * 0.4);

                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Texte du compteur
            ctx.fillStyle = 'black';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(corbeau.touches.toString(), x, y);

            ctx.restore();
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas à droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu || (phaseIntro && phaseIntro.active)) return; // Attendre la fin de l'intro

            // Initialiser le temps de départ si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire apparaître le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;

                // Alterner la direction à chaque passage
                if(corbeau.direction === 1) {
                    // Gauche vers droite
                    corbeau.x = -100;
                    corbeau.vx = C.CV; // Vitesse adaptative corbeau
                } else {
                    // Droite vers gauche
                    corbeau.x = C.W + 100;
                    corbeau.vx = -C.CV; // Vitesse adaptative corbeau
                }

                corbeau.y = C.H * 0.4; // Vers le milieu de l'écran
                corbeau.touches = 0; // Réinitialiser le compteur de touches

                // Alterner pour le prochain passage
                corbeau.direction *= -1;

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;

                // 🔊 Son de corbeau (cri)
                AudioSystem.playCrow();

                //
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                // ⚡ OPTIMISATION: Mouvement ondulant supprimé (trop gênant)
                // Le corbeau traverse directement sans mouvements parasites

                // Vérifier collision avec la lanterne allumée
                if(lanterne.active && balle.visible && !chauveSouris.revelee) {
                    const distanceX = Math.abs(corbeau.x - balle.x);
                    const distanceY = Math.abs(corbeau.y - balle.y);
                    const distanceCollision = 60; // Distance de collision

                    if(distanceX < distanceCollision && distanceY < distanceCollision) {
                        // Révéler la chauve-souris !
                        revelerChauveSouris(corbeau.x, corbeau.y);

                        // Faire disparaître l'oiseau
                        corbeau.actif = false;
                        corbeau.x = 0;
                        corbeau.y = 0;
                    }
                }

                // Retirer le corbeau s'il sort de l'écran (dans les deux directions)
                if((corbeau.vx > 0 && corbeau.x > C.W + 100) || (corbeau.vx < 0 && corbeau.x < -100)) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        // ========== MODULE OISEAUX CSS - FONCTION MODIFIÉE ==========
        function dessinerCorbeau() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            if (!corbeau.actif || (phaseIntro && phaseIntro.active)) {
                // Masquer tous les oiseaux
                crowElement.classList.remove('bird-visible');
                crowElement.classList.add('bird-hidden');
                doveElement.classList.remove('bird-visible');
                doveElement.classList.add('bird-hidden');
                return;
            }

            // Positionner l'oiseau selon les coordonnées
            const activeElement = corbeau.type === 'corbeau' ? crowElement : doveElement;
            const inactiveElement = corbeau.type === 'corbeau' ? doveElement : crowElement;

            // Masquer l'oiseau inactif
            inactiveElement.classList.remove('bird-visible');
            inactiveElement.classList.add('bird-hidden');

            // Positionner et afficher l'oiseau actif avec transform au lieu de left/top
            // Cela évite les reflows et utilise le GPU (pas de scintillement mer)
            // IMPORTANT: On utilise left/top car l'animation CSS utilise déjà transform
            activeElement.style.left = `${corbeau.x}px`;
            activeElement.style.top = `${corbeau.y}px`;
            activeElement.style.transform = `scale(var(--bird-scale))`; // Juste le scale

            // Orienter l'oiseau selon sa direction avec l'animation appropriée
            if (corbeau.vx < 0) {
                // Va vers la gauche - utiliser animation retournée
                activeElement.style.animation = 'crow-auto-flight-left calc(2s / var(--animation-speed)) infinite';
                //console.log('🐦 Corbeau orienté GAUCHE ← (animation crow-auto-flight-left), x:', corbeau.x);
            } else {
                // Va vers la droite - animation normale
                activeElement.style.animation = 'crow-auto-flight calc(2s / var(--animation-speed)) infinite';
                //console.log('🐦 Corbeau orienté DROITE → (animation crow-auto-flight), x:', corbeau.x);
            }

            activeElement.classList.remove('bird-hidden');
            activeElement.classList.add('bird-visible');
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y, invisible = false) {
            // Décaler largement la position pour éviter les superpositions
            const decalageAleatoire = Math.random() * 100 - 50; // ±50px
            const yDecale = y + (textesVolants.length * 50); // Décalage vertical de 50px par texte existant

            textesVolants.push({
                texte: texte,
                x: x + decalageAleatoire,
                y: yDecale,
                xDepart: x + decalageAleatoire,
                yDepart: yDecale,
                vy: 0, // Vitesse calculée dynamiquement
                taille: 12, // Taille initiale
                alpha: invisible ? 0 : 1, // Opacité (0 si invisible)
                temps: 0,
                phase: 'descente', // 'descente' puis 'montee'
                invisible: invisible // Marquer comme invisible
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.006; // Ralenti (était 0.012)

                // Mouvement vers le centre horizontal plus lent
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Ralenti (était 3)
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis montée
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 100); // Ralenti (était 200)

                    // Fondu pendant la descente plus lent
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Ralenti (était 4)

                    // Passer à la phase montée plus tard
                    if(texte.temps > 0.3) { // Plus long (était 0.15)
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 80); // Ralenti (était 180)

                    // Fondu retour pendant la montée plus lent
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 2); // Ralenti (était 4)
                }

                // Grossissement très progressif et doux
                texte.taille = 12 + texte.temps * 15; // Ralenti (était 20)

                // Disparition finale plus lente
                if(texte.temps > 0.8) { // Plus long (était 0.4)
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.8) * 2); // Ralenti (était 4)
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu
        function boucleJeu() {
            // 🔍 DEBUG SIMPLE: Une seule fois pour vérifier que la boucle démarre
            if (!window.boucleStarted) {
                window.boucleStarted = true;
                console.log('🎮 BoucleJeu DÉMARRÉE');
            }
            
            // 🔍 DEBUG: État du jeu et de l'intro (une fois seulement)
            if (!window.debugStateLogged) {
                window.debugStateLogged = true;
                console.log('🎮 État du jeu:', {
                    jeu: jeu,
                    phaseIntroActive: phaseIntro?.active,
                    phaseIntroEtape: phaseIntro?.etape,
                    languageSelectorActive: languageSelector?.active,
                    languageChosen: languageSelector?.languageChosen
                });
            }
            
            // ⚡ OPTIMISATION #1 : CLEAR CANVAS AU DÉBUT DE CHAQUE FRAME
            // Évite l'accumulation de dessins et surcharge GPU mobile
            ctx.clearRect(0, 0, C.W, C.H);
            
            // Animation du survol du drapeau (simple)
            if (flagHover && flagHoverAnimation < 1) {
                flagHoverAnimation = Math.min(1, flagHoverAnimation + flagHoverAnimationSpeed);
            } else if (!flagHover && flagHoverAnimation > 0) {
                flagHoverAnimation = Math.max(0, flagHoverAnimation - flagHoverAnimationSpeed);
            }
            
            // 🌍 SI LANGUE NON CHOISIE : dessiner seulement le sélecteur
            if (languageSelector.active && !languageSelector.languageChosen) {
                // Canvas déjà clear en haut

                // ⚡ OPTIMISATION: Créer gradient une seule fois
                if (!fondAniméCache.gradients.languageSelector) {
                    const gradient = ctx.createLinearGradient(0, 0, 0, C.H);
                    gradient.addColorStop(0, '#0055A4');      // Bleu roi
                    gradient.addColorStop(0.5, '#ffffff');    // Blanc
                    gradient.addColorStop(1, '#EF4135');      // Rouge
                    fondAniméCache.gradients.languageSelector = gradient;
                }
                
                ctx.fillStyle = fondAniméCache.gradients.languageSelector;
                ctx.fillRect(0, 0, C.W, C.H);

                // ⚡ OPTIMISATION: Calculer vagues tous les 2 frames (30 FPS - fluide et performant)
                const time = Date.now() / 1000;
                
                if (fondAniméCache.frameCount - fondAniméCache.lastLanguageWaveFrame >= fondAniméCache.languageWaveThrottle) {
                    fondAniméCache.lastLanguageWaveFrame = fondAniméCache.frameCount;
                    fondAniméCache.languageWavesPath = [];
                    
                    ctx.save();

                    // Vague 1 (arrière) - pas réduit de 5 à 10
                    const wave1 = new Path2D();
                    for (let x = 0; x <= C.W; x += 10) {
                        const y = C.H * 0.3 + Math.sin(x * 0.01 + time * 0.5) * 40 + Math.cos(x * 0.02 + time * 0.3) * 20;
                        if (x === 0) wave1.moveTo(x, y);
                        else wave1.lineTo(x, y);
                    }
                    fondAniméCache.languageWavesPath[0] = { path: wave1, alpha: 0.15, width: 3 };

                    // Vague 2 (milieu)
                    const wave2 = new Path2D();
                    for (let x = 0; x <= C.W; x += 10) {
                        const y = C.H * 0.5 + Math.sin(x * 0.015 + time * 0.7) * 50 + Math.cos(x * 0.025 + time * 0.5) * 25;
                        if (x === 0) wave2.moveTo(x, y);
                        else wave2.lineTo(x, y);
                    }
                    fondAniméCache.languageWavesPath[1] = { path: wave2, alpha: 0.2, width: 4 };

                    // Vague 3 (avant)
                    const wave3 = new Path2D();
                    for (let x = 0; x <= C.W; x += 10) {
                        const y = C.H * 0.7 + Math.sin(x * 0.02 + time * 1) * 60 + Math.cos(x * 0.03 + time * 0.8) * 30;
                        if (x === 0) wave3.moveTo(x, y);
                        else wave3.lineTo(x, y);
                    }
                    fondAniméCache.languageWavesPath[2] = { path: wave3, alpha: 0.25, width: 5 };
                    
                    ctx.restore();
                }
                
                // Dessiner les vagues en cache
                ctx.save();
                ctx.strokeStyle = '#ffffff';
                fondAniméCache.languageWavesPath.forEach(wave => {
                    ctx.globalAlpha = wave.alpha;
                    ctx.lineWidth = wave.width;
                    ctx.stroke(wave.path);
                });
                ctx.globalAlpha = 1;
                ctx.restore();

                // ⚡ OPTIMISATION #4 : Particules réduites selon qualité mobile
                const effects = window.getAdaptiveEffectSettings ? window.getAdaptiveEffectSettings() : { particleMultiplier: 1.0 };
                const particleCount = Math.floor(10 * effects.particleMultiplier); // 10 → 5 → 2.5 selon device
                
                for (let i = 0; i < particleCount; i++) {
                    const x = (i * C.W / particleCount) + (Math.sin(time + i) * 50);
                    const y = (i * C.H / particleCount) + (Math.cos(time + i) * 30);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.15 + Math.sin(time + i) * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // NUAGE DE TRADUCTIONS "PETIT BATEAU"
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ⚡ OPTIMISATION #3 : Réduire shadowBlur de 50% sur mobile
                const shadowBlur = effects.shadowBlurMax || 15;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = effects.shadows ? shadowBlur : 0;

                // Traductions de "Petit Bateau" dans différentes langues avec positions et tailles variées
                // Positions ajustées pour éviter les bords
                const margin = 100; // Marge de sécurité
                const translations = [
                    { text: '⛵', x: C.W/2, y: C.H/2 - 310, size: 64, opacity: 1 },
                    { text: 'PETIT BATEAU', x: C.W/2, y: C.H/2 - 180, size: 48, opacity: 1 },
                    { text: 'LITTLE BOAT', x: Math.max(margin, C.W/2 - 200), y: C.H/2 - 220, size: 36, opacity: 0.85 },
                    { text: '小さな船', x: Math.min(C.W - margin, C.W/2 + 220), y: C.H/2 - 210, size: 32, opacity: 0.8 },
                    { text: 'МАЛЕНЬКИЙ ЧОВЕН', x: Math.max(margin + 50, C.W/2 - 180), y: C.H/2 - 130, size: 28, opacity: 0.75 },
                    { text: 'قارب صغير', x: Math.min(C.W - margin, C.W/2 + 200), y: C.H/2 - 140, size: 30, opacity: 0.7 },
                    { text: 'छोटी नाव', x: Math.max(margin, C.W/2 - 250), y: C.H/2 - 170, size: 24, opacity: 0.65 },
                    { text: 'PEQUEÑO BARCO', x: Math.min(C.W - margin - 50, C.W/2 + 180), y: C.H/2 - 170, size: 26, opacity: 0.7 },
                    { text: 'PICCOLA BARCA', x: Math.max(margin + 30, C.W/2 - 140), y: C.H/2 - 90, size: 22, opacity: 0.6 },
                    { text: '작은 배', x: Math.min(C.W - margin, C.W/2 + 240), y: C.H/2 - 100, size: 28, opacity: 0.65 },
                ];

                translations.forEach(trans => {
                    ctx.font = `bold ${trans.size}px "Segoe UI", Arial, sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${trans.opacity})`;
                    ctx.fillText(trans.text, trans.x, trans.y);
                });

                ctx.shadowBlur = 0;

                // 🌍 MINI-JEU "BRISER LES FRONTIÈRES" - Indépendant
                if (briqueLangue.active) {
                    ctx.save();

                    // Initialiser le jeu si nécessaire
                    if (!briqueLangue.game) {
                        briqueLangue.game = {
                            bricks: [],
                            ball: { x: C.W/2, y: C.H - 100, dx: 4, dy: -4, radius: 10, launched: false },
                            paddle: { x: C.W/2 - 50, y: C.H - 40, width: 100, height: 15 }
                        };

                        // Tous les drapeaux du monde
                        const tousLesDrapeaux = [
                            { drapeau: '🇫🇷', code: 'fr', nom: 'Français' },
                            { drapeau: '🇬🇧', code: 'en', nom: 'English' },
                            { drapeau: '🇯🇵', code: 'jp', nom: '日本語' },
                            { drapeau: '🇺🇦', code: 'uk', nom: 'Українська' },
                            { drapeau: '🇪🇸', code: 'es', nom: 'Español' },
                            { drapeau: '🇩🇪', code: 'de', nom: 'Deutsch' },
                            { drapeau: '🇮🇹', code: 'it', nom: 'Italiano' },
                            { drapeau: '🇵🇹', code: 'pt', nom: 'Português' },
                            { drapeau: '🇷🇺', code: 'ru', nom: 'Русский' },
                            { drapeau: '🇨🇳', code: 'zh', nom: '中文' },
                            { drapeau: '🇰🇷', code: 'ko', nom: '한국어' },
                            { drapeau: '🇸🇦', code: 'ar', nom: 'العربية' },
                            { drapeau: '🇮🇳', code: 'hi', nom: 'हिन्दी' },
                            { drapeau: '🇧🇷', code: 'br', nom: 'Brasil' },
                            { drapeau: '🇲🇽', code: 'mx', nom: 'México' },
                            { drapeau: '🇨🇦', code: 'ca', nom: 'Canada' },
                            { drapeau: '🇦🇺', code: 'au', nom: 'Australia' },
                            { drapeau: '🇿🇦', code: 'za', nom: 'South Africa' },
                            { drapeau: '🇪🇬', code: 'eg', nom: 'مصر' },
                            { drapeau: '🇳🇬', code: 'ng', nom: 'Nigeria' },
                            { drapeau: '🇰🇪', code: 'ke', nom: 'Kenya' },
                            { drapeau: '🇹🇷', code: 'tr', nom: 'Türkiye' },
                            { drapeau: '🇮🇷', code: 'ir', nom: 'فارسی' },
                            { drapeau: '🇹🇭', code: 'th', nom: 'ไทย' },
                            { drapeau: '🇻🇳', code: 'vn', nom: 'Việt Nam' },
                            { drapeau: '🇵🇭', code: 'ph', nom: 'Philippines' },
                            { drapeau: '🇮🇩', code: 'id', nom: 'Indonesia' },
                            { drapeau: '🇲🇾', code: 'my', nom: 'Malaysia' },
                            { drapeau: '🇸🇬', code: 'sg', nom: 'Singapore' }
                        ];

                        // Créer les briques drapeaux (4 lignes avec plein de drapeaux)
                        const brickW = 70;
                        const brickH = 45;
                        const cols = Math.floor(C.W / brickW);
                        const startX = (C.W - (cols * brickW)) / 2;
                        const startY = 80;

                        for (let row = 0; row < 4; row++) {
                            for (let col = 0; col < cols; col++) {
                                const randomDrapeau = tousLesDrapeaux[Math.floor(Math.random() * tousLesDrapeaux.length)];
                                briqueLangue.game.bricks.push({
                                    x: startX + col * brickW,
                                    y: startY + row * brickH,
                                    width: brickW - 6,
                                    height: brickH - 6,
                                    flag: randomDrapeau.drapeau,
                                    code: randomDrapeau.code,
                                    nom: randomDrapeau.nom,
                                    alive: true
                                });
                            }
                        }
                    }

                    const game = briqueLangue.game;

                    // Vérifier si toutes les briques sont cassées
                    const brickesRestantes = game.bricks.filter(b => b.alive).length;
                    if (brickesRestantes === 0) {
                        briqueLangue.active = false;
                        const points = game.bricks.length * 3;
                        const message = getTranslatedText('game.messages.frontiers_broken', '🌍💕 FRONTIÈRES BRISÉES! +XXX ❤️').replace('XXX', points);
                        afficherMessagePowerupSimple(message);
                        return;
                    }

                    // Physique de la balle
                    if (game.ball.launched) {
                        game.ball.x += game.ball.dx;
                        game.ball.y += game.ball.dy;

                        // Rebonds murs
                        if (game.ball.x - game.ball.radius < 0 || game.ball.x + game.ball.radius > C.W) {
                            game.ball.dx = -game.ball.dx;
                        }
                        if (game.ball.y - game.ball.radius < 0) {
                            game.ball.dy = -game.ball.dy;
                        }

                        // Rebond raquette
                        if (game.ball.y + game.ball.radius > game.paddle.y &&
                            game.ball.x > game.paddle.x && game.ball.x < game.paddle.x + game.paddle.width &&
                            game.ball.dy > 0) {
                            game.ball.dy = -Math.abs(game.ball.dy);
                            const hitPos = (game.ball.x - game.paddle.x) / game.paddle.width;
                            game.ball.dx = (hitPos - 0.5) * 8;
                        }

                        // Collision briques
                        game.bricks.forEach(brick => {
                            if (!brick.alive) return;
                            if (game.ball.x + game.ball.radius > brick.x &&
                                game.ball.x - game.ball.radius < brick.x + brick.width &&
                                game.ball.y + game.ball.radius > brick.y &&
                                game.ball.y - game.ball.radius < brick.y + brick.height) {
                                brick.alive = false;
                                game.ball.dy = -game.ball.dy;

                                // Faire tomber des cœurs au lieu de changer de langue
                                for (let i = 0; i < 3; i++) {
                                    powerUps.push({
                                        x: brick.x + brick.width/2,
                                        y: brick.y + brick.height/2,
                                        dx: (Math.random() - 0.5) * 2,
                                        dy: Math.random() * 2 + 1,
                                        type: 'coeur',
                                        taille: 20
                                    });
                                }

                                // Particules d'explosion
                                for (let i = 0; i < 15; i++) {
                                    particules.push({
                                        x: brick.x + brick.width/2,
                                        y: brick.y + brick.height/2,
                                        dx: (Math.random() - 0.5) * 5,
                                        dy: (Math.random() - 0.5) * 5,
                                        vie: 30,
                                        taille: Math.random() * 5 + 2,
                                        couleur: `hsl(${Math.random() * 360}, 70%, 60%)`
                                    });
                                }
                            }
                        });

                        // Balle perdue
                        if (game.ball.y > C.H) {
                            game.ball.x = game.paddle.x + game.paddle.width/2;
                            game.ball.y = game.paddle.y - 20;
                            game.ball.launched = false;
                        }
                    } else {
                        // Balle suit la raquette
                        game.ball.x = game.paddle.x + game.paddle.width/2;
                        game.ball.y = game.paddle.y - 20;
                    }

                    // ⚡ OPTIMISATION: Définir styles UNE FOIS avant la boucle
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.lineWidth = 3;

                    // Dessiner briques
                    game.bricks.forEach(brick => {
                        if (!brick.alive) return;

                        // Fond brique
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        
                        // Bordure brique
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                        // ⚡ Font drapeaux (shadow déjà configuré)
                        ctx.font = '36px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(brick.flag, brick.x + brick.width/2, brick.y + brick.height/2 - 5);

                        // ⚡ Font noms (shadow toujours actif)
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(brick.nom, brick.x + brick.width/2, brick.y + brick.height/2 + 15);
                    });

                    // ⚡ OPTIMISATION: Désactiver shadowBlur après briques
                    ctx.shadowBlur = 0;

                    // Dessiner raquette
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 8;
                    ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);

                    // Dessiner balle
                    ctx.beginPath();
                    ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Instructions
                    const instructionOpacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.3;
                    ctx.font = 'bold 22px "Segoe UI", Arial, sans-serif';
                    ctx.fillStyle = `rgba(255, 255, 255, ${instructionOpacity})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 5;
                    ctx.fillText(game.ball.launched ? getTranslatedText('interface.game.break_borders', '🌍 BRISER LES FRONTIÈRES 🌍') : getTranslatedText('interface.game.click_to_launch', '🚀 CLIQUEZ POUR LANCER'), C.W/2, C.H - 80);

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }

                requestAnimationFrame(boucleJeu);
                return; // NE PAS CONTINUER
            }

            // Gérer l'animation du bateau (sauf si sélecteur de langue actif)
            if (!languageSelector.active) {
                gererAnimationBateau();
            }

            // Gérer la phase d'introduction (sauf si sélecteur de langue actif)
            if (!languageSelector.active) {
                gererPhaseIntro();
            }

            // Mise à jour du module de drones (sauf si sélecteur de langue actif)
            if (droneModule && !languageSelector.active) {
                droneModule.animate();
            }

            // Phase bonus - Livre blanc moderne
            if (phaseJeu === 'bonus_livre') {
                dessinerLivreBonus();
            } else if(jeu || (phaseIntro && phaseIntro.active)) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Système projectiles stars
                    mettreAJourProjectiles(); // Nouveau système de projectiles
                    mettreAJourBulle(); // Ancien système pour les autres phases
                    mettreAJourLaser(); // Laser phase 23
                    
                    // Activation automatique du laser en phase 23
                    const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                    if (phaseActuelle === 23 && phaseJeu === 'mur') {
                        activerLaser();
                    }
                }
                mettreAJourParticules();

                // Pluie - mise à jour toujours si active
                mettreAJourPluie();
                
                // Création de gouttes uniquement en phase 5
                if (narrationManager && narrationManager.currentPhase === 5) {
                    creerGouttesPluie();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                
                // Désactiver petits cœurs pour phases 17-23
                const phaseActuelleMaj = narrationManager ? narrationManager.currentPhase : 0;
                if (!(phaseActuelleMaj >= 17 && phaseActuelleMaj <= 23 && phaseJeu === 'mur')) {
                    mettreAJourPetitsCoeurs();
                }
                
                mettreAJourTextesVolants();

                // Corbeau et chauve-souris - toujours vérifier
                mettreAJourCorbeau(); // Vérifie en interne si actif
                if (corbeau.actif) mettreAJourMessageCorbeauBas();
                if (chauveSouris.active) mettreAJourChauveSouris();

                // ⚡ OPTIMISATION: Animation menu - N'appeler que si visible
                if (menuEnigmesCanvas.visible) {
                    mettreAJourMenuEnigmesCanvas();
                }

                // Vérification automatique des énigmes (réduite à 0.5%)
                if (enigmaCollector && Math.random() < 0.005) {
                    enigmaCollector.verifierCollectionAutomatique();
                }
                mettreAJourEtoileCompteur();

                // Éclairs uniquement en mode nuit
                if (periode === 'nuit') {
                    mettreAJourEclairNuit();
                }

                // Obstacles gérés par le module secret seulement

                // Objets kawaii réservés au mode secret uniquement
                // (Les objets kawaii sont maintenant dans le module secret)
                // Mode secret - désactivé en phase finale
                if (phaseJeu !== 'final' && phaseJeu !== 'feux_artifice') {
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.update();
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        mettreAJourProjectilesSecret();
                    }
                }
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }

        // Démarrage avec intro forcée
        initJeu();

        // Initialiser le module secret
        initSecretModeModule();

        // 🔥 FORCER l'intro SEULEMENT si pas de sauvegarde (sera réécrasé dans le load event)
        // Ce code s'exécute avant le load event, donc phaseIntro est encore null
        // On laisse phaseIntro à null ici - il sera initialisé dans le load event
        // phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        // jeu = false;

        // 🎯 AFFICHAGE IMMÉDIAT DE L'INTRO (solution radicale)
        // 🔥 BLOQUÉ SI SAUVEGARDE - vérifier AVANT le setTimeout
        const hasSaveBeforeTimeout = localStorage.getItem('petit_bateau_save') !== null;
        
        if (!hasSaveBeforeTimeout) {
            console.warn('✅ Pas de sauvegarde - Lancement de l\'intro programmée');
            setTimeout(() => {
                // Double vérification au moment de l'exécution
                if (window.isRestoringGame || window.narrationStarted || window.skipNarrationIntro) {
                    console.warn('⏭️ Intro programmée annulée - Flags de sauvegarde détectés');
                    return;
                }
                
                // 🎯 ACTIVER LE TITRE DANS LE CANVAS APRÈS 7 SECONDES
            setTimeout(() => {
                titreVoyage.active = true;
                titreVoyage.texte = getTranslatedText('narrative.phase1.title', 'L\'aube des doutes\nPhase 1');
                titreVoyage.fin = Date.now() + 30000; // Affiché pendant 30 secondes
            }, 15000); // 15 secondes de délai



            // Code bouton supprimé pour simplicité
            /*afficherMessage(`
                <div style="font-size: 22px; color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); line-height: 1.4;">
                    🌟 "On m'a dit qu'ils étaient tous des monstres...
                    <br>✨ On m'a dit tant de mal, tant de malheurs sur eux...
                    <br>🔍 Mais moi, j'ai préféré aller voir de mes propres yeux."
                </div>

                CODE BOUTON COMPLEXE SUPPRIMÉ POUR SIMPLICITÉ
            */

            // Affichage direct de l'intro Phase 1 avec bouton passer
            // Utiliser notre système simple
            afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.intro_full', "On m'a dit qu'ils étaient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai préféré aller voir\nde mes propres yeux..."), 12000);

            // Activer le bouton passer pendant l'intro
            boutonPasser.actif = true;

            // Désactiver le bouton après l'intro (même timing que le message narratif)
            setTimeout(() => {
                boutonPasser.actif = false;
            }, 12000);

            // 🎯 AFFICHER LE MESSAGE "NON ON PEUT PAS LAISSER PASSER ÇA" À LA FIN
            setTimeout(() => {
                afficherMessageNarratifSimple(getTranslatedText('narrative.phase1.reaction', 'NON on peut pas laisser passer ça !'), 3000);

                // 🌧️ Pluie émotionnelle IMMÉDIATE pendant le message
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();

                    // 🌧️ Deuxième vague de pluie plus intense 1 seconde après
                    setTimeout(() => {
                        declencherPluieLumineuse();
                    }, 1000);
                } else {
                    console.error('❌ Fonction declencherPluieLumineuse non trouvée !');
                }
            }, 12000); // À la fin de l'intro (12 secondes)

            // 🎯 DÉCLENCHER LA RÉCOMPENSE 100 POINTS APRÈS LE MESSAGE ET ACTIVER LE JEU
            setTimeout(async () => {

                // Attendre que les traductions soient chargées
                if (window.translationsReady) {
                    await window.translationsReady;
                }

                try {
                    if (phaseJeu === 'tir_coeurs_haut') {
                        //
                        pointsConnaissance += 100;
                        //
                    } else {
                        //
                        score += 100;
                        //
                    }

                    // Message simple
                    afficherMessagePowerupSimple(getTranslatedText('game.messages.intro_points', '🌟 +100 Points intro complète'));
                } catch (error) {
                    console.error('❌ Erreur lors de l\'attribution points intro:', error);
                }

                // 🎮 FORCER L'ACTIVATION DU JEU APRÈS L'INTRO
                phaseIntro.active = false;
                jeu = true;

                // 🎬 CRÉER LES PETITS CŒURS POUR LA PHASE 1
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();
                creerPetitsCoeurs();
            }, 15000); // Déclencher après le message NON (12000ms + 3000ms)

            }, 500); // Attendre 0.5 seconde pour être sûr que l'interface est prête
        } else {
            console.warn('⏭️⏭️⏭️ SAUVEGARDE DÉTECTÉE - INTRO ENTIÈREMENT BLOQUÉE ⏭️⏭️⏭️');
        }

        // === RACCOURCIS TEST (ACTIVÉS POUR DEBUG MODE SECRET) ===
        document.addEventListener('keydown', (e) => {
            // Ne pas intercepter les touches si on est dans un input/textarea/select
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            // Touche S pour lancer le mode secret directement
            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                console.log('🎮 Activation MODE SECRET via touche S');
                if (typeof lancerNiveauSecret === 'function') {
                    lancerNiveauSecret();
                } else {
                    console.error('❌ Fonction lancerNiveauSecret non trouvée');
                }
            }
        });

        // === ANCIEN SYSTÈME NARRATION SUPPRIMÉ ===
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let phaseAvantSecret = null; // Sauvegarder la phase avant le mode secret
        let modeEtoileLance = false; // Pour tracker si on est en mode étoile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        // anciens messages supprimés

        // Fonction supprimée

        // Fonctions supprimées

        // === RACCOURCIS CLAVIER (DÉSACTIVÉS EN PRODUCTION) ===
        /*
        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Ne pas intercepter les touches si on est dans un input/textarea/select
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            // Touche ESC pour fermer les menus
            if (e.key === 'Escape') {
                e.preventDefault();
                if (menuEnigmesCanvas.visible) {
                    fermerMenuEnigmesCanvas();
                }
            }

            // 💾 Touche K pour sauvegarder manuellement
            if (e.key === 'k' || e.key === 'K') {
                e.preventDefault();
                if (GameSaveSystem.save()) {
                    afficherMessagePowerupSimple('💾 Partie sauvegardée !');
                }
            }

            // 📂 Touche L pour charger la sauvegarde
            if (e.key === 'l' || e.key === 'L') {
                e.preventDefault();
                const state = GameSaveSystem.load();
                if (state) {
                    if (GameSaveSystem.restore(state)) {
                        afficherMessagePowerupSimple(getTranslatedText('save.loaded', '📂 Partie chargée !'));
                    }
                } else {
                    afficherMessagePowerupSimple(getTranslatedText('save.not_found', '❌ Aucune sauvegarde trouvée'));
                }
            }

            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer à la phase suivante (désactivé)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprimée pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Touche 3 pour aller à la phase 20
            if(e.key === '3') {
                e.preventDefault();
                if (narrationManager) {
                    narrationManager.currentPhase = 20;
                    narrationManager.start();
                }
            }

            // Touche S pour recommencer la phase
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                if (narrationManager) {
                    narrationManager.restart();
                } else {
                    recommencer();
                }
            }

            // Touche N pour niveau secret
            if(e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Touche R pour recommencer UNIQUEMENT la phase actuelle (pas depuis le début)
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                if (narrationManager && narrationManager.restart) {
                    // Redémarrer juste la phase en cours
                    narrationManager.restart();
                }
            }

            // 🎆 TEST : Touche X pour tester l'animation d'explosion
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                animerExplosionIconeCollector(() => {
                });
            }

            // 🔄 RESET : Touche Z pour réinitialiser à zéro
            if(e.key === 'z' || e.key === 'Z') {
                e.preventDefault();

                // Effacer toutes les données localStorage
                localStorage.removeItem('vdv_enigmes_collectees');
                localStorage.removeItem('petit_bateau_progression');
                localStorage.removeItem('vdv_gameState');

                // Recharger la page
                location.reload();
            }

            // 🌧️ PLUIE : Touche P pour déclencher pluie de traits lumineux
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }

            // Mode passe : Touche E pour tir automatique étoiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

            // Cheat code : Touche X pour multiplier puissance x10
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                if (multiplicateurPuissance === 1) {
                    multiplicateurPuissance = 10;
                } else {
                    multiplicateurPuissance = 1;
                }
            }

            // Cheat code : Touche C pour casser TOUT instantanément
            if(e.key === 'c' || e.key === 'C') {
                e.preventDefault();

                // Casser toutes les briques
                if (briques && briques.length > 0) {
                    const nbBriques = briques.length;
                    briques.forEach(brique => {
                        if (brique.visible) {
                            brique.visible = false;
                            brises++;
                            score += 100;
                            // Particules d'explosion
                            for(let i = 0; i < 3; i++) {
                                particules.push({
                                    x: brique.x + brique.w/2,
                                    y: brique.y + brique.h/2,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -(Math.random() * 3 + 2),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 2,
                                    type: 'coeur'
                                });
                            }
                        }
                    });
                    briques = briques.filter(b => b.visible);
                    window.score = score;
                }

                // Casser tous les petits cœurs décoratifs
                if (petitsCoeurs && petitsCoeurs.length > 0) {
                    const nbCoeurs = petitsCoeurs.length;
                    petitsCoeurs.forEach(coeur => {
                        score += 50;
                        // Particules
                        for(let i = 0; i < 2; i++) {
                            particules.push({
                                x: coeur.x,
                                y: coeur.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -(Math.random() * 2 + 1),
                                couleur: coeur.couleur,
                                vie: 1,
                                taille: Math.random() * 2 + 1,
                                type: 'coeur'
                            });
                        }
                    });
                    petitsCoeurs = [];
                    window.score = score;
                }

                afficherMessageNarratifSimple(getTranslatedText('game.messages.all_broken', '💥 TOUT CASSÉ ! 💥'), 2000);

                // Vérifier la fin de niveau après le cheat
                setTimeout(() => {
                    const briquesRestantes = briques.filter(b => b.visible).length;
                    const coeursRestants = petitsCoeurs.filter(c => c.visible).length;

                    // Si tout est détruit, déclencher la fin du niveau
                    if (briquesRestantes === 0 && coeursRestants === 0) {
                        // 🌈 EXCEPTION PHASE 22 : Ne pas terminer si power-up Espoir pas collecté !
                        const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
                        if (phaseActuelle === 22 && phaseJeu === 'mur') {
                            const espoirPresent = powerUps && powerUps.some(p => p.type === 'rainbow_hope' && !p.collected);
                            if (espoirPresent) {
                                console.log('🌈 Phase 22 : Cheat utilisé mais power-up ESPOIR pas encore collecté !');
                                return; // ← Sortir sans animation
                            }
                        }

                        // Animation d'explosion et passage à la phase suivante
                        if (typeof animerExplosionIconeCollector === 'function') {
                            animerExplosionIconeCollector(() => {
                                if (narrationManager && typeof narrationManager.goToNextPhaseDirect === 'function') {
                                    narrationManager.goToNextPhaseDirect();
                                }
                            });
                        }
                    }
                }, 100);
            }

        });
        */

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            // Bloquer en phases 1 et 2 (désactivé pour tests)
            const phaseActuelle = narrationManager ? narrationManager.currentPhase : 0;
            if (false && (phaseActuelle === 1 || phaseActuelle === 2)) {
                console.log('🚫 Mode secret bloqué en phases 1 et 2');
                afficherMessagePowerupSimple(getTranslatedText('game.messages.bird_no', '🐦 NON !'));
                return;
            }
            
            // 🧪 TEST: Forcer phase 3 minimum pour le mode secret
            if (phaseActuelle < 3) {
                console.log('🧪 TEST: Passage automatique en phase 3 pour mode secret');
                phaseJeu = 3;
                if (narrationManager) narrationManager.currentPhase = 3;
            }

            // Désactiver les objets kawaii pendant le mode secret
            desactiverObjetsKawaii();

            // Utiliser le module si disponible, sinon le système intégré
            if (secretModeModule) {
                secretModeModule.activate();
                return;
            }

            // Fallback vers l'ancien système
            // Sauvegarder la phase actuelle
            phaseAvantSecret = phaseJeu;

            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = []; // Réinitialiser les obstacles pour le fallback

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Mode secret utilise maintenant le module secret - pas d'obstacles de fallback

            afficherMessageAnime(getTranslatedText('game.messages.secret_mode', '🎯 Mode Secret : Tir de Précision 🎯\n\n🧊 Tirez sur les icebergs et poubelles ♻\n🐋 Les baleines sont protégées !\n🚫 Tirer sur une baleine = perte de vie\n👆 Chaque clic = un tir précis\n💰 +100 points par obstacle détruit'), 5000, 'glitch', 50);
        }



        function creerProjectile() {
            // Créer un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // Vérifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle déjà touché

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision détectée !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine protégée ! Perdre une vie
                            vies--;

                            // Messages amusants variés
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                // Restaurer la phase d'origine même en Game Over
                                if (phaseAvantSecret) {
                                    phaseJeu = phaseAvantSecret;
                                    phaseAvantSecret = null;
                                } else {
                                    phaseJeu = 'briques'; // Fallback par défaut
                                }

                                // Réactiver les objets kawaii après Game Over
                                activerObjetsKawaii();

                                afficherMessageAvecBoutons(`💀 ${messageAleatoire} 💀\n\n🐋 Tu as tiré sur une baleine protégée !\n😱 Toutes tes vies sont épuisées !\n🚫 Les baleines ne se tirent pas !\n🤪 HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 Les baleines sont protégées !\n💔 Vie perdue : ${vies} restantes\n😤 Tire seulement sur les icebergs !\n🙄 TSSS TSSS!`,
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 BALEINE = INTERDITE !\n💔 Oups : ${vies} vies restantes\n😤 ICEBERGS SEULEMENT !\n🤦‍♂️ PFFFFFF!`,
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 PAUVRE BALEINE !\n💔 Punition : ${vies} vies left\n😤 GLACE = OK, BALEINE = NON !\n😂 HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (colère)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK à détruire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle détruit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succès)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touché temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        async function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // SUPPRIMÉ: creerObstaclesMarins() - remplacé par le module secret

        // SUPPRIMÉ: mettreAJourObstacles() - remplacé par le module secret

        // SUPPRIMÉ: Module obstacles legacy - remplacé par le module secret

        // SUPPRIMÉ: dessinerObstacles() - remplacé par le module secret

        // L'animation démarre automatiquement via gererAnimationBateau()
        window.addEventListener('load', async function() {
            console.log('🚀 LOAD EVENT DÉCLENCHÉ');

            // 🔥 Vérifier si un reset était en cours
            const resetInProgress = localStorage.getItem('gameResetInProgress');
            if (resetInProgress === 'true') {
                console.log('🔄 Reset détecté - Nettoyage du flag');
                localStorage.removeItem('gameResetInProgress');
                // Ne pas charger de sauvegarde, continuer normalement
            }

            // 🔥 VÉRIFIER IMMÉDIATEMENT s'il y a une sauvegarde et bloquer l'intro
            const hasSavedGame = !resetInProgress && GameSaveSystem.hasSave();
            console.log('🔍 Vérification sauvegarde:', {
                hasSave: hasSavedGame,
                resetInProgress
            });
            
            if (hasSavedGame) {
                // 🔒 BLOQUER TOUT dès maintenant
                window.isRestoringGame = true;
                window.narrationStarted = true;
                window.skipNarrationIntro = true;
                window.skipIntroAnimation = false; // ✅ Initialiser le flag
                console.log('🔒 Sauvegarde détectée - Flags de blocage activés');
            } else {
                window.skipIntroAnimation = false; // ✅ Initialiser le flag
                console.log('ℹ️ Pas de sauvegarde - Démarrage normal');
            }
            
            // 🎬 INITIALISER phaseIntro MAINTENANT (après activation des flags)
            // ✅ Désactiver intro si sauvegarde OU si restauration en cours
            const skipIntro = window.isRestoringGame || hasSavedGame;
            phaseIntro = { 
                active: skipIntro ? false : langueDejaChoisie, 
                etape: skipIntro ? 'terminee' : 'arrivee_bateau', 
                tempsDebut: skipIntro ? 0 : (langueDejaChoisie ? Date.now() : 0)
            };
            console.log('🎬 Phase intro initialisée:', {
                active: phaseIntro.active,
                skipIntro: skipIntro,
                hasSavedGame: hasSavedGame,
                isRestoring: window.isRestoringGame
            });

            // Initialiser le module i18n en premier
            if (window.i18n) {
                console.log('🌍 Initialisation du module i18n...');
                await window.i18n.init();
                console.log('🌍 Module i18n initialisé avec succès');
                
                // Synchroniser la langue actuelle
                currentLang = window.i18n.getCurrentLanguage();
                console.log(`🌍 Langue actuelle: ${currentLang}`);
                
                // Forcer le chargement des traductions si ce n'est pas le français
                if (currentLang !== 'fr') {
                    await window.i18n.loadLanguage(currentLang);
                    console.log(`🌍 Traductions ${currentLang} chargées`);
                }
            } else {
                console.warn('⚠️ Module i18n non disponible, utilisation du français par défaut');
                currentLang = 'fr';
            }

            // Initialiser les tableaux de briques
            if (JOUR.length === 0 || NUIT.length === 0) {
                initializeBrickArrays();
            }

            // 💾 Chargement automatique de la sauvegarde (si existe)
            // ✅ SIMPLIFICATION: Pas de confirmation - charge directement
            if (hasSavedGame) {
                const saveInfo = GameSaveSystem.getSaveInfo();
                if (saveInfo && saveInfo.hasSave) {
                    console.log('💾 Sauvegarde détectée - Chargement automatique...', saveInfo);
                    
                    // Charger automatiquement
                    const gameState = GameSaveSystem.load();
                    if (gameState) {
                        GameSaveSystem.restore(gameState);
                        console.log(`✅ Partie restaurée automatiquement (Phase ${saveInfo.phase})`);
                    } else {
                        // Sauvegarde corrompue → Démarrage normal
                        console.warn('⚠️ Sauvegarde invalide - Démarrage normal');
                        window.isRestoringGame = false;
                        window.narrationStarted = false;
                        window.skipNarrationIntro = false;
                        window.skipIntroAnimation = false; // ✅ Reset du flag
                        
                        // Timer automatique supprimé - Musique démarrera au premier clic
                        console.log('🎵 Mode manuel activé - La musique démarrera au premier clic utilisateur');
                    }
                } else {
                    // Pas de sauvegarde valide → Démarrage normal
                    console.log('ℹ️ Pas de sauvegarde valide - Démarrage normal');
                    window.isRestoringGame = false;
                    window.narrationStarted = false;
                    window.skipNarrationIntro = false;
                    window.skipIntroAnimation = false; // ✅ Reset du flag
                    
                    // Timer automatique supprimé - Musique démarrera au premier clic
                    console.log('🎵 Mode manuel activé - La musique démarrera au premier clic utilisateur');
                }
            }

            // ✅ NOTE: Pour effacer la sauvegarde, l'utilisateur peut vider le cache du navigateur
            // Ou utiliser la console: GameSaveSystem.clear()

            // Attente pour s'assurer que tout est initialisé
            setTimeout(() => {
                console.log('🎮 Démarrage de la boucle de jeu');
                boucleJeu();
            }, 500);
        });
    </script>

<!-- PWA Service Worker -->
<script>
    // Enregistrement du Service Worker pour PWA
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then(registration => {
                    console.log('✅ Service Worker enregistré:', registration.scope);
                    
                    // Vérifier les mises à jour
                    registration.addEventListener('updatefound', () => {
                        console.log('🔄 Mise à jour disponible');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // Charger les notes de version depuis VERSION.json
                                fetch('./VERSION.json')
                                    .then(res => res.json())
                                    .then(async versionData => {
                                        const version = versionData.version;
                                        const changelog = versionData.changelog[version];
                                        
                                        // Message avec notes de version (traduit)
                                        let updateMessage = `🎮 ${changelog.title}\n\n`;
                                        updateMessage += `📦 Version ${version}\n`;
                                        updateMessage += `📅 ${changelog.date}\n\n`;
                                        updateMessage += changelog.changes.slice(0, 5).join('\n');
                                        if (changelog.changes.length > 5) {
                                            const moreText = getTranslatedText('update.and_more_improvements', 'et {count} autres améliorations')
                                                .replace('{count}', changelog.changes.length - 5);
                                            updateMessage += `\n... ${moreText}`;
                                        }
                                        const questionText = getTranslatedText('update.update_now_question', 'Voulez-vous mettre à jour maintenant ?');
                                        updateMessage += `\n\n${questionText}`;
                                        
                                        if (await customConfirm(updateMessage)) {
                                            newWorker.postMessage({type: 'SKIP_WAITING'});
                                            window.location.reload();
                                        } else {
                                            // Afficher un bouton de mise à jour dans le jeu
                                            showUpdateBanner(version, changelog);
                                        }
                                    })
                                    .catch(async () => {
                                        // Fallback si VERSION.json non disponible (traduit)
                                        const newVersionText = getTranslatedText('update.new_version_available', '🎨 Nouvelle version disponible !');
                                        const questionText = getTranslatedText('update.update_now_question', 'Voulez-vous mettre à jour maintenant ?');
                                        const updateMessage = `${newVersionText}\n\n${questionText}`;
                                        
                                        if (await customConfirm(updateMessage)) {
                                            newWorker.postMessage({type: 'SKIP_WAITING'});
                                            window.location.reload();
                                        } else {
                                            showUpdateBanner();
                                        }
                                    });
                            }
                        });
                    });
                })
                .catch(error => {
                    console.log('❌ Erreur Service Worker:', error);
                });
        });

        // Écouter les changements de contrôleur
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            window.location.reload();
        });
    }

    // Gérer l'événement beforeinstallprompt pour personnaliser l'installation
    let deferredPrompt;

    // Écouter les changements de langue pour mettre à jour l'affichage
    window.addEventListener('languageChanged', (event) => {
        console.log('🌍 Langue changée vers:', event.detail.language);
        // L'affichage sera automatiquement mis à jour au prochain render du menu
        
        // Mettre à jour le texte du bouton d'installation
        updateInstallButtonText();
    });
    
    // Fonction pour mettre à jour le texte du bouton selon la langue
    function updateInstallButtonText() {
        const installBtn = document.getElementById('install-button');
        if (!installBtn) return;
        
        const getTranslatedText = window.getTranslatedText || ((key, fallback) => fallback);
        const btnText = getTranslatedText('ui.install_app', 'Installer l\'app');
        installBtn.textContent = btnText;
    }
    
    // Attacher l'event listener au bouton d'installation
    window.addEventListener('DOMContentLoaded', () => {
        const installBtn = document.getElementById('install-button');
        if (installBtn) {
            installBtn.addEventListener('click', installPWA);
            console.log('📥 Bouton d\'installation PWA initialisé');
        } else {
            console.warn('⚠️ Bouton d\'installation PWA non trouvé dans le DOM');
        }
    });
    
    window.addEventListener('beforeinstallprompt', (e) => {
        console.log('🔧 PWA installable détectée');
        e.preventDefault();
        deferredPrompt = e;
        
        // Afficher le bouton d'installation
        const installBtn = document.getElementById('install-button');
        if (installBtn) {
            installBtn.style.display = 'block';
            updateInstallButtonText();
        }
    });

    // Détecter si l'app est installée
    window.addEventListener('appinstalled', (evt) => {
        console.log('🎉 PWA installée avec succès');
        deferredPrompt = null;
        
        // Masquer le bouton d'installation
        const installBtn = document.getElementById('install-button');
        if (installBtn) {
            installBtn.style.display = 'none';
        }
    });

    // Fonction pour déclencher l'installation
    async function installPWA() {
        if (!deferredPrompt) {
            console.log('⚠️ Prompt d\'installation non disponible');
            
            // Si déjà installée ou pas supporté, afficher un message
            const getTranslatedText = window.getTranslatedText || ((key, fallback) => fallback);
            const message = getTranslatedText('ui.already_installed', 'L\'application est déjà installée ou votre navigateur ne supporte pas l\'installation.');
            
            if (typeof afficherMessagePowerupSimple === 'function') {
                afficherMessagePowerupSimple(message);
            } else {
                await customAlert(message);
            }
            return;
        }
        
        // Afficher le prompt natif
        deferredPrompt.prompt();
        
        // Attendre la réponse de l'utilisateur
        deferredPrompt.userChoice.then((result) => {
            const getTranslatedText = window.getTranslatedText || ((key, fallback) => fallback);
            
            if (result.outcome === 'accepted') {
                console.log('✅ Utilisateur a accepté l\'installation');
                const successMsg = getTranslatedText('ui.install_success', '🎉 Application installée avec succès !');
                
                if (typeof afficherMessagePowerupSimple === 'function') {
                    afficherMessagePowerupSimple(successMsg);
                }
                
                // Masquer le bouton
                const installBtn = document.getElementById('install-button');
                if (installBtn) {
                    installBtn.style.display = 'none';
                }
            } else {
                console.log('❌ Utilisateur a refusé l\'installation');
            }
            
            deferredPrompt = null;
        });
    }

    // Fonction pour afficher un banner de mise à jour
    function showUpdateBanner(version, changelog) {
        const banner = document.createElement('div');
        banner.id = 'update-banner';
        banner.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(45deg, #4169E1, #1E90FF);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            animation: slideDown 0.5s ease-out;
        `;
        
        // Message avec détails de version si disponibles
        let message = version && changelog 
            ? `🎮 ${changelog.title} - v${version} disponible !`
            : '🎨 Nouvelle version disponible !';
        
        banner.innerHTML = `
            ${message}
            <button onclick="updateApp()" style="
                background: white; 
                color: #4169E1; 
                border: none; 
                padding: 8px 16px; 
                margin-left: 15px; 
                border-radius: 20px; 
                font-weight: bold; 
                cursor: pointer;
            ">Mettre à jour</button>
            <button onclick="hideUpdateBanner()" style="
                background: transparent; 
                color: white; 
                border: 1px solid white; 
                padding: 8px 16px; 
                margin-left: 10px; 
                border-radius: 20px; 
                cursor: pointer;
            ">Plus tard</button>
        `;
        
        // Ajouter animation CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateY(-100%); }
                to { transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(banner);
    }

    function updateApp() {
        window.location.reload();
    }

    function hideUpdateBanner() {
        const banner = document.getElementById('update-banner');
        if (banner) {
            banner.style.animation = 'slideDown 0.5s ease-out reverse';
            setTimeout(() => banner.remove(), 500);
        }
    }
</script>

</body></html>
