<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßä Sons d'Impacts & Effets</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .subtitle {
            color: rgba(255,255,255,0.9);
            margin-bottom: 30px;
            text-align: center;
        }

        .controls {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-control input {
            width: 150px;
        }

        .categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            width: 100%;
            max-width: 1200px;
        }

        .category {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .category h2 {
            margin-top: 0;
            color: #667eea;
            font-size: 1.3em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .sound-btn {
            width: 100%;
            padding: 12px 20px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .sound-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .sound-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <h1>üßä Sons d'Impacts & Effets</h1>
    <p class="subtitle">Toc, glace, pfff et autres sons d'impact</p>

    <div class="controls">
        <div class="volume-control">
            <label for="volume">üîä Volume:</label>
            <input type="range" id="volume" min="0" max="100" value="70">
            <span id="volumeValue">70%</span>
        </div>
    </div>

    <div class="categories">
        <div class="category">
            <h2>üö™ Toc Toc - Variations</h2>
            <button class="sound-btn" onclick="playTocBois()">ü™µ Toc Bois Sec</button>
            <button class="sound-btn" onclick="playTocCreux()">ü•Å Toc Creux</button>
            <button class="sound-btn" onclick="playTocMetal()">üî© Toc M√©tal</button>
            <button class="sound-btn" onclick="playTocDouble()">üëä Toc-Toc Double</button>
        </div>

        <div class="category">
            <h2>üßä Glace - Craquements</h2>
            <button class="sound-btn" onclick="playGlaceCrack()">‚ùÑÔ∏è Craquement Glace</button>
            <button class="sound-btn" onclick="playGlaceBrise()">üíé Glace Bris√©e</button>
            <button class="sound-btn" onclick="playGlaceFissure()">‚ö° Fissure Progressive</button>
            <button class="sound-btn" onclick="playGlaceEclat()">‚ú® √âclats de Glace</button>
        </div>

        <div class="category">
            <h2>üí® Pfff - Souffles</h2>
            <button class="sound-btn" onclick="playPfffCourt()">üí® Pfff Court</button>
            <button class="sound-btn" onclick="playPfffLong()">üå¨Ô∏è Pfff Long</button>
            <button class="sound-btn" onclick="playPfffDeception()">üòÆ‚Äçüí® Pfff D√©ception</button>
            <button class="sound-btn" onclick="playPfffEpuise()">üò§ Pfff √âpuis√©</button>
        </div>

        <div class="category">
            <h2>‚ö° Impacts Divers</h2>
            <button class="sound-btn" onclick="playClac()">üëè Clac!</button>
            <button class="sound-btn" onclick="playPaf()">üí• Paf!</button>
            <button class="sound-btn" onclick="playPouf()">‚òÅÔ∏è Pouf!</button>
            <button class="sound-btn" onclick="playDing()">üîî Ding!</button>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let masterVolume = 0.7;

        // Mise √† jour du volume
        document.getElementById('volume').addEventListener('input', (e) => {
            masterVolume = e.target.value / 100;
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });

        // ===== TOC TOC VARIATIONS =====

        function playTocBois() {
            // Toc sur bois sec - 2 coups rapides
            for (let i = 0; i < 2; i++) {
                setTimeout(() => {
                    const noise = audioCtx.createBufferSource();
                    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let j = 0; j < buffer.length; j++) {
                        const t = j / buffer.length;
                        const envelope = Math.exp(-t * 25);
                        data[j] = (Math.random() * 2 - 1) * envelope;
                    }

                    noise.buffer = buffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 800;
                    filter.Q.value = 8;

                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(masterVolume * 0.4, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);

                    noise.start();
                }, i * 150);
            }
        }

        function playTocCreux() {
            // Toc sur surface creuse - r√©sonne
            for (let i = 0; i < 2; i++) {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.frequency.setValueAtTime(250, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.3);

                    gain.gain.setValueAtTime(masterVolume * 0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.3);
                }, i * 200);
            }
        }

        function playTocMetal() {
            // Toc m√©tallique avec harmoniques
            for (let i = 0; i < 2; i++) {
                setTimeout(() => {
                    [1, 2.3, 3.7, 5.1].forEach((mult, idx) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();

                        osc.frequency.value = 1200 * mult;

                        gain.gain.setValueAtTime(masterVolume * (0.25 / (idx + 1)), audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);

                        osc.connect(gain);
                        gain.connect(audioCtx.destination);

                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.2);
                    });
                }, i * 180);
            }
        }

        function playTocDouble() {
            // Double toc rapide type "toc-toc"
            const timings = [0, 80];

            timings.forEach(delay => {
                setTimeout(() => {
                    const noise = audioCtx.createBufferSource();
                    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.06, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / buffer.length;
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 30);
                    }

                    noise.buffer = buffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 600;
                    filter.Q.value = 10;

                    const gain = audioCtx.createGain();
                    gain.gain.value = masterVolume * 0.35;

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);

                    noise.start();
                }, delay);
            });
        }

        // ===== GLACE CRAQUEMENTS =====

        function playGlaceCrack() {
            // Craquement de glace - mont√©e puis cassure
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(1500, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(2000, audioCtx.currentTime + 0.05);
            osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.15);

            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(masterVolume * 0.3, audioCtx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }

        function playGlaceBrise() {
            // Glace qui se brise - plusieurs craquements
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    const freq = 1200 + Math.random() * 800;
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, audioCtx.currentTime + 0.1);

                    gain.gain.setValueAtTime(masterVolume * 0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                }, i * 40);
            }
        }

        function playGlaceFissure() {
            // Fissure progressive - 3 craquements de plus en plus forts
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const noise = audioCtx.createBufferSource();
                    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let j = 0; j < buffer.length; j++) {
                        const t = j / buffer.length;
                        data[j] = (Math.random() * 2 - 1) * (1 - t) * (i + 1) / 3;
                    }

                    noise.buffer = buffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1500 - (i * 200);

                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(masterVolume * (0.15 + i * 0.1), audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);

                    noise.start();
                }, i * 200);
            }
        }

        function playGlaceEclat() {
            // √âclats de glace qui tombent - sons cristallins
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    const freq = 2000 + Math.random() * 1500;
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, audioCtx.currentTime);
                    gain.gain.linearRampToValueAtTime(masterVolume * 0.12, audioCtx.currentTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }, i * 60);
            }
        }

        // ===== PFFF SOUFFLES =====

        function playPfffCourt() {
            // Pfff court - expiration rapide
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / buffer.length;
                const envelope = Math.exp(-t * 8);
                data[i] = (Math.random() * 2 - 1) * envelope * 0.4;
            }

            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, audioCtx.currentTime);
            filter.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.3);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(masterVolume * 0.3, audioCtx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }

        function playPfffLong() {
            // Pfff long - expiration prolong√©e
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.2, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / buffer.length;
                const envelope = Math.exp(-t * 3);
                data[i] = (Math.random() * 2 - 1) * envelope * 0.35;
            }

            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(600, audioCtx.currentTime);
            filter.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 1.2);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(masterVolume * 0.25, audioCtx.currentTime + 0.1);
            gain.gain.linearRampToValueAtTime(masterVolume * 0.2, audioCtx.currentTime + 0.8);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }

        function playPfffDeception() {
            // Pfff de d√©ception - avec descente tonale
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.6, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / buffer.length;
                const envelope = Math.sin(t * Math.PI);
                data[i] = (Math.random() * 2 - 1) * envelope * 0.3;
            }

            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(700, audioCtx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.6);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(masterVolume * 0.28, audioCtx.currentTime + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();

            // Tonalit√© descendante pour l'effet "d√©ception"
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();

            osc.frequency.setValueAtTime(300, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.6);

            oscGain.gain.setValueAtTime(0, audioCtx.currentTime);
            oscGain.gain.linearRampToValueAtTime(masterVolume * 0.08, audioCtx.currentTime + 0.1);
            oscGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);

            osc.connect(oscGain);
            oscGain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.6);
        }

        function playPfffEpuise() {
            // Pfff √©puis√© - saccad√©
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const noise = audioCtx.createBufferSource();
                    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let j = 0; j < buffer.length; j++) {
                        data[j] = (Math.random() * 2 - 1) * 0.3;
                    }

                    noise.buffer = buffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400 - (i * 80);

                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(masterVolume * (0.25 - i * 0.05), audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioCtx.destination);

                    noise.start();
                }, i * 200);
            }
        }

        // ===== IMPACTS DIVERS =====

        function playClac() {
            // Clac - claquement sec
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / buffer.length;
                data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40);
            }

            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1500;
            filter.Q.value = 15;

            const gain = audioCtx.createGain();
            gain.gain.value = masterVolume * 0.4;

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }

        function playPaf() {
            // Paf - impact avec basse
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);

            gain.gain.setValueAtTime(masterVolume * 0.35, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);

            // Partie haute de l'impact
            const noise = audioCtx.createBufferSource();
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);

            for (let i = 0; i < noiseBuffer.length; i++) {
                const t = i / noiseBuffer.length;
                noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 30);
            }

            noise.buffer = noiseBuffer;

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 800;

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.value = masterVolume * 0.25;

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noise.start();
        }

        function playPouf() {
            // Pouf - doux et amorti
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.25, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / buffer.length;
                const envelope = Math.sin(t * Math.PI) * Math.exp(-t * 3);
                data[i] = (Math.random() * 2 - 1) * envelope * 0.4;
            }

            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300;

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(masterVolume * 0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start();
        }

        function playDing() {
            // Ding - cloche courte
            [1, 2, 3].forEach((mult, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.frequency.value = 1800 * mult;

                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(masterVolume * (0.3 / mult), audioCtx.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (0.4 / mult));

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + (0.4 / mult));
            });
        }
    </script>
</body>
</html>
