<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üëÅÔ∏è Voir la V√©rit√© üëÅÔ∏è</title>
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(255,255,255,0.98), rgba(250,251,252,0.96));
            backdrop-filter: blur(30px); -webkit-backdrop-filter: blur(30px);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 20px; padding: 25px 30px;
            box-shadow:
                0 30px 60px rgba(0,0,0,0.2),
                0 0 0 1px rgba(255,255,255,0.3),
                inset 0 2px 0 rgba(255,255,255,0.9);
            max-width: calc(100% - 20px); width: 95%; text-align: center; z-index: 200;
            display: none; font-size: clamp(14px, 3.5vw, 16px); color: #1a202c;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
        }

        /* Messages narratifs - style cin√©matique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: linear-gradient(145deg, rgba(0,0,0,0.3), rgba(20,20,20,0.25));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: 420px; width: auto;
                font-size: clamp(14px, 1.8vw, 16px);
                padding: 20px 25px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="message" class="message"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            return { width, height };
        }

        let size = setupCanvas();
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: Math.max(Math.min(size.width, size.height) * 0.002, 1.5)
        };

        // Voyage de d√©couverte de la v√©rit√© - Chapitre 1 : La Lumi√®re
        const CHAPITRE1 = [
            { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: 'üó£Ô∏è Les manipulations s\'effacent devant la v√©rit√© !' },
            { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Non... des humains comme nous !' },
            { nom: 'PR√âJUG√âS', couleur: '#DDA0DD', msg: 'üé≠ Les masques tombent un √† un...' },
            { nom: 'PEURS', couleur: '#98FB98', msg: 'üëÅÔ∏è J\'ai choisi de voir par moi-m√™me !' },
            { nom: 'M√âFIANCE', couleur: '#FFCCCB', msg: 'ü§ù La m√©fiance c√®de √† la compation...' },
            { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '‚ùì Cette question hante mes nuits...' },
            { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: 'üëÅÔ∏è Et mes yeux se sont ouverts...' },
            { nom: 'UN P√àRE', couleur: '#FFDAB9', msg: 'üë® Un homme qui aime ses enfants...' },
            { nom: 'UNE M√àRE', couleur: '#AFEEEE', msg: 'üë© Une femme courageuse...' },
            { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: 'üë∂ Des rires purs et innocents...' },
            { nom: 'L\'HUMANIT√â', couleur: '#FFE4E1', msg: 'üí´ L\'essence m√™me de ce que nous sommes...' },
            { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '‚ù§Ô∏è Plus fort que toutes les barri√®res...' },
            { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: 'ü§ó Qui unit au-del√† des diff√©rences...' },
            { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: 'üåÖ Une lumi√®re dans l\'obscurit√©...' },
            { nom: 'LA PAIX', couleur: '#F5F5DC', msg: 'üïäÔ∏è Possible quand on choisis d\'aimer...' },
            { nom: 'COMME MOI', couleur: '#FFFACD', msg: 'üåç On est tous des immigr√©s...' }
        ];

        // Chapitre 2 : L'Obscurit√© - Les maux qui tentent de corrompre
        const CHAPITRE2 = [
            { nom: 'DISCORD', couleur: '#8B0000', msg: '‚ö° On m\'a dit de ne pas les √©couter...' },
            { nom: 'HAINE', couleur: '#4B0000', msg: 'üå©Ô∏è Ne pas laisser l\'orage me faire peur...' },
            { nom: 'DESTRUCTION', couleur: '#2F1B14', msg: 'ü¶à Mais les requins rodent dans les eaux sombres...' },
            { nom: 'MENSONGE', couleur: '#36454F', msg: '‚õàÔ∏è Les mensonges √©clatent comme la foudre...' },
            { nom: 'MANIPULATION', couleur: '#2F2F2F', msg: 'üï∑Ô∏è Les fils invisibles tirent les c≈ìurs...' },
            { nom: 'CUPIDIT√â', couleur: '#654321', msg: 'üí∞ L\'or ternit m√™me la plus pure lumi√®re...' },
            { nom: 'AVIDIT√â', couleur: '#483C32', msg: 'üï≥Ô∏è L\'avidit√© d√©vore tout sur son passage...' },
            { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: 'üíö Le poison vert de l\'envie...' },
            { nom: 'ORGUEIL', couleur: '#191970', msg: 'üëë La couronne qui aveugle...' },
            { nom: 'COL√àRE', couleur: '#8B1538', msg: 'üî• Les flammes qui consument la raison...' },
            { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '‚öîÔ∏è La spirale sans fin de la souffrance...' },
            { nom: 'INDIFF√âRENCE', couleur: '#708090', msg: 'üßä Le froid qui glace les √¢mes...' },
            { nom: '√âGO√èSME', couleur: '#5D5D5D', msg: 'ü™û Ne voir que son propre reflet...' },
            { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: 'üôà Choisir de fermer les yeux...' },
            { nom: 'R√âSISTANCE', couleur: '#1C1C1C', msg: 'üõ°Ô∏è Mais je garde mon c≈ìur pur dans la temp√™te...' },
            { nom: 'LUMI√àRE', couleur: '#483D8B', msg: '‚ú® Car au-del√† des nuages, elle existe toujours...' }
        ];

        // Voyage actuel selon le chapitre
        let VOYAGE = CHAPITRE1;

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.03,
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au d√©but - les drones restent hors √©cran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors √©cran √† gauche
                        -100, // Commencer hors √©cran en haut
                        i
                    ));
                }
            }

            setFormation(formation) {
                this.currentFormation = formation;
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                this.drones.forEach(drone => {
                    drone.firework();
                });

                setTimeout(() => {
                    this.createDrones();
                    this.setFormation(this.currentFormation);
                }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const starRadius = (i % 2 === 0) ? size : size * 0.6;
                            positions.push({
                                x: centerX + Math.cos(angle) * starRadius,
                                y: centerY + Math.sin(angle) * starRadius
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // Animation s√©par√©e pour mise √† jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options);
                });
            }

            render() {
                // Rendu s√©par√© √† appeler depuis la boucle de jeu
                this.drones.forEach(drone => {
                    drone.draw(this.ctx, this.options);
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options) {
                if (this.inExplosion) {
                    this.x += this.explosionVelX;
                    this.y += this.explosionVelY;
                    this.explosionVelY += 0.3;
                    this.life -= 0.015;
                    if (this.life <= 0) this.life = 0;
                } else {
                    this.x += (this.targetX - this.x) * options.speed;
                    this.y += (this.targetY - this.y) * options.speed;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) this.trail.shift();
                }

                this.brightness = 0.6 + Math.sin(Date.now() * 0.008 + this.id) * 0.2;
            }

            draw(ctx, options) {
                if (this.life <= 0) return;

                if (options.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color + '60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                const glowSize = 8 + Math.sin(Date.now() * 0.004 + this.id) * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, this.color + Math.floor(this.brightness * this.life * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(0.8, this.color + '30');
                gradient.addColorStop(1, this.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapt√© pour int√©gration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.animationState = {
                    isRunning: false,
                    currentIndex: 0,
                    timeoutId: null,
                    text: '',
                    speed: 50,
                    onComplete: null
                };
            }

            // Animation machine √† √©crire
            typewriter(element, text, speed = 50, onComplete = null) {
                this.reset();
                this.animationState.text = text;
                this.animationState.speed = speed;
                this.animationState.onComplete = onComplete;
                this.animationState.isRunning = true;

                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';

                const animate = () => {
                    if (this.animationState.currentIndex < this.animationState.text.length) {
                        element.innerHTML += this.animationState.text.charAt(this.animationState.currentIndex);
                        this.animationState.currentIndex++;
                        this.animationState.timeoutId = setTimeout(animate, this.animationState.speed);
                    } else {
                        element.style.borderRight = 'none';
                        this.animationState.isRunning = false;
                        if (this.animationState.onComplete) {
                            this.animationState.onComplete();
                        }
                    }
                };

                animate();
            }

            // Animation style digital/matrix
            digital(element, text, speed = 30, onComplete = null) {
                this.reset();
                this.animationState.text = text;
                this.animationState.speed = speed;
                this.animationState.onComplete = onComplete;
                this.animationState.isRunning = true;

                element.innerHTML = '';
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                element.style.fontFamily = 'Courier New, monospace';

                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\|~^&%$#@!?';

                const animate = () => {
                    if (this.animationState.currentIndex < this.animationState.text.length) {
                        let displayText = this.animationState.text.substring(0, this.animationState.currentIndex);
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));

                        element.innerHTML = displayText;

                        setTimeout(() => {
                            this.animationState.currentIndex++;
                            if (this.animationState.currentIndex < this.animationState.text.length) {
                                this.animationState.timeoutId = setTimeout(animate, this.animationState.speed);
                            } else {
                                element.innerHTML = this.animationState.text;
                                this.animationState.isRunning = false;
                                if (this.animationState.onComplete) {
                                    this.animationState.onComplete();
                                }
                            }
                        }, this.animationState.speed / 2);
                    }
                };

                animate();
            }

            // Animation fade in
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                this.animationState.onComplete = onComplete;
                this.animationState.isRunning = true;

                element.innerHTML = text;
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 10);

                setTimeout(() => {
                    this.animationState.isRunning = false;
                    if (this.animationState.onComplete) {
                        this.animationState.onComplete();
                    }
                }, duration);
            }

            // Animation glitch
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();
                this.animationState.onComplete = onComplete;
                this.animationState.isRunning = true;

                element.innerHTML = text;
                element.style.position = 'relative';
                element.style.animation = 'glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas d√©j√† pr√©sentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.style.animation = 'none';
                    element.style.textShadow = 'none';
                    element.style.transform = 'none';
                    this.animationState.isRunning = false;
                    if (this.animationState.onComplete) {
                        this.animationState.onComplete();
                    }
                }, duration);
            }

            // Arr√™ter l'animation en cours
            stop() {
                if (this.animationState.timeoutId) {
                    clearTimeout(this.animationState.timeoutId);
                }
                this.animationState.isRunning = false;
            }

            // Reset
            reset() {
                this.stop();
                this.animationState.currentIndex = 0;
                this.animationState.text = '';
                this.animationState.onComplete = null;
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.animationState.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;
        let raquette = {}, balle = {}, briques = [], particules = [];
        let starsProjectiles = []; // Projectiles √©toiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles √©toiles (phase briques) - commence √† 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let coeursBateau = []; // C≈ìurs lanc√©s par le bateau
        let derniereCreeRafale = 0; // Temps de la derni√®re rafale
        let petitsCoeurs = []; // Petits c≈ìurs d√©coratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause apr√®s explosion
        let textesVolants = []; // Textes qui montent au ciel
        let corbeau = { actif: false, x: 0, y: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000 }; // Corbeau secret (10s pour test)
        let soleil = { clignotement: false, tempsClignotement: 0 }; // √âtat du soleil
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition
        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let modeNarration = true; // Mode narration actif au d√©but
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Syst√®me de messages narratifs
        let chapitre = 1; // Chapitre actuel
        let transitionChapitre = { active: false, progression: 0 };
        let phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: 0 }; // Phase d'introduction
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de c≈ìurs vers les petits c≈ìurs du haut (phase d'√©veil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'√©toiles vers les briques en mode nuit (phase de r√©v√©lation)
         * 4. 'feux_artifice' : C√©l√©bration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: true,
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: 0,
            dureeArret: 20000 // 20 secondes d'arr√™t
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.0006, 0.4); // Vitesse r√©duite 10x

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 8,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors √©cran √† gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = Date.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            munitions = 0; // Commencer sans munitions en phase stars
            rechargement = 0;

            briques = [];

            // Cr√©er les briques si on est en phase stars (nuit) - FORC√â
            if(phaseJeu === 'stars') {
                // FORCER l'arr√™t de tous les syst√®mes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                etapeIntro = 3;

                // FORCER la cr√©ation des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Cr√©er
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les c≈ìurs
            const zoneW = C.W - 40;

            // Positions dispers√©es et tailles diff√©rentes pour chaque c≈ìur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront cr√©√©es √† partir des petits c≈ìurs du haut
            // Initialisation vide, elles appara√Ætront lors du d√©doublement des c≈ìurs
            briques = [];
            particules = [];
            powerUps = [];
            lanterne = { active: false, intensite: 0 }; // Lanterne √©teinte par d√©faut
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propri√©t√©s selon la phase
            if(phaseJeu === 'lanterne') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au d√©but
                    dy: 0, // Immobile au d√©but
                    visible: true, // Visible en phase lanterne
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles √©toiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Cr√©er les 10 petits c≈ìurs d√©coratifs en haut (cach√©s pendant l'animation)
            creerPetitsCoeurs();

            // Cacher les c≈ìurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'√©toile principale - utiliser les projectiles stars

            // R√©initialiser la phase d'intro (d√©sactiv√©e pendant l'animation du bateau)
            phaseIntro = { active: false, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (!animationBateau.active) return;

            const tempsActuel = Date.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arriv√©e depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arriv√©e fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arriv√© au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // D√©clencher l'affichage du premier message
                        etapeIntro = 0;
                        afficherEtapeIntro();
                    }
                    break;

                case 'arret':
                    // Bateau arr√™t√©, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de d√©part vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'√©cran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation termin√©e, d√©marrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        etapeIntro = 3; // Phase de jeu

                        // Repositionner le bateau normalement et d√©marrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;
                        jeu = true; // Activer le jeu
                        phaseJeu = 'tir_coeurs_haut'; // Commencer par la premi√®re phase

                        // R√©v√©ler les petits c≈ìurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre √† jour l'√©toile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            if (!phaseIntro.active || animationBateau.active) return; // D√©sactiv√© pendant l'animation du bateau

            const tempsEcoule = Date.now() - phaseIntro.tempsDebut;

            if (phaseIntro.etape === 'rafales') {
                // Phase 1: Attendre 2 secondes puis passer au jeu
                if (tempsEcoule >= 2000) {
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                if (tempsEcoule >= 1000) {
                    phaseIntro.active = false;
                    jeu = true; // D√©marrer le jeu
                    phaseJeu = 'tir_coeurs_haut'; // Commencer par tirer sur les c≈ìurs du haut
                    afficherMessage('‚ú® PHASE 1 : √âVEIL DE LA CONNAISSANCE ‚ú®<br><br>üå∏ Envoie des vagues d\'amour vers les c≈ìurs du haut !<br>üß† √âveille ta connaissance int√©rieure !<br><br>üëÜ Clique pour lib√©rer des vagues de compassion !', 4000);
                }
            }
        }

        // Interface int√©gr√©e compl√®te
        function dessinerInterface() {
            ctx.save();

            // Header avec gradient
            const headerH = Math.max(C.H * 0.12, 60);
            const grad = ctx.createLinearGradient(0, 0, 0, headerH);
            grad.addColorStop(0, 'rgba(255,255,255,0.95)');
            grad.addColorStop(1, 'rgba(248,250,255,0.8)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, headerH);

            // Bordure header
            ctx.strokeStyle = 'rgba(102,126,234,0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre principal
            ctx.fillStyle = '#2c3e50';
            ctx.font = `800 ${Math.max(C.H * 0.025, 16)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('üëÅÔ∏è VOIR LA V√âRIT√â üëÅÔ∏è', C.W/2, Math.max(C.H * 0.035, 22));

            // Citation inspirante
            ctx.fillStyle = '#7f8c8d';
            ctx.font = `italic ${Math.max(C.H * 0.018, 11)}px sans-serif`;
            ctx.fillText('"J\'ai pr√©f√©r√© voir de mes propres yeux"', C.W/2, Math.max(C.H * 0.055, 35));

            // Stats ligne
            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points de connaissance
            ctx.textAlign = 'left';
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`üß† Connaissance: ${pointsConnaissance}`, 15, Math.max(C.H * 0.085, 52));
            } else {
                ctx.fillText(`üïäÔ∏è ${score}`, 15, Math.max(C.H * 0.085, 52));
            }

            // Progression
            ctx.textAlign = 'center';
            ctx.fillText(`üß± ${brises}/${VOYAGE.length}`, C.W/2, Math.max(C.H * 0.085, 52));

            // Vies
            ctx.textAlign = 'right';
            const coeurs = vies > 0 ? '‚ù§Ô∏è'.repeat(vies) : 'üíî';
            ctx.fillText(coeurs, C.W - 15, Math.max(C.H * 0.085, 52));

            // Affichage des commandes mode passe (en bas √† droite)
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                'üîë MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir √©toiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();

            ctx.restore();
        }

        // Tirer un projectile √©toile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars ET feux_artifice
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation √©toile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de d√©placement pour la tra√Æn√©e
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Tra√Æn√©e d'√©toile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // Gradient de la tra√Æn√©e
                const gradientTrainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                gradientTrainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                gradientTrainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradientTrainee.addColorStop(1, projectile.couleur || '#FFD700');

                // Dessiner la tra√Æn√©e
                ctx.fillStyle = gradientTrainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'√©toile elle-m√™me
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // √âtoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // Halo lumineux
                    const gradientHalo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                    gradientHalo.addColorStop(0, projectile.couleur || '#FFD700');
                    gradientHalo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradientHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = gradientHalo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // √âtoile centrale brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, projectile.couleur || '#FFD700');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0.8)');

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // √âtoile √† 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre √† jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {
                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                                    // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // D√©sactiv√© : Ancien syst√®me de fin simple - remplac√© par la s√©quence compl√®te
                                    // if(brises >= VOYAGE.length) { ... }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // Collision avec les petits c≈ìurs
                petitsCoeurs.forEach((petitCoeur, j) => {
                    if(!petitCoeur.visible) return;

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // C≈ìur touch√© !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                        const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                        if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                            // Passer √† la phase suivante (seulement si on √©tait en phase tir_coeurs_haut)
                            setTimeout(() => {
                                phaseJeu = 'lanterne';
                                dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                // R√©initialiser le jeu pour la phase lanterne
                                initJeu();
                                // Forcer la balle visible en phase lanterne et la mettre en attente
                                balle.visible = true;
                                balle.enAttente = true;
                                balle.dx = 0;
                                balle.dy = 0;
                                // Lanterne √©teinte au d√©but
                                lanterne.active = false;
                                lanterne.intensite = 0;
                                // Initialiser les briques pour la phase 2
                                dedoublerCoeursEnBriques();
                                afficherMessageAnime('üí≠ "Qui √©taient ces gens-l√† ?...<br><br>Et j\'ai vu...<br>Un p√®re... une m√®re... des enfants...<br>Tous cherchant simplement √† vivre leur meilleure vie...<br>Comme moi."<br><br>üß± PHASE 2 : CASSE-BRIQUES<br><br>üèÆ Collectez des power-ups pour allumer la lanterne !<br><br>üëÜ Cliquez pour lancer la lanterne !', 8000, 'typewriter', 60);

                                // Cr√©er quelques c≈ìurs d√©coratifs qui flottent
                                setTimeout(() => {
                                    for(let k = 0; k < 10; k++) {
                                        particules.push({
                                            x: Math.random() * C.W,
                                            y: C.H + Math.random() * 50,
                                            vx: (Math.random() - 0.5) * 2,
                                            vy: -(Math.random() * 3 + 1),
                                            couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][k % 5],
                                            vie: 1,
                                            taille: Math.random() * 4 + 3,
                                            type: 'coeur'
                                        });
                                    }

                                    afficherMessage('üíù Les c≈ìurs montent vers la lumi√®re !<br><br>‚ú® Pr√©paration de la transformation...<br><br>üß± Les briques apparaissent dans 3 secondes !', 3000);

                                    // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                    // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                }, 3000);
                            }, 1000);
                        }
                        return;
                    }
                });
            }
        }

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // Dessiner la lanterne √©teinte comme balle du jeu UNIQUEMENT pendant la phase casse-briques
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0; // Position de la balle
            const posY = balle.y || 0; // Position de la balle
            const temps = Date.now() * 0.001;

            // V√©rification de s√©curit√© pour √©viter les valeurs non finies
            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // 1. HALO DE BOUGIE SIMPLE (seulement si lanterne active)
            if(lanterne.active) {
                // Halo simple statique
                const haloSize = C.BS * 1.5;
                const haloIntensity = 0.4;

                // Halo principal simple avec v√©rification
                if (isFinite(haloSize) && haloSize > 0) {
                    const haloGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, haloSize);
                haloGrad.addColorStop(0, `rgba(255, 220, 150, ${haloIntensity})`);
                haloGrad.addColorStop(0.3, `rgba(255, 180, 100, ${haloIntensity * 0.7})`);
                haloGrad.addColorStop(0.7, `rgba(255, 140, 60, ${haloIntensity * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');

                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. LANTERNE CYLINDRIQUE CLASSIQUE

            // Dimensions de la lanterne cylindrique plus haute et plus petite
            const rayon = C.BS * 0.4;        // Rayon du cylindre (2x plus petit)
            const corpsH = C.BS * 1.2;       // Hauteur du corps cylindrique (2x plus petite)
            const domeH = C.BS * 0.1;        // Hauteur du d√¥me (2x plus petite)
            const baseH = C.BS * 0.1;        // Hauteur de la base (2x plus petite)

            // LUEUR DOUCE AUTOUR DE LA LANTERNE
            if(lanterne.active) {
                // Halo de lueur douce adapt√© √† la taille
                const lueurSize = rayon * 1.25;
                if (isFinite(rayon) && isFinite(lueurSize) && rayon > 0 && lueurSize > 0) {
                    const lueurGrad = ctx.createRadialGradient(posX, posY, rayon, posX, posY, lueurSize);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.2)');
                lueurGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
                ctx.fillStyle = lueurGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, lueurSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Armature m√©tallique de la lanterne
            const armatureColor = lanterne.active ? '#B8860B' : '#654321';
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;

            // BASE RONDE plus petite
            const baseY = posY + corpsH/2;
            ctx.fillStyle = armatureColor;
            ctx.beginPath();
            ctx.ellipse(posX, baseY, rayon * 1.05, baseH, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // CORPS CYLINDRIQUE
            const corpsTop = posY - corpsH/2;
            const corpsBottom = posY + corpsH/2;

            // Vitres cylindriques
            if(lanterne.active) {
                // Vitres dor√©es lumineuses
                if (isFinite(rayon) && rayon > 0) {
                    const vitreGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, rayon);
                    vitreGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    vitreGrad.addColorStop(0.7, 'rgba(255, 200, 0, 0.6)');
                    vitreGrad.addColorStop(1, 'rgba(255, 180, 0, 0.4)');
                    ctx.fillStyle = vitreGrad;
                } else {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                }
            } else {
                // Vitres √©teintes
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.ellipse(posX, posY, rayon, corpsH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Contour du cylindre
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Barreaux en forme de croix
            ctx.beginPath();
            // Barre verticale
            ctx.moveTo(posX, corpsTop);
            ctx.lineTo(posX, corpsBottom);
            // Barre horizontale
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // D√îME SUP√âRIEUR
            const domeTop = corpsTop - domeH;
            ctx.fillStyle = armatureColor;
            ctx.strokeStyle = '#CD7F32';
            ctx.lineWidth = 2;

            // D√¥me en forme d'ellipse plus petit
            ctx.beginPath();
            ctx.ellipse(posX, domeTop + domeH/2, rayon * 0.9, domeH/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 3. FLAMME AVEC ANIMATIONS TR√àS LENTES
            if(lanterne.active) {
                // Flamme avec mouvement tr√®s lent et doux
                const flammeX = posX + Math.sin(temps * 0.3) * 1; // Tr√®s lent
                const flammeY = posY - C.BS * 0.3;
                const flammeH = C.BS * 0.6;
                const flammeW = C.BS * 0.3;

                // Flamme principale avec danse tr√®s douce
                if (isFinite(flammeX) && isFinite(flammeY) && isFinite(flammeH) && flammeH > 0) {
                    const flammeGrad = ctx.createRadialGradient(flammeX, flammeY, 0, flammeX, flammeY, flammeH);
                flammeGrad.addColorStop(0, '#FFFF99');
                flammeGrad.addColorStop(0.3, '#FFD700');
                flammeGrad.addColorStop(0.6, '#FFA500');
                flammeGrad.addColorStop(1, '#FF6347');

                    ctx.fillStyle = flammeGrad;
                    ctx.beginPath();
                    // Forme de flamme avec variations tr√®s lentes
                    ctx.ellipse(flammeX, flammeY, flammeW * (0.6 + Math.sin(temps * 0.4) * 0.05), flammeH * (0.8 + Math.cos(temps * 0.35) * 0.05), Math.sin(temps * 0.2) * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    // C≈ìur de la flamme plus lumineux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(flammeX, flammeY, flammeW * 0.3, flammeH * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // M√®che de la bougie
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY, 2, C.BS * 0.2);
            } else {
                // M√®che √©teinte
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY - 2, 2, 4);

                // C≈ìur d'humanit√© au repos
                const coeurSize = C.BS * 0.4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(posX, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX, posY, posX - coeurSize*0.5, posY, posX - coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX - coeurSize*0.5, posY + coeurSize*0.7, posX, posY + coeurSize*0.7, posX, posY + coeurSize);
                ctx.bezierCurveTo(posX, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX + coeurSize*0.5, posY, posX, posY, posX, posY + coeurSize*0.3);
                ctx.fill();
            }

            // 4. SYST√àME DE SUSPENSION SIMPLE
            const cordeLength = C.BS * 1;
            ctx.strokeStyle = lanterne.active ? '#8B4513' : '#4a4a4a';
            ctx.lineWidth = 2;

            // Cordes depuis le d√¥me adapt√©es √† la taille
            ctx.beginPath();
            ctx.moveTo(posX - rayon*0.6, domeTop); // Gauche du d√¥me
            ctx.lineTo(posX - rayon*0.2, posY - cordeLength);
            ctx.moveTo(posX + rayon*0.6, domeTop); // Droite du d√¥me
            ctx.lineTo(posX + rayon*0.2, posY - cordeLength);
            ctx.stroke();

            // Corde centrale
            ctx.beginPath();
            ctx.moveTo(posX, domeTop); // Centre du d√¥me
            ctx.lineTo(posX, posY - cordeLength);
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau √©l√©gant g√©om√©trique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec √©trave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient bleu pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#74b9ff'); // Bleu clair
                coqueGrad.addColorStop(0.5, '#0984e3'); // Bleu moyen
                coqueGrad.addColorStop(1, '#2d3436'); // Bleu fonc√©

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');
                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Coque du bateau - forme g√©om√©trique √©l√©gante
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient rouge pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#ff6b6b');
                coqueGrad.addColorStop(0.5, '#e74c3c');
                coqueGrad.addColorStop(1, '#c0392b');

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // Vraies briques avec c≈ìurs √† l'int√©rieur pour le casse-brique
        function dessinerPrejuges() {
            briques.forEach((brique, index) => {
                if(!brique.visible) return;

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec √©tat de d√©g√¢ts
                ctx.save();

                // Couleur selon la vie restante
                let couleurBrique = couleur;
                if (brique.vieMax === 2) {
                    // Phase lanterne : 2 vies maximum
                    if (brique.vie === 1) {
                        // Brique endommag√©e (1er coup re√ßu sur 2)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.6)`;
                    }
                } else {
                    // Phase stars : 3 vies maximum
                    if (brique.vie === 2) {
                        // Brique l√©g√®rement endommag√©e (1er coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.8)`;
                    } else if (brique.vie === 1) {
                        // Brique tr√®s endommag√©e (2√®me coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.5)`;
                    }
                }

                ctx.fillStyle = couleurBrique;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                // Clignotement si r√©cemment touch√©e
                if (brique.clignotement > 0) {
                    ctx.fillStyle = '#FFFFFF';
                    brique.clignotement--;
                }

                // Rectangle de brique
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);


                // Effet 3D de brique
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.3); // Highlight du haut

                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(brique.x, brique.y + brique.h * 0.8, brique.w, brique.h * 0.2); // Ombre du bas

                // Dessiner les fissures zigzag blanches selon les d√©g√¢ts
                if ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2)) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    // Premi√®re fissure zigzag apr√®s le 1er coup
                    ctx.beginPath();
                    const startX1 = brique.x + brique.w * 0.3;
                    const endX1 = brique.x + brique.w * 0.2;
                    const segments = 4; // Nombre de segments zigzag
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX1 + (endX1 - startX1) * progress + (i % 2 === 0 ? 0 : brique.w * 0.05) * Math.sin(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                if (brique.vie <= 1) {
                    // Deuxi√®me fissure zigzag apr√®s le 2√®me coup
                    ctx.beginPath();
                    const startX2 = brique.x + brique.w * 0.7;
                    const endX2 = brique.x + brique.w * 0.8;
                    const segments = 4;
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX2 + (endX2 - startX2) * progress + (i % 2 === 1 ? 0 : brique.w * 0.04) * Math.cos(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le c≈ìur √† l'int√©rieur de la brique
                dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);

                // En phase stars (nuit), afficher les mots pour guider le joueur
                if(phaseJeu === 'stars' && brique.etape && brique.etape.nom) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Contour noir pour la lisibilit√©
                    ctx.strokeText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                    // Texte blanc par-dessus
                    ctx.fillText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                }

                // En phase lanterne, le texte reste cach√© - il n'appara√Æt que lors de l'explosion
                // Le myst√®re reste entier jusqu'√† la lib√©ration du c≈ìur !
            });
        }

        // Power-Up Bleu √âtincelant
        function creerPowerUp(x, y) {
            powerUps.push({
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: 'bug',
                temps: 0,
                etincelles: []
            });
        }

        function dessinerPowerUps() {
            powerUps.forEach(power => {
                ctx.save();

                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);

                // Cube bleu √©tincelant
                const bleuGrad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                bleuGrad.addColorStop(0, `hsl(${(power.temps * 5) % 360}, 100%, 80%)`);
                bleuGrad.addColorStop(0.5, '#00aaff');
                bleuGrad.addColorStop(1, `hsl(${(power.temps * 8) % 360}, 100%, 60%)`);

                ctx.fillStyle = bleuGrad;
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // Bordure scintillante
                ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                ctx.lineWidth = 3;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.strokeRect(power.x, power.y, power.w, power.h);
                ctx.shadowBlur = 0;

                // Ic√¥ne lanterne üèÆ
                ctx.fillStyle = '#ffffff';
                ctx.font = `${power.h * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('üèÆ', power.x + power.w/2, power.y + power.h*0.7);

                // √âtincelles autour
                for(let i = 0; i < 3; i++) {
                    const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = power.w * 0.8;
                    const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                    const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                    ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                power.temps += 1;
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Power-up pour allumer la lanterne
                    if (!lanterne.active) {
                        lanterne.active = true;
                        lanterne.intensite = 1;
                        afficherMessage('üèÆ LANTERNE ALLUM√âE ! üèÆ<br>‚ú® √âclairage magique activ√© !', 2500);
                    } else {
                        afficherMessage('üèÆ POWER-UP LANTERNE ! üèÆ<br>‚ú® La lanterne est d√©j√† allum√©e !', 2500);
                    }

                    // Explosion de particules dor√©es
                    ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 15);

                    powerUps.splice(i, 1);
                    }
                }
            }
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise √† jour pendant l'animation
            if(lanterne.active) {
                // Effet de pulsation douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);

                // Cr√©er quelques particules dor√©es occasionnellement
                if(Math.random() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Cr√©er une rafale de 1-3 c≈ìurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // √âventail 40¬∞
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // D√©part l√©g√®rement dispers√©
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, tr√®s grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // D√©lai entre chaque c≈ìur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            const tempsActuel = Date.now();

            // Plus de c≈ìurs automatiques pendant l'intro
            // Pendant le jeu normal : plus de d√©clenchement automatique
            // Les rafales se d√©clenchent seulement sur clic/touche

            // Mettre √† jour les c≈ìurs de lumi√®re
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Mont√©e rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Animation de flottement gauche-droite
                if(coeur.vitesseFlottement !== undefined) {
                    coeur.flottemment += coeur.vitesseFlottement;
                    // Ajouter un mouvement oscillant horizontal
                    coeur.x += Math.sin(coeur.flottemment) * 0.5;
                }

                // Animation de scintillement
                coeur.scintillement += 0.2;
                coeur.luminosite = 0.7 + 0.3 * Math.sin(coeur.scintillement);

                // Supprimer si sort de l'√©cran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits c≈ìurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // V√©rifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // C≈ìur touch√© !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                            // Supprimer le c≈ìur du bateau
                            coeursBateau.splice(i, 1);

                            // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // Passer √† la phase suivante (seulement si on √©tait en phase tir_coeurs_haut)
                                setTimeout(() => {
                                    phaseJeu = 'lanterne';
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // R√©initialiser le jeu pour la phase lanterne
                                    initJeu();
                                    // Forcer la balle visible en phase lanterne et la mettre en attente
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    // Lanterne √©teinte au d√©but
                                    lanterne.active = false;
                                    lanterne.intensite = 0;
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    afficherMessageAnime('üí≠ "Qui √©taient ces gens-l√† ?...<br><br>Et j\'ai vu...<br>Un p√®re... une m√®re... des enfants...<br>Tous cherchant simplement √† vivre leur meilleure vie...<br>Comme moi."<br><br>üß± PHASE 2 : CASSE-BRIQUES<br><br>üèÆ Collectez des power-ups pour allumer la lanterne !<br><br>üëÜ Cliquez pour lancer la lanterne !', 8000, 'typewriter', 60);

                                    // Cr√©er quelques c≈ìurs d√©coratifs qui flottent (diff√©rents de ceux du haut)
                                    setTimeout(() => {
                                        // Cr√©er des c≈ìurs d√©coratifs flottants au lieu de recr√©er les c≈ìurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

                                        afficherMessage('üíù Les c≈ìurs montent vers la lumi√®re !<br><br>‚ú® Pr√©paration de la transformation...<br><br>üß± Les briques apparaissent dans 3 secondes !', 3000);

                                        // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                }, 1000);
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                briques.forEach(brique => {
                    if(!brique.visible) return;

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames

                        // Supprimer le c≈ìur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // Explosion en 3 petits c≈ìurs seulement
                            for(let j = 0; j < 3; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du c≈ìur qui grossit et monte au ciel
                            ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                            // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        if(brises >= VOYAGE.length) {
                            if(phaseJeu === 'lanterne') {
                                // Passer √† la phase 3 : tir d'√©toiles nocturne !
                                phaseJeu = 'stars';
                                chapitre = 2; // Mode nuit
                                dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 2);
                                jeu = true; // Activer le jeu pour la phase stars
                                animationBateau.active = false; // FORCER L'ARR√äT DE L'ANIMATION BATEAU
                                phaseIntro.active = false; // FORCER L'ARR√äT DU SYST√àME NARRATIF
                                etapeIntro = 3; // MARQUER L'INTRO COMME TERMIN√âE

                                // D√©sactiver la lanterne et remettre √† z√©ro
                                lanterne.active = false;
                                lanterne.intensite = 0;
                                brises = 0; // R√©initialiser le compteur pour la nouvelle phase
                                starsProjectiles = []; // Nettoyer les projectiles stars de la phase pr√©c√©dente

                                // R√©initialiser le jeu pour la nouvelle phase (cela va cr√©er les briques automatiquement)
                                initJeu();

                                // Forcer la visibilit√© de la balle pour la phase stars
                                if(balle) {
                                    balle.visible = true;
                                }

                                // Forcer l'affichage des briques
                                briques.forEach(brique => {
                                    brique.visible = true;
                                });

                                afficherMessageAnime('üåü PHASE 3 : TIR D\'√âTOILES NOCTURNE üåü<br><br>‚≠ê Tire des √©toiles pour briser les derniers pr√©jug√©s !<br>üåô La nuit r√©v√®le la v√©rit√© cach√©e !<br><br>‚ú® Les √©toiles percent l\'obscurit√© !', 4000, 'digital', 50);
                            } else {
                                veriteLiberee();
                            }
                        }
                    }
                });
            }
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';

                // Forme √©toile/diamant pour les c≈ìurs du bateau
                ctx.save();
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                const t = coeur.taille;

                ctx.translate(coeur.x, coeur.y);

                // C≈ìur en polygone pour le bateau
                ctx.beginPath();

                // Lobe gauche
                ctx.moveTo(-t * 0.25, 0);
                ctx.lineTo(-t * 0.15, -t * 0.15);
                ctx.lineTo(-t * 0.05, -t * 0.1);
                ctx.lineTo(-t * 0.02, 0);

                // Lobe droit
                ctx.lineTo(t * 0.02, 0);
                ctx.lineTo(t * 0.05, -t * 0.1);
                ctx.lineTo(t * 0.15, -t * 0.15);
                ctx.lineTo(t * 0.25, 0);

                // Descente vers la pointe
                ctx.lineTo(t * 0.1, t * 0.15);
                ctx.lineTo(0, t * 0.3);
                ctx.lineTo(-t * 0.1, t * 0.15);

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            });
        }

        // Petits c≈ìurs d√©coratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Cr√©er un visage rond avec les c≈ìurs
            const centreX = C.W / 2;
            const centreY = C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.15; // Rayon du visage

            for(let i = 0; i < 40; i++) { // 40 c≈ìurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles vari√©es

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // R√©partir sur 360¬∞
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut √™tre cass√©
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une √©tape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.02,
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02
                });
            }
        }

        // G√©n√©rer des positions en forme de c≈ìur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du c≈ìur

            // G√©n√©rer des positions selon l'√©quation param√©trique d'un c≈ìur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Param√®tre de 0 √† 2œÄ

                // √âquation param√©trique d'un c≈ìur : x = 16sin¬≥(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise √† l'√©chelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits c≈ìurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les c≈ìurs r√©siduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le c≈ìur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // G√©n√©rer les positions en forme de c≈ìur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Cr√©er les briques selon la disposition en c≈ìur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: phaseJeu === 'lanterne' ? 2 : 3,     // 2 coups en phase lanterne, 3 en phase stars
                    vie: phaseJeu === 'lanterne' ? 2 : 3,        // Vie actuelle
                    clignotement: 0, // Animation quand touch√©e
                    // Animation de d√©doublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }
        }

        function libererVaguesAmour() {
            // Ne lib√©rer des vagues d'amour que si le jeu est actif
            if (!jeu || phaseIntro.active) return;

            const tempsActuel = Date.now();

            // Emp√™cher la pr√©cipitation - l'amour prend son temps
            if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : lib√©rer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : lib√©rer l'amour seulement pour la derni√®re brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        function mettreAJourPetitsCoeurs() {
            petitsCoeurs.forEach(coeur => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;
            });
        }

        // Fonction pour dessiner des c≈ìurs avec 20 triangles (pour les briques)
        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            const temps = Date.now() * 0.003;
            const pulsation = 1 + Math.sin(temps) * 0.15; // Pulsation douce

            // Appliquer la pulsation
            ctx.scale(pulsation, pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            const triangleSize = t * 0.08;

            // C≈ìur super mignon pour les briques qui pulse
            ctx.beginPath();

            // Lobe gauche (forme arrondie avec segments)
            ctx.moveTo(-t * 0.3, -t * 0.02);
            ctx.lineTo(-t * 0.22, -t * 0.18);
            ctx.lineTo(-t * 0.12, -t * 0.2);
            ctx.lineTo(-t * 0.05, -t * 0.1);
            ctx.lineTo(-t * 0.02, -t * 0.02);

            // Lobe droit (forme arrondie avec segments)
            ctx.lineTo(t * 0.02, -t * 0.02);
            ctx.lineTo(t * 0.05, -t * 0.1);
            ctx.lineTo(t * 0.12, -t * 0.2);
            ctx.lineTo(t * 0.22, -t * 0.18);
            ctx.lineTo(t * 0.3, -t * 0.02);

            // Descente vers la pointe avec courbe
            ctx.lineTo(t * 0.18, t * 0.15);
            ctx.lineTo(t * 0.08, t * 0.3);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.08, t * 0.3);
            ctx.lineTo(-t * 0.18, t * 0.15);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // D√©tails mignons - petits c≈ìurs √† l'int√©rieur
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Petit c≈ìur gauche
            ctx.beginPath();
            ctx.moveTo(-t * 0.15, -t * 0.05);
            ctx.lineTo(-t * 0.12, -t * 0.08);
            ctx.lineTo(-t * 0.09, -t * 0.05);
            ctx.lineTo(-t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Petit c≈ìur droit
            ctx.beginPath();
            ctx.moveTo(t * 0.09, -t * 0.05);
            ctx.lineTo(t * 0.12, -t * 0.08);
            ctx.lineTo(t * 0.15, -t * 0.05);
            ctx.lineTo(t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Point lumineux central
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, t * 0.05, t * 0.02, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // C≈ìur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // C√¥t√©s qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits c≈ìurs pendant l'animation du bateau, la phase lanterne ou la phase stars
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars') return;

            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // Calculs d'animation
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le c≈ìur polygonal
                dessinerCoeurPolygonal(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });
        }

        // Syst√®me de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur, vie: 1,
                    taille: Math.random() * 4 + 2,
                    type: 'rond'
                });
            }
        }

        // Particules en forme de petits c≈ìurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6, // Moins de dispersion horizontale
                    vy: -(Math.random() * 8 + 4),  // Toujours vers le haut
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                if(p.type === 'coeur') {
                    // C≈ìurs : pas de gravit√©, continuent vers le haut
                    p.vy *= 0.99; // L√©g√®re d√©c√©l√©ration
                } else {
                    // Particules normales : gravit√©
                    p.vy += 0.15;
                }

                p.vie -= 0.02;

                // Supprimer les particules qui sortent de l'√©cran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.vie * 0.8;
                ctx.fillStyle = p.couleur;

                if(p.type === 'coeur') {
                    // Dessiner petit c≈ìur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du c≈ìur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du c≈ìur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du c≈ìur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Particule ronde normale
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions
        function afficherMunitions() {
            if (animationBateau.active || phaseJeu !== 'stars') return;

            ctx.fillStyle = '#FFD700';
            ctx.font = '16px Arial';
            ctx.fillText(`√âtoiles: ${munitions}`, 10, 30);

            // Afficher le mode √©toiles
            ctx.fillStyle = '#FFD700';
            ctx.fillText('‚≠ê Mode: √âtoiles', 10, 55);
        }

        // Dessiner les projectiles √©toiles
        function dessinerProjectiles() {
            // Ne dessiner les projectiles √©toiles QUE pendant la phase stars
            if(phaseJeu !== 'stars') return;

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = 8;

                // Calcul pour l'effet de rotation scintillante
                const rotation = Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner l'√©toile dor√©e avec effet de lueur
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile + 3);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;

                // √âtoile √† 5 branches
                ctx.beginPath();
                for(let i = 0; i < 5; i++) {
                    const angle1 = (i * 2 * Math.PI) / 5;
                    const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                    if(i === 0) {
                        ctx.moveTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    } else {
                        ctx.lineTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    }

                    ctx.lineTo(Math.cos(angle2) * rayonEtoile * 0.4, Math.sin(angle2) * rayonEtoile * 0.4);
                }
                ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Tirer un projectile √©toile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne
            if (rechargement > 0 || phaseJeu !== 'lanterne') return;

            // Tant qu'il y a des munitions, tirer des √©toiles
            if (munitions > 0) {
                // Tir d'√©toiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;

                projectiles.push({
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY
                });

                munitions--;

                // V√©rifier si c'√©tait la derni√®re munition
                if (munitions === 0) {
                    setTimeout(() => {
                        phaseJeu = 'lanterne';
                        balle.dx = 0; // Immobile au d√©but
                        balle.dy = 0; // Immobile au d√©but
                        balle.visible = true; // S'assurer que la lanterne est visible
                        balle.enAttente = true; // Attendre le clic
                        afficherMessage('üèÆ PHASE CASSE-BRIQUES ! üèÆ<br>üéØ Utilisez la lanterne pour d√©truire les briques !<br><br>üëÜ Cliquez pour lancer la lanterne !', 4000);
                    }, 500);
                }
            }

            rechargement = 20; // D√©lai entre les tirs
        }

        // Mettre √† jour les projectiles
        function mettreAJourProjectiles() {
            if (animationBateau.active || phaseJeu !== 'lanterne') {
                // Nettoyer les projectiles si on n'est pas en phase lanterne
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est d√©truite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Explosion en 3 petits c≈ìurs
                                for(let j = 0; j < 3; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                if(Math.random() < 0.3) {
                                    creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2);
                                }

                                // V√©rifier si toutes les briques sont d√©truites
                                if(briques.every(b => !b.visible)) {
                                    phaseJeu = 'fin_niveau';
                                    setTimeout(() => {
                                        // Passer au niveau suivant ou terminer
                                        if(chapitre === 1 && brises >= VOYAGE.length) {
                                            veriteLiberee();
                                        } else {
                                            afficherMessage('üéâ Niveau termin√© !', 2000);
                                        }
                                    }, 1000);
                                }
                            }
                        }
                    }
                });
            }

            // R√©duire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // G√©rer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // V√©rifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqu√©
            }

            balle.x += balle.dx;
            balle.y += balle.dy;

            // Mode casse-briques : rebonds classiques (uniquement en phase casse_briques)
            if(phaseJeu === 'lanterne') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' ? C.SP * 1.5 : C.SP) * ecart * 0.8;
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode √©toiles : traverser les bords avec t√©l√©portation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // R√©appara√Æt √† droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // R√©appara√Æt √† gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // T√©l√©portation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // R√©appara√Æt en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de v√©rit√© (bas) - seulement dans les phases o√π la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'√©toile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'√©toile continue sa trajectoire
            }

            // Briser les pr√©jug√©s - une seule brique par frame maximum
            let briqueTouchee = false;
            briques.forEach(brique => {
                if(briqueTouchee) return; // Arr√™ter si on a d√©j√† touch√© une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Marquer qu'on a touch√© une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond plus pr√©cis selon la position de contact
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // L'√©toile traverse sans rebondir
                        // Effet magique de passage √† travers les pr√©jug√©s

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;

                        // Explosion en 3 petits c≈ìurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: 1,
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du c≈ìur qui grossit et monte au ciel
                        ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                        // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // D√©sactiv√© : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de cr√©er un power-up bleu
                        if(Math.random() < 0.3) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    if(brises >= VOYAGE.length) {
                        if(phaseJeu === 'stars' && !modeEtoileLance) {
                            // Phase finale normale : s√©quence compl√®te avec bateau + feux + lever soleil
                            phaseJeu = 'feux_artifice';
                            jeu = false;

                            // FORCER L'ARR√äT DU SYST√àME NARRATIF pour √©viter les interf√©rences
                            phaseIntro.active = false;
                            etapeIntro = 3;

                            // √âTAPE 1 : Animation bateau 2s
                            animationBateau.active = true;
                            animationBateau.vitesse = 3; // Plus rapide pour finale

                            setTimeout(() => {
                                // √âTAPE 2 : Feux d'artifice 5s
                                animationBateau.active = false;

                                // Cr√©er des feux d'artifice spectaculaires pendant 5s
                                for(let i = 0; i < 25; i++) {
                                    setTimeout(() => {
                                        const x = Math.random() * C.W;
                                        const y = Math.random() * C.H * 0.7;
                                        const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                        const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                        ajouterParticules(x, y, couleur, 5);
                                    }, i * 200);
                                }

                                setTimeout(() => {
                                    // √âTAPE 3 : Lever de soleil + message final avec bouton
                                    leverSoleilFinal();
                                    setTimeout(() => {
                                        afficherMessageFinal();
                                    }, 1000);
                                }, 5000);

                            }, 2000);
                        } else if(modeEtoileLance) {
                            // Mode √©toile infini : relancer le m√™me niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // √âv√©nements
        function perdreVie() {
            vies--;
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position √† l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne') {
                // En phase lanterne, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© !<br><br>üëÜ Cliquez pour relancer la lanterne ! üëÅÔ∏è', 4000);
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1);
                balle.dy = -C.SP;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© ! üëÅÔ∏è', 3000);
            }
        }

        function finDuVoyage() {
            jeu = false;
            afficherMessage('üò¢ Le voyage vers la v√©rit√© continue...<br><br>üí™ "La v√©rit√© finit toujours par triompher !"<br><br>‚ú® Touchez pour recommencer ‚ú®', 6000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // D√©lai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(chapitre === 1) {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    afficherMessageAnime('üéâ‚ú® CHAPITRE 1 TERMIN√â ! ‚ú®üéâ<br><br>üëÅÔ∏è Tu as vu de tes propres yeux !<br>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Un p√®re, une m√®re, des enfants<br>‚ù§Ô∏è Qui veulent juste vivre comme toi !<br><br>üåë Mais la nuit tombe... Le deuxi√®me chapitre commence...<br><br>üëÜ Touchez pour continuer', 8000, 'fade', 80);
                } else {
                    // Fin du chapitre 2 : d√©clencher la s√©quence finale des feux d'artifice
                    // Phase finale : s√©quence compl√®te avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARR√äT DU SYST√àME NARRATIF pour √©viter les interf√©rences
                    phaseIntro.active = false;
                    etapeIntro = 3;

                    // √âTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = Date.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // √âTAPE 2 : Feux d'artifice 5s
                        console.log("Fin animation bateau, d√©but feux d'artifice");
                        animationBateau.active = false;

                        // Cr√©er des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // √âTAPE 3 : Lever de soleil + message final avec bouton
                            console.log("D√©marrage lever de soleil final");
                            leverSoleilFinal();
                            setTimeout(() => {
                                console.log("Affichage message final");
                                afficherMessageFinal();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de d√©lai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le d√©but pour √©viter les probl√®mes
            chapitre = 1;
            VOYAGE = CHAPITRE1;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            if(chapitre === 1 && brises >= VOYAGE.length) {
                // Transition vers le chapitre 2 - MODE STARS
                chapitre = 2;
                VOYAGE = CHAPITRE2;
                phaseJeu = 'stars'; // IMPORTANT: Passer directement en phase stars pour chapitre 2
                score = 0; vies = 3; brises = 0; jeu = true;
                animationBateau.active = false; // FORCER L'ARR√äT DE L'ANIMATION BATEAU
                phaseIntro.active = false; // FORCER L'ARR√äT DU SYST√àME NARRATIF
                etapeIntro = 3; // MARQUER L'INTRO COMME TERMIN√âE
                initJeu();

                // FORCER la recr√©ation compl√®te des briques pour phase stars
                briques = []; // Vider le tableau
                dedoublerCoeursEnBriques(); // Recr√©er

                // Forcer l'affichage des briques
                briques.forEach(brique => {
                    brique.visible = true;
                });

                // Forcer la visibilit√© de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
                afficherMessage('üåë CHAPITRE 2 : L\'OBSCURIT√â üåë<br><br>‚õàÔ∏è Des orages de discord √©clatent...<br>ü¶à Les requins de la cupidit√© r√¥dent...<br>üåä Mais garde ton c≈ìur pur dans la temp√™te !<br><br>üëÜ Touchez pour affronter l\'obscurit√©', 7000);
            } else {
                // Reprendre au dernier niveau atteint au lieu de restart complet
                reprendreAuDernierNiveau();
            }
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            if(chapitre === 1) {
                chapitre = 2;
                VOYAGE = CHAPITRE2;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Cr√©er les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilit√© de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
                afficherMessage('üåë TEST : CHAPITRE 2 - PHASE STARS üåë<br><br>‚≠ê Tire des √©toiles filantes !<br>ü¶à Mode nuit avec requins !<br><br>üåü Click pour tirer des √©toiles !', 3000);
            } else {
                chapitre = 1;
                VOYAGE = CHAPITRE1;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recr√©er les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits c≈ìurs visibles et d√©sactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
                afficherMessage('‚òÄÔ∏è TEST : CHAPITRE 1 - PHASE COEURS ‚òÄÔ∏è<br><br>üíñ Tire des c≈ìurs vers le haut !<br>üåÖ Mode jour avec soleil !<br><br>‚ú® Click pour tirer des c≈ìurs !', 3000);
            }
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessage('‚ùå AUCUNE BRIQUE TROUV√âE !<br><br>üß± Utilise P pour cr√©er des briques', 2000);
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessage(`‚ö° MODE RAPIDE ACTIV√â ! ‚ö°<br><br>üî® ${briquesModifiees} briques √† 1 vie !<br>üí• Destruction en 1 coup !`, 2000);
            } else {
                afficherMessage('‚ÑπÔ∏è TOUTES LES BRIQUES<br>SONT D√âJ√Ä √Ä 1 VIE !', 1500);
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // D√©sactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessage('‚≠ê TIR √âTOILES D√âSACTIV√â', 1500);
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessage('üåü TIR √âTOILES AUTOMATIQUE ! üåü<br><br>‚≠ê Tir continu activ√© !<br>üéØ E pour d√©sactiver', 2000);

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si n√©cessaire
                        if(!jeu) jeu = true;

                        // Viser une brique al√©atoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Lib√©rer les c≈ìurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            console.log("Lever de soleil : passage en mode jour");
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise √† jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode √©toile test
            console.log("Lancement du mode √©toile test");

            // Configuration pour mode √©toile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = CHAPITRE2;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode √©toile depuis le menu

            // Forcer l'arr√™t des syst√®mes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'√©toiles automatique en mode √©toile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les √©l√©ments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Cr√©er les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessageAnime('üåü MODE √âTOILE INFINI ACTIV√â üåü<br><br>‚≠ê Tire des √©toiles filantes en continu !<br>üåô Mode nuit √©ternel avec requins !<br><br>üéØ Tir automatique d\'√©toiles activ√© !', 3000, 'glitch', 80);
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones √† chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centr√©e
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion apr√®s 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // D√©lai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le m√™me niveau stars infini
                phaseJeu = 'stars';
                chapitre = 2;
                VOYAGE = CHAPITRE2;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessageAnime('üåü MODE √âTOILE INFINI üåü<br><br>‚≠ê Niveau termin√© ! Nouveau niveau stars !<br>üåô Mode nuit √©ternel avec requins !<br><br>üéØ Tir automatique d\'√©toiles activ√© !', 3000, 'typewriter', 45);

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'√©toiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // D√©lai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // S√©quence finale : 3 formations al√©atoires avec explosions
            console.log("Lancement de la s√©quence finale avec 3 formations");

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations al√©atoires diff√©rentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // S√©quence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position al√©atoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        console.log(`Formation ${index + 1}: ${formation} √† (${x}, ${y})`);

                        // Explosion apr√®s formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu apr√®s la s√©quence compl√®te (3 √ó 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arr√™ter le tir automatique √† la fin du mode √©toile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard
            afficherMessageFinal();
        }


        function afficherMessageFinal() {
            const msg = document.getElementById('message');

            // Texte simple sans HTML pour l'animation
            const texteSimple = `üëÅÔ∏è REGARDE BIEN C'EST LA FIN üëÅÔ∏è

üéÆ Jeu cr√©√© par Emmanuel
üíñ Avec amour et passion
üåü Merci d'avoir jou√© !

‚ú® Fin du voyage de la v√©rit√© ‚ú®`;

            // Afficher avec animation typewriter
            msg.classList.add('show');
            msg.style.display = 'block';
            msg.style.textAlign = 'center';
            msg.style.color = 'white';
            msg.style.fontSize = '18px';
            msg.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8), 1px 1px 2px rgba(0,0,0,0.6)';
            // Supprimer le fond
            msg.style.background = 'transparent';
            msg.style.border = 'none';
            msg.style.boxShadow = 'none';
            msg.style.backdropFilter = 'none';

            textAnimator.typewriter(msg, texteSimple, 50, () => {
                // Ajouter le bouton apr√®s l'animation
                msg.innerHTML += `<br><br><button onclick="window.location.reload()" style="background: linear-gradient(145deg, #4f46e5, #7c3aed); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 18px; font-weight: bold; cursor: pointer;">üîÑ RELOADER</button>`;
            });
        }

        function recommencerJeu() {
            // R√©initialiser compl√®tement le jeu
            chapitre = 1;
            VOYAGE = CHAPITRE1;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = false; // Commencer avec jeu d√©sactiv√© pour l'intro

            // R√©initialiser les syst√®mes
            animationBateau.active = false;
            phaseIntro.active = true;
            etapeIntro = 0;

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Cacher le message
            cacherMessage();

            // Red√©marrer l'intro compl√®te avec animation typewriter
            afficherMessageAnime('üëÅÔ∏è‚ú® VOIR LA V√âRIT√â ‚ú®üëÅÔ∏è<br><br>üåÖ CHAPITRE 1 : LA LUMI√àRE<br><br>üí≠ "On m\'a dit qu\'ils √©taient tous des monstres...<br>On m\'a dit tant de mal, tant de malheurs sur eux...<br>Mais moi, j\'ai pr√©f√©r√© aller voir de mes propres yeux.<br>Qui √©taient ces gens-l√† ?..."<br><br>üëÜ Touchez pour d√©couvrir la v√©rit√©', 12000, 'typewriter', 60);
        }

        // Nouvelle fonction pour les messages avec animation
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span><br><br>${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Faire dispara√Ætre le texte apr√®s la dur√©e d√©finie (d√©marre imm√©diatement)
            if(duree > 0) {
                setTimeout(() => {
                    cacherMessage();
                }, duree);
            }

            // Callback vide pour l'animation
            const onComplete = () => {
                // Animation termin√©e, mais le timer de disparition a d√©j√† √©t√© lanc√©
            };

            switch(animation) {
                case 'typewriter':
                    textAnimator.typewriter(msg, texteComplet, speed, onComplete);
                    break;
                case 'digital':
                    textAnimator.digital(msg, texteComplet, speed, onComplete);
                    break;
                case 'fade':
                    textAnimator.fadeIn(msg, texteComplet, speed * 20, onComplete);
                    break;
                case 'glitch':
                    textAnimator.glitch(msg, texteComplet, speed * 40, onComplete);
                    break;
                default:
                    msg.innerHTML = texteComplet;
                    onComplete();
            }
        }

        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span><br><br>${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Cr√©er le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        üîÑ Rejouer
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ‚û°Ô∏è Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }

        function afficherMessageNarratif(texte, duree = 0) {
            const msg = document.getElementById('message');

            // Ajouter la classe narratif pour le style cin√©matique
            msg.classList.remove('show');
            msg.classList.add('narratif');
            msg.innerHTML = texte;
            msg.classList.add('show');

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    setTimeout(() => {
                        msg.classList.remove('narratif');
                    }, 300);
                }, duree);
            }
        }

        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifi√© et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;

            // Couleur de la mer selon le chapitre
            const merGrad = ctx.createLinearGradient(0, merY, 0, C.H);
            if(chapitre === 1) {
                // Mer bleue paisible
                merGrad.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
                merGrad.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
                merGrad.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            } else {
                // Mer sombre et mena√ßante
                merGrad.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
                merGrad.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
                merGrad.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
            }
            ctx.fillStyle = merGrad;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // Vagues selon le chapitre
            if(chapitre === 1) {
                // Vagues paisibles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                // Vagues agit√©es
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = chapitre === 1 ? (8 - ligne * 2) : (12 - ligne * 3);
                const fr√©quence = 0.01 + ligne * 0.005;
                const vitesse = chapitre === 1 ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                for(let x = 0; x <= C.W; x += 10) {
                    const vague = Math.sin(x * fr√©quence + offset) * amplitude;
                    if(x === 0) ctx.moveTo(x, y + vague);
                    else ctx.lineTo(x, y + vague);
                }
                ctx.stroke();
            }

            // Ailerons de requin dans le chapitre 2 (disparaissent pendant le lever de soleil)
            if(chapitre === 2 && !leverSoleil.active) {
                const requins = [
                    { x: 0.2, vitesse: 0.3, taille: 1.0 },
                    { x: 0.6, vitesse: 0.5, taille: 0.8 },
                    { x: 0.9, vitesse: 0.4, taille: 1.2 }
                ];

                requins.forEach(requin => {
                    const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                    const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                    const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;

                    // Aileron de requin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8); // Base gauche
                    ctx.lineTo(reqX, reqY - taille); // Pointe
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5); // Base droite
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8); // Retour base
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Sillage du requin
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // D√©clarer les variables pour √©viter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(chapitre === 1) {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% √† 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui √©volue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // Rayons du soleil (plus nombreux pendant le lever)
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3;
                const nbRayons = leverSoleil.active ? 16 : 8;
                for(let i = 0; i < nbRayons; i++) {
                    const rotationSoleil = Date.now() * 0.0005; // Rotation lente
                    const angle = (i / nbRayons) * Math.PI * 2 + rotationSoleil;
                    const longueurRayon = leverSoleil.active ? 25 : 15;
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            } else {
                // CHAPITRE 2: Lune inqui√©tante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(chapitre === 1) {
                // V√©rifier si le soleil fait un clin d'≈ìil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'≈ìil pendant 2 secondes

                // Arr√™ter le clignotement apr√®s 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant √† la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et ferm√©s (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux ferm√©s paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et mod√©r√©
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence √† sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'≈ìil ! ≈íil gauche ferm√©, ≈ìil droit ouvert
                        // ≈íil gauche ferm√© (clin d'≈ìil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // ≈íil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'≈ìil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au d√©but
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inqui√©tante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre
            if(chapitre === 1) {
                // Nuages blancs paisibles
                const nuages = [
                    { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                    { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                    { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                ];

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.lineWidth = 2;

                nuages.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                    for(let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * taille * 0.8;
                        const rayonNuage = taille * (0.8 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                });
            } else {
                // Nuages d'orage gris avec √©clairs
                const nuagesOrage = [
                    { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                    { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                    { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                ];

                nuagesOrage.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                    // Nuages gris mena√ßants
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                    ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                    ctx.lineWidth = 2;

                    for(let i = 0; i < 4; i++) {
                        const offsetX = (i - 1.5) * taille * 0.6;
                        const rayonNuage = taille * (0.7 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // √âclairs occasionnels
                    if(Math.random() < 0.02) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(nuageX, nuageY + taille);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                        ctx.stroke();
                    }
                });
            }
        }

        // Rendu principal
        function dessiner() {

            // Fond d√©grad√© selon le chapitre
            const grad = ctx.createLinearGradient(0, 0, 0, C.H);
            if(chapitre === 1) {
                // Ciel diurne
                grad.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
                grad.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
                grad.addColorStop(1, 'rgba(240,248,255,0.98)');
            } else {
                // Ciel nocturne orageux
                grad.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
                grad.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
                grad.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, C.H);

            dessinerCiel();
            dessinerMer();
            dessinerInterface();
            dessinerPrejuges();
            dessinerPowerUps();
            dessinerCoeursBateau();
            dessinerPetitsCoeurs();
            dessinerBateau();
            afficherMunitions();
            dessinerStarsProjectiles(); // √âtoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // √âtoiles (phase briques)
            dessinerProjectilesSecret(); // Cercles (mode secret)
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret
            dessinerObstacles(); // Mode secret obstacles
            dessinerParticules();

            // Rendu des drones feux d'artifice
            if (droneModule) {
                droneModule.render();
            }

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
        }

        // Contr√¥les tactiles et souris unifi√©s
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left };
        }

        function deplacerRaquette(x) {
            if(!jeu) return;
            raquette.x = x - C.PW/2;
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));
        }

        // √âv√©nements tactiles
        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); tactile = true;
            if(animationBateau.active || etapeIntro < 3) { return; } // Bloquer pendant l'animation et l'intro
            if(!jeu && etapeIntro >= 3 && chapitre !== 2) { recommencer(); return; } // Ne recommencer que si l'intro est termin√©e ET pas en chapitre 2

            if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles tactile
                const pos = obtenirPosition(e);
                tirerStarsProjectile(pos.x, pos.y);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1); // Direction al√©atoire
                    balle.dy = -C.SP * 1.5; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessage('üèÆ LANTERNE LANC√âE ! üèÆ<br>‚ú® √Ä toi de jouer !', 2000);
                } else {
                    // Si la balle est d√©j√† en mouvement, d√©placer la raquette
                    const pos = obtenirPosition(e);
                    deplacerRaquette(pos.x);
                }
            } else {
                const pos = obtenirPosition(e);
                deplacerRaquette(pos.x);
                libererVaguesAmour(); // Lib√©rer une vague d'amour
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // √âv√©nements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();


            deplacerRaquette(e.clientX - rect.left);
        });

        canvas.addEventListener('click', (e) => {
            if(animationBateau.active || etapeIntro < 3) { return; } // Bloquer pendant l'animation et l'intro
            if(!jeu && etapeIntro >= 3 && phaseJeu !== 'feux_artifice') { // Permettre transition mais pas pendant les feux
                recommencer();
            } else if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1); // Direction al√©atoire
                    balle.dy = -C.SP * 1.5; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessage('üèÆ LANTERNE LANC√âE ! üèÆ<br>‚ú® √Ä toi de jouer !', 2000);
                }
            } else {
                let corbeauTouche = false;

                // V√©rifier si on a cliqu√© sur le corbeau
                if(corbeau.actif) {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

                    const dx = x - corbeau.x;
                    const dy = y - corbeau.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < 40) { // Rayon de collision du corbeau
                        corbeauTouche = true;
                        corbeau.touches++;
                        score += 100; // Points bonus pour toucher le corbeau

                        // Effet visuel
                        ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

                        if(corbeau.touches >= 3) {
                            // Transformer en colombe !
                            corbeau.type = 'colombe';
                            score += 1000; // Gros bonus pour la transformation

                            // D√©bloquer le niveau secret !
                            niveauSecretDebloque = true;

                            afficherMessage('üïäÔ∏è MIRACLE ! üïäÔ∏è<br><br>‚ú® Le corbeau s\'est transform√© en colombe !<br>üíé +1000 points bonus !<br>‚òÄÔ∏è Le soleil vous fait un clin d\'≈ìil !<br><br>üîì NIVEAU SECRET D√âBLOQU√â !<br>üéÆ Mode Pacman activ√© !', 3000);

                            // Le soleil fait un clin d'≈ìil
                            soleil.clignotement = true;
                            soleil.tempsClignotement = Date.now();

                            // D√©clencher le niveau secret apr√®s un d√©lai
                            setTimeout(() => {
                                lancerNiveauSecret();
                            }, 4000);
                        } else {
                            // Message discret en bas √† droite
                            afficherMessageCorbeauBas(`üéØ ${corbeau.touches}/3 üí∞ +100`, 1000);
                        }
                    }
                }

                // Toujours lib√©rer une vague d'amour, m√™me si on a touch√© le corbeau
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, tirer un projectile √† chaque clic
                    creerProjectile();
                }
            }
        });

        // Redimensionnement responsive
        window.addEventListener('resize', () => {
            size = setupCanvas();
            if(!jeu) initJeu();
        });

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas √† droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu) return;

            // Initialiser le temps de d√©part si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire appara√Ætre le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;
                corbeau.x = -100; // Commence hors √©cran √† gauche
                corbeau.y = C.H * 0.4; // Vers le milieu de l'√©cran
                corbeau.vx = 0.8 / 1.5; // Vitesse 1.5x plus lente
                corbeau.touches = 0; // R√©initialiser le compteur de touches
                // Garder le type actuel (corbeau ou colombe) - ne pas forcer le retour en corbeau

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                corbeau.y += Math.sin(Date.now() * 0.0005) * 0.25; // Mouvement ondulant tr√®s doux et petit

                // Retirer le corbeau s'il sort de l'√©cran
                if(corbeau.x > C.W + 100) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        function dessinerCorbeau() {
            if(!corbeau.actif) return;

            ctx.save();

            const taille = 40;
            const x = corbeau.x;
            const y = corbeau.y;

            if(corbeau.type === 'corbeau') {
                // Corbeau noir style manga
                ctx.fillStyle = '#000000';

                // Corps du corbeau
                ctx.beginPath();
                ctx.ellipse(x, y, taille * 0.6, taille * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ailes d√©ploy√©es
                ctx.beginPath();
                ctx.ellipse(x - taille * 0.3, y - taille * 0.1, taille * 0.4, taille * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + taille * 0.3, y - taille * 0.1, taille * 0.4, taille * 0.2, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Bec
                ctx.fillStyle = '#FFAA00';
                ctx.beginPath();
                ctx.moveTo(x + taille * 0.6, y);
                ctx.lineTo(x + taille * 0.8, y);
                ctx.lineTo(x + taille * 0.6, y + 5);
                ctx.fill();

                // ≈íil manga
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(x + taille * 0.2, y - 5, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(x + taille * 0.2, y - 5, 4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Colombe blanche
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#DDDDDD';
                ctx.lineWidth = 1;

                // Corps de la colombe
                ctx.beginPath();
                ctx.ellipse(x, y, taille * 0.6, taille * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Ailes blanches
                ctx.beginPath();
                ctx.ellipse(x - taille * 0.3, y - taille * 0.1, taille * 0.4, taille * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(x + taille * 0.3, y - taille * 0.1, taille * 0.4, taille * 0.2, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Bec dor√©
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(x + taille * 0.6, y);
                ctx.lineTo(x + taille * 0.8, y);
                ctx.lineTo(x + taille * 0.6, y + 5);
                ctx.fill();

                // ≈íil doux
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(x + taille * 0.2, y - 5, 3, 0, Math.PI * 2);
                ctx.fill();

                // Halo de lumi√®re
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, taille * 0.8, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y) {
            textesVolants.push({
                texte: texte,
                x: x,
                y: y,
                xDepart: x,
                yDepart: y,
                vy: 0, // Vitesse calcul√©e dynamiquement
                taille: 12, // Taille initiale
                alpha: 1, // Opacit√©
                temps: 0,
                phase: 'descente' // 'descente' puis 'montee'
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.004; // Progression plus lente

                // Mouvement vers le centre horizontal
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Progression plus lente vers le centre
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis mont√©e
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 200); // Descend plus bas (200px max)

                    // Fondu pendant la descente
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Fondu plus marqu√©

                    // Passer √† la phase mont√©e apr√®s plus de temps
                    if(texte.temps > 0.2) {
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 120); // Remonte moins vite

                    // Fondu retour pendant la mont√©e
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 3);
                }

                // Grossissement tr√®s progressif et doux
                texte.taille = 12 + texte.temps * 20;

                // Disparition finale tr√®s progressive
                if(texte.temps > 0.6) {
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.6) * 2);
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu
        function boucleJeu() {
            // G√©rer l'animation du bateau
            gererAnimationBateau();

            // G√©rer la phase d'introduction
            gererPhaseIntro();

            if(jeu || phaseIntro.active) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Syst√®me projectiles stars
                    mettreAJourProjectiles(); // Nouveau syst√®me de projectiles
                    mettreAJourBulle(); // Ancien syst√®me pour les autres phases
                }
                mettreAJourParticules();

                // Mise √† jour du module de drones
                if (droneModule) {
                    droneModule.animate();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                mettreAJourPetitsCoeurs();
                mettreAJourTextesVolants();
                mettreAJourCorbeau(); // Gestion du corbeau secret
                mettreAJourMessageCorbeauBas(); // Messages discrets du corbeau
                mettreAJourObstacles(); // Mode secret obstacles
                mettreAJourProjectilesSecret(); // Projectiles du mode secret
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }

        // D√©marrage
        initJeu();
        // Afficher l'introduction en trois parties avec bouton Suivant
        let etapeIntro = 0;
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let modeEtoileLance = false; // Pour tracker si on est en mode √©toile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        const messagesIntro = [
            'üåÖ CHAPITRE 1 : LA LUMI√àRE\n\nüí≠ "On m\'a dit qu\'ils √©taient tous des monstres...\nOn m\'a dit tant de mal, tant de malheurs sur eux...\nMais moi, j\'ai pr√©f√©r√© aller voir de mes propres yeux.\nQui √©taient ces gens-l√† ?..."',
            'üí≠ "Et j\'ai vu...\nUn p√®re... une m√®re... des enfants...\nTous cherchant simplement √† vivre leur meilleure vie...\nComme moi."',
            'üåë Puis viendra l\'obscurit√©... ‚õàÔ∏è\n\nüéÆ Brise les pr√©jug√©s, r√©siste aux temp√™tes !\n\nüëÜ Touchez pour commencer le voyage !'
        ];

        function afficherEtapeIntro() {
            if(etapeIntro < messagesIntro.length) {
                const duree = 12000; // 12 secondes par d√©faut
                let texteSeul = messagesIntro[etapeIntro];

                // Utiliser textAnimator directement comme pour le menu final
                const msg = document.getElementById('message');
                msg.classList.add('show');
                msg.style.display = 'block';
                msg.style.textAlign = 'center';
                msg.style.color = 'white';
                msg.style.fontSize = '18px';
                msg.style.lineHeight = '1.8';
                msg.style.width = '100%';
                msg.style.maxWidth = 'none';
                msg.style.margin = '0';
                msg.style.paddingLeft = '20px';
                msg.style.paddingRight = '20px';
                msg.style.paddingTop = '120px';
                msg.style.top = '0';
                msg.style.left = '0';
                msg.style.transform = 'none';
                msg.style.position = 'absolute';
                msg.style.whiteSpace = 'pre-line';
                msg.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8), 1px 1px 2px rgba(0,0,0,0.6)';
                // Supprimer le fond
                msg.style.background = 'transparent';
                msg.style.border = 'none';
                msg.style.boxShadow = 'none';
                msg.style.backdropFilter = 'none';

                // Faire dispara√Ætre le texte apr√®s la dur√©e d√©finie (d√©marre imm√©diatement)
                if(duree > 0) {
                    setTimeout(() => {
                        cacherMessage();
                    }, duree);
                }

                // Timer de disparition automatique (d√©marre imm√©diatement)
                setTimeout(() => {
                    cacherMessage();
                }, duree);

                // Animer le texte d'abord, puis ajouter le bouton
                textAnimator.typewriter(msg, texteSeul, 30, () => {
                    // Ajouter le bouton apr√®s l'animation du texte
                    if(etapeIntro < 2) {
                        msg.innerHTML += '<br><br><button onclick="suivantIntro()" title="Non! On ne peut pas laisser passer √ßa" style="background: transparent; border: none; padding: 10px 20px; color: white; font-size: 18px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; text-shadow: 0 0 10px #4da6ff, 0 0 20px #4da6ff, 0 0 30px #4da6ff;" onmouseover="this.style.textShadow=\'0 0 15px #4da6ff, 0 0 30px #4da6ff, 0 0 45px #4da6ff\';" onmouseout="this.style.textShadow=\'0 0 10px #4da6ff, 0 0 20px #4da6ff, 0 0 30px #4da6ff\';">Passer ‚ûú</button>';
                    } else if(etapeIntro === 2) {
                        // Derni√®re √©tape : bouton pour commencer le jeu
                        msg.innerHTML += '<br><br><button onclick="commencerJeu()" style="background: transparent; border: none; padding: 10px 20px; color: white; font-size: 18px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; text-shadow: 0 0 10px #4da6ff, 0 0 20px #4da6ff, 0 0 30px #4da6ff;" onmouseover="this.style.textShadow=\'0 0 15px #4da6ff, 0 0 30px #4da6ff, 0 0 45px #4da6ff\';" onmouseout="this.style.textShadow=\'0 0 10px #4da6ff, 0 0 20px #4da6ff, 0 0 30px #4da6ff\';">üöÄ Commencer l\'aventure</button>';
                    }
                });
            }
        }

        // Fonction pour avancer manuellement (accessible globalement)
        window.suivantIntro = function() {
            if(animationBateau.active) {
                // Message d'interdiction pendant l'animation
                // Affichage sp√©cial pour le message d'interdiction
                const msg = document.getElementById('message');
                msg.classList.add('show');
                msg.style.position = 'absolute';
                msg.style.top = '50%';
                msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.width = 'auto';
                msg.style.maxWidth = '90%';
                msg.style.margin = '0';
                msg.style.padding = '20px';
                msg.style.textAlign = 'center';
                msg.style.color = 'white';
                msg.style.textShadow = '0 0 10px #4da6ff, 0 0 20px #4da6ff, 0 0 30px #4da6ff';
                msg.style.background = 'transparent';
                msg.style.border = 'none';
                msg.style.boxShadow = 'none';
                msg.style.backdropFilter = 'none';

                // R√©initialiser le positionnement au centre
                msg.style.top = '50%';
                msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.position = 'absolute';

                // Afficher directement avec innerHTML pour les balises HTML
                msg.innerHTML = '‚ùå NON !<br><br>üö´ On ne peut pas laisser passer √ßa !<br><br>‚è≥ Profitez de ce moment...';
                msg.classList.add('show'); // Ajouter la classe show pour rendre visible

                setTimeout(() => {
                    cacherMessage();
                }, 3000);
                return;
            }
            if(etapeIntro < 2) {
                etapeIntro++;
                afficherEtapeIntro();
            }
        }

        // Fonction pour commencer le jeu depuis la derni√®re √©tape d'intro
        window.commencerJeu = function() {
            cacherMessage();
            etapeIntro = 3; // Marquer l'intro comme termin√©e
            // Le jeu d√©marrera automatiquement gr√¢ce √† l'animation du bateau
        }

        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer √† la phase suivante (d√©sactiv√©)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprim√©e pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Mode passe : Touche S pour niveau secret
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Mode passe : Touche R pour r√©duire la vie des briques √† 1
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                reduireVieBriques();
            }

            // Mode passe : Touche E pour tir automatique √©toiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

        });

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = [];

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Cr√©er 3 obstacles marins de d√©part √† diff√©rentes profondeurs
            for(let i = 0; i < 3; i++) {
                creerObstaclesMarins();
                // Espacer les obstacles dans la profondeur
                if(obstacles.length > 0) {
                    obstacles[obstacles.length - 1].z = 0.1 + i * 0.1;
                }
            }

            afficherMessage('üéØ NIVEAU SECRET : TIR DE PR√âCISION ! üéØ<br><br>üßä Tirez sur les icebergs et poubelles ! ‚ôª<br>üêã ATTENTION : Les baleines sont prot√©g√©es !<br>üö´ Tirer sur une baleine = "NO GREAT!" et perte de vie<br>üëÜ Chaque clic = un tir pr√©cis<br>üí∞ +100 points par obstacle d√©truit !', 5000);
        }



        function creerProjectile() {
            // Cr√©er un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // V√©rifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle d√©j√† touch√©

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision d√©tect√©e !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine prot√©g√©e ! Perdre une vie
                            vies--;

                            // Messages amusants vari√©s
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                afficherMessageAvecBoutons(`üíÄ ${messageAleatoire} üíÄ<br><br>üêã Tu as tir√© sur une baleine prot√©g√©e !<br>üò± Toutes tes vies sont √©puis√©es !<br>üö´ Les baleines ne se tirent pas !<br>ü§™ HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `üö´ ${messageAleatoire} üö´<br><br>üêã Les baleines sont prot√©g√©es !<br>üíî Vie perdue : ${vies} restantes<br>üò§ Tire seulement sur les icebergs !<br>üôÑ TSSS TSSS!`,
                                    `üö´ ${messageAleatoire} üö´<br><br>üêã BALEINE = INTERDITE !<br>üíî Oups : ${vies} vies restantes<br>üò§ ICEBERGS SEULEMENT !<br>ü§¶‚Äç‚ôÇÔ∏è PFFFFFF!`,
                                    `üö´ ${messageAleatoire} üö´<br><br>üêã PAUVRE BALEINE !<br>üíî Punition : ${vies} vies left<br>üò§ GLACE = OK, BALEINE = NON !<br>üòÇ HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (col√®re)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK √† d√©truire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle d√©truit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succ√®s)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touch√© temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function creerObstaclesMarins() {
            // Cr√©er obstacle qui tombe du ciel
            const types = ['baleine', 'iceberg', 'poubelle'];

            // Position horizontale al√©atoire
            const x = 50 + Math.random() * (C.W - 100);

            // Obstacle qui tombe du haut vers le bas
            obstacles.push({
                x: x,
                y: -50, // Commence au-dessus de l'√©cran
                vitesse: 2 + Math.random() * 2, // Vitesse de chute variable
                type: types[Math.floor(Math.random() * types.length)],
                taille: 30 + Math.random() * 20, // Taille variable
                vie: 1, // Points de vie
                touche: false // Pour √©viter plusieurs hits
            });
        }

        function mettreAJourObstacles() {
            if(!modeSecret) return;

            // Ajouter de nouveaux obstacles r√©guli√®rement
            if(obstacles.length < 3 && Date.now() - tempsDernierObstacle > 1500) {
                creerObstaclesMarins();
                tempsDernierObstacle = Date.now();
            }

            // Mettre √† jour chaque obstacle
            obstacles.forEach((obstacle, index) => {
                // Faire tomber l'obstacle
                obstacle.y += obstacle.vitesse;

                // Supprimer les obstacles qui sortent en bas
                if(obstacle.y > C.H + 50) {
                    obstacles.splice(index, 1);
                    return;
                }
            });

            // V√©rifier si on a surv√©cu 30 secondes
            if(Date.now() - tempsDebutSecret > 30000) {
                // Victoire !
                modeSecret = false;
                jeu = false;
                score += 5000; // Gros bonus !
                afficherMessageAvecBoutons('üèÜ VICTOIRE SECR√àTE ! üèÜ<br><br>üéâ Vous avez surv√©cu aux obstacles marins !<br>üíé +5000 points bonus !<br>üåü Ma√Ætre de la navigation !',
                    'lancerNiveauSecret', 'recommencer');
            }
        }

        // ========== MODULE OBSTACLES ==========
        const ObstacleSystem = {
            // Syst√®me de rendu
            renderers: {
            baleine: function(ctx, taille) {
                // Corps principal
                ctx.fillStyle = '#2d3436';
                ctx.beginPath();
                ctx.ellipse(0, 0, taille, taille * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Yeux
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(-taille * 0.3, -taille * 0.2, taille * 0.1, 0, Math.PI * 2);
                ctx.arc(taille * 0.3, -taille * 0.2, taille * 0.1, 0, Math.PI * 2);
                ctx.fill();

                // Pupilles
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(-taille * 0.3, -taille * 0.2, taille * 0.05, 0, Math.PI * 2);
                ctx.arc(taille * 0.3, -taille * 0.2, taille * 0.05, 0, Math.PI * 2);
                ctx.fill();
            },

            iceberg: function(ctx, taille) {
                // Corps principal
                ctx.fillStyle = '#74b9ff';
                ctx.strokeStyle = '#0984e3';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(0, -taille);
                ctx.lineTo(taille * 0.7, taille * 0.8);
                ctx.lineTo(-taille * 0.7, taille * 0.8);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Lignes de glace
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-taille * 0.3, -taille * 0.2);
                ctx.lineTo(taille * 0.4, taille * 0.3);
                ctx.moveTo(taille * 0.2, -taille * 0.4);
                ctx.lineTo(-taille * 0.2, taille * 0.5);
                ctx.stroke();
            },

            poubelle: function(ctx, taille) {
                // Corps de la poubelle
                ctx.fillStyle = '#2d3436';
                ctx.fillRect(-taille * 0.6, -taille * 0.4, taille * 1.2, taille * 1.2);

                // Couvercle
                ctx.fillStyle = '#636e72';
                ctx.fillRect(-taille * 0.7, -taille * 0.6, taille * 1.4, taille * 0.2);

                // Poign√©e du couvercle
                ctx.strokeStyle = '#636e72';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, -taille * 0.5, taille * 0.2, Math.PI, 0, false);
                ctx.stroke();

                // Rayures sur la poubelle
                ctx.strokeStyle = '#636e72';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i = -2; i <= 2; i++) {
                    ctx.moveTo(i * taille * 0.15, -taille * 0.2);
                    ctx.lineTo(i * taille * 0.15, taille * 0.6);
                }
                ctx.stroke();

                // Symbole recyclage
                ctx.fillStyle = '#00b894';
                ctx.font = `${taille * 0.3}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('‚ôª', 0, taille * 0.2);
            }
            }
        };

        function dessinerObstacles() {
            if(!modeSecret) return;

            obstacles.forEach(obstacle => {
                ctx.save();
                ctx.translate(obstacle.x, obstacle.y);

                const renderer = ObstacleSystem.renderers[obstacle.type];
                if(renderer) {
                    renderer(ctx, obstacle.taille);
                }

                ctx.restore();
            });

            // Afficher le temps restant
            ctx.save();
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            const tempsRestant = Math.max(0, 30 - Math.floor((Date.now() - tempsDebutSecret) / 1000));
            ctx.fillText(`‚è∞ ${tempsRestant}s`, C.W/2, 50);
            ctx.restore();
        }

        // L'animation d√©marre automatiquement via gererAnimationBateau()
        boucleJeu();
    </script>
</body>
</html>