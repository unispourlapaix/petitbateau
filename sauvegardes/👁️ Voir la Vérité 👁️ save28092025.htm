<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üëÅÔ∏è Voir la V√©rit√© üëÅÔ∏è</title>
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            background: transparent;
            backdrop-filter: none; -webkit-backdrop-filter: none;
            border: none;
            border-radius: 0; padding: 25px 113px;
            box-shadow: none;
            max-width: none; width: 100%; text-align: center; z-index: 200;
            display: none; font-size: clamp(21px, 5.25vw, 24px); color: #ffffff;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Messages narratifs - style cin√©matique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: transparent;
            border: none;
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: none; width: 100%;
                font-size: clamp(21px, 2.7vw, 24px);
                padding: 20px 113px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Indicateur d'√©tape */
        .etape-indicateur {
            display: none !important;
        }

        .etape-indicateur.show {
            display: block;
        }

        /* Animation shake pour le bouton skip */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes etapeGlow {
            0% {
                box-shadow:
                    0 4px 15px rgba(0,0,0,0.3),
                    0 0 20px rgba(77,166,255,0.2),
                    inset 0 1px 1px rgba(255,255,255,0.1);
            }
            100% {
                box-shadow:
                    0 4px 20px rgba(0,0,0,0.4),
                    0 0 30px rgba(77,166,255,0.5),
                    inset 0 1px 1px rgba(255,255,255,0.2);
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* üé¨ STYLES TEXTANIMATOR OPTIMIS√â */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .text-animator-display {
            font-size: 1.2em;
            line-height: 1.6;
            background: transparent;
        }

        /* Animations de base */
        .ta-typewriter { border-right: 2px solid #ffffff; animation: ta-blink 1s infinite; }
        .ta-digital { color: #00cc44; text-shadow: 0 0 8px #00cc44; font-family: 'Courier New', monospace; letter-spacing: 2px; }
        .ta-fade-in { animation: ta-fadeIn 1s ease-in; }
        .ta-glitch { position: relative; color: #fff; animation: ta-glitch 2s infinite; }

        /* Effets 3D optimis√©s */
        .ta-effect-shadow3d { text-shadow: 2px 2px 0px var(--ta-effect-color, #64ffda), 4px 4px 0px rgba(0,0,0,0.5), 6px 6px 10px rgba(0,0,0,0.8); }
        .ta-effect-neon { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda), 0 0 80px var(--ta-effect-color, #64ffda); animation: ta-neonPulse 2s ease-in-out infinite alternate; }
        .ta-effect-emboss { text-shadow: 1px 1px 0px var(--ta-effect-color, #64ffda), -1px -1px 0px rgba(0,0,0,0.8), 2px 2px 5px rgba(0,0,0,0.6); color: var(--ta-text-color, #fff); }
        .ta-effect-outline { text-shadow: -2px -2px 0 var(--ta-effect-color, #64ffda), 2px -2px 0 var(--ta-effect-color, #64ffda), -2px 2px 0 var(--ta-effect-color, #64ffda), 2px 2px 0 var(--ta-effect-color, #64ffda), 0 0 10px rgba(0,0,0,0.5); }
        .ta-effect-fire { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; animation: ta-fireFlicker 1.5s ease-in-out infinite alternate; }
        .ta-effect-ice { background: linear-gradient(45deg, #87ceeb, #add8e6, #e0ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); animation: ta-iceShimmer 3s ease-in-out infinite; }

        /* Keyframes optimis√©es */
        @keyframes ta-blink { 0%, 50% { border-color: transparent; } 51%, 100% { border-color: #ffffff; } }
        @keyframes ta-fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes ta-glitch { 0%, 100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000; transform: translate(0); } 20% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; transform: translate(-2px, 2px); } 40% { text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff; transform: translate(-2px, -2px); } 60% { text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; transform: translate(2px, 2px); } 80% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff; transform: translate(2px, -2px); } }
        @keyframes ta-neonPulse { from { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda); } to { text-shadow: 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-text-color, #fff), 0 0 30px var(--ta-effect-color, #64ffda), 0 0 60px var(--ta-effect-color, #64ffda), 0 0 100px var(--ta-effect-color, #64ffda); } }
        @keyframes ta-fireFlicker { 0%, 100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; } 50% { text-shadow: 0 0 5px #ff4500, 0 0 15px #ff8c00, 0 0 25px #ffd700, 0 0 35px #ff4500; } }
        @keyframes ta-iceShimmer { 0%, 100% { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); } 50% { text-shadow: 1px 1px 3px rgba(0,0,0,1); } }
        /* ===========================================
           MODULE OISEAUX VOLANTS - INT√âGRATION
           Par Emmanuel Payet / Dreamer Unisona
           ========================================== */

        /* Variables CSS pour le module oiseaux */
        :root {
            --bird-scale: 1;
            --animation-speed: 1;
            --crow-color: #1A1A1A;
            --dove-color: #FFFFFF;
            --bat-color: #000000;
        }

        /* Container pour oiseaux sur canvas */
        .flying-birds-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 150;
        }

        /* Base commune pour tous les oiseaux */
        .bird-base {
            position: absolute;
            transform-origin: center;
            pointer-events: auto;
            transition: all 0.3s ease;
            transform: scale(var(--bird-scale));
            cursor: pointer;
        }

        /* √âtats de visibilit√© */
        .bird-hidden {
            opacity: 0;
            transform: scale(0) scale(var(--bird-scale));
        }

        .bird-visible {
            opacity: 1;
            transform: scale(1) scale(var(--bird-scale));
        }

        /* CORBEAU BADASS - ID: crow */
        #crow {
            width: 45px;
            height: 30px;
            background: linear-gradient(135deg, var(--crow-color), #000000);
            clip-path: polygon(10% 15%, 25% 0%, 75% 5%, 90% 25%, 95% 60%, 85% 90%, 15% 95%, 5% 70%);
            animation: crow-auto-flight calc(2s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* Aile du corbeau */
        #crow::before {
            content: '';
            position: absolute;
            width: 28px;
            height: 18px;
            background: linear-gradient(45deg, #4A4A4A, #2F2F2F, #1A1A1A);
            clip-path: polygon(0% 20%, 30% 0%, 70% 5%, 100% 30%, 90% 70%, 60% 100%, 20% 85%, 5% 50%);
            top: 5px;
            left: 2px;
            z-index: -1;
            animation: crow-wing-beat calc(0.15s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        /* ≈íil rouge du corbeau */
        #crow::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 5px;
            background: linear-gradient(135deg, #FF0000, #8B0000);
            clip-path: polygon(0% 40%, 30% 0%, 100% 20%, 80% 100%, 20% 80%);
            top: 9px;
            right: 8px;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
            animation: crow-evil-glow calc(1.5s / var(--animation-speed)) infinite;
        }

        /* COLOMBE √âL√âGANTE - ID: dove */
        #dove {
            width: 40px;
            height: 25px;
            background: linear-gradient(135deg, var(--dove-color), #F8F8FF, #E6E6FA);
            clip-path: polygon(15% 10%, 40% 0%, 85% 8%, 95% 35%, 90% 65%, 75% 90%, 25% 95%, 5% 60%, 10% 30%);
            animation: dove-auto-flight calc(3s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.15));
        }

        /* Aile de la colombe */
        #dove::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 12px;
            background: linear-gradient(45deg, #F8F8FF, #E6E6FA, #D6D6EA);
            clip-path: polygon(0% 30%, 25% 0%, 60% 5%, 85% 15%, 100% 40%, 95% 70%, 75% 100%, 40% 95%, 15% 85%, 5% 60%);
            top: 6px;
            left: 6px;
            z-index: -1;
            animation: dove-wing-beat calc(0.4s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.2));
        }

        /* ≈íil bleu de la colombe */
        #dove::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle at 30% 30%, #87CEEB, #4169E1);
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            top: 8px;
            right: 8px;
            box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
            animation: dove-sparkle calc(3s / var(--animation-speed)) infinite;
        }

        /* ANIMATIONS DU MODULE */
        @keyframes crow-auto-flight {
            0%, 100% {
                transform: translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: translateY(-15px) rotate(2deg) scale(var(--bird-scale));
            }
            50% {
                transform: translateY(-8px) rotate(-1deg) scale(var(--bird-scale));
            }
            75% {
                transform: translateY(-20px) rotate(1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-auto-flight-left {
            0%, 100% {
                transform: scaleX(-1) translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: scaleX(-1) translateY(-15px) rotate(-2deg) scale(var(--bird-scale));
            }
            50% {
                transform: scaleX(-1) translateY(-8px) rotate(1deg) scale(var(--bird-scale));
            }
            75% {
                transform: scaleX(-1) translateY(-20px) rotate(-1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-15deg) scaleX(1);
            }
            100% {
                transform: rotateY(-20deg) rotateZ(10deg) scaleX(1.1);
            }
        }

        @keyframes crow-evil-glow {
            0%, 100% {
                box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 0, 0, 1);
                filter: brightness(1.3);
            }
        }

        @keyframes dove-auto-flight {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(var(--bird-scale));
            }
            33% {
                transform: translateY(-12px) translateX(2px) scale(var(--bird-scale));
            }
            66% {
                transform: translateY(-8px) translateX(-1px) scale(var(--bird-scale));
            }
        }

        @keyframes dove-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-8deg) translateX(0px);
            }
            100% {
                transform: rotateY(-12deg) rotateZ(5deg) translateX(1px);
            }
        }

        @keyframes dove-sparkle {
            0%, 100% {
                box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 8px rgba(135, 206, 235, 0.8);
                filter: brightness(1.2);
            }
        }

    </style>
</head>
<body style="filter: brightness(0.7);">
    <div class="game-container">
        <canvas id="gameCanvas" width="449" height="799" style="width: 449px; height: 799px;"></canvas>

        <!-- CHARGER LES MODULES AVANT LE SCRIPT PRINCIPAL -->
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20save28092025_fichiers/kawaii_objects_module.js"></script>
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20save28092025_fichiers/secret-mode.js"></script>

        <!-- MODULE OISEAUX VOLANTS CSS -->
        <div class="flying-birds-overlay">
            <!-- Corbeau Badass -->
            <div id="crow" class="bird-base bird-visible" style="left: 218.333px; top: 286.979px; animation: crow-auto-flight-left calc(2s / var(--animation-speed)) infinite;"></div>

            <!-- Colombe √âl√©gante -->
            <div id="dove" class="bird-base bird-hidden"></div>
        </div>
        <div id="message" class="message" style="transform: translate(-50%, -50%) scale(1); display: none;">
                                üåü "On m'a dit qu'ils √©taient tous des monstres...
                                ‚ú® On m'a dit tant de mal, tant de malheurs sur eux...
                                üîç Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."

                                <button onclick="
                                    alert('üö´ NON on peut pas laisser passer √ßa ! üö´');

                                    // Gagner 50 points (syst√®me adaptatif)
                                    if (phaseJeu === 'tir_coeurs_haut') {
                                        pointsConnaissance += 50;
                                        console.log('50 pointsConnaissance ajout√©s ! Total:', pointsConnaissance);
                                    } else {
                                        score += 50;
                                        console.log('50 score ajout√©s ! Total:', score);
                                    }

                                    // Changer le bouton en NON !
                                    this.innerHTML = 'NON !';
                                    this.style.background = '#f44336';

                                    // Changer l'action du bouton pour les prochains clics
                                    this.onclick = function() {
                                        afficherMessage('üö´ NON ! On ne peut pas laisser passer √ßa ! üö´', 2000);
                                        // Gagner 10 points √† chaque clic sur NON
                                        if (phaseJeu === 'tir_coeurs_haut') {
                                            pointsConnaissance += 10;
                                            console.log('10 pointsConnaissance ajout√©s ! Total:', pointsConnaissance);
                                        } else {
                                            score += 10;
                                            console.log('10 score ajout√©s ! Total:', score);
                                        }
                                    };
                                " style="margin-top: 20px; padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    Passer
                                </button>
                            </div>
        <div id="etapeIndicateur" class="etape-indicateur show">
                    <div>üß± 4/16</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">Voyage ‚Äî L'ombre des nuages</div>
                </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            return { width, height };
        }

        let size = setupCanvas();
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: Math.max(Math.min(size.width, size.height) * 0.002, 1.5)
        };

        // Voyage de d√©couverte de la v√©rit√© - Le Jour : La Lumi√®re
        const JOUR = [
            { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: 'üó£Ô∏è Les manipulations s\'effacent devant la v√©rit√© !' },
            { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Non... des humains comme nous !' },
            { nom: 'PR√âJUG√âS', couleur: '#DDA0DD', msg: 'üé≠ Les masques tombent un √† un...' },
            { nom: 'PEURS', couleur: '#98FB98', msg: 'üëÅÔ∏è J\'ai choisi de voir par moi-m√™me !' },
            { nom: 'M√âFIANCE', couleur: '#FFCCCB', msg: 'ü§ù La m√©fiance c√®de √† la compation...' },
            { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '‚ùì Cette question hante mes nuits...' },
            { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: 'üëÅÔ∏è Et mes yeux se sont ouverts...' },
            { nom: 'UN P√àRE', couleur: '#FFDAB9', msg: 'üë® Un homme qui aime ses enfants...' },
            { nom: 'UNE M√àRE', couleur: '#AFEEEE', msg: 'üë© Une femme courageuse...' },
            { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: 'üë∂ Des rires purs et innocents...' },
            { nom: 'L\'HUMANIT√â', couleur: '#FFE4E1', msg: 'üí´ L\'essence m√™me de ce que nous sommes...' },
            { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '‚ù§Ô∏è Plus fort que toutes les barri√®res...' },
            { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: 'ü§ó Qui unit au-del√† des diff√©rences...' },
            { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: 'üåÖ Une lumi√®re dans l\'obscurit√©...' },
            { nom: 'LA PAIX', couleur: '#F5F5DC', msg: 'üïäÔ∏è Possible quand on choisis d\'aimer...' },
            { nom: 'COMME MOI', couleur: '#FFFACD', msg: 'üåç On est tous des immigr√©s...' }
        ];

        // La Nuit : L'Obscurit√© - Les maux qui tentent de corrompre
        const NUIT = [
            { nom: 'DISCORDES', couleur: '#8B0000', msg: '‚ö° Des discordes... des haines... des destructions...' },
            { nom: 'HAINES', couleur: '#4B0000', msg: 'üíî Venues avec les maux de l\'ombre...' },
            { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: 'üå™Ô∏è Le vol, le mensonge, la manipulation...' },
            { nom: 'VOL', couleur: '#36454F', msg: 'ü¶π Qui s\'empare de ce qui n\'appartient pas...' },
            { nom: 'MENSONGE', couleur: '#2F2F2F', msg: 'üé≠ Les masques de la tromperie...' },
            { nom: 'MANIPULATION', couleur: '#654321', msg: 'üï∑Ô∏è Les fils invisibles tirent les c≈ìurs...' },
            { nom: 'CUPIDIT√â', couleur: '#654321', msg: 'üí∞ La cupidit√© et l\'avidit√©...' },
            { nom: 'AVIDIT√â', couleur: '#483C32', msg: '‚õìÔ∏è Comme des cha√Ænes invisibles...' },
            { nom: 'CHA√éNES', couleur: '#2E4B2E', msg: 'üîó Serrant le c≈ìur des hommes...' },
            { nom: 'MURS DE FER', couleur: '#191970', msg: 'üß± Enferm√©s derri√®re des murs de fer et de peur...' },
            { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: 'üíö Le poison vert de l\'envie...' },
            { nom: 'ORGUEIL', couleur: '#191970', msg: 'üëë La couronne qui aveugle...' },
            { nom: 'COL√àRE', couleur: '#8B1538', msg: 'üî• Les flammes qui consument la raison...' },
            { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '‚öîÔ∏è La spirale sans fin de la souffrance...' },
            { nom: 'INDIFF√âRENCE', couleur: '#708090', msg: 'üßä Le froid qui glace les √¢mes...' },
            { nom: '√âGO√èSME', couleur: '#5D5D5D', msg: 'ü™û Ne voir que son propre reflet...' },
            { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: 'üôà Choisir de fermer les yeux...' },
            { nom: 'R√âSISTANCE', couleur: '#1C1C1C', msg: 'üõ°Ô∏è Mais je garde mon c≈ìur pur dans la temp√™te...' },
            { nom: 'LUMI√àRE', couleur: '#483D8B', msg: '‚ú® Car au-del√† des nuages, elle existe toujours...' }
        ];

        // Voyage actuel selon la p√©riode
        let VOYAGE = JOUR;

        // ===============================================
        // NOUVEAU SYST√àME DE NARRATION COMPLETE V2.0
        // ===============================================

        // Gestionnaire central de la narration
        class NarrationManager {
            constructor() {
                this.currentPhase = 1;
                this.isTransitioning = false;
                this.victoryTimers = new Map();
                this.phaseHistory = [];

                // Configuration des phases avec IDs uniques
                this.phases = [
                    {
                        id: 'VDV_NARR_P01_INTRO_LUMIERE',
                        phase: 1,
                        titre: 'Voyage ‚Äî L\'aube des doutes',
                        texte: "\"On m'a dit qu'ils √©taient tous des monstres...\nOn m'a dit tant de mal, tant de malheurs sur eux...\nMais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux.\"",
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P02_REVELATION_FAMILLE',
                        phase: 2,
                        titre: 'Voyage ‚Äî La lumi√®re',
                        texte: 'üí≠ "Qui √©taient-ils vraiment ?... Et j\'ai vu...\nUn p√®re... une m√®re... des enfants...\nTous cherchant simplement √† vivre leur meilleure vie... Comme moi."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'neon',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P03_TRANSITION_OBSCURITE',
                        phase: 3,
                        titre: 'Voyage ‚Äî L\'ombre des nuages',
                        texte: 'üí≠ "Alors, la lune apparut.\nLe ciel s\'assombrit comme une page br√ªl√©e par le temps.\nUn aileron fendit les vagues sombres...\nDes √©clairs z√©br√®rent les nuages gris."',
                        mode: 'coeurs',
                        duree: 8000,
                        transition: 'shadow3d',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P04_CHAPITRE2_NUAGES',
                        phase: 4,
                        titre: 'Voyage ‚Äî L\'ombre des nuages',
                        texte: 'üí≠ "Et avec eux vinrent des maux...\nDes discordes... des haines... des destructions...\nLe vol, le mensonge, la manipulation...\nLa cupidit√© et l\'avidit√©, comme des cha√Ænes invisibles,\nserrant le c≈ìur des hommes."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P05_MAUX_CHAINES',
                        phase: 5,
                        titre: 'Voyage ‚Äî Le silence de l\'√¢me',
                        texte: 'üí≠ "On m\'a dit de ne pas √©couter leurs cris.\nOn m\'a dit de ne pas laisser l\'orage me faire peur.\nCar l\'orage, aussi bruyant qu\'il soit,\nne dure jamais √©ternellement."',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'fire',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P06_ORAGE_TEMPORAIRE',
                        phase: 6,
                        titre: 'Voyage ‚Äî Le silence de l\'√¢me',
                        texte: 'üí≠ "Et si la temp√™te gronde,\nc\'est peut-√™tre pour rappeler √† l\'homme\nqu\'au-del√† des nuages, il existe toujours une lumi√®re.\nMais pour la voir, il faut d\'abord traverser la nuit."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P07_LUMIERE_NUAGES',
                        phase: 7,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'üí≠ "On m\'a dit...\nque l\'humanit√© n\'existait plus,\nqu\'elle s\'√©tait perdue dans les guerres et les rancunes.\nOn m\'a dit que les hommes n\'accueillaient plus personne,\nqu\'ils s\'enfermaient derri√®re des murs de fer et de peur."',
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'outline',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P08_CHAPITRE3_HUMANITE',
                        phase: 8,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'üí≠ "Mais moi, j\'ai vu‚Ä¶\nUne main tendue √† un √©tranger.\nUn sourire partag√© malgr√© la faim.\nUne porte ouverte pour celui qui tremblait dans la nuit."',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'digital',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P09_MAIN_TENDUE',
                        phase: 9,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'üí≠ "C\'est cela, l\'hospitalit√© :\nnon pas donner ce qu\'on a de trop,\nmais partager m√™me ce qui manque."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P10_HOSPITALITE',
                        phase: 10,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'üí≠ "On m\'a dit que la libert√© n\'√©tait qu\'un mot,\nune illusion que les puissants vendaient aux faibles.\nMais j\'ai vu‚Ä¶\nUn enfant courir pieds nus sous la pluie,\nriant sans cha√Ænes,\net dans ses rires, j\'ai compris que la libert√© vit d\'abord dans l\'√¢me."',
                        mode: 'coeurs',
                        duree: 8000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P11_LIBERTE_AME',
                        phase: 11,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'üí≠ "On m\'a dit que les hommes n\'aidaient plus,\nque chacun ne vivait que pour soi.\nMais j\'ai vu‚Ä¶\nDes inconnus soulever ensemble une pierre trop lourde,\net dans cette force partag√©e, j\'ai vu l\'amour na√Ætre."',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'neon',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P12_AMOUR_PARTAGE',
                        phase: 12,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'üí≠ "On m\'a dit que l\'amour √©tait fragile,\nmais j\'ai vu qu\'il est plus fort que la haine,\ncar il construit quand la haine d√©truit."',
                        mode: 'briques',
                        duree: 12000,
                        transition: 'fire',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P13_AMOUR_CONSTRUCTION',
                        phase: 13,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'üí≠ "On m\'a dit que la tol√©rance √©tait une faiblesse,\nmais j\'ai vu qu\'elle est une sagesse,\ncelle de reconna√Ætre que nous ne sommes pas tous semblables,\net que c\'est bien ainsi."',
                        mode: 'coeurs',
                        duree: 10000,
                        transition: 'shadow3d',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P14_TOLERANCE_SAGESSE',
                        phase: 14,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'üí≠ "La diversit√©‚Ä¶\nElle n\'est pas un danger,\nelle est un tr√©sor.\nComme les couleurs d\'un arc-en-ciel,\nc\'est leur diff√©rence qui fait na√Ætre la beaut√©."',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'typewriter',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P15_DIVERSITE_TRESOR',
                        phase: 15,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'üí≠ "Et dans ce m√©lange d\'humanit√©,\nj\'ai compris que nous sommes un seul peuple,\nli√© par la m√™me soif de vivre,\nde cr√©er,\net d\'aimer."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P16_UNITE_HUMANITE',
                        phase: 16,
                        titre: 'L\'Unit√© de l\'Humanit√©',
                        texte: 'üí≠ "Nous avons construit des murs l√† o√π il fallait des ponts.\nDress√© des fronti√®res l√† o√π coulaient des rivi√®res communes.\n\nMais quand enfin nous comprenons,\nquand les murs tombent dans nos c≈ìurs,\nquand la peur c√®de place √† la curiosit√©,\nna√Æt cette unit√© qui engendre la paix v√©ritable.\n\nNon pas l\'uniformit√© qui efface,\nmais l\'harmonie qui respecte chaque diff√©rence,\ncette paix qui grandit quand nous r√©alisons\nque nous ne sommes qu\'un seul peuple sous les √©toiles."\n\n‚ú® FIN ‚ú®',
                        mode: 'final',
                        duree: 12000,
                        transition: 'neon',
                        speed: 40
                    }
                ];
            }

            // Obtenir la phase actuelle
            getCurrentPhase() {
                // Trouver la phase par son num√©ro au lieu d'utiliser l'index
                return this.phases.find(phase => phase.phase === this.currentPhase) || null;
            }

            // Obtenir la phase par ID
            getPhaseById(id) {
                return this.phases.find(phase => phase.id === id) || null;
            }

            // Avancer √† la prochaine phase
            nextPhase() {
                // Trouver la phase suivante par num√©ro
                const nextPhaseNumber = this.currentPhase + 1;
                const nextPhase = this.phases.find(phase => phase.phase === nextPhaseNumber);

                if (nextPhase) {
                    this.currentPhase = nextPhaseNumber;
                    return true;
                } else {
                    return false; // Fin de la narration
                }
            }

            // R√©initialiser la narration
            reset() {
                console.log(`[DEBUG] reset() appel√© - retour currentPhase √† 1`);
                this.currentPhase = 1;
                this.phaseHistory = [];
                this.isTransitioning = false;
                this.victoryTimers.clear();
                this.hideStepIndicator();
            }

            // D√©marrer la narration
            start() {
                console.log(`[DEBUG] start() appel√© - appel reset() puis executeCurrentPhase()`);
                console.trace(`[DEBUG] Trace de l'appel start():`);
                this.reset();
                this.executeCurrentPhase();
            }

            // Ex√©cuter la phase actuelle
            executeCurrentPhase() {
                const phase = this.getCurrentPhase();
                if (!phase) {
                    this.finalizeNarration();
                    return;
                }

                // Afficher le titre du voyage au d√©but de la phase
                this.afficherTitreVoyage();

                console.log(`[NARRATION] Ex√©cution phase ${phase.phase}: ${phase.id}`);
                this.phaseHistory.push(phase.id);

                this.isTransitioning = true;

                // Mettre √† jour l'indicateur d'√©tape
                this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                // La narration est maintenant g√©r√©e dans chaque setup de mode
                // Pour les modes non-interactifs, programmer un nextPhase automatique
                if (phase.mode !== 'coeurs' && phase.mode !== 'briques' && phase.mode !== 'nuit_coeurs' && phase.mode !== 'etoiles') {
                    setTimeout(() => {
                        this.nextPhase();
                        this.executeCurrentPhase();
                    }, phase.duree);
                }

                // Configurer le mode de jeu
                this.configureGameMode(phase.mode);

                // Marquer la transition comme termin√©e apr√®s configuration
                this.isTransitioning = false;
            }

            // Afficher le titre du voyage
            afficherTitreVoyage() {
                const phase = this.currentPhase;
                let voyageNom = '';

                if (phase === 1) {
                    voyageNom = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageNom = 'La lumi√®re';
                } else if (phase >= 3 && phase <= 4) {
                    voyageNom = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageNom = 'Le silence de l\'√¢me';
                } else if (phase >= 7 && phase <= 9) {
                    voyageNom = 'L\'humanit√© des c≈ìurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageNom = 'La sagesse des diff√©rences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageNom = 'L\'unit√©';
                } else if (phase === 16) {
                    voyageNom = 'Animation finale';
                }

                if (voyageNom) {
                    titreVoyage.active = true;
                    titreVoyage.texte = voyageNom + '\nPhase ' + phase;
                    titreVoyage.fin = Date.now() + 5000; // 5 secondes
                }
            }

            // Afficher message narratif simple centr√©
            afficherMessageAnime(texte, animation = 'emboss', speed = 45, onComplete) {
                // Utiliser notre nouveau syst√®me simple centr√©
                afficherMessageNarratifSimple(texte, 12000);

                // Appeler onComplete apr√®s la dur√©e du message si fourni
                if (onComplete) {
                    setTimeout(onComplete, 12000);
                }

                return; // Sortir pour √©viter l'ancien code

                switch(animation) {
                    case 'emboss':
                        anim.setColors('#ffffff', '#666666');
                        anim.applyEffect('emboss');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'neon':
                        anim.setColors('#64ffda', '#4da6ff');
                        anim.applyEffect('neon');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'shadow3d':
                        anim.setColors('#ffffff', '#333333');
                        anim.applyEffect('shadow3d');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'glitch':
                        anim.setColors('#ff4444', '#ff6666');
                        anim.applyEffect('glitch');
                        anim.digital(texte, speed, onComplete);
                        break;
                    case 'fire':
                        anim.setColors('#ff4444', '#ff8800');
                        anim.applyEffect('fire');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'ice':
                        anim.setColors('#ffffff', '#ffffff');
                        anim.applyEffect('none');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    default:
                        anim.typewriter(texte, speed, onComplete);
                        break;
                }

                // Note: isTransitioning est maintenant remis √† false directement dans executeCurrentPhase
            }

            // Mettre √† jour l'indicateur d'√©tape
            updateStepIndicator(phase, titre, mode) {
                const indicateur = document.getElementById('etapeIndicateur');
                if (!indicateur) return;

                // Ic√¥ne selon le mode
                let icone = '';
                switch(mode) {
                    case 'coeurs': icone = 'üíñ'; break;
                    case 'nuit_coeurs': icone = 'üåôüíñ'; break;
                    case 'briques': icone = 'üß±'; break;
                    case 'etoiles': icone = '‚≠ê'; break;
                    case 'final': icone = '‚ú®'; break;
                    default: icone = 'üìñ'; break;
                }

                // Mettre √† jour le contenu
                indicateur.innerHTML = `
                    <div>${icone} ${phase}/16</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">${titre}</div>
                `;

                // Afficher l'indicateur
                indicateur.classList.add('show');
            }

            // Cacher l'indicateur d'√©tape
            hideStepIndicator() {
                const indicateur = document.getElementById('etapeIndicateur');
                if (indicateur) {
                    indicateur.classList.remove('show');
                }
            }

            // Configurer le mode de jeu selon la phase
            configureGameMode(mode) {
                // Ne pas reconfigurer si on est d√©j√† dans le bon mode
                if (phaseJeu === mode ||
                    (mode === 'coeurs' && phaseJeu === 'tir_coeurs_haut') ||
                    (mode === 'nuit_coeurs' && phaseJeu === 'tir_coeurs_nuit') ||
                    (mode === 'briques' && phaseJeu === 'lanterne') ||
                    (mode === 'etoiles' && phaseJeu === 'stars')) {
                    console.log(`[DEBUG] D√©j√† dans le bon mode: ${phaseJeu} pour ${mode}`);
                    return;
                }

                switch(mode) {
                    case 'coeurs':
                        this.setupCoeursMode();
                        break;
                    case 'nuit_coeurs':
                        this.setupNuitCoeursMode();
                        break;
                    case 'briques':
                        this.setupBriquesMode();
                        break;
                    case 'etoiles':
                        this.setupEtoilesMode();
                        break;
                    case 'final':
                        this.setupFinalMode();
                        break;
                }
            }

            // D√©terminer la p√©riode selon la phase (P3, P4, P5, P6, P11, P12 = nuit)
            getPeriodeFromPhase(phaseNumber) {
                return (phaseNumber === 3 || phaseNumber === 4 || phaseNumber === 5 ||
                        phaseNumber === 6 || phaseNumber === 11 || phaseNumber === 12) ? 'nuit' : 'jour';
            }

            // Configuration mode c≈ìurs
            setupCoeursMode() {
                console.log(`[DEBUG] setupCoeursMode appel√© - currentPhase: ${this.currentPhase}`);
                const phase = this.getCurrentPhase();
                console.log(`[DEBUG] setupCoeursMode - phase:`, phase);

                // Afficher la narration de d√©but
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Reset effet nuit
                document.body.style.filter = '';
            }

            // Configuration mode nuit c≈ìurs (parties ambigu√´s)
            setupNuitCoeursMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de d√©but
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet visuel de nuit - assombrir le fond
                document.body.style.filter = 'brightness(0.7)';
            }

            // Configuration mode briques
            setupBriquesMode() {
                console.log(`[DEBUG] setupBriquesMode - currentPhase: ${this.currentPhase}`);
                const phase = this.getCurrentPhase();
                console.log(`[DEBUG] setupBriquesMode - phase:`, phase);

                // Afficher la narration de d√©but avec un d√©lai pour √©viter le conflit avec le titre
                setTimeout(() => {
                    this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);
                }, 4500); // Attendre que le titre de voyage disparaisse

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;

                // En mode nuit, activer les √©toiles tirables en plus des briques
                if(periode === 'nuit') {
                    phaseJeu = 'stars'; // Mode √©toiles tirables dans la nuit
                } else {
                    phaseJeu = 'lanterne'; // Mode classique casse-briques avec lanterne
                    balle.visible = true;
                    balle.enAttente = true;
                    balle.dx = 0;
                    balle.dy = 0;
                }

                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
                // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                // lanterne.active et lanterne.intensite conserv√©s

                // Appliquer effet nuit si n√©cessaire
                if(periode === 'nuit') {
                    document.body.style.filter = 'brightness(0.7)';
                } else {
                    document.body.style.filter = '';
                }
            }

            // Configuration mode √©toiles
            setupEtoilesMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de d√©but
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'stars';
                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
            }

            // Configuration mode final
            setupFinalMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de d√©but
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                setTimeout(() => {
                    this.finalizeNarration();
                }, phase.duree + 2000);
            }

            // Finaliser la narration
            finalizeNarration() {
                phaseJeu = 'feux_artifice';
                jeu = false;

                // Cacher l'indicateur d'√©tape
                this.hideStepIndicator();

                // S√©quence finale avec feux d'artifice
                if (droneModule) {
                    const formations = ['hexagon', 'star', 'heart', 'cross'];
                    const formationsChoixies = [];

                    for(let i = 0; i < 3; i++) {
                        const index = Math.floor(Math.random() * formations.length);
                        formationsChoixies.push(formations[index]);
                    }

                    formationsChoixies.forEach((formation, index) => {
                        setTimeout(() => {
                            const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                            const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                            droneModule.moveFormationTo(x, y);
                            droneModule.setFormation(formation);

                            setTimeout(() => {
                                droneModule.explode(x, y);
                            }, 800);
                        }, index * 1500);
                    });
                }

                setTimeout(() => {
                    this.showFinalMenu();
                }, 6000);
            }

            // G√©n√©rer un r√©sum√© √©l√©gant en 3 lignes
            generateElegantSummary() {
                const completedCount = Math.min(this.currentPhase, this.phases.length);
                const progressPercent = Math.round((completedCount / this.phases.length) * 100);

                return `
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05)); border-radius: 12px; border: 1px solid rgba(100,255,218,0.3);">
                        <div style="color: #64ffda; font-size: 16px; font-weight: 600; margin-bottom: 6px;">
                            ‚ú® ${completedCount}/16 CHAPITRES (${progressPercent}%) ‚ú®
                        </div>
                        <div style="color: #ffffff; font-size: 14px; margin: 4px 0; opacity: 0.9;">
                            üìö De "La Lumi√®re" √† "L'Unit√© de l'Humanit√©"
                        </div>
                        <div style="color: #cccccc; font-size: 12px; font-style: italic; opacity: 0.8;">
                            Un voyage √† travers la v√©rit√© de l'humanit√©
                        </div>
                    </div>
                `;
            }

            // Afficher le menu final
            showFinalMenu() {
                const msg = document.getElementById('message');
                msg.classList.remove('narratif');
                msg.classList.add('show');
                msg.style.transform = 'translate(-50%, -50%) scale(1)';
                msg.style.transition = '';

                const summaryHTML = this.generateElegantSummary();

                const boutonsHTML = `
                    <div style="margin-top: 15px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="narrationManager.restart()"
                                style="background: linear-gradient(45deg, #64ffda, #4da6ff);
                                       color: #1a1a1a; border: none; padding: 12px 24px;
                                       border-radius: 25px; font-size: 14px; font-weight: 600;
                                       cursor: pointer; transform: scale(1);
                                       transition: all 0.3s ease;
                                       box-shadow: 0 3px 10px rgba(100,255,218,0.3);
                                       text-shadow: 0 1px 2px rgba(0,0,0,0.2);
                                       letter-spacing: 0.5px;">
                            üîÑ Recommencer
                        </button>
                    </div>
                `;

                const titleHTML = `
                    <div style="text-align: center; margin-bottom: 8px;">
                        <div style="color: #64ffda; text-shadow: 0 0 10px rgba(100,255,218,0.8); margin: 0; font-size: 22px; font-weight: 600; letter-spacing: 1px;">
                            üëÅÔ∏è VOIR LA V√âRIT√â
                        </div>
                        <div style="color: #ffffff; margin: 5px 0; font-size: 16px; font-weight: 300; opacity: 0.9;">
                            Aventure termin√©e ‚ú®
                        </div>
                    </div>
                `;

                msg.innerHTML = titleHTML + summaryHTML + boutonsHTML;
            }

            // Red√©marrer la narration
            restart() {
                cacherMessage();

                // R√©initialiser compl√®tement
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                score = 0;
                vies = 3;
                brises = 0;
                jeu = false;

                // R√©initialiser les syst√®mes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les √©l√©ments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // Continuer √† la phase courante apr√®s un d√©lai (sans reset)
                setTimeout(() => {
                    this.executeCurrentPhase();
                }, 1000);
            }

            // Fonction appel√©e √† la fin d'une phase
            onPhaseComplete() {
                if (this.isTransitioning) return;

                // Cr√©er un timer de victoire unique
                const timerId = `victory_${Date.now()}_${Math.random()}`;

                this.victoryTimers.set(timerId, setTimeout(() => {
                    this.victoryTimers.delete(timerId);
                    // R√©initialiser les compteurs pour la prochaine phase
                    brises = 0;

                    if (this.nextPhase()) {
                        this.executeCurrentPhase();
                    } else {
                        this.finalizeNarration();
                    }
                }, 1500));
            }

            // M√©thode pour avancer directement √† la phase suivante sans narration
            goToNextPhase() {
                if (this.isTransitioning) return;

                console.log(`[DEBUG] goToNextPhase - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    console.log(`[DEBUG] goToNextPhase - currentPhase apr√®s nextPhase: ${this.currentPhase}`);
                    this.executeCurrentPhase();
                } else {
                    this.finalizeNarration();
                }
            }

            // Progression directe sans narration - pour la fin des modes
            goToNextPhaseDirect() {
                if (this.isTransitioning) {
                    console.log('üö´ Transition d√©j√† en cours, ignore goToNextPhaseDirect');
                    return;
                }

                console.log(`üé¨ goToNextPhaseDirect - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    console.log(`‚úÖ goToNextPhaseDirect - currentPhase apr√®s nextPhase: ${this.currentPhase}`);
                    const phase = this.getCurrentPhase();
                    if (phase) {
                        // Afficher le titre du voyage
                        this.afficherTitreVoyage();

                        // Mettre √† jour l'indicateur d'√©tape
                        this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                        console.log(`[DEBUG] Configuration mode ${phase.mode} pour phase ${phase.phase}: ${phase.id}`);

                        // Configurer directement le mode de jeu
                        this.configureGameMode(phase.mode);

                        // Marquer la transition comme termin√©e apr√®s tout
                        setTimeout(() => {
                            this.isTransitioning = false;
                        }, 100);
                    }
                } else {
                    this.finalizeNarration();
                }
            }

            // Alias pour compatibilit√© avec l'ancien code
            onLevelComplete() {
                this.onPhaseComplete();
            }
        }

        // Instance globale du gestionnaire de narration
        const narrationManager = new NarrationManager();

        // ===============================================
        // COMPATIBILIT√â AVEC L'ANCIEN SYST√àME
        // ===============================================

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.03,
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au d√©but - les drones restent hors √©cran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors √©cran √† gauche
                        -100, // Commencer hors √©cran en haut
                        i
                    ));
                }
            }

            setFormation(formation) {
                this.currentFormation = formation;
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                this.drones.forEach(drone => {
                    drone.firework();
                });

                setTimeout(() => {
                    this.createDrones();
                    this.setFormation(this.currentFormation);
                }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const starRadius = (i % 2 === 0) ? size : size * 0.6;
                            positions.push({
                                x: centerX + Math.cos(angle) * starRadius,
                                y: centerY + Math.sin(angle) * starRadius
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // Animation s√©par√©e pour mise √† jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options);
                });
            }

            render() {
                // Rendu s√©par√© √† appeler depuis la boucle de jeu
                this.drones.forEach(drone => {
                    drone.draw(this.ctx, this.options);
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options) {
                if (this.inExplosion) {
                    this.x += this.explosionVelX;
                    this.y += this.explosionVelY;
                    this.explosionVelY += 0.3;
                    this.life -= 0.015;
                    if (this.life <= 0) this.life = 0;
                } else {
                    this.x += (this.targetX - this.x) * options.speed;
                    this.y += (this.targetY - this.y) * options.speed;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) this.trail.shift();
                }

                this.brightness = 0.6 + Math.sin(Date.now() * 0.008 + this.id) * 0.2;
            }

            draw(ctx, options) {
                if (this.life <= 0) return;

                if (options.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color + '60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                const glowSize = 8 + Math.sin(Date.now() * 0.004 + this.id) * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, this.color + Math.floor(this.brightness * this.life * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(0.8, this.color + '30');
                gradient.addColorStop(1, this.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapt√© pour int√©gration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentIndex = 0;
                this.timeoutId = null;
                this.text = '';
                this.options = {};
            }

            // Configuration des couleurs
            setColors(element, textColor = '#ffffff', effectColor = '#64ffda') {
                element.style.setProperty('--ta-text-color', textColor);
                element.style.setProperty('--ta-effect-color', effectColor);
                element.style.color = textColor;
            }

            // Arr√™te l'animation
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
            }

            // Reset
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.text = '';
            }

            // Animation machine √† √©crire avec support HTML complet
            typewriter(element, text, speed = 50, onComplete = null) {
                console.log('TextAnimationModule.typewriter appel√© avec:', {text: text.substring(0, 50), speed, element});
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';
                this.isRunning = true;
                console.log('D√©marrage _typewriterStep');

                this._typewriterStep(element);
            }

            _typewriterStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    // Gestion des balises HTML et des \n
                    let currentChar = this.text.charAt(this.currentIndex);

                    // Si on trouve une balise HTML, on l'ajoute enti√®rement
                    if (currentChar === '<') {
                        let tagEnd = this.text.indexOf('>', this.currentIndex);
                        if (tagEnd !== -1) {
                            let fullTag = this.text.substring(this.currentIndex, tagEnd + 1);
                            element.innerHTML += fullTag;
                            this.currentIndex = tagEnd + 1;
                        } else {
                            element.innerHTML += currentChar;
                            this.currentIndex++;
                        }
                    } else if (currentChar === '\n') {
                        // G√©rer les sauts de ligne
                        element.innerHTML += '<br>';
                        this.currentIndex++;
                    } else {
                        element.innerHTML += currentChar;
                        this.currentIndex++;
                    }

                    this.timeoutId = setTimeout(() => this._typewriterStep(element), this.options.speed);
                } else {
                    element.style.borderRight = 'none';
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                }
            }

            // Animation fade avec support HTML
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                element.innerHTML = text.replace(/\n/g, '<br>');
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 50);

                setTimeout(() => {
                    element.style.transition = '';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Animation digital avec support HTML
            digital(element, text, speed = 50, onComplete = null) {
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                this.isRunning = true;

                this._digitalStep(element);
            }

            _digitalStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    let displayText = '';
                    let textOnly = this.text.replace(/<[^>]*>/g, '').replace(/\n/g, ' '); // Texte sans balises
                    let currentTextIndex = 0;

                    // Reconstitue le texte avec balises jusqu'√† la position actuelle
                    for (let i = 0; i < this.text.length && currentTextIndex < this.currentIndex; i++) {
                        if (this.text.charAt(i) === '<') {
                            let tagEnd = this.text.indexOf('>', i);
                            if (tagEnd !== -1) {
                                displayText += this.text.substring(i, tagEnd + 1);
                                i = tagEnd;
                            }
                        } else if (this.text.charAt(i) === '\n') {
                            displayText += '<br>';
                            currentTextIndex++;
                        } else {
                            displayText += this.text.charAt(i);
                            currentTextIndex++;
                        }
                    }

                    // Ajoute un caract√®re al√©atoire si on n'est pas √† la fin
                    if (this.currentIndex < textOnly.length) {
                        const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }

                    element.innerHTML = displayText;

                    setTimeout(() => {
                        this.currentIndex++;
                        if (this.currentIndex < textOnly.length) {
                            this.timeoutId = setTimeout(() => this._digitalStep(element), this.options.speed);
                        } else {
                            element.innerHTML = this.text.replace(/\n/g, '<br>');
                            this.isRunning = false;
                            if (this.options.onComplete) this.options.onComplete();
                        }
                    }, this.options.speed / 2);
                }
            }

            // Animation glitch avec support HTML
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();

                // Effet de glitch en pr√©servant le HTML
                let textOnly = text.replace(/<[^>]*>/g, '').replace(/\n/g, ' ');
                let glitchText = '';
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';

                // Reconstitue le texte avec des caract√®res glitch
                for (let i = 0; i < text.length; i++) {
                    if (text.charAt(i) === '<') {
                        let tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            glitchText += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text.charAt(i) === '\n') {
                        glitchText += '<br>';
                    } else {
                        if (Math.random() < 0.1 && text.charAt(i) !== ' ') {
                            glitchText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        } else {
                            glitchText += text.charAt(i);
                        }
                    }
                }

                element.innerHTML = glitchText;
                element.style.animation = 'ta-glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas d√©j√† pr√©sentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes ta-glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.innerHTML = text.replace(/\n/g, '<br>');
                    element.style.animation = 'none';
                    if (onComplete) onComplete();
                }, duration);
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé¨ NOUVELLE CLASSE TEXTANIMATOR OPTIMIS√âE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class TextAnimator {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('TextAnimator: Element non trouv√©:', elementId);
                    return;
                }
                this.reset();
            }

            // √âtat et m√©thodes utilitaires optimis√©es
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.element.innerHTML = '';
                // Garder les classes originales du message
                const originalClasses = this.element.className;
                this.element.className = originalClasses.replace(/ta-\w+/g, '').trim();
            }

            stop() {
                this.isRunning = false;
                if (this.timeoutId) clearTimeout(this.timeoutId);
            }

            setColors(textColor = '#ffffff', effectColor = '#64ffda') {
                this.element.style.setProperty('--ta-text-color', textColor);
                this.element.style.setProperty('--ta-effect-color', effectColor);
                this.element.style.color = textColor;
            }

            applyEffect(effect = 'none') {
                const effects = ['shadow3d', 'neon', 'emboss', 'outline', 'fire', 'ice'];
                effects.forEach(e => this.element.classList.remove(`ta-effect-${e}`));
                if (effect !== 'none') this.element.classList.add(`ta-effect-${effect}`);
            }

            // Animation machine √† √©crire optimis√©e
            typewriter(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-typewriter');
                this.isRunning = true;
                this._typewriterStep();
            }

            _typewriterStep() {
                if (!this.isRunning || this.currentIndex >= this.text.length) {
                    this.element.classList.remove('ta-typewriter');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                const char = this.text.charAt(this.currentIndex);
                if (char === '<') {
                    const tagEnd = this.text.indexOf('>', this.currentIndex);
                    if (tagEnd !== -1) {
                        this.element.innerHTML += this.text.substring(this.currentIndex, tagEnd + 1);
                        this.currentIndex = tagEnd + 1;
                    } else {
                        this.element.innerHTML += char;
                        this.currentIndex++;
                    }
                } else if (char === '\n') {
                    this.element.innerHTML += '<br>';
                    this.currentIndex++;
                } else {
                    this.element.innerHTML += char;
                    this.currentIndex++;
                }

                this.timeoutId = setTimeout(() => this._typewriterStep(), this.options.speed);
            }

            // Animation code digital optimis√©e
            digital(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-digital');
                this.isRunning = true;
                this._digitalStep();
            }

            _digitalStep() {
                if (!this.isRunning) return;

                const textOnly = this.text.replace(/<[^>]*>/g, '');
                if (this.currentIndex >= textOnly.length) {
                    this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                let displayText = this._buildHtmlText(this.currentIndex);
                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                displayText += digitalChars[Math.floor(Math.random() * digitalChars.length)];

                this.element.innerHTML = displayText;

                setTimeout(() => {
                    this.currentIndex++;
                    if (this.currentIndex < textOnly.length) {
                        this.timeoutId = setTimeout(() => this._digitalStep(), this.options.speed);
                    } else {
                        this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                        this.isRunning = false;
                        if (this.options.onComplete) this.options.onComplete();
                    }
                }, this.options.speed / 2);
            }

            // Animation fade
            fade(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-fade-in');
                this.element.innerHTML = text.replace(/\n/g, '<br>');

                setTimeout(() => {
                    this.element.classList.remove('ta-fade-in');
                    if (this.options.onComplete) this.options.onComplete();
                }, 1000);
            }

            // Animation glitch optimis√©e
            glitch(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-glitch');

                const glitchText = this._createGlitchText(text);
                this.element.innerHTML = glitchText;

                this.timeoutId = setTimeout(() => {
                    this.element.innerHTML = text.replace(/\n/g, '<br>');
                    this.element.classList.remove('ta-glitch');
                    if (this.options.onComplete) this.options.onComplete();
                }, this.options.speed * 5);
            }

            // M√©thodes utilitaires optimis√©es
            setupAnimation(text, options) {
                this.text = text;
                this.options = {
                    speed: options.speed || 50,
                    textColor: options.textColor || '#ffffff',
                    effectColor: options.effectColor || '#64ffda',
                    effect: options.effect || 'none',
                    onComplete: options.onComplete
                };
                this.reset();
                this.setColors(this.options.textColor, this.options.effectColor);
                this.applyEffect(this.options.effect);
            }

            _buildHtmlText(index) {
                let result = '';
                let textIndex = 0;
                for (let i = 0; i < this.text.length && textIndex < index; i++) {
                    if (this.text[i] === '<') {
                        const tagEnd = this.text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += this.text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (this.text[i] === '\n') {
                        result += '<br>';
                        textIndex++;
                    } else {
                        result += this.text[i];
                        textIndex++;
                    }
                }
                return result;
            }

            _createGlitchText(text) {
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '<') {
                        const tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text[i] === '\n') {
                        result += '<br>';
                    } else if (Math.random() < 0.1 && text[i] !== ' ') {
                        result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        result += text[i];
                    }
                }
                return result;
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;

        // Rendre score accessible globalement pour les modules
        window.score = score;
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (value) => { score = value; }
        });
        let titreVoyage = { active: false, texte: '', fin: 0 }; // Affichage titre voyage
        let raquette = {}, balle = {}, briques = [], particules = [];
        let starsProjectiles = []; // Projectiles √©toiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles √©toiles (phase briques) - commence √† 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let coeursBateau = []; // C≈ìurs lanc√©s par le bateau
        let derniereCreeRafale = 0; // Temps de la derni√®re rafale
        let petitsCoeurs = []; // Petits c≈ìurs d√©coratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause apr√®s explosion
        let textesVolants = []; // Textes qui montent au ciel
        let corbeau = { actif: false, x: 0, y: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000, direction: 1 }; // Corbeau secret (10s pour test)
        let soleil = { clignotement: false, tempsClignotement: 0 }; // √âtat du soleil
        let multiplicateurPuissance = 1; // Cheat code x10 puissance
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition
        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let secretModeModule = null; // Module mode secret
        // let kawaiiObjectsModule = null; // SUPPRIM√â - utilisation via module secret seulement
        let modeNarration = true; // Mode narration actif au d√©but
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Syst√®me de messages narratifs
        let periode = 'jour'; // P√©riode actuelle : 'jour' ou 'nuit'
        let transitionPeriode = { active: false, progression: 0 };
        let phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() }; // Phase d'introduction
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de c≈ìurs vers les petits c≈ìurs du haut (phase d'√©veil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'√©toiles vers les briques en mode nuit (phase de r√©v√©lation)
         * 4. 'feux_artifice' : C√©l√©bration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: true,
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: 0,
            dureeArret: 20000 // 20 secondes d'arr√™t
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.0006, 0.4); // Vitesse r√©duite 10x

            // Les objets kawaii seront activ√©s apr√®s l'animation d'intro
            // activerObjetsKawaii(); // Trop t√¥t, on attend la fin de l'intro

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 8,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Initialiser les gestionnaires d'√©v√©nements des oiseaux CSS
            setupBirdClickHandlers();

            // Initialiser le module mode secret
            initSecretModeModule();

            // Les objets kawaii sont maintenant g√©r√©s par le module secret seulement

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors √©cran √† gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = Date.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            munitions = 0; // Commencer sans munitions en phase stars
            rechargement = 0;

            briques = [];

            // Cr√©er les briques si on est en phase stars (nuit) - FORC√â
            if(phaseJeu === 'stars') {
                // FORCER l'arr√™t de tous les syst√®mes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                // Introduction termin√©e

                // Les objets kawaii sont r√©serv√©s au mode secret seulement
                // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                // FORCER la cr√©ation des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Cr√©er
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les c≈ìurs
            const zoneW = C.W - 40;

            // Positions dispers√©es et tailles diff√©rentes pour chaque c≈ìur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront cr√©√©es √† partir des petits c≈ìurs du haut
            // Initialisation vide, elles appara√Ætront lors du d√©doublement des c≈ìurs
            briques = [];
            particules = [];
            powerUps = [];
            // Garder l'√©tat de la lanterne pendant initJeu() - ne pas la remettre √† z√©ro
            // lanterne conserve son √©tat pr√©c√©dent
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propri√©t√©s selon la phase
            if(phaseJeu === 'lanterne') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au d√©but
                    dy: 0, // Immobile au d√©but
                    visible: true, // Visible en phase lanterne
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles √©toiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Cr√©er les 10 petits c≈ìurs d√©coratifs en haut (seulement en mode coeurs)
            if(phaseJeu !== 'lanterne' && phaseJeu !== 'stars') {
                creerPetitsCoeurs();
            }

            // Cacher les c≈ìurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'√©toile principale - utiliser les projectiles stars

            // R√©initialiser la phase d'intro (activ√©e apr√®s l'animation du bateau)
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (!animationBateau.active) return;

            const tempsActuel = Date.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arriv√©e depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arriv√©e fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arriv√© au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // Intro d√©j√† g√©r√©e par gererPhaseIntro()
                        // narrationManager.start();
                    }
                    break;

                case 'arret':
                    // Bateau arr√™t√©, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de d√©part vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'√©cran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation termin√©e, d√©marrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        // Introduction termin√©e // Phase de jeu

                        // Les objets kawaii sont r√©serv√©s au mode secret seulement
                        // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                        // Repositionner le bateau normalement et d√©marrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;
                        jeu = true; // Activer le jeu
                        phaseJeu = 'tir_coeurs_haut'; // Commencer par la premi√®re phase

                        // R√©v√©ler les petits c≈ìurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre √† jour l'√©toile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            if (!phaseIntro.active) {
                // Intro termin√©e - comportement normal
                return;
            }

            const tempsEcoule = Date.now() - phaseIntro.tempsDebut;
            console.log(`üîÑ gererPhaseIntro: √©tape=${phaseIntro.etape}, temps=${tempsEcoule}ms`);

            if (phaseIntro.etape === 'arrivee_bateau') {
                // Phase d'introduction: D√©marrer l'intro tr√®s rapidement
                if (tempsEcoule >= 200) { // R√©duire √† 0.2 seconde
                    // D√©marrer le syst√®me narratif avec la premi√®re phase (une seule fois)
                    if (narrationManager && !window.narrationStarted) {
                        window.narrationStarted = true; // Marquer comme d√©j√† d√©marr√©
                        console.log('üéØ D√©marrage forc√© de l\'intro narrative');

                        // Forcer l'affichage de l'intro imm√©diatement
                        if (narrationManager.narrativeData && narrationManager.narrativeData.phases) {
                            console.log('‚úÖ Donn√©es narratives disponibles, d√©marrage normal');
                            narrationManager.start();
                        } else {
                            console.log('‚ö†Ô∏è Donn√©es narratives non disponibles, affichage intro forc√©');


                            // Affichage direct de l'intro Phase 1
                            afficherMessage(`
                                üåü "On m'a dit qu'ils √©taient tous des monstres...
                                ‚ú® On m'a dit tant de mal, tant de malheurs sur eux...
                                üîç Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."

                                <button onclick="
                                    alert('üö´ NON on peut pas laisser passer √ßa ! üö´');

                                    // Gagner 50 points (syst√®me adaptatif)
                                    if (phaseJeu === 'tir_coeurs_haut') {
                                        pointsConnaissance += 50;
                                        console.log('50 pointsConnaissance ajout√©s ! Total:', pointsConnaissance);
                                    } else {
                                        score += 50;
                                        console.log('50 score ajout√©s ! Total:', score);
                                    }

                                    // Changer le bouton en NON !
                                    this.innerHTML = 'NON !';
                                    this.style.background = '#f44336';

                                    // Changer l'action du bouton pour les prochains clics
                                    this.onclick = function() {
                                        afficherMessage('üö´ NON ! On ne peut pas laisser passer √ßa ! üö´', 2000);
                                        // Gagner 10 points √† chaque clic sur NON
                                        if (phaseJeu === 'tir_coeurs_haut') {
                                            pointsConnaissance += 10;
                                            console.log('10 pointsConnaissance ajout√©s ! Total:', pointsConnaissance);
                                        } else {
                                            score += 10;
                                            console.log('10 score ajout√©s ! Total:', score);
                                        }
                                    };
                                "
                                        style="margin-top: 20px; padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    Passer
                                </button>
                            `, 12000);
                        }
                    }
                    phaseIntro.etape = 'rafales';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'rafales') {
                // Phase 1: R√©duire l'attente pour un flux plus rapide
                if (tempsEcoule >= 1000) { // R√©duire de 2s √† 1s
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                if (tempsEcoule >= 1000) {
                    phaseIntro.active = false;
                    jeu = true; // D√©marrer le jeu
                    // Ne pas forcer le mode - conserver le mode d√©j√† configur√© par narrationManager
                    // Message g√©r√© par le nouveau syst√®me narratif
                }
            }
        }

        // Interface int√©gr√©e compl√®te
        function dessinerInterface() {
            ctx.save();

            // Header optimis√© tr√®s compact - bleu roi
            const headerH = Math.max(C.H * 0.045, 32);
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.fillRect(0, 0, C.W, headerH);

            // Lignes ondul√©es en fond transparent blanc
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const waveY = headerH * (0.2 + i * 0.3);
                const waveLength = C.W / 8;
                for(let x = 0; x <= C.W; x += 10) {
                    const y = waveY + Math.sin((x / waveLength) * Math.PI * 2) * 3;
                    if(x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();

            // Bordure header
            ctx.strokeStyle = '#3b82f6'; // Bordure bleu plus clair
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre centr√© en hauteur
            const titleY = headerH / 2 + 4; // Centr√© verticalement dans le header
            const iconSize = Math.max(C.H * 0.008, 8); // Tr√®s petits bateaux

            ctx.save();
            // Titre moderne et plus gros
            ctx.fillStyle = '#ffffff';
            ctx.font = `800 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = '2px';
            ctx.fillText('PETIT BATEAU', C.W/2, titleY);

            // Tr√®s petits bateaux discrets
            const leftBoatX = C.W/2 - 120;
            const rightBoatX = C.W/2 + 120;
            drawBoatIcon(ctx, leftBoatX, titleY - iconSize, iconSize, 'red');
            drawBoatIcon(ctx, rightBoatX, titleY - iconSize, iconSize, 'blue');
            ctx.restore();

            // Afficher le titre du voyage si actif
            if (titreVoyage.active && Date.now() < titreVoyage.fin) {
                const voyageY = Math.max(C.H * 0.10, 70); // Tr√®s l√©g√®rement plus bas
                ctx.save();

                // Style moderne avec blanc et ombres
                ctx.fillStyle = '#ffffff';
                ctx.font = `700 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', system-ui, sans-serif`;
                ctx.textAlign = 'center';

                // Ombres multiples pour effet profondeur
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 8;

                // S√©parer le nom du voyage et la phase
                const lignes = titreVoyage.texte.split('\n');
                const voyageNom = lignes[0];
                const phaseTexte = lignes[1] || '';

                // Premi√®re ombre (arri√®re) pour le titre voyage
                ctx.fillText(`üó∫Ô∏è Voyage ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Deuxi√®me couche avec ombre plus subtile pour le titre
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 4;
                ctx.fillText(`üó∫Ô∏è Voyage ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Sous-titre phase avec ombres noires
                if (phaseTexte) {
                    ctx.font = `600 ${Math.max(C.H * 0.018, 16)}px 'Segoe UI', system-ui, sans-serif`;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.shadowBlur = 6;
                    ctx.fillText(phaseTexte, C.W/2, voyageY + Math.max(C.H * 0.035, 28));
                }

                ctx.restore();
            } else if (titreVoyage.active && Date.now() >= titreVoyage.fin) {
                titreVoyage.active = false; // D√©sactiver apr√®s 4 secondes
            }

            // Stats ligne avec fond blanc plus pr√®s du header
            const statsY = Math.max(C.H * 0.045, 30); // Beaucoup plus pr√®s du header
            const padding = 8;
            const bgHeight = Math.max(C.H * 0.025, 20);

            // Fond blanc pour toute la barre de stats
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, statsY - bgHeight/2, C.W, bgHeight);

            // Bordure subtile
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, statsY - bgHeight/2, C.W, bgHeight);

            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points XP - centr√© verticalement dans la barre
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`‚≠ê XP: ${pointsConnaissance}`, 15, statsY);
            } else {
                ctx.fillText(`üïäÔ∏è ${score}`, 15, statsY);
            }

            // Progression avec voyage et phase
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            let phaseInfo = '';
            if (narrationManager && narrationManager.currentPhase) {
                const phase = narrationManager.currentPhase; // Phase 1 = intro simple
                let voyageIcon = '';
                let voyageName = '';

                if (phase === 1) {
                    voyageIcon = 'üåÖ'; voyageName = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageIcon = '‚òÄÔ∏è'; voyageName = 'La lumi√®re';
                } else if (phase >= 3 && phase <= 4) {
                    voyageIcon = '‚òÅÔ∏è'; voyageName = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageIcon = 'ü§´'; voyageName = 'Le silence de l\'√¢me';
                } else if (phase >= 7 && phase <= 9) {
                    voyageIcon = '‚ù§Ô∏è'; voyageName = 'L\'humanit√© des c≈ìurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageIcon = 'üß†'; voyageName = 'La sagesse des diff√©rences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageIcon = 'üåç'; voyageName = 'L\'unit√©';
                } else if (phase === 16) {
                    voyageIcon = 'üéÜ'; voyageName = 'Animation finale';
                } else {
                    voyageIcon = 'üìñ'; voyageName = 'Voyage';
                }

                phaseInfo = `üìñ Phase ${phase}/16`;
            } else {
                phaseInfo = `üß± ${brises}/${VOYAGE.length}`;
            }
            ctx.fillText(phaseInfo, C.W/2, statsY);

            // Vies
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const coeurs = vies > 0 ? '‚ù§Ô∏è'.repeat(vies) : 'üíî';
            ctx.fillText(coeurs, C.W - 15, statsY);

            // Affichage des commandes mode passe d√©sactiv√©
            /*
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                'üîë MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir √©toiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();
            */

            ctx.restore();
        }

        // Tirer un projectile √©toile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars, feux_artifice ET lanterne (pour Poxerstart)
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice' && phaseJeu !== 'lanterne') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation √©toile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de d√©placement pour la tra√Æn√©e
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Tra√Æn√©e d'√©toile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // Gradient de la tra√Æn√©e
                const gradientTrainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                // Tra√Æn√©e dor√©e normale
                gradientTrainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                gradientTrainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradientTrainee.addColorStop(1, projectile.couleur || '#FFD700');

                // Dessiner la tra√Æn√©e
                ctx.fillStyle = gradientTrainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'√©toile elle-m√™me
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // √âtoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // Halo lumineux
                    const gradientHalo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                    gradientHalo.addColorStop(0, projectile.couleur || '#FFD700');
                    gradientHalo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradientHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = gradientHalo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // √âtoile centrale brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, projectile.couleur || '#FFD700');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0.8)');

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // √âtoile √† 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre √† jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {
                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                                    // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // D√©sactiv√© : Ancien syst√®me de fin simple - remplac√© par la s√©quence compl√®te
                                    // if(brises >= VOYAGE.length) { ... }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // Collision avec les petits c≈ìurs
                petitsCoeurs.forEach((petitCoeur, j) => {
                    if(!petitCoeur.visible) return;

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // C≈ìur touch√© !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                        const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                        console.log(`[DEBUG] Condition fin coeurs: restants=${coeurRestants}, phaseJeu=${phaseJeu}`);
                        if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                            console.log(`[DEBUG] Condition remplie, appel goToNextPhaseDirect dans 1s`);
                            // Progression directe vers la phase suivante
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();

                                // Cr√©er quelques c≈ìurs d√©coratifs qui flottent
                                setTimeout(() => {
                                    for(let k = 0; k < 10; k++) {
                                        particules.push({
                                            x: Math.random() * C.W,
                                            y: C.H + Math.random() * 50,
                                            vx: (Math.random() - 0.5) * 2,
                                            vy: -(Math.random() * 3 + 1),
                                            couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][k % 5],
                                            vie: 1,
                                            taille: Math.random() * 4 + 3,
                                            type: 'coeur'
                                        });
                                    }


                                    // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                    // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                }, 3000);
                            }, 1000);
                        }
                        return;
                    }
                });
            }
        }

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // Dessiner la lanterne √©teinte comme balle du jeu UNIQUEMENT pendant la phase casse-briques
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0; // Position de la balle
            const posY = balle.y || 0; // Position de la balle
            const temps = Date.now() * 0.001;

            // V√©rification de s√©curit√© pour √©viter les valeurs non finies
            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // EFFET TRA√éN√âE VERTE (power-up vitesse)
            if(balle.traineeVerte && balle.vitesseActive) {
                // Tra√Æn√©e verte dynamique
                for(let i = 0; i < 5; i++) {
                    const alpha = (5 - i) / 5 * 0.6;
                    const size = C.BS * (1 - i * 0.15);
                    const offsetX = (balle.dx || 0) * -i * 2;
                    const offsetY = (balle.dy || 0) * -i * 2;

                    const grad = ctx.createRadialGradient(
                        posX + offsetX, posY + offsetY, 0,
                        posX + offsetX, posY + offsetY, size
                    );
                    grad.addColorStop(0, `rgba(0, 255, 0, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 255, 50, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(0, 255, 0, 0)`);

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(posX + offsetX, posY + offsetY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 1. HALO DE BOUGIE SIMPLE (seulement si lanterne active)
            if(lanterne.active) {
                // Halo simple statique
                const haloSize = C.BS * 1.5;
                const haloIntensity = 0.4;

                // Halo principal simple avec v√©rification
                if (isFinite(haloSize) && haloSize > 0) {
                    const haloGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, haloSize);
                haloGrad.addColorStop(0, `rgba(255, 220, 150, ${haloIntensity})`);
                haloGrad.addColorStop(0.3, `rgba(255, 180, 100, ${haloIntensity * 0.7})`);
                haloGrad.addColorStop(0.7, `rgba(255, 140, 60, ${haloIntensity * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');

                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. LANTERNE CYLINDRIQUE CLASSIQUE

            // Dimensions de la lanterne avec multiplicateur de taille si actif
            const multiplTaille = balle.multiplicateurTaille || 1;
            const rayon = C.BS * 0.4 * multiplTaille;        // Rayon du cylindre
            const corpsH = C.BS * 1.2 * multiplTaille;       // Hauteur du corps cylindrique
            const domeH = C.BS * 0.1 * multiplTaille;        // Hauteur du d√¥me
            const baseH = C.BS * 0.1 * multiplTaille;        // Hauteur de la base

            // LUEUR DOUCE AUTOUR DE LA LANTERNE
            if(lanterne.active) {
                // Halo de lueur douce adapt√© √† la taille
                const lueurSize = rayon * 1.25;
                if (isFinite(rayon) && isFinite(lueurSize) && rayon > 0 && lueurSize > 0) {
                    const lueurGrad = ctx.createRadialGradient(posX, posY, rayon, posX, posY, lueurSize);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.2)');
                lueurGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
                ctx.fillStyle = lueurGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, lueurSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Armature m√©tallique de la lanterne
            const armatureColor = lanterne.active ? '#B8860B' : '#654321';
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;

            // BASE RONDE plus petite
            const baseY = posY + corpsH/2;
            ctx.fillStyle = armatureColor;
            ctx.beginPath();
            ctx.ellipse(posX, baseY, rayon * 1.05, baseH, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // CORPS CYLINDRIQUE
            const corpsTop = posY - corpsH/2;
            const corpsBottom = posY + corpsH/2;

            // Vitres cylindriques
            if(lanterne.active) {
                // Vitres dor√©es lumineuses
                if (isFinite(rayon) && rayon > 0) {
                    const vitreGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, rayon);
                    vitreGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    vitreGrad.addColorStop(0.7, 'rgba(255, 200, 0, 0.6)');
                    vitreGrad.addColorStop(1, 'rgba(255, 180, 0, 0.4)');
                    ctx.fillStyle = vitreGrad;
                } else {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                }
            } else {
                // Vitres √©teintes
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.ellipse(posX, posY, rayon, corpsH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Contour du cylindre
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Barreaux en forme de croix
            ctx.beginPath();
            // Barre verticale
            ctx.moveTo(posX, corpsTop);
            ctx.lineTo(posX, corpsBottom);
            // Barre horizontale
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // D√îME SUP√âRIEUR
            const domeTop = corpsTop - domeH;
            ctx.fillStyle = armatureColor;
            ctx.strokeStyle = '#CD7F32';
            ctx.lineWidth = 2;

            // D√¥me en forme d'ellipse plus petit
            ctx.beginPath();
            ctx.ellipse(posX, domeTop + domeH/2, rayon * 0.9, domeH/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 3. FLAMME AVEC ANIMATIONS TR√àS LENTES
            if(lanterne.active) {
                // Flamme avec mouvement tr√®s lent et doux
                const flammeX = posX + Math.sin(temps * 0.3) * 1 * multiplTaille; // Tr√®s lent
                const flammeY = posY - C.BS * 0.3 * multiplTaille;
                const flammeH = C.BS * 0.6 * multiplTaille;
                const flammeW = C.BS * 0.3 * multiplTaille;

                // Flamme principale avec danse tr√®s douce
                if (isFinite(flammeX) && isFinite(flammeY) && isFinite(flammeH) && flammeH > 0) {
                    const flammeGrad = ctx.createRadialGradient(flammeX, flammeY, 0, flammeX, flammeY, flammeH);
                flammeGrad.addColorStop(0, '#FFFF99');
                flammeGrad.addColorStop(0.3, '#FFD700');
                flammeGrad.addColorStop(0.6, '#FFA500');
                flammeGrad.addColorStop(1, '#FF6347');

                    ctx.fillStyle = flammeGrad;
                    ctx.beginPath();
                    // Forme de flamme avec variations tr√®s lentes
                    ctx.ellipse(flammeX, flammeY, flammeW * (0.6 + Math.sin(temps * 0.4) * 0.05), flammeH * (0.8 + Math.cos(temps * 0.35) * 0.05), Math.sin(temps * 0.2) * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    // C≈ìur de la flamme plus lumineux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(flammeX, flammeY, flammeW * 0.3, flammeH * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // M√®che de la bougie
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1 * multiplTaille, posY, 2 * multiplTaille, C.BS * 0.2 * multiplTaille);
            } else {
                // M√®che √©teinte
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY - 2, 2, 4);

                // C≈ìur d'humanit√© au repos
                const coeurSize = C.BS * 0.4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(posX, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX, posY, posX - coeurSize*0.5, posY, posX - coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX - coeurSize*0.5, posY + coeurSize*0.7, posX, posY + coeurSize*0.7, posX, posY + coeurSize);
                ctx.bezierCurveTo(posX, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX + coeurSize*0.5, posY, posX, posY, posX, posY + coeurSize*0.3);
                ctx.fill();
            }

            // 4. SYST√àME DE SUSPENSION SIMPLE
            const cordeLength = C.BS * 1;
            ctx.strokeStyle = lanterne.active ? '#8B4513' : '#4a4a4a';
            ctx.lineWidth = 2;

            // Cordes depuis le d√¥me adapt√©es √† la taille
            ctx.beginPath();
            ctx.moveTo(posX - rayon*0.6, domeTop); // Gauche du d√¥me
            ctx.lineTo(posX - rayon*0.2, posY - cordeLength);
            ctx.moveTo(posX + rayon*0.6, domeTop); // Droite du d√¥me
            ctx.lineTo(posX + rayon*0.2, posY - cordeLength);
            ctx.stroke();

            // Corde centrale
            ctx.beginPath();
            ctx.moveTo(posX, domeTop); // Centre du d√¥me
            ctx.lineTo(posX, posY - cordeLength);
            ctx.stroke();

            ctx.restore();
        }

        // Fonction pour dessiner les ic√¥nes de bateaux miniatures
        function drawBoatIcon(ctx, x, y, size, color) {
            ctx.save();

            // Couleurs selon le type
            let coqueColors, borderColor;
            if (color === 'red') {
                coqueColors = ['#ff6b6b', '#e74c3c', '#c0392b'];
                borderColor = '#a93226';
            } else {
                coqueColors = ['#74b9ff', '#0984e3', '#2d3436'];
                borderColor = '#2d3436';
            }

            // Coque simplifi√©e
            const coqueW = size * 1.5;
            const coqueH = size * 0.8;

            const coqueGrad = ctx.createLinearGradient(x, y, x, y + coqueH);
            coqueGrad.addColorStop(0, coqueColors[0]);
            coqueGrad.addColorStop(0.5, coqueColors[1]);
            coqueGrad.addColorStop(1, coqueColors[2]);

            ctx.fillStyle = coqueGrad;
            ctx.beginPath();
            ctx.ellipse(x, y + coqueH/2, coqueW/2, coqueH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bordure
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // M√¢t
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + coqueH/2);
            ctx.lineTo(x, y - size);
            ctx.stroke();

            // Voile triangulaire
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size/2, y);
            ctx.lineTo(x + size/3, y - size/3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#ced4da';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau √©l√©gant g√©om√©trique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // EFFET POXERSTART (aura rose pulsante)
            if(raquette.poxerstart && Date.now() < raquette.poxerstartFin) {
                const tempsRestant = (raquette.poxerstartFin - Date.now()) / 7000; // 0 √† 1
                const pulsation = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                const alpha = tempsRestant * pulsation * 0.6;

                // Aura rose autour du bateau
                const grad = ctx.createRadialGradient(
                    raquette.x + C.PW/2, raquette.y + C.PH/2, 0,
                    raquette.x + C.PW/2, raquette.y + C.PH/2, C.PW * 1.5
                );
                grad.addColorStop(0, `rgba(255, 105, 180, ${alpha})`);
                grad.addColorStop(0.7, `rgba(255, 105, 180, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 105, 180, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(
                    raquette.x - C.PW * 0.5, raquette.y - C.PH * 0.5,
                    C.PW * 2, C.PH * 2
                );

                // √âtoiles qui scintillent autour
                for(let i = 0; i < 3; i++) {
                    const angle = Date.now() * 0.005 + i * Math.PI * 2 / 3;
                    const rayon = C.PW * 0.8;
                    const x = raquette.x + C.PW/2 + Math.cos(angle) * rayon;
                    const y = raquette.y + C.PH/2 + Math.sin(angle) * rayon * 0.5;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', x, y);
                }
            } else if(raquette.poxerstart) {
                // Nettoyer l'effet quand fini
                raquette.poxerstart = false;
            }

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec √©trave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient bleu pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#74b9ff'); // Bleu clair
                coqueGrad.addColorStop(0.5, '#0984e3'); // Bleu moyen
                coqueGrad.addColorStop(1, '#2d3436'); // Bleu fonc√©

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');
                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Coque du bateau - forme g√©om√©trique √©l√©gante
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient rouge pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#ff6b6b');
                coqueGrad.addColorStop(0.5, '#e74c3c');
                coqueGrad.addColorStop(1, '#c0392b');

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // Vraies briques avec c≈ìurs √† l'int√©rieur pour le casse-brique
        function dessinerPrejuges() {
            briques.forEach((brique, index) => {
                if(!brique.visible) return;

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec √©tat de d√©g√¢ts
                ctx.save();

                // Couleur selon la vie restante
                let couleurBrique = couleur;
                if (brique.vieMax === 2) {
                    // Phase lanterne : 2 vies maximum
                    if (brique.vie === 1) {
                        // Brique endommag√©e (1er coup re√ßu sur 2)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.6)`;
                    }
                } else {
                    // Phase stars : 3 vies maximum
                    if (brique.vie === 2) {
                        // Brique l√©g√®rement endommag√©e (1er coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.8)`;
                    } else if (brique.vie === 1) {
                        // Brique tr√®s endommag√©e (2√®me coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.5)`;
                    }
                }

                ctx.fillStyle = couleurBrique;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                // Clignotement si r√©cemment touch√©e
                if (brique.clignotement > 0) {
                    ctx.fillStyle = '#FFFFFF';
                    brique.clignotement--;
                }

                // Rectangle de brique
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);


                // Effet 3D de brique
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.3); // Highlight du haut

                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(brique.x, brique.y + brique.h * 0.8, brique.w, brique.h * 0.2); // Ombre du bas

                // Dessiner les fissures zigzag blanches selon les d√©g√¢ts
                if ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2)) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    // Premi√®re fissure zigzag apr√®s le 1er coup
                    ctx.beginPath();
                    const startX1 = brique.x + brique.w * 0.3;
                    const endX1 = brique.x + brique.w * 0.2;
                    const segments = 4; // Nombre de segments zigzag
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX1 + (endX1 - startX1) * progress + (i % 2 === 0 ? 0 : brique.w * 0.05) * Math.sin(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                if (brique.vie <= 1) {
                    // Deuxi√®me fissure zigzag apr√®s le 2√®me coup
                    ctx.beginPath();
                    const startX2 = brique.x + brique.w * 0.7;
                    const endX2 = brique.x + brique.w * 0.8;
                    const segments = 4;
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX2 + (endX2 - startX2) * progress + (i % 2 === 1 ? 0 : brique.w * 0.04) * Math.cos(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le c≈ìur √† l'int√©rieur de la brique
                dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);

                // En phase stars (nuit), afficher les mots pour guider le joueur
                if(phaseJeu === 'stars' && brique.etape && brique.etape.nom) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Contour noir pour la lisibilit√©
                    ctx.strokeText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                    // Texte blanc par-dessus
                    ctx.fillText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                }

                // En phase lanterne, le texte reste cach√© - il n'appara√Æt que lors de l'explosion
                // Le myst√®re reste entier jusqu'√† la lib√©ration du c≈ìur !
            });
        }

        // Messages simples centr√©s pour powerups et narratifs
        let messagePowerupActif = null;
        let messageNarratifActif = null;

        // Bouton simple "Passer" avec juste texte et ombre
        let boutonPasser = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 80,
            hauteur: 30,
            texte: "Passer",
            hover: false
        };

        function afficherMessagePowerupSimple(texte) {
            messagePowerupActif = {
                texte: texte,
                temps: Date.now() + 2000, // 2 secondes
                alpha: 1.0
            };
        }

        function afficherMessageNarratifSimple(texte, duree = 12000) {
            messageNarratifActif = {
                texte: texte,
                temps: Date.now() + duree,
                alpha: 1.0
            };
        }

        // Fonction pour dessiner le message powerup simple sous les titres narratifs
        function dessinerMessagePowerupSimple() {
            if (!messagePowerupActif) return;

            const maintenant = Date.now();
            if (maintenant > messagePowerupActif.temps) {
                messagePowerupActif = null;
                return;
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messagePowerupActif.temps - maintenant;
            if (tempsRestant < 500) {
                messagePowerupActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messagePowerupActif.alpha;

            // Position sous les titres narratifs
            const voyageY = Math.max(C.H * 0.10, 70);
            const posY = voyageY + Math.max(C.H * 0.035, 28) + 25; // Sous le sous-titre + 25px

            // Pas de fond - texte blanc avec contour noir pour lisibilit√©
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Contour noir √©pais pour lisibilit√© sur tous les arri√®re-plans
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(messagePowerupActif.texte, C.W/2, posY);
            ctx.fillText(messagePowerupActif.texte, C.W/2, posY);

            ctx.restore();
        }

        // Fonction pour dessiner le message narratif discret (en bas, sans fond)
        function dessinerMessageNarratifSimple() {
            if (!messageNarratifActif) return;

            const maintenant = Date.now();
            if (maintenant > messageNarratifActif.temps) {
                messageNarratifActif = null;
                return;
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messageNarratifActif.temps - maintenant;
            if (tempsRestant < 500) {
                messageNarratifActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messageNarratifActif.alpha;

            // Position un peu plus bas que le centre pour ne pas g√™ner le jeu
            const posY = C.H * 0.65; // 65% de la hauteur (un peu plus bas que le centre)

            // Diviser le texte en lignes pour les longs messages
            const lignes = messageNarratifActif.texte.split('\n');

            // Pas de fond - style discret mais bien visible
            // Texte blanc bold avec ombre noire marqu√©e
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 20px Arial'; // Plus gros et bold
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Ombre noire marqu√©e pour lisibilit√©
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.shadowBlur = 6;

            // Traiter chaque ligne pour un formatage optimal
            const hauteurLigne = 26;
            const margeHorizontale = 40;
            const largeurMax = C.W - (margeHorizontale * 2);

            let lignesFinales = [];

            // Pr√©-traiter toutes les lignes pour g√©rer le retour √† la ligne intelligent
            lignes.forEach(ligne => {
                const largeurTexte = ctx.measureText(ligne).width;

                if (largeurTexte > largeurMax) {
                    // Diviser intelligemment la ligne trop longue
                    const mots = ligne.split(' ');
                    let ligneActuelle = '';

                    for (let mot of mots) {
                        const testLigne = ligneActuelle + (ligneActuelle ? ' ' : '') + mot;
                        const testLargeur = ctx.measureText(testLigne).width;

                        if (testLargeur > largeurMax && ligneActuelle !== '') {
                            lignesFinales.push(ligneActuelle);
                            ligneActuelle = mot;
                        } else {
                            ligneActuelle = testLigne;
                        }
                    }

                    if (ligneActuelle) {
                        lignesFinales.push(ligneActuelle);
                    }
                } else {
                    lignesFinales.push(ligne);
                }
            });

            // Calculer la position de d√©part pour centrer verticalement le bloc de texte
            const hauteurTotale = lignesFinales.length * hauteurLigne;
            const yDebut = posY - hauteurTotale / 2;

            // Dessiner toutes les lignes finales
            lignesFinales.forEach((ligne, index) => {
                const y = yDebut + (index + 1) * hauteurLigne;
                ctx.fillText(ligne, C.W/2, y);
            });

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Passer" simple
        function dessinerBoutonPasser() {
            if (!boutonPasser.actif) return;

            // Position au milieu de l'√©cran
            boutonPasser.x = C.W/2 - boutonPasser.largeur/2;
            boutonPasser.y = C.H/2 - 50; // En haut du milieu

            ctx.save();

            // Juste du texte avec ombre - pas de fond ni bordure
            ctx.fillStyle = boutonPasser.hover ? '#ff6666' : '#ff0000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre marqu√©e pour lisibilit√©
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.shadowBlur = 6;

            ctx.fillText(boutonPasser.texte, boutonPasser.x + boutonPasser.largeur/2, boutonPasser.y + boutonPasser.hauteur/2);

            ctx.restore();
        }

        // Fonction pour v√©rifier si on clique sur le bouton
        function verifierClicBoutonPasser(x, y) {
            if (!boutonPasser.actif) return false;

            return x >= boutonPasser.x && x <= boutonPasser.x + boutonPasser.largeur &&
                   y >= boutonPasser.y && y <= boutonPasser.y + boutonPasser.hauteur;
        }

        // Power-Up Bleu √âtincelant
        function creerPowerUp(x, y) {
            // allume_lanterne n'appara√Æt pas al√©atoirement - seulement via creerPowerUpLanterne()
            const types = ['etoile_montante', 'poxerstart', 'vitesse', 'bonus_points'];
            const typeAleatoire = types[Math.floor(Math.random() * types.length)];

            const nouveauPowerUp = {
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: typeAleatoire,
                temps: 0,
                etincelles: []
            };

            powerUps.push(nouveauPowerUp);
            console.log(`üéØ Power-up cr√©√©: ${typeAleatoire} √† (${x}, ${y}), total: ${powerUps.length}`);
        }

        function dessinerPowerUps() {
            if(powerUps.length > 0) {
                console.log(`üé® Dessin de ${powerUps.length} power-ups`);
            }
            powerUps.forEach(power => {
                ctx.save();

                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);

                // Couleur selon le type
                let couleur1, couleur2, couleur3;
                switch(power.type) {
                    case 'etoile_montante':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Dor√©
                        break;
                    case 'poxerstart':
                        couleur1 = '#FF69B4'; couleur2 = '#FF1493'; couleur3 = '#DC143C'; // Rose/Rouge
                        break;
                    case 'vitesse':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert
                        break;
                    case 'bonus_points':
                        couleur1 = '#9400D3'; couleur2 = '#8A2BE2'; couleur3 = '#7B68EE'; // Violet
                        break;
                    case 'allume_lanterne':
                        couleur1 = '#FFA500'; couleur2 = '#FF8C00'; couleur3 = '#FF6347'; // Orange/Rouge (feu)
                        break;
                    default:
                        couleur1 = '#00aaff'; couleur2 = '#0099dd'; couleur3 = '#0088cc'; // Bleu
                }

                // D√©grad√© selon le type
                const grad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                grad.addColorStop(0, couleur1);
                grad.addColorStop(0.5, couleur2);
                grad.addColorStop(1, couleur3);

                ctx.fillStyle = grad;
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // Bordure scintillante
                ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                ctx.lineWidth = 3;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.strokeRect(power.x, power.y, power.w, power.h);
                ctx.shadowBlur = 0;

                // Ic√¥ne lanterne üèÆ
                ctx.fillStyle = '#ffffff';
                ctx.font = `${power.h * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('üèÆ', power.x + power.w/2, power.y + power.h*0.7);

                // √âtincelles autour
                for(let i = 0; i < 3; i++) {
                    const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = power.w * 0.8;
                    const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                    const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                    ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                power.temps += 1;
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                if(powerUps.length > 0) {
                    console.log(`üîç V√©rif collision balle(${balle.x.toFixed(1)}, ${balle.y.toFixed(1)}) avec ${powerUps.length} power-ups`);
                }
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Effets selon le type de power-up
                    console.log(`‚ö° Power-up activ√©: ${power.type}`);
                    switch(power.type) {
                        case 'etoile_montante':
                            // Cr√©er une √©toile qui monte au ciel + 1000 XP
                            creerEtoileMontante(power.x + power.w/2, power.y + power.h/2);
                            score += 1000;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 30);
                            console.log('‚≠ê √âtoile montante cr√©√©e + 1000 XP');

                            // Message simple
                            afficherMessagePowerupSimple('‚≠ê √âtoile montante +1000 XP');
                            break;

                        case 'poxerstart':
                            // Active le mode tir √©toiles normal pendant 7 secondes
                            if(!window.modeTirStars || !window.modeTirStars.actif) {
                                const finTirStars = Date.now() + 7000;
                                window.modeTirStars = { actif: true, fin: finTirStars };
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 30);
                                console.log('üåü Mode tir √©toiles POXERSTART activ√© (7s)');

                                // Message simple
                                afficherMessagePowerupSimple('üåü Poxerstart activ√© - 7 secondes');

                                // Indicateur visuel sur la raquette
                                raquette.poxerstart = true;
                                raquette.poxerstartFin = finTirStars;
                            } else {
                                console.log('üö´ Mode tir √©toiles d√©j√† actif - ignor√©');
                            }
                            break;

                        case 'vitesse':
                            // Balle BEAUCOUP plus rapide pendant 8 secondes (ne pas cumuler)
                            if(!balle.vitesseActive) {
                                balle.multiplicateurVitesse = (balle.multiplicateurVitesse || 1) * 2.5; // 2.5x au lieu de 1.5x
                                balle.vitesseActive = true;
                                balle.vitesseFinTime = Date.now() + 8000; // 8s au lieu de 10s

                                // Effet visuel de tra√Æn√©e verte
                                balle.traineeVerte = true;

                                setTimeout(() => {
                                    balle.multiplicateurVitesse = (balle.multiplicateurVitesse || 2.5) / 2.5;
                                    balle.vitesseActive = false;
                                    balle.traineeVerte = false;
                                    console.log('üí® Mode vitesse termin√©');
                                }, 8000);

                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 20);
                                console.log('üí® Mode vitesse TURBO activ√© (8s) - 2.5x plus rapide!');

                                // Message simple
                                afficherMessagePowerupSimple('üí® Vitesse turbo activ√©e !');
                            } else {
                                console.log('üö´ Vitesse d√©j√† active - ignor√©');
                            }
                            break;

                        case 'bonus_points':
                            // Points bonus (toujours cumulable) - augment√© !
                            score += 500; // 500 au lieu de 200
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 35);
                            console.log('üíé +500 points bonus!');

                            // Message simple
                            afficherMessagePowerupSimple('üíé Bonus points +500');
                            break;

                        case 'allume_lanterne':
                            // Allumer la lanterne si elle est √©teinte
                            if(!lanterne.active) {
                                lanterne.active = true;
                                lanterne.intensite = 1.0;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 40);
                                console.log('üèÆ Lanterne allum√©e!');

                                // Message simple
                                afficherMessagePowerupSimple('üèÆ Lanterne allum√©e !');
                            } else {
                                // Si d√©j√† allum√©e, donner des points bonus
                                score += 300;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 25);
                                console.log('üèÆ Lanterne d√©j√† allum√©e - +300 points bonus');
                                afficherMessagePowerupSimple('üèÆ Lanterne +300 bonus');
                            }
                            break;
                    }

                    // Toujours supprimer le power-up apr√®s contact (m√™me si effet ignor√©)
                    powerUps.splice(i, 1);
                    }
                }
            }
        }

        // Fonction sp√©ciale pour cr√©er le power-up lanterne sur la premi√®re brique en bas
        function creerPowerUpLanterne() {
            // Trouver la brique la plus en bas (plus grand Y)
            let briqueLoPlus = null;
            let yMax = -1;

            briques.forEach(brique => {
                if(brique.visible && brique.y > yMax) {
                    yMax = brique.y;
                    briqueLoPlus = brique;
                }
            });

            // Si on a trouv√© une brique en bas, y placer le power-up lanterne
            if(briqueLoPlus) {
                const powerUpLanterne = {
                    x: briqueLoPlus.x + briqueLoPlus.w/2 - C.BS * 0.75,
                    y: briqueLoPlus.y + briqueLoPlus.h/2 - C.BS * 0.75,
                    w: C.BS * 1.5,
                    h: C.BS * 1.5,
                    type: 'allume_lanterne',
                    temps: 0,
                    etincelles: [],
                    special: true // Marquer comme power-up sp√©cial
                };

                powerUps.push(powerUpLanterne);
                console.log('üèÆ Power-up LANTERNE plac√© sur la brique du bas!');
            }
        }

        // Cr√©er une √©toile qui monte vers le ciel
        function creerEtoileMontante(x, y) {
            // Cr√©er l'√©toile montante
            const etoile = {
                x: x,
                y: y,
                taille: 30,
                vitesseY: -3,
                temps: 0,
                alpha: 1,
                particules: []
            };

            // Animation de l'√©toile qui monte
            const animer = () => {
                etoile.y += etoile.vitesseY;
                etoile.temps += 1;
                etoile.alpha = Math.max(0, 1 - etoile.temps / 120); // Dispara√Æt en 2 secondes √† 60fps

                // Dessiner l'√©toile
                ctx.save();
                ctx.globalAlpha = etoile.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.font = `${etoile.taille}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê', etoile.x, etoile.y);

                // Effet de tra√Æn√©e dor√©e
                for(let i = 0; i < 3; i++) {
                    const particuleX = etoile.x + (Math.random() - 0.5) * 20;
                    const particuleY = etoile.y + i * 15;
                    ctx.globalAlpha = etoile.alpha * (1 - i * 0.3);
                    ctx.fillStyle = `hsl(45, 100%, ${70 - i * 10}%)`;
                    ctx.font = `${etoile.taille * (1 - i * 0.2)}px serif`;
                    ctx.fillText('‚ú®', particuleX, particuleY);
                }
                ctx.restore();

                // Continuer l'animation si l'√©toile est encore visible
                if(etoile.alpha > 0 && etoile.y > -50) {
                    requestAnimationFrame(animer);
                }
            };

            requestAnimationFrame(animer);
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise √† jour pendant l'animation
            if(lanterne.active) {
                // Effet de pulsation douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);

                // Cr√©er quelques particules dor√©es occasionnellement
                if(Math.random() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Cr√©er une rafale de 1-3 c≈ìurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // √âventail 40¬∞
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // D√©part l√©g√®rement dispers√©
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, tr√®s grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // D√©lai entre chaque c≈ìur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            const tempsActuel = Date.now();

            // Plus de c≈ìurs automatiques pendant l'intro
            // Pendant le jeu normal : plus de d√©clenchement automatique
            // Les rafales se d√©clenchent seulement sur clic/touche

            // Mettre √† jour les c≈ìurs de lumi√®re
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Mont√©e rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Animation de flottement gauche-droite
                if(coeur.vitesseFlottement !== undefined) {
                    coeur.flottemment += coeur.vitesseFlottement;
                    // Ajouter un mouvement oscillant horizontal
                    coeur.x += Math.sin(coeur.flottemment) * 0.5;
                }

                // Animation de scintillement
                coeur.scintillement += 0.2;
                coeur.luminosite = 0.7 + 0.3 * Math.sin(coeur.scintillement);

                // Supprimer si sort de l'√©cran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits c≈ìurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // V√©rifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // C≈ìur touch√© !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                            // Supprimer le c≈ìur du bateau
                            coeursBateau.splice(i, 1);

                            // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // Passer √† la phase suivante (seulement si on √©tait en phase tir_coeurs_haut)
                                setTimeout(() => {
                                    // Progression directe vers la phase suivante
                                    narrationManager.goToNextPhaseDirect();
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // Forcer la balle visible en phase lanterne et la mettre en attente
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                                    // lanterne.active et lanterne.intensite conserv√©s
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    // Message g√©r√© par le nouveau syst√®me narratif

                                    // Cr√©er quelques c≈ìurs d√©coratifs qui flottent (diff√©rents de ceux du haut)
                                    setTimeout(() => {
                                        // Cr√©er des c≈ìurs d√©coratifs flottants au lieu de recr√©er les c≈ìurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

    
                                        // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                }, 1000);
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                briques.forEach(brique => {
                    if(!brique.visible) return;

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames

                        // Supprimer le c≈ìur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // Explosion en 3 petits c≈ìurs seulement
                            for(let j = 0; j < 3; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du c≈ìur qui grossit et monte au ciel
                            ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                            // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        // V√©rifier la condition de fin selon le mode de jeu
                        if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                            // Mode briques : v√©rifier si toutes les briques sont d√©truites
                            const briquesRestantes = briques.filter(b => b.visible).length;
                            console.log(`üîç V√©rif briques restantes: ${briquesRestantes}`);
                            if(briquesRestantes === 0) {
                                console.log('üéØ Toutes les briques d√©truites (stars)! Transition vers phase suivante...');
                                // Progression directe vers la phase suivante
                                setTimeout(() => {
                                    console.log('üöÄ Appel narrationManager.goToNextPhaseDirect() (stars)');
                                    narrationManager.goToNextPhaseDirect();
                                }, 1000);
                            }
                        } else if(brises >= VOYAGE.length) {
                            // Mode c≈ìurs : progression classique bas√©e sur VOYAGE
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();
                            }, 1000);
                        }
                    }
                });
            }
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';

                // Forme √©toile/diamant pour les c≈ìurs du bateau
                ctx.save();
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                const t = coeur.taille;

                ctx.translate(coeur.x, coeur.y);

                // C≈ìur en polygone pour le bateau
                ctx.beginPath();

                // Lobe gauche
                ctx.moveTo(-t * 0.25, 0);
                ctx.lineTo(-t * 0.15, -t * 0.15);
                ctx.lineTo(-t * 0.05, -t * 0.1);
                ctx.lineTo(-t * 0.02, 0);

                // Lobe droit
                ctx.lineTo(t * 0.02, 0);
                ctx.lineTo(t * 0.05, -t * 0.1);
                ctx.lineTo(t * 0.15, -t * 0.15);
                ctx.lineTo(t * 0.25, 0);

                // Descente vers la pointe
                ctx.lineTo(t * 0.1, t * 0.15);
                ctx.lineTo(0, t * 0.3);
                ctx.lineTo(-t * 0.1, t * 0.15);

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            });
        }

        // Petits c≈ìurs d√©coratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Cr√©er un visage rond avec les c≈ìurs
            const centreX = C.W / 2;
            const centreY = C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.15; // Rayon du visage

            for(let i = 0; i < 40; i++) { // 40 c≈ìurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles vari√©es

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // R√©partir sur 360¬∞
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut √™tre cass√©
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une √©tape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.02,
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02,
                });
            }
        }

        // G√©n√©rer des positions en forme de c≈ìur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du c≈ìur

            // G√©n√©rer des positions selon l'√©quation param√©trique d'un c≈ìur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Param√®tre de 0 √† 2œÄ

                // √âquation param√©trique d'un c≈ìur : x = 16sin¬≥(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise √† l'√©chelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits c≈ìurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les c≈ìurs r√©siduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le c≈ìur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // G√©n√©rer les positions en forme de c≈ìur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Cr√©er les briques selon la disposition en c≈ìur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: phaseJeu === 'lanterne' ? 2 : 3,     // 2 coups en phase lanterne, 3 en phase stars
                    vie: phaseJeu === 'lanterne' ? 2 : 3,        // Vie actuelle
                    clignotement: 0, // Animation quand touch√©e
                    // Animation de d√©doublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }

            // Placer automatiquement le power-up lanterne sur la premi√®re brique en bas
            // Mais seulement en phase lanterne et si la lanterne n'est pas d√©j√† allum√©e
            if(phaseJeu === 'lanterne' && !lanterne.active) {
                setTimeout(() => {
                    creerPowerUpLanterne();
                }, 500); // Petit d√©lai pour laisser les briques se placer
            }
        }

        function libererVaguesAmour() {
            // Ne lib√©rer des vagues d'amour que si le jeu est actif
            if (!jeu || phaseIntro.active) return;

            const tempsActuel = Date.now();

            // Mode √©toile c≈ìur activ√© par power-up
            if(window.modeEtoileCoeur && window.modeEtoileCoeur.actif) {
                if(Date.now() > window.modeEtoileCoeur.fin) {
                    window.modeEtoileCoeur.actif = false;
                } else if(tempsActuel - derniereCreeRafale >= 200) { // Plus fr√©quent pendant le power-up
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
            // Mode normal
            else if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : lib√©rer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : lib√©rer l'amour seulement pour la derni√®re brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        function mettreAJourPetitsCoeurs() {
            petitsCoeurs.forEach((coeur, index) => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;

            });
        }

        // Fonction pour dessiner des c≈ìurs avec 20 triangles (pour les briques)
        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            const temps = Date.now() * 0.003;
            const pulsation = 1 + Math.sin(temps) * 0.15; // Pulsation douce

            // Appliquer la pulsation
            ctx.scale(pulsation, pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            const triangleSize = t * 0.08;

            // C≈ìur super mignon pour les briques qui pulse
            ctx.beginPath();

            // Lobe gauche (forme arrondie avec segments)
            ctx.moveTo(-t * 0.3, -t * 0.02);
            ctx.lineTo(-t * 0.22, -t * 0.18);
            ctx.lineTo(-t * 0.12, -t * 0.2);
            ctx.lineTo(-t * 0.05, -t * 0.1);
            ctx.lineTo(-t * 0.02, -t * 0.02);

            // Lobe droit (forme arrondie avec segments)
            ctx.lineTo(t * 0.02, -t * 0.02);
            ctx.lineTo(t * 0.05, -t * 0.1);
            ctx.lineTo(t * 0.12, -t * 0.2);
            ctx.lineTo(t * 0.22, -t * 0.18);
            ctx.lineTo(t * 0.3, -t * 0.02);

            // Descente vers la pointe avec courbe
            ctx.lineTo(t * 0.18, t * 0.15);
            ctx.lineTo(t * 0.08, t * 0.3);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.08, t * 0.3);
            ctx.lineTo(-t * 0.18, t * 0.15);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // D√©tails mignons - petits c≈ìurs √† l'int√©rieur
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Petit c≈ìur gauche
            ctx.beginPath();
            ctx.moveTo(-t * 0.15, -t * 0.05);
            ctx.lineTo(-t * 0.12, -t * 0.08);
            ctx.lineTo(-t * 0.09, -t * 0.05);
            ctx.lineTo(-t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Petit c≈ìur droit
            ctx.beginPath();
            ctx.moveTo(t * 0.09, -t * 0.05);
            ctx.lineTo(t * 0.12, -t * 0.08);
            ctx.lineTo(t * 0.15, -t * 0.05);
            ctx.lineTo(t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Point lumineux central
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, t * 0.05, t * 0.02, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // C≈ìur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // C√¥t√©s qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits c≈ìurs pendant l'animation du bateau, la phase lanterne ou la phase stars
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars') return;

            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // Calculs d'animation
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le c≈ìur polygonal
                dessinerCoeurPolygonal(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });
        }

        // Syst√®me de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur, vie: 1,
                    taille: Math.random() * 4 + 2,
                    type: 'rond'
                });
            }
        }

        // Particules en forme de petits c≈ìurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6, // Moins de dispersion horizontale
                    vy: -(Math.random() * 8 + 4),  // Toujours vers le haut
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                if(p.type === 'coeur') {
                    // C≈ìurs : pas de gravit√©, continuent vers le haut
                    p.vy *= 0.99; // L√©g√®re d√©c√©l√©ration
                } else {
                    // Particules normales : gravit√©
                    p.vy += 0.15;
                }

                p.vie -= 0.02;

                // Supprimer les particules qui sortent de l'√©cran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.vie * 0.8;
                ctx.fillStyle = p.couleur;

                if(p.type === 'coeur') {
                    // Dessiner petit c≈ìur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du c≈ìur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du c≈ìur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du c≈ìur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Particule ronde normale
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions
        function afficherMunitions() {
            if (animationBateau.active || phaseJeu !== 'stars') return;

            ctx.fillStyle = '#FFD700';
            ctx.font = '16px Arial';
            ctx.fillText(`√âtoiles: ${munitions}`, 10, 30);

            // Afficher le mode √©toiles
            ctx.fillStyle = '#FFD700';
            ctx.fillText('‚≠ê Mode: √âtoiles', 10, 55);
        }

        // Dessiner les projectiles √©toiles
        function dessinerProjectiles() {
            // Dessiner les projectiles √©toiles pendant la phase stars ET lanterne (pour le mode Pluton)
            if(phaseJeu !== 'stars' && phaseJeu !== 'lanterne') return;

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = 8;

                // Calcul pour l'effet de rotation scintillante
                const rotation = Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner l'√©toile avec effet de lueur (couleur selon le type)
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile + 3);

                // Projectiles dor√©s
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                ctx.strokeStyle = '#FFD700';

                ctx.fillStyle = gradient;
                ctx.lineWidth = 1;

                // √âtoile √† 5 branches
                ctx.beginPath();
                for(let i = 0; i < 5; i++) {
                    const angle1 = (i * 2 * Math.PI) / 5;
                    const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                    if(i === 0) {
                        ctx.moveTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    } else {
                        ctx.lineTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    }

                    ctx.lineTo(Math.cos(angle2) * rayonEtoile * 0.4, Math.sin(angle2) * rayonEtoile * 0.4);
                }
                ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Tirer un projectile √©toile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne
            if (rechargement > 0 || phaseJeu !== 'lanterne') return;

            // Tant qu'il y a des munitions, tirer des √©toiles
            if (munitions > 0) {
                // Tir d'√©toiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;


                projectiles.push({
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY
                });

                munitions--;

                // V√©rifier si c'√©tait la derni√®re munition
                if (munitions === 0) {
                    setTimeout(() => {
                        phaseJeu = 'lanterne';
                        balle.dx = 0; // Immobile au d√©but
                        balle.dy = 0; // Immobile au d√©but
                        balle.visible = true; // S'assurer que la lanterne est visible
                        balle.enAttente = true; // Attendre le clic
                        // Message g√©r√© par le nouveau syst√®me narratif
                    }, 500);
                }
            }

            rechargement = 20; // D√©lai entre les tirs
        }

        // Mettre √† jour les projectiles
        function mettreAJourProjectiles() {
            if (animationBateau.active || phaseJeu !== 'lanterne') {
                // Nettoyer les projectiles si on n'est pas en phase lanterne
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est d√©truite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Explosion en 3 petits c≈ìurs
                                for(let j = 0; j < 3; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                if(Math.random() < 0.3) {
                                    creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2);
                                }

                                // V√©rifier si toutes les briques sont d√©truites
                                if(briques.every(b => !b.visible)) {
                                    console.log('üéØ Toutes les briques d√©truites! Transition vers phase suivante...');

                                    // Auto-r√©cup√©rer les powerups restants
                                    if(powerUps && powerUps.length > 0) {
                                        console.log(`üéÅ Auto-r√©cup√©ration de ${powerUps.length} powerups restants`);
                                        powerUps.forEach(powerup => {
                                            // D√©clencher les effets selon le type
                                            switch(powerup.type) {
                                                case 'etoile_montante':
                                                    score += 1000;
                                                    break;
                                                case 'bonus_points':
                                                    score += 500;
                                                    break;
                                                case 'allume_lanterne':
                                                    lanterne.active = true;
                                                    lanterne.intensite = 1.0;
                                                    break;
                                            }
                                            // Particules d'effet
                                            if(window.ajouterParticules) {
                                                ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                            }
                                        });
                                        powerUps = []; // Vider la liste
                                    }

                                    phaseJeu = 'fin_niveau';
                                    setTimeout(() => {
                                        // Progression directe vers la phase suivante
                                        console.log('üöÄ Appel narrationManager.goToNextPhaseDirect()');
                                        narrationManager.goToNextPhaseDirect();
                                    }, 1000);
                                }
                            }
                        }
                    }
                });
            }

            // R√©duire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // G√©rer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // V√©rifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqu√©
            }

            // Appliquer le multiplicateur de vitesse s'il existe
            const vitesseMulti = balle.multiplicateurVitesse || 1;
            balle.x += balle.dx * vitesseMulti;
            balle.y += balle.dy * vitesseMulti;

            // Mode casse-briques : rebonds classiques (uniquement en phase casse_briques)
            if(phaseJeu === 'lanterne') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' ? C.SP * 1.5 : C.SP) * ecart * 0.8 * multiplicateurPuissance;
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode √©toiles : traverser les bords avec t√©l√©portation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // R√©appara√Æt √† droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // R√©appara√Æt √† gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // T√©l√©portation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // R√©appara√Æt en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de v√©rit√© (bas) - seulement dans les phases o√π la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'√©toile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'√©toile continue sa trajectoire
            }

            // Briser les pr√©jug√©s - une seule brique par frame maximum
            let briqueTouchee = false;
            briques.forEach(brique => {
                if(briqueTouchee) return; // Arr√™ter si on a d√©j√† touch√© une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Marquer qu'on a touch√© une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond plus pr√©cis selon la position de contact
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // L'√©toile traverse sans rebondir
                        // Effet magique de passage √† travers les pr√©jug√©s

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;

                        // Explosion en 3 petits c≈ìurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: 1,
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du c≈ìur qui grossit et monte au ciel
                        ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                        // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // D√©sactiv√© : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de cr√©er un power-up bleu
                        if(Math.random() < 0.3) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    // V√©rifier la condition de fin selon le mode de jeu
                    if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                        // Mode briques : v√©rifier si toutes les briques sont d√©truites
                        const briquesRestantes = briques.filter(b => b.visible).length;
                        console.log(`üîç V√©rif briques restantes (balle): ${briquesRestantes}`);
                        if(briquesRestantes === 0) {
                            console.log('üéØ Toutes les briques d√©truites (balle)! Transition vers phase suivante...');

                            // Auto-r√©cup√©rer les powerups restants
                            if(powerUps && powerUps.length > 0) {
                                console.log(`üéÅ Auto-r√©cup√©ration de ${powerUps.length} powerups restants (balle)`);
                                powerUps.forEach(powerup => {
                                    switch(powerup.type) {
                                        case 'etoile_montante': score += 1000; break;
                                        case 'bonus_points': score += 500; break;
                                        case 'allume_lanterne': lanterne.active = true; lanterne.intensite = 1.0; break;
                                    }
                                    if(window.ajouterParticules) {
                                        ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                    }
                                });
                                powerUps = [];
                            }

                            if(!modeEtoileLance) {
                                // Progression directe vers la phase suivante
                                setTimeout(() => {
                                    console.log('üöÄ Appel narrationManager.goToNextPhaseDirect() (balle)');
                                    narrationManager.goToNextPhaseDirect();
                                }, 1000);

                                // La fin sera g√©r√©e par finalizeNarration() automatiquement
                            } else if(modeEtoileLance) {
                                // Mode √©toile infini : relancer le m√™me niveau stars
                                jeu = false;
                                relancerModeEtoileInfini();
                            } else {
                                veriteLiberee();
                            }
                        }
                    } else if(brises >= VOYAGE.length) {
                        if(!modeEtoileLance) {
                            // Progression directe vers la phase suivante
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();
                            }, 1000);

                            // La fin sera g√©r√©e par finalizeNarration() automatiquement
                        } else if(modeEtoileLance) {
                            // Mode √©toile infini : relancer le m√™me niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // √âv√©nements
        function perdreVie() {
            vies--;
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position √† l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne') {
                // En phase lanterne, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© !\n\nüëÜ Cliquez pour relancer la lanterne ! üëÅÔ∏è', 4000);
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                balle.dy = -C.SP * multiplicateurPuissance;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© ! üëÅÔ∏è', 3000);
            }
        }

        function finDuVoyage() {
            jeu = false;
            afficherMessage('üò¢ Le voyage vers la v√©rit√© continue...\n\nüí™ "La v√©rit√© finit toujours par triompher !"\n\n‚ú® Touchez pour recommencer ‚ú®', 6000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // D√©lai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(periode === 'jour') {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    // Message g√©r√© par le nouveau syst√®me narratif
                } else {
                    // Fin du chapitre 2 : d√©clencher la s√©quence finale des feux d'artifice
                    // Phase finale : s√©quence compl√®te avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARR√äT DU SYST√àME NARRATIF pour √©viter les interf√©rences
                    phaseIntro.active = false;
                    // Introduction termin√©e

                    // √âTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = Date.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // √âTAPE 2 : Feux d'artifice 5s
                        console.log("Fin animation bateau, d√©but feux d'artifice");
                        animationBateau.active = false;

                        // Cr√©er des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // √âTAPE 3 : Lever de soleil + fin normale via finalizeNarration
                            console.log("D√©marrage lever de soleil final");
                            leverSoleilFinal();
                            setTimeout(() => {
                                console.log("Appel finalizeNarration pour menu correct");
                                narrationManager.finalizeNarration();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de d√©lai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le d√©but pour √©viter les probl√®mes
            chapitre = 1;
            VOYAGE = JOUR;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            // V√©rifier la condition de fin selon le mode de jeu
            if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                // Mode briques : v√©rifier si toutes les briques sont d√©truites
                const briquesRestantes = briques.filter(b => b.visible).length;
                if(briquesRestantes === 0) {
                    narrationManager.goToNextPhaseDirect();
                }
            } else if(brises >= VOYAGE.length) {
                // Mode c≈ìurs : progression classique bas√©e sur VOYAGE
                narrationManager.goToNextPhaseDirect();
            }

            // Forcer l'affichage des briques
            briques.forEach(brique => {
                brique.visible = true;
            });

            // Forcer la visibilit√© de la balle et activer le jeu
            if(balle) {
                balle.visible = true;
            }
            jeu = true;

            cacherMessage();
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            // Mode passe phase d√©sactiv√©
            return;
            if(periode === 'jour') {
                periode = 'nuit';
                VOYAGE = NUIT;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Cr√©er les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilit√© de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
            } else {
                periode = 'jour';
                VOYAGE = JOUR;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recr√©er les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits c≈ìurs visibles et d√©sactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
            }
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessagePowerupSimple('‚ùå Aucune brique trouv√©e');
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessagePowerupSimple(`‚ö° Mode rapide activ√© - ${briquesModifiees} briques`);
            } else {
                afficherMessagePowerupSimple('‚ÑπÔ∏è Toutes les briques d√©j√† √† 1 vie');
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // D√©sactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessagePowerupSimple('‚≠ê Tir √©toiles d√©sactiv√©');
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessagePowerupSimple('üåü Tir √©toiles automatique activ√©');

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si n√©cessaire
                        if(!jeu) jeu = true;

                        // Viser une brique al√©atoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Lib√©rer les c≈ìurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            console.log("Lever de soleil : passage en mode jour");
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise √† jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode √©toile test
            console.log("Lancement du mode √©toile test");

            // Configuration pour mode √©toile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = NUIT;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode √©toile depuis le menu

            // Forcer l'arr√™t des syst√®mes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'√©toiles automatique en mode √©toile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les √©l√©ments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Cr√©er les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessagePowerupSimple('üåü Mode √©toile infini activ√©');
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones √† chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centr√©e
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion apr√®s 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // D√©lai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le m√™me niveau stars infini
                phaseJeu = 'stars';
                periode = 'nuit';
                VOYAGE = NUIT;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessagePowerupSimple('üåü Niveau termin√© - Nouveau niveau stars');

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'√©toiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // D√©lai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // S√©quence finale : 3 formations al√©atoires avec explosions
            console.log("Lancement de la s√©quence finale avec 3 formations");

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations al√©atoires diff√©rentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // S√©quence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position al√©atoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        console.log(`Formation ${index + 1}: ${formation} √† (${x}, ${y})`);

                        // Explosion apr√®s formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu apr√®s la s√©quence compl√®te (3 √ó 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arr√™ter le tir automatique √† la fin du mode √©toile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard correct
            narrationManager.showFinalMenu();
        }


        function afficherMessageFinal() {
            const msg = document.getElementById('message');

            // Menu simple et √©l√©gant
            msg.innerHTML = `
                <div style="text-align: center; background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); max-width: 400px; margin: 0 auto;">
                    <h2 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 24px; font-weight: 300;">‚ú® Voyage Termin√© ‚ú®</h2>

                    <p style="margin: 15px 0 30px 0; color: #5a6c7d; font-size: 16px; line-height: 1.5;">
                        Merci d'avoir d√©couvert la v√©rit√©
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <button onclick="lancerPhaseBonus()"
                                style="background: linear-gradient(145deg, #4a90e2, #357abd); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            üìñ √âpilogue
                        </button>

                        <button onclick="location.reload()"
                                style="background: linear-gradient(145deg, #6c7b7f, #5a6c7d); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(108, 123, 127, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            üîÑ Rejouer
                        </button>
                    </div>
                </div>
            `;

            msg.classList.add('show');
            msg.style.display = 'block';
        }

        // Lancer la phase bonus
        function lancerPhaseBonus() {
            // Charger le module de phase bonus
            if (!window.PhaseBonusMur) {
                const script = document.createElement('script');
                script.src = 'modules/phase-bonus-mur.js';
                script.onload = () => {
                    demarrerPhaseBonus();
                };
                document.head.appendChild(script);
            } else {
                demarrerPhaseBonus();
            }
        }

        function demarrerPhaseBonus() {
            // Donner le bonus XP AVANT de cr√©er la phase bonus
            giveXPBonus(200);

            // Cr√©er et initialiser la phase bonus
            if (!window.phaseBonusMur) {
                window.phaseBonusMur = new window.PhaseBonusMur({ angel: angel });
                window.phaseBonusMur.init(canvas, ctx);
            }

            // Passer en mode phase bonus
            jeu = false;
            phaseJeu = 'bonus_mur';

            // D√©marrer la phase bonus
            window.phaseBonusMur.start();

            // Ajouter la gestion dans la boucle de jeu
            window.gameManager = window.gameManager || {};
            window.gameManager.startBonusPoem = () => {
                window.phaseBonusMur.startBonusPoem();
            };
            window.gameManager.restart = () => {
                window.location.reload();
            };
        }

        // Fonction d√©di√©e pour donner XP bonus (simple avec score)
        function giveXPBonus(amount) {
            try {
                console.log('üåü Attribution bonus score:', amount);
                console.log('Score avant:', score);

                // Ajouter au score directement
                score += amount;

                console.log('Score apr√®s:', score);

                // Message simple
                afficherMessagePowerupSimple('üåü +' + amount + ' Points bonus fin de jeu');

                return true;
            } catch (error) {
                console.error('‚ùå Erreur attribution bonus score:', error);
                return false;
            }
        }

        function afficherCreditsFinaux() {
            const msg = document.getElementById('message');
            msg.innerHTML = `
                <div style="text-align: center; background: linear-gradient(135deg, #8B4513, #A0522D); padding: 30px; border-radius: 15px; margin: 20px;">
                    <h2 style="margin-bottom: 20px; color: #ffffff;">üìú Cr√©dits Complets üìú</h2>

                    <div style="color: #ffffff; line-height: 1.6; margin: 20px 0;">
                        <p><strong>üéÆ Cr√©ation & D√©veloppement :</strong> Emmanuel Payet</p>
                        <p><strong>üé® Design & Concept :</strong> Emmanuel Payet</p>
                        <p><strong>‚úçÔ∏è Narration & Po√©sie :</strong> Emmanuel Payet</p>
                        <p><strong>üéµ Vision Artistique :</strong> Emmanuel Payet</p>
                        <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p><strong>üíù Projet :</strong> "Voir la V√©rit√©"</p>
                        <p><strong>üåü Message :</strong> Une fable interactive sur les pr√©jug√©s</p>
                        <p><strong>üìÖ Ann√©e :</strong> 2025</p>
                        <p><strong>‚ú® Signature Artistique :</strong> Dreamer Unisona</p>
                        <p><strong>üè∑Ô∏è Copyright :</strong> ¬© Emmanuel Payet - Tous droits r√©serv√©s</p>
                        <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p style="font-style: italic; color: #ffd700;">
                            "Aucun mur n'est √©ternel.<br>
                            Car l'eau finit toujours par user la pierre,<br>
                            et la libert√© reprendra son chemin."
                        </p>
                        <p style="font-style: italic; color: #87CEEB; margin-top: 15px;">
                            ‚Äî Dreamer Unisona
                        </p>
                    </div>

                    <button onclick="narrationManager.showFinalMenu()"
                            style="background: linear-gradient(145deg, #2E8B57, #3CB371); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer;">
                        ‚Üê Retour au Menu
                    </button>
                </div>
            `;
        }

        function recommencerJeu() {
            // R√©initialiser compl√®tement le jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;

            // Les objets kawaii sont r√©serv√©s au mode secret seulement
            // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret
            vies = 3;
            brises = 0;
            jeu = false; // Commencer avec jeu d√©sactiv√© pour l'intro

            // R√©initialiser les syst√®mes
            animationBateau.active = false;
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
            narrationManager.reset();

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Cacher le message
            cacherMessage();

            // D√©marrer la narration compl√®te P1 √† P16
            setTimeout(() => {
                narrationManager.start();
            }, 1000);
        }

        // Nouvelle fonction pour les messages avec animation
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Callback pour g√©rer la fin de l'animation et le timing de disparition
            const onComplete = () => {
                console.log('Animation termin√©e, attente avant disparition...');
                // Attendre un peu apr√®s la fin de l'animation avant de faire dispara√Ætre
                setTimeout(() => {
                    cacherMessage();
                }, Math.max(1000, duree * 0.2)); // Au moins 1s d'attente apr√®s l'animation
            };

            console.log('Animation appel√©e:', animation, 'Texte:', texteComplet.substring(0, 50));

            // Cr√©er une nouvelle instance TextAnimator avec le nouveau code optimis√©
            const anim = new TextAnimator('message');

            switch(animation) {
                case 'typewriter':
                    console.log('Appel typewriter avec speed:', speed);
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'digital':
                    anim.digital(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fade':
                    anim.fade(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'glitch':
                    anim.glitch(texteComplet, {
                        duration: Math.max(2000, duree * 0.3),
                        onComplete: onComplete
                    });
                    break;
                case 'emboss':
                    anim.setColors('#ffffff', '#666666');
                    anim.applyEffect('emboss');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'neon':
                    anim.setColors('#64ffda', '#64ffda');
                    anim.applyEffect('neon');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'shadow3d':
                    anim.setColors('#ffffff', '#333333');
                    anim.applyEffect('shadow3d');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fire':
                    anim.setColors('#ff4444', '#ff8800');
                    anim.applyEffect('fire');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'ice':
                    anim.setColors('#ffffff', '#ffffff');
                    anim.applyEffect('none');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'outline':
                    anim.setColors('#ffffff', '#000000');
                    anim.applyEffect('outline');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                default:
                    msg.innerHTML = texteComplet.replace(/\n/g, '<br>');
                    onComplete();
            }
        }

        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Cr√©er le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        üîÑ Rejouer
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ‚û°Ô∏è Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }

        function afficherMessageNarratif(texte, duree = 0) {
            const msg = document.getElementById('message');

            // Ajouter la classe narratif pour le style cin√©matique
            msg.classList.remove('show');
            msg.classList.add('narratif');
            msg.innerHTML = texte;
            msg.classList.add('show');

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    setTimeout(() => {
                        msg.classList.remove('narratif');
                    }, 300);
                }, duree);
            }
        }

        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifi√© et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;

            // Couleur de la mer selon le chapitre
            const merGrad = ctx.createLinearGradient(0, merY, 0, C.H);
            if(periode === 'jour') {
                // Mer bleue paisible
                merGrad.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
                merGrad.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
                merGrad.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            } else {
                // Mer sombre et mena√ßante
                merGrad.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
                merGrad.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
                merGrad.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
            }
            ctx.fillStyle = merGrad;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // Vagues selon le chapitre
            if(periode === 'jour') {
                // Vagues paisibles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                // Vagues agit√©es
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = periode === 'jour' ? (8 - ligne * 2) : (12 - ligne * 3);
                const fr√©quence = 0.01 + ligne * 0.005;
                const vitesse = periode === 'jour' ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                for(let x = 0; x <= C.W; x += 10) {
                    const vague = Math.sin(x * fr√©quence + offset) * amplitude;
                    if(x === 0) ctx.moveTo(x, y + vague);
                    else ctx.lineTo(x, y + vague);
                }
                ctx.stroke();
            }

            // Ailerons de requin dans le chapitre 2 (disparaissent pendant le lever de soleil)
            if(periode === 'nuit' && !leverSoleil.active) {
                const requins = [
                    { x: 0.2, vitesse: 0.3, taille: 1.0 },
                    { x: 0.6, vitesse: 0.5, taille: 0.8 },
                    { x: 0.9, vitesse: 0.4, taille: 1.2 }
                ];

                requins.forEach(requin => {
                    const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                    const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                    const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;

                    // Aileron de requin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8); // Base gauche
                    ctx.lineTo(reqX, reqY - taille); // Pointe
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5); // Base droite
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8); // Retour base
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Sillage du requin
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // D√©clarer les variables pour √©viter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(periode === 'jour') {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% √† 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui √©volue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // Rayons du soleil (plus nombreux pendant le lever)
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3;
                const nbRayons = leverSoleil.active ? 16 : 8;
                for(let i = 0; i < nbRayons; i++) {
                    const rotationSoleil = Date.now() * 0.0005; // Rotation lente
                    const angle = (i / nbRayons) * Math.PI * 2 + rotationSoleil;
                    const longueurRayon = leverSoleil.active ? 25 : 15;
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            } else {
                // CHAPITRE 2: Lune inqui√©tante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(periode === 'jour') {
                // V√©rifier si le soleil fait un clin d'≈ìil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'≈ìil pendant 2 secondes

                // Arr√™ter le clignotement apr√®s 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant √† la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et ferm√©s (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux ferm√©s paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et mod√©r√©
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence √† sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'≈ìil ! ≈íil gauche ferm√©, ≈ìil droit ouvert
                        // ≈íil gauche ferm√© (clin d'≈ìil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // ≈íil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'≈ìil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au d√©but
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inqui√©tante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre
            if(periode === 'jour') {
                // Nuages blancs paisibles
                const nuages = [
                    { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                    { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                    { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                ];

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.lineWidth = 2;

                nuages.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                    for(let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * taille * 0.8;
                        const rayonNuage = taille * (0.8 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                });
            } else {
                // Nuages d'orage gris avec √©clairs
                const nuagesOrage = [
                    { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                    { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                    { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                ];

                nuagesOrage.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                    // Nuages gris mena√ßants
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                    ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                    ctx.lineWidth = 2;

                    for(let i = 0; i < 4; i++) {
                        const offsetX = (i - 1.5) * taille * 0.6;
                        const rayonNuage = taille * (0.7 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // √âclairs occasionnels
                    if(Math.random() < 0.02) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(nuageX, nuageY + taille);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                        ctx.stroke();
                    }
                });
            }
        }

        // Rendu principal
        function dessiner() {

            // Fond d√©grad√© selon le chapitre
            const grad = ctx.createLinearGradient(0, 0, 0, C.H);
            if(periode === 'jour') {
                // Ciel diurne
                grad.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
                grad.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
                grad.addColorStop(1, 'rgba(240,248,255,0.98)');
            } else {
                // Ciel nocturne orageux
                grad.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
                grad.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
                grad.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, C.H);

            dessinerCiel();
            dessinerMer();
            dessinerInterface();
            dessinerPrejuges();
            dessinerPowerUps();
            dessinerCoeursBateau();
            dessinerPetitsCoeurs();
            dessinerBateau();
            afficherMunitions();
            dessinerStarsProjectiles(); // √âtoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // √âtoiles (phase briques)
            // Mode secret - utiliser le module
            if (secretModeModule && secretModeModule.isActive) {
                secretModeModule.render();
            } else if (modeSecret) {
                // Fallback si le module n'est pas disponible
                dessinerProjectilesSecret();
            }
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret

            // Obstacles g√©r√©s par le module secret seulement

            // Objets kawaii r√©serv√©s au mode secret uniquement
            // (Les objets kawaii sont maintenant dans le module secret)

            dessinerParticules();

            // Rendu des drones feux d'artifice
            if (droneModule) {
                droneModule.render();
            }

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
            dessinerMessagePowerupSimple(); // Messages simples des powerups en haut
            dessinerMessageNarratifSimple(); // Messages narratifs centr√©s
            dessinerBoutonPasser(); // Bouton passer simple en haut
        }

        // Contr√¥les tactiles et souris unifi√©s
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left };
        }

        function deplacerRaquette(x) {
            if(!jeu) return;
            raquette.x = x - C.PW/2;
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));
        }

        // √âv√©nements tactiles
        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); tactile = true;

            // V√©rifier le clic sur le bouton passer
            const pos = obtenirPosition(e);
            if (verifierClicBoutonPasser(pos.x, pos.y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && periode !== 'nuit' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
                return;
            }

            if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles tactile
                const pos = obtenirPosition(e);
                tirerStarsProjectile(pos.x, pos.y);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction al√©atoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('üèÆ Lanterne lanc√©e !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir √©toiles activ√© par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const pos = obtenirPosition(e);
                        tirerStarsProjectile(pos.x, pos.y);
                    }
                } else {
                    // Si la balle est d√©j√† en mouvement, d√©placer la raquette
                    const pos = obtenirPosition(e);
                    deplacerRaquette(pos.x);
                }
            } else {
                const pos = obtenirPosition(e);
                deplacerRaquette(pos.x);
                libererVaguesAmour(); // Lib√©rer une vague d'amour
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // √âv√©nements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();


            deplacerRaquette(e.clientX - rect.left);
        });

        canvas.addEventListener('click', (e) => {
            // V√©rifier le clic sur le bouton passer
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (verifierClicBoutonPasser(x, y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement en phases lanterne/stars/fin_niveau - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && phaseJeu !== 'feux_artifice' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
            } else if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction al√©atoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('üèÆ Lanterne lanc√©e !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir √©toiles activ√© par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const rect = canvas.getBoundingClientRect();
                        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                        tirerStarsProjectile(mouseX, mouseY);
                    }
                }
            } else {
                // Le syst√®me de clic sur les oiseaux est maintenant g√©r√© par les √©v√©nements CSS
                // Voir la fonction setupBirdClickHandlers() plus bas

                // Clic normal sur canvas pour lib√©rer l'amour
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, utiliser le module
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.createProjectile();
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        creerProjectile();
                    }
                }
            }
        });

        // Redimensionnement responsive
        window.addEventListener('resize', () => {
            size = setupCanvas();
            if(!jeu) initJeu();
        });

        // ========== MODULE MODE SECRET - INITIALISATION ==========
        function initSecretModeModule() {
            if (!canvas || !ctx) {
                console.error('Canvas ou contexte non disponible pour le module secret');
                return;
            }

            // V√©rifier si la classe SecretModeModule est disponible
            if (typeof SecretModeModule === 'undefined') {
                console.warn('‚ö†Ô∏è SecretModeModule non trouv√© - Utilisation du mode secret int√©gr√©');
                secretModeModule = null;
                return;
            }

            try {
                // Cr√©er l'instance du module avec un objet gameState plus simple
                const gameStateRef = {
                    get modeSecret() { return modeSecret; },
                    set modeSecret(val) { modeSecret = val; },
                    get jeu() { return jeu; },
                    set jeu(val) { jeu = val; },
                    get score() { return score; },
                    set score(val) { score = val; },
                    get raquette() { return raquette; },
                    get C() { return C; },
                    get phaseJeu() { return phaseJeu; },
                    set phaseJeu(val) { phaseJeu = val; },
                    afficherMessage: (msg, duree) => afficherMessage(msg, duree),
                    ajouterParticules: (x, y, couleur, nb) => ajouterParticules(x, y, couleur, nb)
                };

                secretModeModule = new SecretModeModule(canvas, ctx, gameStateRef);
                console.log('üéÆ Module Mode Secret initialis√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur initialisation module secret:', error);
                secretModeModule = null;
            }
        }

        // ========== MODULE OBJETS KAWAII - INITIALISATION ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret DOM
        // Plus besoin d'initialisation s√©par√©e

        // ========== MODULE OBJETS KAWAII - SUPPRIM√â ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret
        function activerObjetsKawaii() {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        function desactiverObjetsKawaii() {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        function configurerObjetsKawaii(config) {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        // ========== MODULE OISEAUX CSS - GESTIONNAIRE √âV√âNEMENTS ==========
        function setupBirdClickHandlers() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            // Clic sur le corbeau
            crowElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'corbeau') {
                    handleBirdClick();
                }
            });

            // Clic sur la colombe
            doveElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'colombe') {
                    handleBirdClick();
                }
            });
        }

        function handleBirdClick() {
            corbeau.touches++;
            score += 100; // Points bonus pour toucher l'oiseau

            // Effet visuel
            ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

            if (corbeau.touches >= 3 && corbeau.type === 'corbeau') {
                // Transformer en colombe !
                corbeau.type = 'colombe';
                score += 1000; // Gros bonus pour la transformation

                // D√©bloquer le niveau secret !
                niveauSecretDebloque = true;

                afficherMessagePowerupSimple('üïäÔ∏è Miracle! +1000 pts - Niveau secret d√©bloqu√©!');

                // Le soleil fait un clin d'≈ìil
                soleil.clignotement = true;
                soleil.tempsClignotement = Date.now();

                // D√©clencher le niveau secret apr√®s un d√©lai
                setTimeout(() => {
                    if (secretModeModule) {
                        secretModeModule.activate();
                    } else {
                        console.error('Module secret non initialis√© !');
                        lancerNiveauSecret(); // Fallback vers l'ancien syst√®me
                    }
                }, 4000);
            } else {
                // Message discret en bas √† droite
                afficherMessageCorbeauBas(`üéØ ${corbeau.touches}/3 üí∞ +100`, 1000);
            }
        }

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas √† droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu) return;

            // Initialiser le temps de d√©part si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire appara√Ætre le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;

                // Alterner la direction √† chaque passage
                if(corbeau.direction === 1) {
                    // Gauche vers droite
                    corbeau.x = -100;
                    corbeau.vx = 0.8 / 1.5;
                } else {
                    // Droite vers gauche
                    corbeau.x = C.W + 100;
                    corbeau.vx = -(0.8 / 1.5);
                }

                corbeau.y = C.H * 0.4; // Vers le milieu de l'√©cran
                corbeau.touches = 0; // R√©initialiser le compteur de touches

                // Alterner pour le prochain passage
                corbeau.direction *= -1;

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;

                console.log(`üê¶ Corbeau spawn - Direction: ${corbeau.vx > 0 ? 'droite ‚Üí' : '‚Üê gauche'}`);
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                corbeau.y += Math.sin(Date.now() * 0.0005) * 0.25; // Mouvement ondulant tr√®s doux et petit

                // Retirer le corbeau s'il sort de l'√©cran (dans les deux directions)
                if((corbeau.vx > 0 && corbeau.x > C.W + 100) || (corbeau.vx < 0 && corbeau.x < -100)) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        // ========== MODULE OISEAUX CSS - FONCTION MODIFI√âE ==========
        function dessinerCorbeau() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            if (!corbeau.actif) {
                // Masquer tous les oiseaux
                crowElement.classList.remove('bird-visible');
                crowElement.classList.add('bird-hidden');
                doveElement.classList.remove('bird-visible');
                doveElement.classList.add('bird-hidden');
                return;
            }

            // Positionner l'oiseau selon les coordonn√©es
            const activeElement = corbeau.type === 'corbeau' ? crowElement : doveElement;
            const inactiveElement = corbeau.type === 'corbeau' ? doveElement : crowElement;

            // Masquer l'oiseau inactif
            inactiveElement.classList.remove('bird-visible');
            inactiveElement.classList.add('bird-hidden');

            // Positionner et afficher l'oiseau actif
            activeElement.style.left = corbeau.x + 'px';
            activeElement.style.top = corbeau.y + 'px';

            // Orienter l'oiseau selon sa direction avec l'animation appropri√©e
            if (corbeau.vx < 0) {
                // Va vers la gauche - utiliser animation retourn√©e
                activeElement.style.animation = 'crow-auto-flight-left calc(2s / var(--animation-speed)) infinite';
                console.log('üê¶ Corbeau orient√© GAUCHE ‚Üê (animation crow-auto-flight-left)');
            } else {
                // Va vers la droite - animation normale
                activeElement.style.animation = 'crow-auto-flight calc(2s / var(--animation-speed)) infinite';
                console.log('üê¶ Corbeau orient√© DROITE ‚Üí (animation crow-auto-flight)');
            }

            activeElement.classList.remove('bird-hidden');
            activeElement.classList.add('bird-visible');
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y) {
            textesVolants.push({
                texte: texte,
                x: x,
                y: y,
                xDepart: x,
                yDepart: y,
                vy: 0, // Vitesse calcul√©e dynamiquement
                taille: 12, // Taille initiale
                alpha: 1, // Opacit√©
                temps: 0,
                phase: 'descente' // 'descente' puis 'montee'
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.004; // Progression plus lente

                // Mouvement vers le centre horizontal
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Progression plus lente vers le centre
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis mont√©e
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 200); // Descend plus bas (200px max)

                    // Fondu pendant la descente
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Fondu plus marqu√©

                    // Passer √† la phase mont√©e apr√®s plus de temps
                    if(texte.temps > 0.2) {
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 120); // Remonte moins vite

                    // Fondu retour pendant la mont√©e
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 3);
                }

                // Grossissement tr√®s progressif et doux
                texte.taille = 12 + texte.temps * 20;

                // Disparition finale tr√®s progressive
                if(texte.temps > 0.6) {
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.6) * 2);
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu
        function boucleJeu() {
            // G√©rer l'animation du bateau
            gererAnimationBateau();

            // G√©rer la phase d'introduction
            gererPhaseIntro();

            // Phase bonus - Le Mur dans la Mer
            if (phaseJeu === 'bonus_mur' && window.phaseBonusMur) {
                window.phaseBonusMur.update();
            } else if(jeu || phaseIntro.active) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Syst√®me projectiles stars
                    mettreAJourProjectiles(); // Nouveau syst√®me de projectiles
                    mettreAJourBulle(); // Ancien syst√®me pour les autres phases
                }
                mettreAJourParticules();

                // Mise √† jour du module de drones
                if (droneModule) {
                    droneModule.animate();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                mettreAJourPetitsCoeurs();
                mettreAJourTextesVolants();
                mettreAJourCorbeau(); // Gestion du corbeau secret
                mettreAJourMessageCorbeauBas(); // Messages discrets du corbeau

                // Obstacles g√©r√©s par le module secret seulement

                // Objets kawaii r√©serv√©s au mode secret uniquement
                // (Les objets kawaii sont maintenant dans le module secret)
                // Mode secret - utiliser le module
                if (secretModeModule && secretModeModule.isActive) {
                    secretModeModule.update();
                } else if (modeSecret) {
                    // Fallback si le module n'est pas disponible
                    mettreAJourProjectilesSecret();
                }
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }

        // D√©marrage avec intro forc√©e
        initJeu();

        // FORCER l'intro apr√®s initJeu (car initJeu peut modifier ces valeurs)
        phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        jeu = false; // Important: forcer jeu = false pour permettre l'intro

        // üéØ AFFICHAGE IMM√âDIAT DE L'INTRO (solution radicale)
        console.log('üöÄ FOR√áAGE IMM√âDIAT DE L\'INTRO');
        setTimeout(() => {
            // üéØ ACTIVER LE TITRE DANS LE CANVAS
            titreVoyage.active = true;
            titreVoyage.texte = 'L\'aube des doutes\nPhase 1';
            titreVoyage.fin = Date.now() + 30000; // Affich√© pendant 30 secondes


            // Affichage direct de l'intro Phase 1 avec bouton passer
            // Utiliser notre syst√®me simple
            afficherMessageNarratifSimple(`"On m'a dit qu'ils √©taient tous des monstres...
On m'a dit tant de mal, tant de malheurs sur eux...
Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."`, 12000);

            // Activer le bouton passer pendant l'intro
            boutonPasser.actif = true;

            // D√©sactiver le bouton apr√®s l'intro
            setTimeout(() => {
                boutonPasser.actif = false;
            }, 15000);

            // Code bouton supprim√© pour simplicit√©
            /*afficherMessage(`
                <div style="font-size: 22px; color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); line-height: 1.4;">
                    üåü "On m'a dit qu'ils √©taient tous des monstres...
                    <br>‚ú® On m'a dit tant de mal, tant de malheurs sur eux...
                    <br>üîç Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."
                </div>

                CODE BOUTON COMPLEXE SUPPRIM√â POUR SIMPLICIT√â
            */

            // üéØ AFFICHER LE MESSAGE "NON ON PEUT PAS LAISSER PASSER √áA" √Ä LA FIN
            setTimeout(() => {
                afficherMessageNarratifSimple('NON on peut pas laisser passer √ßa !', 3000);
            }, 12000); // √Ä la fin de l'intro (12 secondes)

            // üéØ D√âCLENCHER LA R√âCOMPENSE 100 POINTS APR√àS LE MESSAGE
            setTimeout(() => {
                console.log('üåü Fin de l\'intro - Attribution 100 Points');

                try {
                    if (phaseJeu === 'tir_coeurs_haut') {
                        console.log('pointsConnaissance avant bonus intro:', pointsConnaissance);
                        pointsConnaissance += 100;
                        console.log('pointsConnaissance apr√®s bonus intro:', pointsConnaissance);
                    } else {
                        console.log('Score avant bonus intro:', score);
                        score += 100;
                        console.log('Score apr√®s bonus intro:', score);
                    }

                    // Message simple
                    afficherMessagePowerupSimple('üåü +100 Points intro compl√®te');
                } catch (error) {
                    console.error('‚ùå Erreur lors de l\'attribution points intro:', error);
                }
            }, 15000); // D√©clencher apr√®s le message NON (12000ms + 3000ms)

        }, 500); // Attendre 0.5 seconde pour √™tre s√ªr que l'interface est pr√™te

        // === RACCOURCI TEST MENU ===
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                e.preventDefault();
                narrationManager.showFinalMenu();
            }
        });

        // === ANCIEN SYST√àME NARRATION SUPPRIM√â ===
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let phaseAvantSecret = null; // Sauvegarder la phase avant le mode secret
        let modeEtoileLance = false; // Pour tracker si on est en mode √©toile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        // anciens messages supprim√©s

        // Fonction supprim√©e

        // Fonctions supprim√©es

        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer √† la phase suivante (d√©sactiv√©)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprim√©e pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Mode passe : Touche S pour niveau secret
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Mode passe : Touche R pour r√©duire la vie des briques √† 1
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                reduireVieBriques();
            }

            // Mode passe : Touche E pour tir automatique √©toiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

            // Cheat code : Touche X pour multiplier puissance x10
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                if (multiplicateurPuissance === 1) {
                    multiplicateurPuissance = 10;
                    console.log('üöÄ CHEAT ACTIV√â: Puissance x10!');
                } else {
                    multiplicateurPuissance = 1;
                    console.log('üîÑ CHEAT D√âSACTIV√â: Puissance normale');
                }
            }

        });

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            // D√©sactiver les objets kawaii pendant le mode secret
            desactiverObjetsKawaii();

            // Utiliser le module si disponible, sinon le syst√®me int√©gr√©
            if (secretModeModule) {
                secretModeModule.activate();
                return;
            }

            // Fallback vers l'ancien syst√®me
            // Sauvegarder la phase actuelle
            phaseAvantSecret = phaseJeu;

            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = []; // R√©initialiser les obstacles pour le fallback

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Mode secret utilise maintenant le module secret - pas d'obstacles de fallback

            afficherMessageAnime('üéØ NIVEAU SECRET : TIR DE PR√âCISION ! üéØ\n\nüßä Tirez sur les icebergs et poubelles ! ‚ôª\nüêã ATTENTION : Les baleines sont prot√©g√©es !\nüö´ Tirer sur une baleine = "NO GREAT!" et perte de vie\nüëÜ Chaque clic = un tir pr√©cis\nüí∞ +100 points par obstacle d√©truit !', 5000, 'glitch', 50);
        }



        function creerProjectile() {
            // Cr√©er un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // V√©rifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle d√©j√† touch√©

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision d√©tect√©e !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine prot√©g√©e ! Perdre une vie
                            vies--;

                            // Messages amusants vari√©s
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                // Restaurer la phase d'origine m√™me en Game Over
                                if (phaseAvantSecret) {
                                    phaseJeu = phaseAvantSecret;
                                    phaseAvantSecret = null;
                                } else {
                                    phaseJeu = 'briques'; // Fallback par d√©faut
                                }

                                // R√©activer les objets kawaii apr√®s Game Over
                                activerObjetsKawaii();

                                afficherMessageAvecBoutons(`üíÄ ${messageAleatoire} üíÄ\n\nüêã Tu as tir√© sur une baleine prot√©g√©e !\nüò± Toutes tes vies sont √©puis√©es !\nüö´ Les baleines ne se tirent pas !\nü§™ HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `üö´ ${messageAleatoire} üö´\n\nüêã Les baleines sont prot√©g√©es !\nüíî Vie perdue : ${vies} restantes\nüò§ Tire seulement sur les icebergs !\nüôÑ TSSS TSSS!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã BALEINE = INTERDITE !\nüíî Oups : ${vies} vies restantes\nüò§ ICEBERGS SEULEMENT !\nü§¶‚Äç‚ôÇÔ∏è PFFFFFF!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã PAUVRE BALEINE !\nüíî Punition : ${vies} vies left\nüò§ GLACE = OK, BALEINE = NON !\nüòÇ HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (col√®re)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK √† d√©truire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle d√©truit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succ√®s)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touch√© temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // SUPPRIM√â: creerObstaclesMarins() - remplac√© par le module secret

        // SUPPRIM√â: mettreAJourObstacles() - remplac√© par le module secret

        // SUPPRIM√â: Module obstacles legacy - remplac√© par le module secret

        // SUPPRIM√â: dessinerObstacles() - remplac√© par le module secret

        // L'animation d√©marre automatiquement via gererAnimationBateau()
        window.addEventListener('load', function() {
            console.log('üéÆ Window load - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
            console.log('üéÆ Window load - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');

            // Attente plus longue pour s'assurer que tous les scripts sont charg√©s
            setTimeout(() => {
                console.log('üéÆ D√©marrage du jeu - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
                console.log('üéÆ D√©marrage du jeu - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');
                boucleJeu();
            }, 500);
        });
    </script>


</body></html>