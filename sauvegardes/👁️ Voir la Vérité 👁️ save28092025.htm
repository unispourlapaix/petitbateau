<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>👁️ Voir la Vérité 👁️</title>
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            background: transparent;
            backdrop-filter: none; -webkit-backdrop-filter: none;
            border: none;
            border-radius: 0; padding: 25px 113px;
            box-shadow: none;
            max-width: none; width: 100%; text-align: center; z-index: 200;
            display: none; font-size: clamp(21px, 5.25vw, 24px); color: #ffffff;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Messages narratifs - style cinématique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: transparent;
            border: none;
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: none; width: 100%;
                font-size: clamp(21px, 2.7vw, 24px);
                padding: 20px 113px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Indicateur d'étape */
        .etape-indicateur {
            display: none !important;
        }

        .etape-indicateur.show {
            display: block;
        }

        /* Animation shake pour le bouton skip */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes etapeGlow {
            0% {
                box-shadow:
                    0 4px 15px rgba(0,0,0,0.3),
                    0 0 20px rgba(77,166,255,0.2),
                    inset 0 1px 1px rgba(255,255,255,0.1);
            }
            100% {
                box-shadow:
                    0 4px 20px rgba(0,0,0,0.4),
                    0 0 30px rgba(77,166,255,0.5),
                    inset 0 1px 1px rgba(255,255,255,0.2);
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* ═══════════════════════════════════════════════════════════════════ */
        /* 🎬 STYLES TEXTANIMATOR OPTIMISÉ */
        /* ═══════════════════════════════════════════════════════════════════ */

        .text-animator-display {
            font-size: 1.2em;
            line-height: 1.6;
            background: transparent;
        }

        /* Animations de base */
        .ta-typewriter { border-right: 2px solid #ffffff; animation: ta-blink 1s infinite; }
        .ta-digital { color: #00cc44; text-shadow: 0 0 8px #00cc44; font-family: 'Courier New', monospace; letter-spacing: 2px; }
        .ta-fade-in { animation: ta-fadeIn 1s ease-in; }
        .ta-glitch { position: relative; color: #fff; animation: ta-glitch 2s infinite; }

        /* Effets 3D optimisés */
        .ta-effect-shadow3d { text-shadow: 2px 2px 0px var(--ta-effect-color, #64ffda), 4px 4px 0px rgba(0,0,0,0.5), 6px 6px 10px rgba(0,0,0,0.8); }
        .ta-effect-neon { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda), 0 0 80px var(--ta-effect-color, #64ffda); animation: ta-neonPulse 2s ease-in-out infinite alternate; }
        .ta-effect-emboss { text-shadow: 1px 1px 0px var(--ta-effect-color, #64ffda), -1px -1px 0px rgba(0,0,0,0.8), 2px 2px 5px rgba(0,0,0,0.6); color: var(--ta-text-color, #fff); }
        .ta-effect-outline { text-shadow: -2px -2px 0 var(--ta-effect-color, #64ffda), 2px -2px 0 var(--ta-effect-color, #64ffda), -2px 2px 0 var(--ta-effect-color, #64ffda), 2px 2px 0 var(--ta-effect-color, #64ffda), 0 0 10px rgba(0,0,0,0.5); }
        .ta-effect-fire { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; animation: ta-fireFlicker 1.5s ease-in-out infinite alternate; }
        .ta-effect-ice { background: linear-gradient(45deg, #87ceeb, #add8e6, #e0ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); animation: ta-iceShimmer 3s ease-in-out infinite; }

        /* Keyframes optimisées */
        @keyframes ta-blink { 0%, 50% { border-color: transparent; } 51%, 100% { border-color: #ffffff; } }
        @keyframes ta-fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes ta-glitch { 0%, 100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000; transform: translate(0); } 20% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; transform: translate(-2px, 2px); } 40% { text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff; transform: translate(-2px, -2px); } 60% { text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; transform: translate(2px, 2px); } 80% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff; transform: translate(2px, -2px); } }
        @keyframes ta-neonPulse { from { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda); } to { text-shadow: 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-text-color, #fff), 0 0 30px var(--ta-effect-color, #64ffda), 0 0 60px var(--ta-effect-color, #64ffda), 0 0 100px var(--ta-effect-color, #64ffda); } }
        @keyframes ta-fireFlicker { 0%, 100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; } 50% { text-shadow: 0 0 5px #ff4500, 0 0 15px #ff8c00, 0 0 25px #ffd700, 0 0 35px #ff4500; } }
        @keyframes ta-iceShimmer { 0%, 100% { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); } 50% { text-shadow: 1px 1px 3px rgba(0,0,0,1); } }
        /* ===========================================
           MODULE OISEAUX VOLANTS - INTÉGRATION
           Par Emmanuel Payet / Dreamer Unisona
           ========================================== */

        /* Variables CSS pour le module oiseaux */
        :root {
            --bird-scale: 1;
            --animation-speed: 1;
            --crow-color: #1A1A1A;
            --dove-color: #FFFFFF;
            --bat-color: #000000;
        }

        /* Container pour oiseaux sur canvas */
        .flying-birds-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 150;
        }

        /* Base commune pour tous les oiseaux */
        .bird-base {
            position: absolute;
            transform-origin: center;
            pointer-events: auto;
            transition: all 0.3s ease;
            transform: scale(var(--bird-scale));
            cursor: pointer;
        }

        /* États de visibilité */
        .bird-hidden {
            opacity: 0;
            transform: scale(0) scale(var(--bird-scale));
        }

        .bird-visible {
            opacity: 1;
            transform: scale(1) scale(var(--bird-scale));
        }

        /* CORBEAU BADASS - ID: crow */
        #crow {
            width: 45px;
            height: 30px;
            background: linear-gradient(135deg, var(--crow-color), #000000);
            clip-path: polygon(10% 15%, 25% 0%, 75% 5%, 90% 25%, 95% 60%, 85% 90%, 15% 95%, 5% 70%);
            animation: crow-auto-flight calc(2s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* Aile du corbeau */
        #crow::before {
            content: '';
            position: absolute;
            width: 28px;
            height: 18px;
            background: linear-gradient(45deg, #4A4A4A, #2F2F2F, #1A1A1A);
            clip-path: polygon(0% 20%, 30% 0%, 70% 5%, 100% 30%, 90% 70%, 60% 100%, 20% 85%, 5% 50%);
            top: 5px;
            left: 2px;
            z-index: -1;
            animation: crow-wing-beat calc(0.15s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        /* Œil rouge du corbeau */
        #crow::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 5px;
            background: linear-gradient(135deg, #FF0000, #8B0000);
            clip-path: polygon(0% 40%, 30% 0%, 100% 20%, 80% 100%, 20% 80%);
            top: 9px;
            right: 8px;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
            animation: crow-evil-glow calc(1.5s / var(--animation-speed)) infinite;
        }

        /* COLOMBE ÉLÉGANTE - ID: dove */
        #dove {
            width: 40px;
            height: 25px;
            background: linear-gradient(135deg, var(--dove-color), #F8F8FF, #E6E6FA);
            clip-path: polygon(15% 10%, 40% 0%, 85% 8%, 95% 35%, 90% 65%, 75% 90%, 25% 95%, 5% 60%, 10% 30%);
            animation: dove-auto-flight calc(3s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.15));
        }

        /* Aile de la colombe */
        #dove::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 12px;
            background: linear-gradient(45deg, #F8F8FF, #E6E6FA, #D6D6EA);
            clip-path: polygon(0% 30%, 25% 0%, 60% 5%, 85% 15%, 100% 40%, 95% 70%, 75% 100%, 40% 95%, 15% 85%, 5% 60%);
            top: 6px;
            left: 6px;
            z-index: -1;
            animation: dove-wing-beat calc(0.4s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.2));
        }

        /* Œil bleu de la colombe */
        #dove::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle at 30% 30%, #87CEEB, #4169E1);
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            top: 8px;
            right: 8px;
            box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
            animation: dove-sparkle calc(3s / var(--animation-speed)) infinite;
        }

        /* ANIMATIONS DU MODULE */
        @keyframes crow-auto-flight {
            0%, 100% {
                transform: translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: translateY(-15px) rotate(2deg) scale(var(--bird-scale));
            }
            50% {
                transform: translateY(-8px) rotate(-1deg) scale(var(--bird-scale));
            }
            75% {
                transform: translateY(-20px) rotate(1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-auto-flight-left {
            0%, 100% {
                transform: scaleX(-1) translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: scaleX(-1) translateY(-15px) rotate(-2deg) scale(var(--bird-scale));
            }
            50% {
                transform: scaleX(-1) translateY(-8px) rotate(1deg) scale(var(--bird-scale));
            }
            75% {
                transform: scaleX(-1) translateY(-20px) rotate(-1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-15deg) scaleX(1);
            }
            100% {
                transform: rotateY(-20deg) rotateZ(10deg) scaleX(1.1);
            }
        }

        @keyframes crow-evil-glow {
            0%, 100% {
                box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 0, 0, 1);
                filter: brightness(1.3);
            }
        }

        @keyframes dove-auto-flight {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(var(--bird-scale));
            }
            33% {
                transform: translateY(-12px) translateX(2px) scale(var(--bird-scale));
            }
            66% {
                transform: translateY(-8px) translateX(-1px) scale(var(--bird-scale));
            }
        }

        @keyframes dove-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-8deg) translateX(0px);
            }
            100% {
                transform: rotateY(-12deg) rotateZ(5deg) translateX(1px);
            }
        }

        @keyframes dove-sparkle {
            0%, 100% {
                box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 8px rgba(135, 206, 235, 0.8);
                filter: brightness(1.2);
            }
        }

    </style>
</head>
<body style="filter: brightness(0.7);">
    <div class="game-container">
        <canvas id="gameCanvas" width="449" height="799" style="width: 449px; height: 799px;"></canvas>

        <!-- CHARGER LES MODULES AVANT LE SCRIPT PRINCIPAL -->
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20save28092025_fichiers/kawaii_objects_module.js"></script>
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20save28092025_fichiers/secret-mode.js"></script>

        <!-- MODULE OISEAUX VOLANTS CSS -->
        <div class="flying-birds-overlay">
            <!-- Corbeau Badass -->
            <div id="crow" class="bird-base bird-visible" style="left: 218.333px; top: 286.979px; animation: crow-auto-flight-left calc(2s / var(--animation-speed)) infinite;"></div>

            <!-- Colombe Élégante -->
            <div id="dove" class="bird-base bird-hidden"></div>
        </div>
        <div id="message" class="message" style="transform: translate(-50%, -50%) scale(1); display: none;">
                                🌟 "On m'a dit qu'ils étaient tous des monstres...
                                ✨ On m'a dit tant de mal, tant de malheurs sur eux...
                                🔍 Mais moi, j'ai préféré aller voir de mes propres yeux."

                                <button onclick="
                                    alert('🚫 NON on peut pas laisser passer ça ! 🚫');

                                    // Gagner 50 points (système adaptatif)
                                    if (phaseJeu === 'tir_coeurs_haut') {
                                        pointsConnaissance += 50;
                                        console.log('50 pointsConnaissance ajoutés ! Total:', pointsConnaissance);
                                    } else {
                                        score += 50;
                                        console.log('50 score ajoutés ! Total:', score);
                                    }

                                    // Changer le bouton en NON !
                                    this.innerHTML = 'NON !';
                                    this.style.background = '#f44336';

                                    // Changer l'action du bouton pour les prochains clics
                                    this.onclick = function() {
                                        afficherMessage('🚫 NON ! On ne peut pas laisser passer ça ! 🚫', 2000);
                                        // Gagner 10 points à chaque clic sur NON
                                        if (phaseJeu === 'tir_coeurs_haut') {
                                            pointsConnaissance += 10;
                                            console.log('10 pointsConnaissance ajoutés ! Total:', pointsConnaissance);
                                        } else {
                                            score += 10;
                                            console.log('10 score ajoutés ! Total:', score);
                                        }
                                    };
                                " style="margin-top: 20px; padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    Passer
                                </button>
                            </div>
        <div id="etapeIndicateur" class="etape-indicateur show">
                    <div>🧱 4/16</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">Voyage — L'ombre des nuages</div>
                </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            return { width, height };
        }

        let size = setupCanvas();
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: Math.max(Math.min(size.width, size.height) * 0.002, 1.5)
        };

        // Voyage de découverte de la vérité - Le Jour : La Lumière
        const JOUR = [
            { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: '🗣️ Les manipulations s\'effacent devant la vérité !' },
            { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: '👨‍👩‍👧‍👦 Non... des humains comme nous !' },
            { nom: 'PRÉJUGÉS', couleur: '#DDA0DD', msg: '🎭 Les masques tombent un à un...' },
            { nom: 'PEURS', couleur: '#98FB98', msg: '👁️ J\'ai choisi de voir par moi-même !' },
            { nom: 'MÉFIANCE', couleur: '#FFCCCB', msg: '🤝 La méfiance cède à la compation...' },
            { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '❓ Cette question hante mes nuits...' },
            { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: '👁️ Et mes yeux se sont ouverts...' },
            { nom: 'UN PÈRE', couleur: '#FFDAB9', msg: '👨 Un homme qui aime ses enfants...' },
            { nom: 'UNE MÈRE', couleur: '#AFEEEE', msg: '👩 Une femme courageuse...' },
            { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: '👶 Des rires purs et innocents...' },
            { nom: 'L\'HUMANITÉ', couleur: '#FFE4E1', msg: '💫 L\'essence même de ce que nous sommes...' },
            { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '❤️ Plus fort que toutes les barrières...' },
            { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: '🤗 Qui unit au-delà des différences...' },
            { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: '🌅 Une lumière dans l\'obscurité...' },
            { nom: 'LA PAIX', couleur: '#F5F5DC', msg: '🕊️ Possible quand on choisis d\'aimer...' },
            { nom: 'COMME MOI', couleur: '#FFFACD', msg: '🌍 On est tous des immigrés...' }
        ];

        // La Nuit : L'Obscurité - Les maux qui tentent de corrompre
        const NUIT = [
            { nom: 'DISCORDES', couleur: '#8B0000', msg: '⚡ Des discordes... des haines... des destructions...' },
            { nom: 'HAINES', couleur: '#4B0000', msg: '💔 Venues avec les maux de l\'ombre...' },
            { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: '🌪️ Le vol, le mensonge, la manipulation...' },
            { nom: 'VOL', couleur: '#36454F', msg: '🦹 Qui s\'empare de ce qui n\'appartient pas...' },
            { nom: 'MENSONGE', couleur: '#2F2F2F', msg: '🎭 Les masques de la tromperie...' },
            { nom: 'MANIPULATION', couleur: '#654321', msg: '🕷️ Les fils invisibles tirent les cœurs...' },
            { nom: 'CUPIDITÉ', couleur: '#654321', msg: '💰 La cupidité et l\'avidité...' },
            { nom: 'AVIDITÉ', couleur: '#483C32', msg: '⛓️ Comme des chaînes invisibles...' },
            { nom: 'CHAÎNES', couleur: '#2E4B2E', msg: '🔗 Serrant le cœur des hommes...' },
            { nom: 'MURS DE FER', couleur: '#191970', msg: '🧱 Enfermés derrière des murs de fer et de peur...' },
            { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: '💚 Le poison vert de l\'envie...' },
            { nom: 'ORGUEIL', couleur: '#191970', msg: '👑 La couronne qui aveugle...' },
            { nom: 'COLÈRE', couleur: '#8B1538', msg: '🔥 Les flammes qui consument la raison...' },
            { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '⚔️ La spirale sans fin de la souffrance...' },
            { nom: 'INDIFFÉRENCE', couleur: '#708090', msg: '🧊 Le froid qui glace les âmes...' },
            { nom: 'ÉGOÏSME', couleur: '#5D5D5D', msg: '🪞 Ne voir que son propre reflet...' },
            { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: '🙈 Choisir de fermer les yeux...' },
            { nom: 'RÉSISTANCE', couleur: '#1C1C1C', msg: '🛡️ Mais je garde mon cœur pur dans la tempête...' },
            { nom: 'LUMIÈRE', couleur: '#483D8B', msg: '✨ Car au-delà des nuages, elle existe toujours...' }
        ];

        // Voyage actuel selon la période
        let VOYAGE = JOUR;

        // ===============================================
        // NOUVEAU SYSTÈME DE NARRATION COMPLETE V2.0
        // ===============================================

        // Gestionnaire central de la narration
        class NarrationManager {
            constructor() {
                this.currentPhase = 1;
                this.isTransitioning = false;
                this.victoryTimers = new Map();
                this.phaseHistory = [];

                // Configuration des phases avec IDs uniques
                this.phases = [
                    {
                        id: 'VDV_NARR_P01_INTRO_LUMIERE',
                        phase: 1,
                        titre: 'Voyage — L\'aube des doutes',
                        texte: "\"On m'a dit qu'ils étaient tous des monstres...\nOn m'a dit tant de mal, tant de malheurs sur eux...\nMais moi, j'ai préféré aller voir de mes propres yeux.\"",
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P02_REVELATION_FAMILLE',
                        phase: 2,
                        titre: 'Voyage — La lumière',
                        texte: '💭 "Qui étaient-ils vraiment ?... Et j\'ai vu...\nUn père... une mère... des enfants...\nTous cherchant simplement à vivre leur meilleure vie... Comme moi."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'neon',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P03_TRANSITION_OBSCURITE',
                        phase: 3,
                        titre: 'Voyage — L\'ombre des nuages',
                        texte: '💭 "Alors, la lune apparut.\nLe ciel s\'assombrit comme une page brûlée par le temps.\nUn aileron fendit les vagues sombres...\nDes éclairs zébrèrent les nuages gris."',
                        mode: 'coeurs',
                        duree: 8000,
                        transition: 'shadow3d',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P04_CHAPITRE2_NUAGES',
                        phase: 4,
                        titre: 'Voyage — L\'ombre des nuages',
                        texte: '💭 "Et avec eux vinrent des maux...\nDes discordes... des haines... des destructions...\nLe vol, le mensonge, la manipulation...\nLa cupidité et l\'avidité, comme des chaînes invisibles,\nserrant le cœur des hommes."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P05_MAUX_CHAINES',
                        phase: 5,
                        titre: 'Voyage — Le silence de l\'âme',
                        texte: '💭 "On m\'a dit de ne pas écouter leurs cris.\nOn m\'a dit de ne pas laisser l\'orage me faire peur.\nCar l\'orage, aussi bruyant qu\'il soit,\nne dure jamais éternellement."',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'fire',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P06_ORAGE_TEMPORAIRE',
                        phase: 6,
                        titre: 'Voyage — Le silence de l\'âme',
                        texte: '💭 "Et si la tempête gronde,\nc\'est peut-être pour rappeler à l\'homme\nqu\'au-delà des nuages, il existe toujours une lumière.\nMais pour la voir, il faut d\'abord traverser la nuit."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P07_LUMIERE_NUAGES',
                        phase: 7,
                        titre: 'Voyage — L\'humanité des cœurs',
                        texte: '💭 "On m\'a dit...\nque l\'humanité n\'existait plus,\nqu\'elle s\'était perdue dans les guerres et les rancunes.\nOn m\'a dit que les hommes n\'accueillaient plus personne,\nqu\'ils s\'enfermaient derrière des murs de fer et de peur."',
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'outline',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P08_CHAPITRE3_HUMANITE',
                        phase: 8,
                        titre: 'Voyage — L\'humanité des cœurs',
                        texte: '💭 "Mais moi, j\'ai vu…\nUne main tendue à un étranger.\nUn sourire partagé malgré la faim.\nUne porte ouverte pour celui qui tremblait dans la nuit."',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'digital',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P09_MAIN_TENDUE',
                        phase: 9,
                        titre: 'Voyage — L\'humanité des cœurs',
                        texte: '💭 "C\'est cela, l\'hospitalité :\nnon pas donner ce qu\'on a de trop,\nmais partager même ce qui manque."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P10_HOSPITALITE',
                        phase: 10,
                        titre: 'Voyage — La sagesse des différences',
                        texte: '💭 "On m\'a dit que la liberté n\'était qu\'un mot,\nune illusion que les puissants vendaient aux faibles.\nMais j\'ai vu…\nUn enfant courir pieds nus sous la pluie,\nriant sans chaînes,\net dans ses rires, j\'ai compris que la liberté vit d\'abord dans l\'âme."',
                        mode: 'coeurs',
                        duree: 8000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P11_LIBERTE_AME',
                        phase: 11,
                        titre: 'Voyage — La sagesse des différences',
                        texte: '💭 "On m\'a dit que les hommes n\'aidaient plus,\nque chacun ne vivait que pour soi.\nMais j\'ai vu…\nDes inconnus soulever ensemble une pierre trop lourde,\net dans cette force partagée, j\'ai vu l\'amour naître."',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'neon',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P12_AMOUR_PARTAGE',
                        phase: 12,
                        titre: 'Voyage — La sagesse des différences',
                        texte: '💭 "On m\'a dit que l\'amour était fragile,\nmais j\'ai vu qu\'il est plus fort que la haine,\ncar il construit quand la haine détruit."',
                        mode: 'briques',
                        duree: 12000,
                        transition: 'fire',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P13_AMOUR_CONSTRUCTION',
                        phase: 13,
                        titre: 'Voyage — L\'unité',
                        texte: '💭 "On m\'a dit que la tolérance était une faiblesse,\nmais j\'ai vu qu\'elle est une sagesse,\ncelle de reconnaître que nous ne sommes pas tous semblables,\net que c\'est bien ainsi."',
                        mode: 'coeurs',
                        duree: 10000,
                        transition: 'shadow3d',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P14_TOLERANCE_SAGESSE',
                        phase: 14,
                        titre: 'Voyage — L\'unité',
                        texte: '💭 "La diversité…\nElle n\'est pas un danger,\nelle est un trésor.\nComme les couleurs d\'un arc-en-ciel,\nc\'est leur différence qui fait naître la beauté."',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'typewriter',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P15_DIVERSITE_TRESOR',
                        phase: 15,
                        titre: 'Voyage — L\'unité',
                        texte: '💭 "Et dans ce mélange d\'humanité,\nj\'ai compris que nous sommes un seul peuple,\nlié par la même soif de vivre,\nde créer,\net d\'aimer."',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P16_UNITE_HUMANITE',
                        phase: 16,
                        titre: 'L\'Unité de l\'Humanité',
                        texte: '💭 "Nous avons construit des murs là où il fallait des ponts.\nDressé des frontières là où coulaient des rivières communes.\n\nMais quand enfin nous comprenons,\nquand les murs tombent dans nos cœurs,\nquand la peur cède place à la curiosité,\nnaît cette unité qui engendre la paix véritable.\n\nNon pas l\'uniformité qui efface,\nmais l\'harmonie qui respecte chaque différence,\ncette paix qui grandit quand nous réalisons\nque nous ne sommes qu\'un seul peuple sous les étoiles."\n\n✨ FIN ✨',
                        mode: 'final',
                        duree: 12000,
                        transition: 'neon',
                        speed: 40
                    }
                ];
            }

            // Obtenir la phase actuelle
            getCurrentPhase() {
                // Trouver la phase par son numéro au lieu d'utiliser l'index
                return this.phases.find(phase => phase.phase === this.currentPhase) || null;
            }

            // Obtenir la phase par ID
            getPhaseById(id) {
                return this.phases.find(phase => phase.id === id) || null;
            }

            // Avancer à la prochaine phase
            nextPhase() {
                // Trouver la phase suivante par numéro
                const nextPhaseNumber = this.currentPhase + 1;
                const nextPhase = this.phases.find(phase => phase.phase === nextPhaseNumber);

                if (nextPhase) {
                    this.currentPhase = nextPhaseNumber;
                    return true;
                } else {
                    return false; // Fin de la narration
                }
            }

            // Réinitialiser la narration
            reset() {
                console.log(`[DEBUG] reset() appelé - retour currentPhase à 1`);
                this.currentPhase = 1;
                this.phaseHistory = [];
                this.isTransitioning = false;
                this.victoryTimers.clear();
                this.hideStepIndicator();
            }

            // Démarrer la narration
            start() {
                console.log(`[DEBUG] start() appelé - appel reset() puis executeCurrentPhase()`);
                console.trace(`[DEBUG] Trace de l'appel start():`);
                this.reset();
                this.executeCurrentPhase();
            }

            // Exécuter la phase actuelle
            executeCurrentPhase() {
                const phase = this.getCurrentPhase();
                if (!phase) {
                    this.finalizeNarration();
                    return;
                }

                // Afficher le titre du voyage au début de la phase
                this.afficherTitreVoyage();

                console.log(`[NARRATION] Exécution phase ${phase.phase}: ${phase.id}`);
                this.phaseHistory.push(phase.id);

                this.isTransitioning = true;

                // Mettre à jour l'indicateur d'étape
                this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                // La narration est maintenant gérée dans chaque setup de mode
                // Pour les modes non-interactifs, programmer un nextPhase automatique
                if (phase.mode !== 'coeurs' && phase.mode !== 'briques' && phase.mode !== 'nuit_coeurs' && phase.mode !== 'etoiles') {
                    setTimeout(() => {
                        this.nextPhase();
                        this.executeCurrentPhase();
                    }, phase.duree);
                }

                // Configurer le mode de jeu
                this.configureGameMode(phase.mode);

                // Marquer la transition comme terminée après configuration
                this.isTransitioning = false;
            }

            // Afficher le titre du voyage
            afficherTitreVoyage() {
                const phase = this.currentPhase;
                let voyageNom = '';

                if (phase === 1) {
                    voyageNom = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageNom = 'La lumière';
                } else if (phase >= 3 && phase <= 4) {
                    voyageNom = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageNom = 'Le silence de l\'âme';
                } else if (phase >= 7 && phase <= 9) {
                    voyageNom = 'L\'humanité des cœurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageNom = 'La sagesse des différences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageNom = 'L\'unité';
                } else if (phase === 16) {
                    voyageNom = 'Animation finale';
                }

                if (voyageNom) {
                    titreVoyage.active = true;
                    titreVoyage.texte = voyageNom + '\nPhase ' + phase;
                    titreVoyage.fin = Date.now() + 5000; // 5 secondes
                }
            }

            // Afficher message narratif simple centré
            afficherMessageAnime(texte, animation = 'emboss', speed = 45, onComplete) {
                // Utiliser notre nouveau système simple centré
                afficherMessageNarratifSimple(texte, 12000);

                // Appeler onComplete après la durée du message si fourni
                if (onComplete) {
                    setTimeout(onComplete, 12000);
                }

                return; // Sortir pour éviter l'ancien code

                switch(animation) {
                    case 'emboss':
                        anim.setColors('#ffffff', '#666666');
                        anim.applyEffect('emboss');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'neon':
                        anim.setColors('#64ffda', '#4da6ff');
                        anim.applyEffect('neon');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'shadow3d':
                        anim.setColors('#ffffff', '#333333');
                        anim.applyEffect('shadow3d');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'glitch':
                        anim.setColors('#ff4444', '#ff6666');
                        anim.applyEffect('glitch');
                        anim.digital(texte, speed, onComplete);
                        break;
                    case 'fire':
                        anim.setColors('#ff4444', '#ff8800');
                        anim.applyEffect('fire');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'ice':
                        anim.setColors('#ffffff', '#ffffff');
                        anim.applyEffect('none');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    default:
                        anim.typewriter(texte, speed, onComplete);
                        break;
                }

                // Note: isTransitioning est maintenant remis à false directement dans executeCurrentPhase
            }

            // Mettre à jour l'indicateur d'étape
            updateStepIndicator(phase, titre, mode) {
                const indicateur = document.getElementById('etapeIndicateur');
                if (!indicateur) return;

                // Icône selon le mode
                let icone = '';
                switch(mode) {
                    case 'coeurs': icone = '💖'; break;
                    case 'nuit_coeurs': icone = '🌙💖'; break;
                    case 'briques': icone = '🧱'; break;
                    case 'etoiles': icone = '⭐'; break;
                    case 'final': icone = '✨'; break;
                    default: icone = '📖'; break;
                }

                // Mettre à jour le contenu
                indicateur.innerHTML = `
                    <div>${icone} ${phase}/16</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">${titre}</div>
                `;

                // Afficher l'indicateur
                indicateur.classList.add('show');
            }

            // Cacher l'indicateur d'étape
            hideStepIndicator() {
                const indicateur = document.getElementById('etapeIndicateur');
                if (indicateur) {
                    indicateur.classList.remove('show');
                }
            }

            // Configurer le mode de jeu selon la phase
            configureGameMode(mode) {
                // Ne pas reconfigurer si on est déjà dans le bon mode
                if (phaseJeu === mode ||
                    (mode === 'coeurs' && phaseJeu === 'tir_coeurs_haut') ||
                    (mode === 'nuit_coeurs' && phaseJeu === 'tir_coeurs_nuit') ||
                    (mode === 'briques' && phaseJeu === 'lanterne') ||
                    (mode === 'etoiles' && phaseJeu === 'stars')) {
                    console.log(`[DEBUG] Déjà dans le bon mode: ${phaseJeu} pour ${mode}`);
                    return;
                }

                switch(mode) {
                    case 'coeurs':
                        this.setupCoeursMode();
                        break;
                    case 'nuit_coeurs':
                        this.setupNuitCoeursMode();
                        break;
                    case 'briques':
                        this.setupBriquesMode();
                        break;
                    case 'etoiles':
                        this.setupEtoilesMode();
                        break;
                    case 'final':
                        this.setupFinalMode();
                        break;
                }
            }

            // Déterminer la période selon la phase (P3, P4, P5, P6, P11, P12 = nuit)
            getPeriodeFromPhase(phaseNumber) {
                return (phaseNumber === 3 || phaseNumber === 4 || phaseNumber === 5 ||
                        phaseNumber === 6 || phaseNumber === 11 || phaseNumber === 12) ? 'nuit' : 'jour';
            }

            // Configuration mode cœurs
            setupCoeursMode() {
                console.log(`[DEBUG] setupCoeursMode appelé - currentPhase: ${this.currentPhase}`);
                const phase = this.getCurrentPhase();
                console.log(`[DEBUG] setupCoeursMode - phase:`, phase);

                // Afficher la narration de début
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Reset effet nuit
                document.body.style.filter = '';
            }

            // Configuration mode nuit cœurs (parties ambiguës)
            setupNuitCoeursMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de début
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet visuel de nuit - assombrir le fond
                document.body.style.filter = 'brightness(0.7)';
            }

            // Configuration mode briques
            setupBriquesMode() {
                console.log(`[DEBUG] setupBriquesMode - currentPhase: ${this.currentPhase}`);
                const phase = this.getCurrentPhase();
                console.log(`[DEBUG] setupBriquesMode - phase:`, phase);

                // Afficher la narration de début avec un délai pour éviter le conflit avec le titre
                setTimeout(() => {
                    this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);
                }, 4500); // Attendre que le titre de voyage disparaisse

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;

                // En mode nuit, activer les étoiles tirables en plus des briques
                if(periode === 'nuit') {
                    phaseJeu = 'stars'; // Mode étoiles tirables dans la nuit
                } else {
                    phaseJeu = 'lanterne'; // Mode classique casse-briques avec lanterne
                    balle.visible = true;
                    balle.enAttente = true;
                    balle.dx = 0;
                    balle.dy = 0;
                }

                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
                // Garder l'état de la lanterne de la phase précédente
                // lanterne.active et lanterne.intensite conservés

                // Appliquer effet nuit si nécessaire
                if(periode === 'nuit') {
                    document.body.style.filter = 'brightness(0.7)';
                } else {
                    document.body.style.filter = '';
                }
            }

            // Configuration mode étoiles
            setupEtoilesMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de début
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                // Déterminer automatiquement la période selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'stars';
                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
            }

            // Configuration mode final
            setupFinalMode() {
                const phase = this.getCurrentPhase();

                // Afficher la narration de début
                this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);

                setTimeout(() => {
                    this.finalizeNarration();
                }, phase.duree + 2000);
            }

            // Finaliser la narration
            finalizeNarration() {
                phaseJeu = 'feux_artifice';
                jeu = false;

                // Cacher l'indicateur d'étape
                this.hideStepIndicator();

                // Séquence finale avec feux d'artifice
                if (droneModule) {
                    const formations = ['hexagon', 'star', 'heart', 'cross'];
                    const formationsChoixies = [];

                    for(let i = 0; i < 3; i++) {
                        const index = Math.floor(Math.random() * formations.length);
                        formationsChoixies.push(formations[index]);
                    }

                    formationsChoixies.forEach((formation, index) => {
                        setTimeout(() => {
                            const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                            const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                            droneModule.moveFormationTo(x, y);
                            droneModule.setFormation(formation);

                            setTimeout(() => {
                                droneModule.explode(x, y);
                            }, 800);
                        }, index * 1500);
                    });
                }

                setTimeout(() => {
                    this.showFinalMenu();
                }, 6000);
            }

            // Générer un résumé élégant en 3 lignes
            generateElegantSummary() {
                const completedCount = Math.min(this.currentPhase, this.phases.length);
                const progressPercent = Math.round((completedCount / this.phases.length) * 100);

                return `
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05)); border-radius: 12px; border: 1px solid rgba(100,255,218,0.3);">
                        <div style="color: #64ffda; font-size: 16px; font-weight: 600; margin-bottom: 6px;">
                            ✨ ${completedCount}/16 CHAPITRES (${progressPercent}%) ✨
                        </div>
                        <div style="color: #ffffff; font-size: 14px; margin: 4px 0; opacity: 0.9;">
                            📚 De "La Lumière" à "L'Unité de l'Humanité"
                        </div>
                        <div style="color: #cccccc; font-size: 12px; font-style: italic; opacity: 0.8;">
                            Un voyage à travers la vérité de l'humanité
                        </div>
                    </div>
                `;
            }

            // Afficher le menu final
            showFinalMenu() {
                const msg = document.getElementById('message');
                msg.classList.remove('narratif');
                msg.classList.add('show');
                msg.style.transform = 'translate(-50%, -50%) scale(1)';
                msg.style.transition = '';

                const summaryHTML = this.generateElegantSummary();

                const boutonsHTML = `
                    <div style="margin-top: 15px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="narrationManager.restart()"
                                style="background: linear-gradient(45deg, #64ffda, #4da6ff);
                                       color: #1a1a1a; border: none; padding: 12px 24px;
                                       border-radius: 25px; font-size: 14px; font-weight: 600;
                                       cursor: pointer; transform: scale(1);
                                       transition: all 0.3s ease;
                                       box-shadow: 0 3px 10px rgba(100,255,218,0.3);
                                       text-shadow: 0 1px 2px rgba(0,0,0,0.2);
                                       letter-spacing: 0.5px;">
                            🔄 Recommencer
                        </button>
                    </div>
                `;

                const titleHTML = `
                    <div style="text-align: center; margin-bottom: 8px;">
                        <div style="color: #64ffda; text-shadow: 0 0 10px rgba(100,255,218,0.8); margin: 0; font-size: 22px; font-weight: 600; letter-spacing: 1px;">
                            👁️ VOIR LA VÉRITÉ
                        </div>
                        <div style="color: #ffffff; margin: 5px 0; font-size: 16px; font-weight: 300; opacity: 0.9;">
                            Aventure terminée ✨
                        </div>
                    </div>
                `;

                msg.innerHTML = titleHTML + summaryHTML + boutonsHTML;
            }

            // Redémarrer la narration
            restart() {
                cacherMessage();

                // Réinitialiser complètement
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                score = 0;
                vies = 3;
                brises = 0;
                jeu = false;

                // Réinitialiser les systèmes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les éléments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // Continuer à la phase courante après un délai (sans reset)
                setTimeout(() => {
                    this.executeCurrentPhase();
                }, 1000);
            }

            // Fonction appelée à la fin d'une phase
            onPhaseComplete() {
                if (this.isTransitioning) return;

                // Créer un timer de victoire unique
                const timerId = `victory_${Date.now()}_${Math.random()}`;

                this.victoryTimers.set(timerId, setTimeout(() => {
                    this.victoryTimers.delete(timerId);
                    // Réinitialiser les compteurs pour la prochaine phase
                    brises = 0;

                    if (this.nextPhase()) {
                        this.executeCurrentPhase();
                    } else {
                        this.finalizeNarration();
                    }
                }, 1500));
            }

            // Méthode pour avancer directement à la phase suivante sans narration
            goToNextPhase() {
                if (this.isTransitioning) return;

                console.log(`[DEBUG] goToNextPhase - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    console.log(`[DEBUG] goToNextPhase - currentPhase après nextPhase: ${this.currentPhase}`);
                    this.executeCurrentPhase();
                } else {
                    this.finalizeNarration();
                }
            }

            // Progression directe sans narration - pour la fin des modes
            goToNextPhaseDirect() {
                if (this.isTransitioning) {
                    console.log('🚫 Transition déjà en cours, ignore goToNextPhaseDirect');
                    return;
                }

                console.log(`🎬 goToNextPhaseDirect - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    console.log(`✅ goToNextPhaseDirect - currentPhase après nextPhase: ${this.currentPhase}`);
                    const phase = this.getCurrentPhase();
                    if (phase) {
                        // Afficher le titre du voyage
                        this.afficherTitreVoyage();

                        // Mettre à jour l'indicateur d'étape
                        this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                        console.log(`[DEBUG] Configuration mode ${phase.mode} pour phase ${phase.phase}: ${phase.id}`);

                        // Configurer directement le mode de jeu
                        this.configureGameMode(phase.mode);

                        // Marquer la transition comme terminée après tout
                        setTimeout(() => {
                            this.isTransitioning = false;
                        }, 100);
                    }
                } else {
                    this.finalizeNarration();
                }
            }

            // Alias pour compatibilité avec l'ancien code
            onLevelComplete() {
                this.onPhaseComplete();
            }
        }

        // Instance globale du gestionnaire de narration
        const narrationManager = new NarrationManager();

        // ===============================================
        // COMPATIBILITÉ AVEC L'ANCIEN SYSTÈME
        // ===============================================

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.03,
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au début - les drones restent hors écran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors écran à gauche
                        -100, // Commencer hors écran en haut
                        i
                    ));
                }
            }

            setFormation(formation) {
                this.currentFormation = formation;
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                this.drones.forEach(drone => {
                    drone.firework();
                });

                setTimeout(() => {
                    this.createDrones();
                    this.setFormation(this.currentFormation);
                }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const starRadius = (i % 2 === 0) ? size : size * 0.6;
                            positions.push({
                                x: centerX + Math.cos(angle) * starRadius,
                                y: centerY + Math.sin(angle) * starRadius
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // Animation séparée pour mise à jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options);
                });
            }

            render() {
                // Rendu séparé à appeler depuis la boucle de jeu
                this.drones.forEach(drone => {
                    drone.draw(this.ctx, this.options);
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options) {
                if (this.inExplosion) {
                    this.x += this.explosionVelX;
                    this.y += this.explosionVelY;
                    this.explosionVelY += 0.3;
                    this.life -= 0.015;
                    if (this.life <= 0) this.life = 0;
                } else {
                    this.x += (this.targetX - this.x) * options.speed;
                    this.y += (this.targetY - this.y) * options.speed;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) this.trail.shift();
                }

                this.brightness = 0.6 + Math.sin(Date.now() * 0.008 + this.id) * 0.2;
            }

            draw(ctx, options) {
                if (this.life <= 0) return;

                if (options.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color + '60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                const glowSize = 8 + Math.sin(Date.now() * 0.004 + this.id) * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, this.color + Math.floor(this.brightness * this.life * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(0.8, this.color + '30');
                gradient.addColorStop(1, this.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapté pour intégration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentIndex = 0;
                this.timeoutId = null;
                this.text = '';
                this.options = {};
            }

            // Configuration des couleurs
            setColors(element, textColor = '#ffffff', effectColor = '#64ffda') {
                element.style.setProperty('--ta-text-color', textColor);
                element.style.setProperty('--ta-effect-color', effectColor);
                element.style.color = textColor;
            }

            // Arrête l'animation
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
            }

            // Reset
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.text = '';
            }

            // Animation machine à écrire avec support HTML complet
            typewriter(element, text, speed = 50, onComplete = null) {
                console.log('TextAnimationModule.typewriter appelé avec:', {text: text.substring(0, 50), speed, element});
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';
                this.isRunning = true;
                console.log('Démarrage _typewriterStep');

                this._typewriterStep(element);
            }

            _typewriterStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    // Gestion des balises HTML et des \n
                    let currentChar = this.text.charAt(this.currentIndex);

                    // Si on trouve une balise HTML, on l'ajoute entièrement
                    if (currentChar === '<') {
                        let tagEnd = this.text.indexOf('>', this.currentIndex);
                        if (tagEnd !== -1) {
                            let fullTag = this.text.substring(this.currentIndex, tagEnd + 1);
                            element.innerHTML += fullTag;
                            this.currentIndex = tagEnd + 1;
                        } else {
                            element.innerHTML += currentChar;
                            this.currentIndex++;
                        }
                    } else if (currentChar === '\n') {
                        // Gérer les sauts de ligne
                        element.innerHTML += '<br>';
                        this.currentIndex++;
                    } else {
                        element.innerHTML += currentChar;
                        this.currentIndex++;
                    }

                    this.timeoutId = setTimeout(() => this._typewriterStep(element), this.options.speed);
                } else {
                    element.style.borderRight = 'none';
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                }
            }

            // Animation fade avec support HTML
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                element.innerHTML = text.replace(/\n/g, '<br>');
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 50);

                setTimeout(() => {
                    element.style.transition = '';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Animation digital avec support HTML
            digital(element, text, speed = 50, onComplete = null) {
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                this.isRunning = true;

                this._digitalStep(element);
            }

            _digitalStep(element) {
                if (!this.isRunning) return;

                if (this.currentIndex < this.text.length) {
                    let displayText = '';
                    let textOnly = this.text.replace(/<[^>]*>/g, '').replace(/\n/g, ' '); // Texte sans balises
                    let currentTextIndex = 0;

                    // Reconstitue le texte avec balises jusqu'à la position actuelle
                    for (let i = 0; i < this.text.length && currentTextIndex < this.currentIndex; i++) {
                        if (this.text.charAt(i) === '<') {
                            let tagEnd = this.text.indexOf('>', i);
                            if (tagEnd !== -1) {
                                displayText += this.text.substring(i, tagEnd + 1);
                                i = tagEnd;
                            }
                        } else if (this.text.charAt(i) === '\n') {
                            displayText += '<br>';
                            currentTextIndex++;
                        } else {
                            displayText += this.text.charAt(i);
                            currentTextIndex++;
                        }
                    }

                    // Ajoute un caractère aléatoire si on n'est pas à la fin
                    if (this.currentIndex < textOnly.length) {
                        const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }

                    element.innerHTML = displayText;

                    setTimeout(() => {
                        this.currentIndex++;
                        if (this.currentIndex < textOnly.length) {
                            this.timeoutId = setTimeout(() => this._digitalStep(element), this.options.speed);
                        } else {
                            element.innerHTML = this.text.replace(/\n/g, '<br>');
                            this.isRunning = false;
                            if (this.options.onComplete) this.options.onComplete();
                        }
                    }, this.options.speed / 2);
                }
            }

            // Animation glitch avec support HTML
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();

                // Effet de glitch en préservant le HTML
                let textOnly = text.replace(/<[^>]*>/g, '').replace(/\n/g, ' ');
                let glitchText = '';
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';

                // Reconstitue le texte avec des caractères glitch
                for (let i = 0; i < text.length; i++) {
                    if (text.charAt(i) === '<') {
                        let tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            glitchText += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text.charAt(i) === '\n') {
                        glitchText += '<br>';
                    } else {
                        if (Math.random() < 0.1 && text.charAt(i) !== ' ') {
                            glitchText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        } else {
                            glitchText += text.charAt(i);
                        }
                    }
                }

                element.innerHTML = glitchText;
                element.style.animation = 'ta-glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas déjà présentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes ta-glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.innerHTML = text.replace(/\n/g, '<br>');
                    element.style.animation = 'none';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Vérifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // 🎬 NOUVELLE CLASSE TEXTANIMATOR OPTIMISÉE
        // ═══════════════════════════════════════════════════════════════════
        class TextAnimator {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('TextAnimator: Element non trouvé:', elementId);
                    return;
                }
                this.reset();
            }

            // État et méthodes utilitaires optimisées
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.element.innerHTML = '';
                // Garder les classes originales du message
                const originalClasses = this.element.className;
                this.element.className = originalClasses.replace(/ta-\w+/g, '').trim();
            }

            stop() {
                this.isRunning = false;
                if (this.timeoutId) clearTimeout(this.timeoutId);
            }

            setColors(textColor = '#ffffff', effectColor = '#64ffda') {
                this.element.style.setProperty('--ta-text-color', textColor);
                this.element.style.setProperty('--ta-effect-color', effectColor);
                this.element.style.color = textColor;
            }

            applyEffect(effect = 'none') {
                const effects = ['shadow3d', 'neon', 'emboss', 'outline', 'fire', 'ice'];
                effects.forEach(e => this.element.classList.remove(`ta-effect-${e}`));
                if (effect !== 'none') this.element.classList.add(`ta-effect-${effect}`);
            }

            // Animation machine à écrire optimisée
            typewriter(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-typewriter');
                this.isRunning = true;
                this._typewriterStep();
            }

            _typewriterStep() {
                if (!this.isRunning || this.currentIndex >= this.text.length) {
                    this.element.classList.remove('ta-typewriter');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                const char = this.text.charAt(this.currentIndex);
                if (char === '<') {
                    const tagEnd = this.text.indexOf('>', this.currentIndex);
                    if (tagEnd !== -1) {
                        this.element.innerHTML += this.text.substring(this.currentIndex, tagEnd + 1);
                        this.currentIndex = tagEnd + 1;
                    } else {
                        this.element.innerHTML += char;
                        this.currentIndex++;
                    }
                } else if (char === '\n') {
                    this.element.innerHTML += '<br>';
                    this.currentIndex++;
                } else {
                    this.element.innerHTML += char;
                    this.currentIndex++;
                }

                this.timeoutId = setTimeout(() => this._typewriterStep(), this.options.speed);
            }

            // Animation code digital optimisée
            digital(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-digital');
                this.isRunning = true;
                this._digitalStep();
            }

            _digitalStep() {
                if (!this.isRunning) return;

                const textOnly = this.text.replace(/<[^>]*>/g, '');
                if (this.currentIndex >= textOnly.length) {
                    this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                let displayText = this._buildHtmlText(this.currentIndex);
                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                displayText += digitalChars[Math.floor(Math.random() * digitalChars.length)];

                this.element.innerHTML = displayText;

                setTimeout(() => {
                    this.currentIndex++;
                    if (this.currentIndex < textOnly.length) {
                        this.timeoutId = setTimeout(() => this._digitalStep(), this.options.speed);
                    } else {
                        this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                        this.isRunning = false;
                        if (this.options.onComplete) this.options.onComplete();
                    }
                }, this.options.speed / 2);
            }

            // Animation fade
            fade(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-fade-in');
                this.element.innerHTML = text.replace(/\n/g, '<br>');

                setTimeout(() => {
                    this.element.classList.remove('ta-fade-in');
                    if (this.options.onComplete) this.options.onComplete();
                }, 1000);
            }

            // Animation glitch optimisée
            glitch(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-glitch');

                const glitchText = this._createGlitchText(text);
                this.element.innerHTML = glitchText;

                this.timeoutId = setTimeout(() => {
                    this.element.innerHTML = text.replace(/\n/g, '<br>');
                    this.element.classList.remove('ta-glitch');
                    if (this.options.onComplete) this.options.onComplete();
                }, this.options.speed * 5);
            }

            // Méthodes utilitaires optimisées
            setupAnimation(text, options) {
                this.text = text;
                this.options = {
                    speed: options.speed || 50,
                    textColor: options.textColor || '#ffffff',
                    effectColor: options.effectColor || '#64ffda',
                    effect: options.effect || 'none',
                    onComplete: options.onComplete
                };
                this.reset();
                this.setColors(this.options.textColor, this.options.effectColor);
                this.applyEffect(this.options.effect);
            }

            _buildHtmlText(index) {
                let result = '';
                let textIndex = 0;
                for (let i = 0; i < this.text.length && textIndex < index; i++) {
                    if (this.text[i] === '<') {
                        const tagEnd = this.text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += this.text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (this.text[i] === '\n') {
                        result += '<br>';
                        textIndex++;
                    } else {
                        result += this.text[i];
                        textIndex++;
                    }
                }
                return result;
            }

            _createGlitchText(text) {
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '<') {
                        const tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text[i] === '\n') {
                        result += '<br>';
                    } else if (Math.random() < 0.1 && text[i] !== ' ') {
                        result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        result += text[i];
                    }
                }
                return result;
            }

            // Vérifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;

        // Rendre score accessible globalement pour les modules
        window.score = score;
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (value) => { score = value; }
        });
        let titreVoyage = { active: false, texte: '', fin: 0 }; // Affichage titre voyage
        let raquette = {}, balle = {}, briques = [], particules = [];
        let starsProjectiles = []; // Projectiles étoiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles étoiles (phase briques) - commence à 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let coeursBateau = []; // Cœurs lancés par le bateau
        let derniereCreeRafale = 0; // Temps de la dernière rafale
        let petitsCoeurs = []; // Petits cœurs décoratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause après explosion
        let textesVolants = []; // Textes qui montent au ciel
        let corbeau = { actif: false, x: 0, y: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000, direction: 1 }; // Corbeau secret (10s pour test)
        let soleil = { clignotement: false, tempsClignotement: 0 }; // État du soleil
        let multiplicateurPuissance = 1; // Cheat code x10 puissance
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition
        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let secretModeModule = null; // Module mode secret
        // let kawaiiObjectsModule = null; // SUPPRIMÉ - utilisation via module secret seulement
        let modeNarration = true; // Mode narration actif au début
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Système de messages narratifs
        let periode = 'jour'; // Période actuelle : 'jour' ou 'nuit'
        let transitionPeriode = { active: false, progression: 0 };
        let phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() }; // Phase d'introduction
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de cœurs vers les petits cœurs du haut (phase d'éveil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'étoiles vers les briques en mode nuit (phase de révélation)
         * 4. 'feux_artifice' : Célébration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: true,
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: 0,
            dureeArret: 20000 // 20 secondes d'arrêt
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.0006, 0.4); // Vitesse réduite 10x

            // Les objets kawaii seront activés après l'animation d'intro
            // activerObjetsKawaii(); // Trop tôt, on attend la fin de l'intro

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 8,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Initialiser les gestionnaires d'événements des oiseaux CSS
            setupBirdClickHandlers();

            // Initialiser le module mode secret
            initSecretModeModule();

            // Les objets kawaii sont maintenant gérés par le module secret seulement

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors écran à gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = Date.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            munitions = 0; // Commencer sans munitions en phase stars
            rechargement = 0;

            briques = [];

            // Créer les briques si on est en phase stars (nuit) - FORCÉ
            if(phaseJeu === 'stars') {
                // FORCER l'arrêt de tous les systèmes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                // Introduction terminée

                // Les objets kawaii sont réservés au mode secret seulement
                // activerObjetsKawaii(); // SUPPRIMÉ - uniquement pour mode secret

                // FORCER la création des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Créer
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les cœurs
            const zoneW = C.W - 40;

            // Positions dispersées et tailles différentes pour chaque cœur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront créées à partir des petits cœurs du haut
            // Initialisation vide, elles apparaîtront lors du dédoublement des cœurs
            briques = [];
            particules = [];
            powerUps = [];
            // Garder l'état de la lanterne pendant initJeu() - ne pas la remettre à zéro
            // lanterne conserve son état précédent
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propriétés selon la phase
            if(phaseJeu === 'lanterne') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au début
                    dy: 0, // Immobile au début
                    visible: true, // Visible en phase lanterne
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles étoiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Créer les 10 petits cœurs décoratifs en haut (seulement en mode coeurs)
            if(phaseJeu !== 'lanterne' && phaseJeu !== 'stars') {
                creerPetitsCoeurs();
            }

            // Cacher les cœurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'étoile principale - utiliser les projectiles stars

            // Réinitialiser la phase d'intro (activée après l'animation du bateau)
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (!animationBateau.active) return;

            const tempsActuel = Date.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arrivée depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arrivée fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arrivé au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // Intro déjà gérée par gererPhaseIntro()
                        // narrationManager.start();
                    }
                    break;

                case 'arret':
                    // Bateau arrêté, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de départ vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'écran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation terminée, démarrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        // Introduction terminée // Phase de jeu

                        // Les objets kawaii sont réservés au mode secret seulement
                        // activerObjetsKawaii(); // SUPPRIMÉ - uniquement pour mode secret

                        // Repositionner le bateau normalement et démarrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;
                        jeu = true; // Activer le jeu
                        phaseJeu = 'tir_coeurs_haut'; // Commencer par la première phase

                        // Révéler les petits cœurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre à jour l'étoile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            if (!phaseIntro.active) {
                // Intro terminée - comportement normal
                return;
            }

            const tempsEcoule = Date.now() - phaseIntro.tempsDebut;
            console.log(`🔄 gererPhaseIntro: étape=${phaseIntro.etape}, temps=${tempsEcoule}ms`);

            if (phaseIntro.etape === 'arrivee_bateau') {
                // Phase d'introduction: Démarrer l'intro très rapidement
                if (tempsEcoule >= 200) { // Réduire à 0.2 seconde
                    // Démarrer le système narratif avec la première phase (une seule fois)
                    if (narrationManager && !window.narrationStarted) {
                        window.narrationStarted = true; // Marquer comme déjà démarré
                        console.log('🎯 Démarrage forcé de l\'intro narrative');

                        // Forcer l'affichage de l'intro immédiatement
                        if (narrationManager.narrativeData && narrationManager.narrativeData.phases) {
                            console.log('✅ Données narratives disponibles, démarrage normal');
                            narrationManager.start();
                        } else {
                            console.log('⚠️ Données narratives non disponibles, affichage intro forcé');


                            // Affichage direct de l'intro Phase 1
                            afficherMessage(`
                                🌟 "On m'a dit qu'ils étaient tous des monstres...
                                ✨ On m'a dit tant de mal, tant de malheurs sur eux...
                                🔍 Mais moi, j'ai préféré aller voir de mes propres yeux."

                                <button onclick="
                                    alert('🚫 NON on peut pas laisser passer ça ! 🚫');

                                    // Gagner 50 points (système adaptatif)
                                    if (phaseJeu === 'tir_coeurs_haut') {
                                        pointsConnaissance += 50;
                                        console.log('50 pointsConnaissance ajoutés ! Total:', pointsConnaissance);
                                    } else {
                                        score += 50;
                                        console.log('50 score ajoutés ! Total:', score);
                                    }

                                    // Changer le bouton en NON !
                                    this.innerHTML = 'NON !';
                                    this.style.background = '#f44336';

                                    // Changer l'action du bouton pour les prochains clics
                                    this.onclick = function() {
                                        afficherMessage('🚫 NON ! On ne peut pas laisser passer ça ! 🚫', 2000);
                                        // Gagner 10 points à chaque clic sur NON
                                        if (phaseJeu === 'tir_coeurs_haut') {
                                            pointsConnaissance += 10;
                                            console.log('10 pointsConnaissance ajoutés ! Total:', pointsConnaissance);
                                        } else {
                                            score += 10;
                                            console.log('10 score ajoutés ! Total:', score);
                                        }
                                    };
                                "
                                        style="margin-top: 20px; padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    Passer
                                </button>
                            `, 12000);
                        }
                    }
                    phaseIntro.etape = 'rafales';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'rafales') {
                // Phase 1: Réduire l'attente pour un flux plus rapide
                if (tempsEcoule >= 1000) { // Réduire de 2s à 1s
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = Date.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                if (tempsEcoule >= 1000) {
                    phaseIntro.active = false;
                    jeu = true; // Démarrer le jeu
                    // Ne pas forcer le mode - conserver le mode déjà configuré par narrationManager
                    // Message géré par le nouveau système narratif
                }
            }
        }

        // Interface intégrée complète
        function dessinerInterface() {
            ctx.save();

            // Header optimisé très compact - bleu roi
            const headerH = Math.max(C.H * 0.045, 32);
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.fillRect(0, 0, C.W, headerH);

            // Lignes ondulées en fond transparent blanc
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const waveY = headerH * (0.2 + i * 0.3);
                const waveLength = C.W / 8;
                for(let x = 0; x <= C.W; x += 10) {
                    const y = waveY + Math.sin((x / waveLength) * Math.PI * 2) * 3;
                    if(x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();

            // Bordure header
            ctx.strokeStyle = '#3b82f6'; // Bordure bleu plus clair
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre centré en hauteur
            const titleY = headerH / 2 + 4; // Centré verticalement dans le header
            const iconSize = Math.max(C.H * 0.008, 8); // Très petits bateaux

            ctx.save();
            // Titre moderne et plus gros
            ctx.fillStyle = '#ffffff';
            ctx.font = `800 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = '2px';
            ctx.fillText('PETIT BATEAU', C.W/2, titleY);

            // Très petits bateaux discrets
            const leftBoatX = C.W/2 - 120;
            const rightBoatX = C.W/2 + 120;
            drawBoatIcon(ctx, leftBoatX, titleY - iconSize, iconSize, 'red');
            drawBoatIcon(ctx, rightBoatX, titleY - iconSize, iconSize, 'blue');
            ctx.restore();

            // Afficher le titre du voyage si actif
            if (titreVoyage.active && Date.now() < titreVoyage.fin) {
                const voyageY = Math.max(C.H * 0.10, 70); // Très légèrement plus bas
                ctx.save();

                // Style moderne avec blanc et ombres
                ctx.fillStyle = '#ffffff';
                ctx.font = `700 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', system-ui, sans-serif`;
                ctx.textAlign = 'center';

                // Ombres multiples pour effet profondeur
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 8;

                // Séparer le nom du voyage et la phase
                const lignes = titreVoyage.texte.split('\n');
                const voyageNom = lignes[0];
                const phaseTexte = lignes[1] || '';

                // Première ombre (arrière) pour le titre voyage
                ctx.fillText(`🗺️ Voyage — ${voyageNom}`, C.W/2, voyageY);

                // Deuxième couche avec ombre plus subtile pour le titre
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 4;
                ctx.fillText(`🗺️ Voyage — ${voyageNom}`, C.W/2, voyageY);

                // Sous-titre phase avec ombres noires
                if (phaseTexte) {
                    ctx.font = `600 ${Math.max(C.H * 0.018, 16)}px 'Segoe UI', system-ui, sans-serif`;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.shadowBlur = 6;
                    ctx.fillText(phaseTexte, C.W/2, voyageY + Math.max(C.H * 0.035, 28));
                }

                ctx.restore();
            } else if (titreVoyage.active && Date.now() >= titreVoyage.fin) {
                titreVoyage.active = false; // Désactiver après 4 secondes
            }

            // Stats ligne avec fond blanc plus près du header
            const statsY = Math.max(C.H * 0.045, 30); // Beaucoup plus près du header
            const padding = 8;
            const bgHeight = Math.max(C.H * 0.025, 20);

            // Fond blanc pour toute la barre de stats
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, statsY - bgHeight/2, C.W, bgHeight);

            // Bordure subtile
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, statsY - bgHeight/2, C.W, bgHeight);

            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points XP - centré verticalement dans la barre
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`⭐ XP: ${pointsConnaissance}`, 15, statsY);
            } else {
                ctx.fillText(`🕊️ ${score}`, 15, statsY);
            }

            // Progression avec voyage et phase
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            let phaseInfo = '';
            if (narrationManager && narrationManager.currentPhase) {
                const phase = narrationManager.currentPhase; // Phase 1 = intro simple
                let voyageIcon = '';
                let voyageName = '';

                if (phase === 1) {
                    voyageIcon = '🌅'; voyageName = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageIcon = '☀️'; voyageName = 'La lumière';
                } else if (phase >= 3 && phase <= 4) {
                    voyageIcon = '☁️'; voyageName = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageIcon = '🤫'; voyageName = 'Le silence de l\'âme';
                } else if (phase >= 7 && phase <= 9) {
                    voyageIcon = '❤️'; voyageName = 'L\'humanité des cœurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageIcon = '🧠'; voyageName = 'La sagesse des différences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageIcon = '🌍'; voyageName = 'L\'unité';
                } else if (phase === 16) {
                    voyageIcon = '🎆'; voyageName = 'Animation finale';
                } else {
                    voyageIcon = '📖'; voyageName = 'Voyage';
                }

                phaseInfo = `📖 Phase ${phase}/16`;
            } else {
                phaseInfo = `🧱 ${brises}/${VOYAGE.length}`;
            }
            ctx.fillText(phaseInfo, C.W/2, statsY);

            // Vies
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const coeurs = vies > 0 ? '❤️'.repeat(vies) : '💔';
            ctx.fillText(coeurs, C.W - 15, statsY);

            // Affichage des commandes mode passe désactivé
            /*
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                '🔑 MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir étoiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();
            */

            ctx.restore();
        }

        // Tirer un projectile étoile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars, feux_artifice ET lanterne (pour Poxerstart)
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice' && phaseJeu !== 'lanterne') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation étoile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de déplacement pour la traînée
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Traînée d'étoile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // Gradient de la traînée
                const gradientTrainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                // Traînée dorée normale
                gradientTrainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                gradientTrainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradientTrainee.addColorStop(1, projectile.couleur || '#FFD700');

                // Dessiner la traînée
                ctx.fillStyle = gradientTrainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'étoile elle-même
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // Étoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // Halo lumineux
                    const gradientHalo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                    gradientHalo.addColorStop(0, projectile.couleur || '#FFD700');
                    gradientHalo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradientHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = gradientHalo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Étoile centrale brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, projectile.couleur || '#FFD700');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0.8)');

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // Étoile à 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre à jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // Déplacer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'écran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {
                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                                    // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // Désactivé : Ancien système de fin simple - remplacé par la séquence complète
                                    // if(brises >= VOYAGE.length) { ... }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // Collision avec les petits cœurs
                petitsCoeurs.forEach((petitCoeur, j) => {
                    if(!petitCoeur.visible) return;

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // Cœur touché !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // Vérifier si tous les cœurs du haut sont touchés
                        const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                        console.log(`[DEBUG] Condition fin coeurs: restants=${coeurRestants}, phaseJeu=${phaseJeu}`);
                        if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                            console.log(`[DEBUG] Condition remplie, appel goToNextPhaseDirect dans 1s`);
                            // Progression directe vers la phase suivante
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();

                                // Créer quelques cœurs décoratifs qui flottent
                                setTimeout(() => {
                                    for(let k = 0; k < 10; k++) {
                                        particules.push({
                                            x: Math.random() * C.W,
                                            y: C.H + Math.random() * 50,
                                            vx: (Math.random() - 0.5) * 2,
                                            vy: -(Math.random() * 3 + 1),
                                            couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][k % 5],
                                            vie: 1,
                                            taille: Math.random() * 4 + 3,
                                            type: 'coeur'
                                        });
                                    }


                                    // Transition vers le jeu de briques après 3 secondes (seulement si on est en phase petits_coeurs)
                                    // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                }, 3000);
                            }, 1000);
                        }
                        return;
                    }
                });
            }
        }

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // Dessiner la lanterne éteinte comme balle du jeu UNIQUEMENT pendant la phase casse-briques
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0; // Position de la balle
            const posY = balle.y || 0; // Position de la balle
            const temps = Date.now() * 0.001;

            // Vérification de sécurité pour éviter les valeurs non finies
            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // EFFET TRAÎNÉE VERTE (power-up vitesse)
            if(balle.traineeVerte && balle.vitesseActive) {
                // Traînée verte dynamique
                for(let i = 0; i < 5; i++) {
                    const alpha = (5 - i) / 5 * 0.6;
                    const size = C.BS * (1 - i * 0.15);
                    const offsetX = (balle.dx || 0) * -i * 2;
                    const offsetY = (balle.dy || 0) * -i * 2;

                    const grad = ctx.createRadialGradient(
                        posX + offsetX, posY + offsetY, 0,
                        posX + offsetX, posY + offsetY, size
                    );
                    grad.addColorStop(0, `rgba(0, 255, 0, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 255, 50, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(0, 255, 0, 0)`);

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(posX + offsetX, posY + offsetY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 1. HALO DE BOUGIE SIMPLE (seulement si lanterne active)
            if(lanterne.active) {
                // Halo simple statique
                const haloSize = C.BS * 1.5;
                const haloIntensity = 0.4;

                // Halo principal simple avec vérification
                if (isFinite(haloSize) && haloSize > 0) {
                    const haloGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, haloSize);
                haloGrad.addColorStop(0, `rgba(255, 220, 150, ${haloIntensity})`);
                haloGrad.addColorStop(0.3, `rgba(255, 180, 100, ${haloIntensity * 0.7})`);
                haloGrad.addColorStop(0.7, `rgba(255, 140, 60, ${haloIntensity * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');

                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. LANTERNE CYLINDRIQUE CLASSIQUE

            // Dimensions de la lanterne avec multiplicateur de taille si actif
            const multiplTaille = balle.multiplicateurTaille || 1;
            const rayon = C.BS * 0.4 * multiplTaille;        // Rayon du cylindre
            const corpsH = C.BS * 1.2 * multiplTaille;       // Hauteur du corps cylindrique
            const domeH = C.BS * 0.1 * multiplTaille;        // Hauteur du dôme
            const baseH = C.BS * 0.1 * multiplTaille;        // Hauteur de la base

            // LUEUR DOUCE AUTOUR DE LA LANTERNE
            if(lanterne.active) {
                // Halo de lueur douce adapté à la taille
                const lueurSize = rayon * 1.25;
                if (isFinite(rayon) && isFinite(lueurSize) && rayon > 0 && lueurSize > 0) {
                    const lueurGrad = ctx.createRadialGradient(posX, posY, rayon, posX, posY, lueurSize);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.2)');
                lueurGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
                ctx.fillStyle = lueurGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, lueurSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Armature métallique de la lanterne
            const armatureColor = lanterne.active ? '#B8860B' : '#654321';
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;

            // BASE RONDE plus petite
            const baseY = posY + corpsH/2;
            ctx.fillStyle = armatureColor;
            ctx.beginPath();
            ctx.ellipse(posX, baseY, rayon * 1.05, baseH, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // CORPS CYLINDRIQUE
            const corpsTop = posY - corpsH/2;
            const corpsBottom = posY + corpsH/2;

            // Vitres cylindriques
            if(lanterne.active) {
                // Vitres dorées lumineuses
                if (isFinite(rayon) && rayon > 0) {
                    const vitreGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, rayon);
                    vitreGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    vitreGrad.addColorStop(0.7, 'rgba(255, 200, 0, 0.6)');
                    vitreGrad.addColorStop(1, 'rgba(255, 180, 0, 0.4)');
                    ctx.fillStyle = vitreGrad;
                } else {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                }
            } else {
                // Vitres éteintes
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.ellipse(posX, posY, rayon, corpsH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Contour du cylindre
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Barreaux en forme de croix
            ctx.beginPath();
            // Barre verticale
            ctx.moveTo(posX, corpsTop);
            ctx.lineTo(posX, corpsBottom);
            // Barre horizontale
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // DÔME SUPÉRIEUR
            const domeTop = corpsTop - domeH;
            ctx.fillStyle = armatureColor;
            ctx.strokeStyle = '#CD7F32';
            ctx.lineWidth = 2;

            // Dôme en forme d'ellipse plus petit
            ctx.beginPath();
            ctx.ellipse(posX, domeTop + domeH/2, rayon * 0.9, domeH/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 3. FLAMME AVEC ANIMATIONS TRÈS LENTES
            if(lanterne.active) {
                // Flamme avec mouvement très lent et doux
                const flammeX = posX + Math.sin(temps * 0.3) * 1 * multiplTaille; // Très lent
                const flammeY = posY - C.BS * 0.3 * multiplTaille;
                const flammeH = C.BS * 0.6 * multiplTaille;
                const flammeW = C.BS * 0.3 * multiplTaille;

                // Flamme principale avec danse très douce
                if (isFinite(flammeX) && isFinite(flammeY) && isFinite(flammeH) && flammeH > 0) {
                    const flammeGrad = ctx.createRadialGradient(flammeX, flammeY, 0, flammeX, flammeY, flammeH);
                flammeGrad.addColorStop(0, '#FFFF99');
                flammeGrad.addColorStop(0.3, '#FFD700');
                flammeGrad.addColorStop(0.6, '#FFA500');
                flammeGrad.addColorStop(1, '#FF6347');

                    ctx.fillStyle = flammeGrad;
                    ctx.beginPath();
                    // Forme de flamme avec variations très lentes
                    ctx.ellipse(flammeX, flammeY, flammeW * (0.6 + Math.sin(temps * 0.4) * 0.05), flammeH * (0.8 + Math.cos(temps * 0.35) * 0.05), Math.sin(temps * 0.2) * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    // Cœur de la flamme plus lumineux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(flammeX, flammeY, flammeW * 0.3, flammeH * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Mèche de la bougie
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1 * multiplTaille, posY, 2 * multiplTaille, C.BS * 0.2 * multiplTaille);
            } else {
                // Mèche éteinte
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY - 2, 2, 4);

                // Cœur d'humanité au repos
                const coeurSize = C.BS * 0.4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(posX, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX, posY, posX - coeurSize*0.5, posY, posX - coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX - coeurSize*0.5, posY + coeurSize*0.7, posX, posY + coeurSize*0.7, posX, posY + coeurSize);
                ctx.bezierCurveTo(posX, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX + coeurSize*0.5, posY, posX, posY, posX, posY + coeurSize*0.3);
                ctx.fill();
            }

            // 4. SYSTÈME DE SUSPENSION SIMPLE
            const cordeLength = C.BS * 1;
            ctx.strokeStyle = lanterne.active ? '#8B4513' : '#4a4a4a';
            ctx.lineWidth = 2;

            // Cordes depuis le dôme adaptées à la taille
            ctx.beginPath();
            ctx.moveTo(posX - rayon*0.6, domeTop); // Gauche du dôme
            ctx.lineTo(posX - rayon*0.2, posY - cordeLength);
            ctx.moveTo(posX + rayon*0.6, domeTop); // Droite du dôme
            ctx.lineTo(posX + rayon*0.2, posY - cordeLength);
            ctx.stroke();

            // Corde centrale
            ctx.beginPath();
            ctx.moveTo(posX, domeTop); // Centre du dôme
            ctx.lineTo(posX, posY - cordeLength);
            ctx.stroke();

            ctx.restore();
        }

        // Fonction pour dessiner les icônes de bateaux miniatures
        function drawBoatIcon(ctx, x, y, size, color) {
            ctx.save();

            // Couleurs selon le type
            let coqueColors, borderColor;
            if (color === 'red') {
                coqueColors = ['#ff6b6b', '#e74c3c', '#c0392b'];
                borderColor = '#a93226';
            } else {
                coqueColors = ['#74b9ff', '#0984e3', '#2d3436'];
                borderColor = '#2d3436';
            }

            // Coque simplifiée
            const coqueW = size * 1.5;
            const coqueH = size * 0.8;

            const coqueGrad = ctx.createLinearGradient(x, y, x, y + coqueH);
            coqueGrad.addColorStop(0, coqueColors[0]);
            coqueGrad.addColorStop(0.5, coqueColors[1]);
            coqueGrad.addColorStop(1, coqueColors[2]);

            ctx.fillStyle = coqueGrad;
            ctx.beginPath();
            ctx.ellipse(x, y + coqueH/2, coqueW/2, coqueH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bordure
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Mât
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + coqueH/2);
            ctx.lineTo(x, y - size);
            ctx.stroke();

            // Voile triangulaire
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size/2, y);
            ctx.lineTo(x + size/3, y - size/3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#ced4da';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau élégant géométrique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // EFFET POXERSTART (aura rose pulsante)
            if(raquette.poxerstart && Date.now() < raquette.poxerstartFin) {
                const tempsRestant = (raquette.poxerstartFin - Date.now()) / 7000; // 0 à 1
                const pulsation = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                const alpha = tempsRestant * pulsation * 0.6;

                // Aura rose autour du bateau
                const grad = ctx.createRadialGradient(
                    raquette.x + C.PW/2, raquette.y + C.PH/2, 0,
                    raquette.x + C.PW/2, raquette.y + C.PH/2, C.PW * 1.5
                );
                grad.addColorStop(0, `rgba(255, 105, 180, ${alpha})`);
                grad.addColorStop(0.7, `rgba(255, 105, 180, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 105, 180, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(
                    raquette.x - C.PW * 0.5, raquette.y - C.PH * 0.5,
                    C.PW * 2, C.PH * 2
                );

                // Étoiles qui scintillent autour
                for(let i = 0; i < 3; i++) {
                    const angle = Date.now() * 0.005 + i * Math.PI * 2 / 3;
                    const rayon = C.PW * 0.8;
                    const x = raquette.x + C.PW/2 + Math.cos(angle) * rayon;
                    const y = raquette.y + C.PH/2 + Math.sin(angle) * rayon * 0.5;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('⭐', x, y);
                }
            } else if(raquette.poxerstart) {
                // Nettoyer l'effet quand fini
                raquette.poxerstart = false;
            }

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec étrave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arrière gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arrière
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arrière droite
                ];

                // Gradient bleu pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#74b9ff'); // Bleu clair
                coqueGrad.addColorStop(0.5, '#0984e3'); // Bleu moyen
                coqueGrad.addColorStop(1, '#2d3436'); // Bleu foncé

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Mât central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du mât
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');
                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots géométriques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Coque du bateau - forme géométrique élégante
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arrière gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arrière
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arrière droite
                ];

                // Gradient rouge pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#ff6b6b');
                coqueGrad.addColorStop(0.5, '#e74c3c');
                coqueGrad.addColorStop(1, '#c0392b');

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Mât central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du mât
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots géométriques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // Vraies briques avec cœurs à l'intérieur pour le casse-brique
        function dessinerPrejuges() {
            briques.forEach((brique, index) => {
                if(!brique.visible) return;

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec état de dégâts
                ctx.save();

                // Couleur selon la vie restante
                let couleurBrique = couleur;
                if (brique.vieMax === 2) {
                    // Phase lanterne : 2 vies maximum
                    if (brique.vie === 1) {
                        // Brique endommagée (1er coup reçu sur 2)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.6)`;
                    }
                } else {
                    // Phase stars : 3 vies maximum
                    if (brique.vie === 2) {
                        // Brique légèrement endommagée (1er coup reçu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.8)`;
                    } else if (brique.vie === 1) {
                        // Brique très endommagée (2ème coup reçu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.5)`;
                    }
                }

                ctx.fillStyle = couleurBrique;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                // Clignotement si récemment touchée
                if (brique.clignotement > 0) {
                    ctx.fillStyle = '#FFFFFF';
                    brique.clignotement--;
                }

                // Rectangle de brique
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);


                // Effet 3D de brique
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.3); // Highlight du haut

                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(brique.x, brique.y + brique.h * 0.8, brique.w, brique.h * 0.2); // Ombre du bas

                // Dessiner les fissures zigzag blanches selon les dégâts
                if ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2)) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    // Première fissure zigzag après le 1er coup
                    ctx.beginPath();
                    const startX1 = brique.x + brique.w * 0.3;
                    const endX1 = brique.x + brique.w * 0.2;
                    const segments = 4; // Nombre de segments zigzag
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX1 + (endX1 - startX1) * progress + (i % 2 === 0 ? 0 : brique.w * 0.05) * Math.sin(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                if (brique.vie <= 1) {
                    // Deuxième fissure zigzag après le 2ème coup
                    ctx.beginPath();
                    const startX2 = brique.x + brique.w * 0.7;
                    const endX2 = brique.x + brique.w * 0.8;
                    const segments = 4;
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX2 + (endX2 - startX2) * progress + (i % 2 === 1 ? 0 : brique.w * 0.04) * Math.cos(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le cœur à l'intérieur de la brique
                dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);

                // En phase stars (nuit), afficher les mots pour guider le joueur
                if(phaseJeu === 'stars' && brique.etape && brique.etape.nom) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Contour noir pour la lisibilité
                    ctx.strokeText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                    // Texte blanc par-dessus
                    ctx.fillText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                }

                // En phase lanterne, le texte reste caché - il n'apparaît que lors de l'explosion
                // Le mystère reste entier jusqu'à la libération du cœur !
            });
        }

        // Messages simples centrés pour powerups et narratifs
        let messagePowerupActif = null;
        let messageNarratifActif = null;

        // Bouton simple "Passer" avec juste texte et ombre
        let boutonPasser = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 80,
            hauteur: 30,
            texte: "Passer",
            hover: false
        };

        function afficherMessagePowerupSimple(texte) {
            messagePowerupActif = {
                texte: texte,
                temps: Date.now() + 2000, // 2 secondes
                alpha: 1.0
            };
        }

        function afficherMessageNarratifSimple(texte, duree = 12000) {
            messageNarratifActif = {
                texte: texte,
                temps: Date.now() + duree,
                alpha: 1.0
            };
        }

        // Fonction pour dessiner le message powerup simple sous les titres narratifs
        function dessinerMessagePowerupSimple() {
            if (!messagePowerupActif) return;

            const maintenant = Date.now();
            if (maintenant > messagePowerupActif.temps) {
                messagePowerupActif = null;
                return;
            }

            // Fade out dans les dernières 500ms
            const tempsRestant = messagePowerupActif.temps - maintenant;
            if (tempsRestant < 500) {
                messagePowerupActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messagePowerupActif.alpha;

            // Position sous les titres narratifs
            const voyageY = Math.max(C.H * 0.10, 70);
            const posY = voyageY + Math.max(C.H * 0.035, 28) + 25; // Sous le sous-titre + 25px

            // Pas de fond - texte blanc avec contour noir pour lisibilité
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Contour noir épais pour lisibilité sur tous les arrière-plans
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(messagePowerupActif.texte, C.W/2, posY);
            ctx.fillText(messagePowerupActif.texte, C.W/2, posY);

            ctx.restore();
        }

        // Fonction pour dessiner le message narratif discret (en bas, sans fond)
        function dessinerMessageNarratifSimple() {
            if (!messageNarratifActif) return;

            const maintenant = Date.now();
            if (maintenant > messageNarratifActif.temps) {
                messageNarratifActif = null;
                return;
            }

            // Fade out dans les dernières 500ms
            const tempsRestant = messageNarratifActif.temps - maintenant;
            if (tempsRestant < 500) {
                messageNarratifActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messageNarratifActif.alpha;

            // Position un peu plus bas que le centre pour ne pas gêner le jeu
            const posY = C.H * 0.65; // 65% de la hauteur (un peu plus bas que le centre)

            // Diviser le texte en lignes pour les longs messages
            const lignes = messageNarratifActif.texte.split('\n');

            // Pas de fond - style discret mais bien visible
            // Texte blanc bold avec ombre noire marquée
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 20px Arial'; // Plus gros et bold
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Ombre noire marquée pour lisibilité
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.shadowBlur = 6;

            // Traiter chaque ligne pour un formatage optimal
            const hauteurLigne = 26;
            const margeHorizontale = 40;
            const largeurMax = C.W - (margeHorizontale * 2);

            let lignesFinales = [];

            // Pré-traiter toutes les lignes pour gérer le retour à la ligne intelligent
            lignes.forEach(ligne => {
                const largeurTexte = ctx.measureText(ligne).width;

                if (largeurTexte > largeurMax) {
                    // Diviser intelligemment la ligne trop longue
                    const mots = ligne.split(' ');
                    let ligneActuelle = '';

                    for (let mot of mots) {
                        const testLigne = ligneActuelle + (ligneActuelle ? ' ' : '') + mot;
                        const testLargeur = ctx.measureText(testLigne).width;

                        if (testLargeur > largeurMax && ligneActuelle !== '') {
                            lignesFinales.push(ligneActuelle);
                            ligneActuelle = mot;
                        } else {
                            ligneActuelle = testLigne;
                        }
                    }

                    if (ligneActuelle) {
                        lignesFinales.push(ligneActuelle);
                    }
                } else {
                    lignesFinales.push(ligne);
                }
            });

            // Calculer la position de départ pour centrer verticalement le bloc de texte
            const hauteurTotale = lignesFinales.length * hauteurLigne;
            const yDebut = posY - hauteurTotale / 2;

            // Dessiner toutes les lignes finales
            lignesFinales.forEach((ligne, index) => {
                const y = yDebut + (index + 1) * hauteurLigne;
                ctx.fillText(ligne, C.W/2, y);
            });

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Passer" simple
        function dessinerBoutonPasser() {
            if (!boutonPasser.actif) return;

            // Position au milieu de l'écran
            boutonPasser.x = C.W/2 - boutonPasser.largeur/2;
            boutonPasser.y = C.H/2 - 50; // En haut du milieu

            ctx.save();

            // Juste du texte avec ombre - pas de fond ni bordure
            ctx.fillStyle = boutonPasser.hover ? '#ff6666' : '#ff0000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre marquée pour lisibilité
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.shadowBlur = 6;

            ctx.fillText(boutonPasser.texte, boutonPasser.x + boutonPasser.largeur/2, boutonPasser.y + boutonPasser.hauteur/2);

            ctx.restore();
        }

        // Fonction pour vérifier si on clique sur le bouton
        function verifierClicBoutonPasser(x, y) {
            if (!boutonPasser.actif) return false;

            return x >= boutonPasser.x && x <= boutonPasser.x + boutonPasser.largeur &&
                   y >= boutonPasser.y && y <= boutonPasser.y + boutonPasser.hauteur;
        }

        // Power-Up Bleu Étincelant
        function creerPowerUp(x, y) {
            // allume_lanterne n'apparaît pas aléatoirement - seulement via creerPowerUpLanterne()
            const types = ['etoile_montante', 'poxerstart', 'vitesse', 'bonus_points'];
            const typeAleatoire = types[Math.floor(Math.random() * types.length)];

            const nouveauPowerUp = {
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: typeAleatoire,
                temps: 0,
                etincelles: []
            };

            powerUps.push(nouveauPowerUp);
            console.log(`🎯 Power-up créé: ${typeAleatoire} à (${x}, ${y}), total: ${powerUps.length}`);
        }

        function dessinerPowerUps() {
            if(powerUps.length > 0) {
                console.log(`🎨 Dessin de ${powerUps.length} power-ups`);
            }
            powerUps.forEach(power => {
                ctx.save();

                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);

                // Couleur selon le type
                let couleur1, couleur2, couleur3;
                switch(power.type) {
                    case 'etoile_montante':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Doré
                        break;
                    case 'poxerstart':
                        couleur1 = '#FF69B4'; couleur2 = '#FF1493'; couleur3 = '#DC143C'; // Rose/Rouge
                        break;
                    case 'vitesse':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert
                        break;
                    case 'bonus_points':
                        couleur1 = '#9400D3'; couleur2 = '#8A2BE2'; couleur3 = '#7B68EE'; // Violet
                        break;
                    case 'allume_lanterne':
                        couleur1 = '#FFA500'; couleur2 = '#FF8C00'; couleur3 = '#FF6347'; // Orange/Rouge (feu)
                        break;
                    default:
                        couleur1 = '#00aaff'; couleur2 = '#0099dd'; couleur3 = '#0088cc'; // Bleu
                }

                // Dégradé selon le type
                const grad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                grad.addColorStop(0, couleur1);
                grad.addColorStop(0.5, couleur2);
                grad.addColorStop(1, couleur3);

                ctx.fillStyle = grad;
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // Bordure scintillante
                ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                ctx.lineWidth = 3;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.strokeRect(power.x, power.y, power.w, power.h);
                ctx.shadowBlur = 0;

                // Icône lanterne 🏮
                ctx.fillStyle = '#ffffff';
                ctx.font = `${power.h * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('🏮', power.x + power.w/2, power.y + power.h*0.7);

                // Étincelles autour
                for(let i = 0; i < 3; i++) {
                    const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = power.w * 0.8;
                    const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                    const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                    ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                power.temps += 1;
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                if(powerUps.length > 0) {
                    console.log(`🔍 Vérif collision balle(${balle.x.toFixed(1)}, ${balle.y.toFixed(1)}) avec ${powerUps.length} power-ups`);
                }
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Effets selon le type de power-up
                    console.log(`⚡ Power-up activé: ${power.type}`);
                    switch(power.type) {
                        case 'etoile_montante':
                            // Créer une étoile qui monte au ciel + 1000 XP
                            creerEtoileMontante(power.x + power.w/2, power.y + power.h/2);
                            score += 1000;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 30);
                            console.log('⭐ Étoile montante créée + 1000 XP');

                            // Message simple
                            afficherMessagePowerupSimple('⭐ Étoile montante +1000 XP');
                            break;

                        case 'poxerstart':
                            // Active le mode tir étoiles normal pendant 7 secondes
                            if(!window.modeTirStars || !window.modeTirStars.actif) {
                                const finTirStars = Date.now() + 7000;
                                window.modeTirStars = { actif: true, fin: finTirStars };
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 30);
                                console.log('🌟 Mode tir étoiles POXERSTART activé (7s)');

                                // Message simple
                                afficherMessagePowerupSimple('🌟 Poxerstart activé - 7 secondes');

                                // Indicateur visuel sur la raquette
                                raquette.poxerstart = true;
                                raquette.poxerstartFin = finTirStars;
                            } else {
                                console.log('🚫 Mode tir étoiles déjà actif - ignoré');
                            }
                            break;

                        case 'vitesse':
                            // Balle BEAUCOUP plus rapide pendant 8 secondes (ne pas cumuler)
                            if(!balle.vitesseActive) {
                                balle.multiplicateurVitesse = (balle.multiplicateurVitesse || 1) * 2.5; // 2.5x au lieu de 1.5x
                                balle.vitesseActive = true;
                                balle.vitesseFinTime = Date.now() + 8000; // 8s au lieu de 10s

                                // Effet visuel de traînée verte
                                balle.traineeVerte = true;

                                setTimeout(() => {
                                    balle.multiplicateurVitesse = (balle.multiplicateurVitesse || 2.5) / 2.5;
                                    balle.vitesseActive = false;
                                    balle.traineeVerte = false;
                                    console.log('💨 Mode vitesse terminé');
                                }, 8000);

                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 20);
                                console.log('💨 Mode vitesse TURBO activé (8s) - 2.5x plus rapide!');

                                // Message simple
                                afficherMessagePowerupSimple('💨 Vitesse turbo activée !');
                            } else {
                                console.log('🚫 Vitesse déjà active - ignoré');
                            }
                            break;

                        case 'bonus_points':
                            // Points bonus (toujours cumulable) - augmenté !
                            score += 500; // 500 au lieu de 200
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 35);
                            console.log('💎 +500 points bonus!');

                            // Message simple
                            afficherMessagePowerupSimple('💎 Bonus points +500');
                            break;

                        case 'allume_lanterne':
                            // Allumer la lanterne si elle est éteinte
                            if(!lanterne.active) {
                                lanterne.active = true;
                                lanterne.intensite = 1.0;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 40);
                                console.log('🏮 Lanterne allumée!');

                                // Message simple
                                afficherMessagePowerupSimple('🏮 Lanterne allumée !');
                            } else {
                                // Si déjà allumée, donner des points bonus
                                score += 300;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 25);
                                console.log('🏮 Lanterne déjà allumée - +300 points bonus');
                                afficherMessagePowerupSimple('🏮 Lanterne +300 bonus');
                            }
                            break;
                    }

                    // Toujours supprimer le power-up après contact (même si effet ignoré)
                    powerUps.splice(i, 1);
                    }
                }
            }
        }

        // Fonction spéciale pour créer le power-up lanterne sur la première brique en bas
        function creerPowerUpLanterne() {
            // Trouver la brique la plus en bas (plus grand Y)
            let briqueLoPlus = null;
            let yMax = -1;

            briques.forEach(brique => {
                if(brique.visible && brique.y > yMax) {
                    yMax = brique.y;
                    briqueLoPlus = brique;
                }
            });

            // Si on a trouvé une brique en bas, y placer le power-up lanterne
            if(briqueLoPlus) {
                const powerUpLanterne = {
                    x: briqueLoPlus.x + briqueLoPlus.w/2 - C.BS * 0.75,
                    y: briqueLoPlus.y + briqueLoPlus.h/2 - C.BS * 0.75,
                    w: C.BS * 1.5,
                    h: C.BS * 1.5,
                    type: 'allume_lanterne',
                    temps: 0,
                    etincelles: [],
                    special: true // Marquer comme power-up spécial
                };

                powerUps.push(powerUpLanterne);
                console.log('🏮 Power-up LANTERNE placé sur la brique du bas!');
            }
        }

        // Créer une étoile qui monte vers le ciel
        function creerEtoileMontante(x, y) {
            // Créer l'étoile montante
            const etoile = {
                x: x,
                y: y,
                taille: 30,
                vitesseY: -3,
                temps: 0,
                alpha: 1,
                particules: []
            };

            // Animation de l'étoile qui monte
            const animer = () => {
                etoile.y += etoile.vitesseY;
                etoile.temps += 1;
                etoile.alpha = Math.max(0, 1 - etoile.temps / 120); // Disparaît en 2 secondes à 60fps

                // Dessiner l'étoile
                ctx.save();
                ctx.globalAlpha = etoile.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.font = `${etoile.taille}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('⭐', etoile.x, etoile.y);

                // Effet de traînée dorée
                for(let i = 0; i < 3; i++) {
                    const particuleX = etoile.x + (Math.random() - 0.5) * 20;
                    const particuleY = etoile.y + i * 15;
                    ctx.globalAlpha = etoile.alpha * (1 - i * 0.3);
                    ctx.fillStyle = `hsl(45, 100%, ${70 - i * 10}%)`;
                    ctx.font = `${etoile.taille * (1 - i * 0.2)}px serif`;
                    ctx.fillText('✨', particuleX, particuleY);
                }
                ctx.restore();

                // Continuer l'animation si l'étoile est encore visible
                if(etoile.alpha > 0 && etoile.y > -50) {
                    requestAnimationFrame(animer);
                }
            };

            requestAnimationFrame(animer);
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise à jour pendant l'animation
            if(lanterne.active) {
                // Effet de pulsation douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);

                // Créer quelques particules dorées occasionnellement
                if(Math.random() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Créer une rafale de 1-3 cœurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // Éventail 40°
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // Départ légèrement dispersé
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, très grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // Délai entre chaque cœur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            const tempsActuel = Date.now();

            // Plus de cœurs automatiques pendant l'intro
            // Pendant le jeu normal : plus de déclenchement automatique
            // Les rafales se déclenchent seulement sur clic/touche

            // Mettre à jour les cœurs de lumière
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Montée rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Animation de flottement gauche-droite
                if(coeur.vitesseFlottement !== undefined) {
                    coeur.flottemment += coeur.vitesseFlottement;
                    // Ajouter un mouvement oscillant horizontal
                    coeur.x += Math.sin(coeur.flottemment) * 0.5;
                }

                // Animation de scintillement
                coeur.scintillement += 0.2;
                coeur.luminosite = 0.7 + 0.3 * Math.sin(coeur.scintillement);

                // Supprimer si sort de l'écran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits cœurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // Vérifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // Cœur touché !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                            // Supprimer le cœur du bateau
                            coeursBateau.splice(i, 1);

                            // Vérifier si tous les cœurs du haut sont touchés
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // Passer à la phase suivante (seulement si on était en phase tir_coeurs_haut)
                                setTimeout(() => {
                                    // Progression directe vers la phase suivante
                                    narrationManager.goToNextPhaseDirect();
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // Forcer la balle visible en phase lanterne et la mettre en attente
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    // Garder l'état de la lanterne de la phase précédente
                                    // lanterne.active et lanterne.intensite conservés
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    // Message géré par le nouveau système narratif

                                    // Créer quelques cœurs décoratifs qui flottent (différents de ceux du haut)
                                    setTimeout(() => {
                                        // Créer des cœurs décoratifs flottants au lieu de recréer les cœurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

    
                                        // Transition vers le jeu de briques après 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                }, 1000);
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                briques.forEach(brique => {
                    if(!brique.visible) return;

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames

                        // Supprimer le cœur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est détruite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // Explosion en 3 petits cœurs seulement
                            for(let j = 0; j < 3; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du cœur qui grossit et monte au ciel
                            ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                            // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        // Vérifier la condition de fin selon le mode de jeu
                        if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                            // Mode briques : vérifier si toutes les briques sont détruites
                            const briquesRestantes = briques.filter(b => b.visible).length;
                            console.log(`🔍 Vérif briques restantes: ${briquesRestantes}`);
                            if(briquesRestantes === 0) {
                                console.log('🎯 Toutes les briques détruites (stars)! Transition vers phase suivante...');
                                // Progression directe vers la phase suivante
                                setTimeout(() => {
                                    console.log('🚀 Appel narrationManager.goToNextPhaseDirect() (stars)');
                                    narrationManager.goToNextPhaseDirect();
                                }, 1000);
                            }
                        } else if(brises >= VOYAGE.length) {
                            // Mode cœurs : progression classique basée sur VOYAGE
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();
                            }, 1000);
                        }
                    }
                });
            }
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';

                // Forme étoile/diamant pour les cœurs du bateau
                ctx.save();
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                const t = coeur.taille;

                ctx.translate(coeur.x, coeur.y);

                // Cœur en polygone pour le bateau
                ctx.beginPath();

                // Lobe gauche
                ctx.moveTo(-t * 0.25, 0);
                ctx.lineTo(-t * 0.15, -t * 0.15);
                ctx.lineTo(-t * 0.05, -t * 0.1);
                ctx.lineTo(-t * 0.02, 0);

                // Lobe droit
                ctx.lineTo(t * 0.02, 0);
                ctx.lineTo(t * 0.05, -t * 0.1);
                ctx.lineTo(t * 0.15, -t * 0.15);
                ctx.lineTo(t * 0.25, 0);

                // Descente vers la pointe
                ctx.lineTo(t * 0.1, t * 0.15);
                ctx.lineTo(0, t * 0.3);
                ctx.lineTo(-t * 0.1, t * 0.15);

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            });
        }

        // Petits cœurs décoratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Créer un visage rond avec les cœurs
            const centreX = C.W / 2;
            const centreY = C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.15; // Rayon du visage

            for(let i = 0; i < 40; i++) { // 40 cœurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles variées

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // Répartir sur 360°
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // Légère variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // Légère variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut être cassé
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une étape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.02,
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02,
                });
            }
        }

        // Générer des positions en forme de cœur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du cœur

            // Générer des positions selon l'équation paramétrique d'un cœur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Paramètre de 0 à 2π

                // Équation paramétrique d'un cœur : x = 16sin³(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise à l'échelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits cœurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les cœurs résiduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le cœur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // Générer les positions en forme de cœur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Créer les briques selon la disposition en cœur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: phaseJeu === 'lanterne' ? 2 : 3,     // 2 coups en phase lanterne, 3 en phase stars
                    vie: phaseJeu === 'lanterne' ? 2 : 3,        // Vie actuelle
                    clignotement: 0, // Animation quand touchée
                    // Animation de dédoublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }

            // Placer automatiquement le power-up lanterne sur la première brique en bas
            // Mais seulement en phase lanterne et si la lanterne n'est pas déjà allumée
            if(phaseJeu === 'lanterne' && !lanterne.active) {
                setTimeout(() => {
                    creerPowerUpLanterne();
                }, 500); // Petit délai pour laisser les briques se placer
            }
        }

        function libererVaguesAmour() {
            // Ne libérer des vagues d'amour que si le jeu est actif
            if (!jeu || phaseIntro.active) return;

            const tempsActuel = Date.now();

            // Mode étoile cœur activé par power-up
            if(window.modeEtoileCoeur && window.modeEtoileCoeur.actif) {
                if(Date.now() > window.modeEtoileCoeur.fin) {
                    window.modeEtoileCoeur.actif = false;
                } else if(tempsActuel - derniereCreeRafale >= 200) { // Plus fréquent pendant le power-up
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
            // Mode normal
            else if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : libérer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : libérer l'amour seulement pour la dernière brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        function mettreAJourPetitsCoeurs() {
            petitsCoeurs.forEach((coeur, index) => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;

            });
        }

        // Fonction pour dessiner des cœurs avec 20 triangles (pour les briques)
        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            const temps = Date.now() * 0.003;
            const pulsation = 1 + Math.sin(temps) * 0.15; // Pulsation douce

            // Appliquer la pulsation
            ctx.scale(pulsation, pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            const triangleSize = t * 0.08;

            // Cœur super mignon pour les briques qui pulse
            ctx.beginPath();

            // Lobe gauche (forme arrondie avec segments)
            ctx.moveTo(-t * 0.3, -t * 0.02);
            ctx.lineTo(-t * 0.22, -t * 0.18);
            ctx.lineTo(-t * 0.12, -t * 0.2);
            ctx.lineTo(-t * 0.05, -t * 0.1);
            ctx.lineTo(-t * 0.02, -t * 0.02);

            // Lobe droit (forme arrondie avec segments)
            ctx.lineTo(t * 0.02, -t * 0.02);
            ctx.lineTo(t * 0.05, -t * 0.1);
            ctx.lineTo(t * 0.12, -t * 0.2);
            ctx.lineTo(t * 0.22, -t * 0.18);
            ctx.lineTo(t * 0.3, -t * 0.02);

            // Descente vers la pointe avec courbe
            ctx.lineTo(t * 0.18, t * 0.15);
            ctx.lineTo(t * 0.08, t * 0.3);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.08, t * 0.3);
            ctx.lineTo(-t * 0.18, t * 0.15);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Détails mignons - petits cœurs à l'intérieur
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Petit cœur gauche
            ctx.beginPath();
            ctx.moveTo(-t * 0.15, -t * 0.05);
            ctx.lineTo(-t * 0.12, -t * 0.08);
            ctx.lineTo(-t * 0.09, -t * 0.05);
            ctx.lineTo(-t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Petit cœur droit
            ctx.beginPath();
            ctx.moveTo(t * 0.09, -t * 0.05);
            ctx.lineTo(t * 0.12, -t * 0.08);
            ctx.lineTo(t * 0.15, -t * 0.05);
            ctx.lineTo(t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Point lumineux central
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, t * 0.05, t * 0.02, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // Cœur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // Côtés qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits cœurs pendant l'animation du bateau, la phase lanterne ou la phase stars
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars') return;

            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // Calculs d'animation
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le cœur polygonal
                dessinerCoeurPolygonal(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });
        }

        // Système de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur, vie: 1,
                    taille: Math.random() * 4 + 2,
                    type: 'rond'
                });
            }
        }

        // Particules en forme de petits cœurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6, // Moins de dispersion horizontale
                    vy: -(Math.random() * 8 + 4),  // Toujours vers le haut
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                if(p.type === 'coeur') {
                    // Cœurs : pas de gravité, continuent vers le haut
                    p.vy *= 0.99; // Légère décélération
                } else {
                    // Particules normales : gravité
                    p.vy += 0.15;
                }

                p.vie -= 0.02;

                // Supprimer les particules qui sortent de l'écran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            if(animationBateau.active) return; // Pas de particules pendant l'animation du bateau

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.vie * 0.8;
                ctx.fillStyle = p.couleur;

                if(p.type === 'coeur') {
                    // Dessiner petit cœur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du cœur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du cœur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du cœur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Particule ronde normale
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions
        function afficherMunitions() {
            if (animationBateau.active || phaseJeu !== 'stars') return;

            ctx.fillStyle = '#FFD700';
            ctx.font = '16px Arial';
            ctx.fillText(`Étoiles: ${munitions}`, 10, 30);

            // Afficher le mode étoiles
            ctx.fillStyle = '#FFD700';
            ctx.fillText('⭐ Mode: Étoiles', 10, 55);
        }

        // Dessiner les projectiles étoiles
        function dessinerProjectiles() {
            // Dessiner les projectiles étoiles pendant la phase stars ET lanterne (pour le mode Pluton)
            if(phaseJeu !== 'stars' && phaseJeu !== 'lanterne') return;

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = 8;

                // Calcul pour l'effet de rotation scintillante
                const rotation = Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner l'étoile avec effet de lueur (couleur selon le type)
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile + 3);

                // Projectiles dorés
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                ctx.strokeStyle = '#FFD700';

                ctx.fillStyle = gradient;
                ctx.lineWidth = 1;

                // Étoile à 5 branches
                ctx.beginPath();
                for(let i = 0; i < 5; i++) {
                    const angle1 = (i * 2 * Math.PI) / 5;
                    const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                    if(i === 0) {
                        ctx.moveTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    } else {
                        ctx.lineTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    }

                    ctx.lineTo(Math.cos(angle2) * rayonEtoile * 0.4, Math.sin(angle2) * rayonEtoile * 0.4);
                }
                ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Tirer un projectile étoile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne
            if (rechargement > 0 || phaseJeu !== 'lanterne') return;

            // Tant qu'il y a des munitions, tirer des étoiles
            if (munitions > 0) {
                // Tir d'étoiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;


                projectiles.push({
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY
                });

                munitions--;

                // Vérifier si c'était la dernière munition
                if (munitions === 0) {
                    setTimeout(() => {
                        phaseJeu = 'lanterne';
                        balle.dx = 0; // Immobile au début
                        balle.dy = 0; // Immobile au début
                        balle.visible = true; // S'assurer que la lanterne est visible
                        balle.enAttente = true; // Attendre le clic
                        // Message géré par le nouveau système narratif
                    }, 500);
                }
            }

            rechargement = 20; // Délai entre les tirs
        }

        // Mettre à jour les projectiles
        function mettreAJourProjectiles() {
            if (animationBateau.active || phaseJeu !== 'lanterne') {
                // Nettoyer les projectiles si on n'est pas en phase lanterne
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // Déplacer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'écran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est détruite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Explosion en 3 petits cœurs
                                for(let j = 0; j < 3; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                if(Math.random() < 0.3) {
                                    creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2);
                                }

                                // Vérifier si toutes les briques sont détruites
                                if(briques.every(b => !b.visible)) {
                                    console.log('🎯 Toutes les briques détruites! Transition vers phase suivante...');

                                    // Auto-récupérer les powerups restants
                                    if(powerUps && powerUps.length > 0) {
                                        console.log(`🎁 Auto-récupération de ${powerUps.length} powerups restants`);
                                        powerUps.forEach(powerup => {
                                            // Déclencher les effets selon le type
                                            switch(powerup.type) {
                                                case 'etoile_montante':
                                                    score += 1000;
                                                    break;
                                                case 'bonus_points':
                                                    score += 500;
                                                    break;
                                                case 'allume_lanterne':
                                                    lanterne.active = true;
                                                    lanterne.intensite = 1.0;
                                                    break;
                                            }
                                            // Particules d'effet
                                            if(window.ajouterParticules) {
                                                ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                            }
                                        });
                                        powerUps = []; // Vider la liste
                                    }

                                    phaseJeu = 'fin_niveau';
                                    setTimeout(() => {
                                        // Progression directe vers la phase suivante
                                        console.log('🚀 Appel narrationManager.goToNextPhaseDirect()');
                                        narrationManager.goToNextPhaseDirect();
                                    }, 1000);
                                }
                            }
                        }
                    }
                });
            }

            // Réduire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // Gérer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // Vérifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqué
            }

            // Appliquer le multiplicateur de vitesse s'il existe
            const vitesseMulti = balle.multiplicateurVitesse || 1;
            balle.x += balle.dx * vitesseMulti;
            balle.y += balle.dy * vitesseMulti;

            // Mode casse-briques : rebonds classiques (uniquement en phase casse_briques)
            if(phaseJeu === 'lanterne') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' ? C.SP * 1.5 : C.SP) * ecart * 0.8 * multiplicateurPuissance;
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode étoiles : traverser les bords avec téléportation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // Réapparaît à droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // Réapparaît à gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // Téléportation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // Réapparaît en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de vérité (bas) - seulement dans les phases où la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'étoile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'étoile continue sa trajectoire
            }

            // Briser les préjugés - une seule brique par frame maximum
            let briqueTouchee = false;
            briques.forEach(brique => {
                if(briqueTouchee) return; // Arrêter si on a déjà touché une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Marquer qu'on a touché une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond plus précis selon la position de contact
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // L'étoile traverse sans rebondir
                        // Effet magique de passage à travers les préjugés

                        // Si la brique est détruite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;

                        // Explosion en 3 petits cœurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: 1,
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du cœur qui grossit et monte au ciel
                        ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                        // Désactivé : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // Désactivé : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de créer un power-up bleu
                        if(Math.random() < 0.3) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    // Vérifier la condition de fin selon le mode de jeu
                    if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                        // Mode briques : vérifier si toutes les briques sont détruites
                        const briquesRestantes = briques.filter(b => b.visible).length;
                        console.log(`🔍 Vérif briques restantes (balle): ${briquesRestantes}`);
                        if(briquesRestantes === 0) {
                            console.log('🎯 Toutes les briques détruites (balle)! Transition vers phase suivante...');

                            // Auto-récupérer les powerups restants
                            if(powerUps && powerUps.length > 0) {
                                console.log(`🎁 Auto-récupération de ${powerUps.length} powerups restants (balle)`);
                                powerUps.forEach(powerup => {
                                    switch(powerup.type) {
                                        case 'etoile_montante': score += 1000; break;
                                        case 'bonus_points': score += 500; break;
                                        case 'allume_lanterne': lanterne.active = true; lanterne.intensite = 1.0; break;
                                    }
                                    if(window.ajouterParticules) {
                                        ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                    }
                                });
                                powerUps = [];
                            }

                            if(!modeEtoileLance) {
                                // Progression directe vers la phase suivante
                                setTimeout(() => {
                                    console.log('🚀 Appel narrationManager.goToNextPhaseDirect() (balle)');
                                    narrationManager.goToNextPhaseDirect();
                                }, 1000);

                                // La fin sera gérée par finalizeNarration() automatiquement
                            } else if(modeEtoileLance) {
                                // Mode étoile infini : relancer le même niveau stars
                                jeu = false;
                                relancerModeEtoileInfini();
                            } else {
                                veriteLiberee();
                            }
                        }
                    } else if(brises >= VOYAGE.length) {
                        if(!modeEtoileLance) {
                            // Progression directe vers la phase suivante
                            setTimeout(() => {
                                narrationManager.goToNextPhaseDirect();
                            }, 1000);

                            // La fin sera gérée par finalizeNarration() automatiquement
                        } else if(modeEtoileLance) {
                            // Mode étoile infini : relancer le même niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // Événements
        function perdreVie() {
            vies--;
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position à l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne') {
                // En phase lanterne, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                afficherMessage('💔 Les mensonges résistent ! Continue à chercher la vérité !\n\n👆 Cliquez pour relancer la lanterne ! 👁️', 4000);
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                balle.dy = -C.SP * multiplicateurPuissance;
                afficherMessage('💔 Les mensonges résistent ! Continue à chercher la vérité ! 👁️', 3000);
            }
        }

        function finDuVoyage() {
            jeu = false;
            afficherMessage('😢 Le voyage vers la vérité continue...\n\n💪 "La vérité finit toujours par triompher !"\n\n✨ Touchez pour recommencer ✨', 6000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // Délai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(periode === 'jour') {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    // Message géré par le nouveau système narratif
                } else {
                    // Fin du chapitre 2 : déclencher la séquence finale des feux d'artifice
                    // Phase finale : séquence complète avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARRÊT DU SYSTÈME NARRATIF pour éviter les interférences
                    phaseIntro.active = false;
                    // Introduction terminée

                    // ÉTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = Date.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // ÉTAPE 2 : Feux d'artifice 5s
                        console.log("Fin animation bateau, début feux d'artifice");
                        animationBateau.active = false;

                        // Créer des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // ÉTAPE 3 : Lever de soleil + fin normale via finalizeNarration
                            console.log("Démarrage lever de soleil final");
                            leverSoleilFinal();
                            setTimeout(() => {
                                console.log("Appel finalizeNarration pour menu correct");
                                narrationManager.finalizeNarration();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de délai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le début pour éviter les problèmes
            chapitre = 1;
            VOYAGE = JOUR;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            // Vérifier la condition de fin selon le mode de jeu
            if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                // Mode briques : vérifier si toutes les briques sont détruites
                const briquesRestantes = briques.filter(b => b.visible).length;
                if(briquesRestantes === 0) {
                    narrationManager.goToNextPhaseDirect();
                }
            } else if(brises >= VOYAGE.length) {
                // Mode cœurs : progression classique basée sur VOYAGE
                narrationManager.goToNextPhaseDirect();
            }

            // Forcer l'affichage des briques
            briques.forEach(brique => {
                brique.visible = true;
            });

            // Forcer la visibilité de la balle et activer le jeu
            if(balle) {
                balle.visible = true;
            }
            jeu = true;

            cacherMessage();
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            // Mode passe phase désactivé
            return;
            if(periode === 'jour') {
                periode = 'nuit';
                VOYAGE = NUIT;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Créer les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilité de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
            } else {
                periode = 'jour';
                VOYAGE = JOUR;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recréer les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits cœurs visibles et désactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
            }
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessagePowerupSimple('❌ Aucune brique trouvée');
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessagePowerupSimple(`⚡ Mode rapide activé - ${briquesModifiees} briques`);
            } else {
                afficherMessagePowerupSimple('ℹ️ Toutes les briques déjà à 1 vie');
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // Désactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessagePowerupSimple('⭐ Tir étoiles désactivé');
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessagePowerupSimple('🌟 Tir étoiles automatique activé');

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si nécessaire
                        if(!jeu) jeu = true;

                        // Viser une brique aléatoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Libérer les cœurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            console.log("Lever de soleil : passage en mode jour");
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise à jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode étoile test
            console.log("Lancement du mode étoile test");

            // Configuration pour mode étoile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = NUIT;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode étoile depuis le menu

            // Forcer l'arrêt des systèmes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'étoiles automatique en mode étoile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les éléments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Créer les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessagePowerupSimple('🌟 Mode étoile infini activé');
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones à chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centrée
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion après 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // Délai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le même niveau stars infini
                phaseJeu = 'stars';
                periode = 'nuit';
                VOYAGE = NUIT;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessagePowerupSimple('🌟 Niveau terminé - Nouveau niveau stars');

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'étoiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // Délai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // Séquence finale : 3 formations aléatoires avec explosions
            console.log("Lancement de la séquence finale avec 3 formations");

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations aléatoires différentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // Séquence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position aléatoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        console.log(`Formation ${index + 1}: ${formation} à (${x}, ${y})`);

                        // Explosion après formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu après la séquence complète (3 × 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arrêter le tir automatique à la fin du mode étoile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard correct
            narrationManager.showFinalMenu();
        }


        function afficherMessageFinal() {
            const msg = document.getElementById('message');

            // Menu simple et élégant
            msg.innerHTML = `
                <div style="text-align: center; background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); max-width: 400px; margin: 0 auto;">
                    <h2 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 24px; font-weight: 300;">✨ Voyage Terminé ✨</h2>

                    <p style="margin: 15px 0 30px 0; color: #5a6c7d; font-size: 16px; line-height: 1.5;">
                        Merci d'avoir découvert la vérité
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <button onclick="lancerPhaseBonus()"
                                style="background: linear-gradient(145deg, #4a90e2, #357abd); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            📖 Épilogue
                        </button>

                        <button onclick="location.reload()"
                                style="background: linear-gradient(145deg, #6c7b7f, #5a6c7d); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(108, 123, 127, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            🔄 Rejouer
                        </button>
                    </div>
                </div>
            `;

            msg.classList.add('show');
            msg.style.display = 'block';
        }

        // Lancer la phase bonus
        function lancerPhaseBonus() {
            // Charger le module de phase bonus
            if (!window.PhaseBonusMur) {
                const script = document.createElement('script');
                script.src = 'modules/phase-bonus-mur.js';
                script.onload = () => {
                    demarrerPhaseBonus();
                };
                document.head.appendChild(script);
            } else {
                demarrerPhaseBonus();
            }
        }

        function demarrerPhaseBonus() {
            // Donner le bonus XP AVANT de créer la phase bonus
            giveXPBonus(200);

            // Créer et initialiser la phase bonus
            if (!window.phaseBonusMur) {
                window.phaseBonusMur = new window.PhaseBonusMur({ angel: angel });
                window.phaseBonusMur.init(canvas, ctx);
            }

            // Passer en mode phase bonus
            jeu = false;
            phaseJeu = 'bonus_mur';

            // Démarrer la phase bonus
            window.phaseBonusMur.start();

            // Ajouter la gestion dans la boucle de jeu
            window.gameManager = window.gameManager || {};
            window.gameManager.startBonusPoem = () => {
                window.phaseBonusMur.startBonusPoem();
            };
            window.gameManager.restart = () => {
                window.location.reload();
            };
        }

        // Fonction dédiée pour donner XP bonus (simple avec score)
        function giveXPBonus(amount) {
            try {
                console.log('🌟 Attribution bonus score:', amount);
                console.log('Score avant:', score);

                // Ajouter au score directement
                score += amount;

                console.log('Score après:', score);

                // Message simple
                afficherMessagePowerupSimple('🌟 +' + amount + ' Points bonus fin de jeu');

                return true;
            } catch (error) {
                console.error('❌ Erreur attribution bonus score:', error);
                return false;
            }
        }

        function afficherCreditsFinaux() {
            const msg = document.getElementById('message');
            msg.innerHTML = `
                <div style="text-align: center; background: linear-gradient(135deg, #8B4513, #A0522D); padding: 30px; border-radius: 15px; margin: 20px;">
                    <h2 style="margin-bottom: 20px; color: #ffffff;">📜 Crédits Complets 📜</h2>

                    <div style="color: #ffffff; line-height: 1.6; margin: 20px 0;">
                        <p><strong>🎮 Création & Développement :</strong> Emmanuel Payet</p>
                        <p><strong>🎨 Design & Concept :</strong> Emmanuel Payet</p>
                        <p><strong>✍️ Narration & Poésie :</strong> Emmanuel Payet</p>
                        <p><strong>🎵 Vision Artistique :</strong> Emmanuel Payet</p>
                        <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p><strong>💝 Projet :</strong> "Voir la Vérité"</p>
                        <p><strong>🌟 Message :</strong> Une fable interactive sur les préjugés</p>
                        <p><strong>📅 Année :</strong> 2025</p>
                        <p><strong>✨ Signature Artistique :</strong> Dreamer Unisona</p>
                        <p><strong>🏷️ Copyright :</strong> © Emmanuel Payet - Tous droits réservés</p>
                        <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p style="font-style: italic; color: #ffd700;">
                            "Aucun mur n'est éternel.<br>
                            Car l'eau finit toujours par user la pierre,<br>
                            et la liberté reprendra son chemin."
                        </p>
                        <p style="font-style: italic; color: #87CEEB; margin-top: 15px;">
                            — Dreamer Unisona
                        </p>
                    </div>

                    <button onclick="narrationManager.showFinalMenu()"
                            style="background: linear-gradient(145deg, #2E8B57, #3CB371); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer;">
                        ← Retour au Menu
                    </button>
                </div>
            `;
        }

        function recommencerJeu() {
            // Réinitialiser complètement le jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;

            // Les objets kawaii sont réservés au mode secret seulement
            // activerObjetsKawaii(); // SUPPRIMÉ - uniquement pour mode secret
            vies = 3;
            brises = 0;
            jeu = false; // Commencer avec jeu désactivé pour l'intro

            // Réinitialiser les systèmes
            animationBateau.active = false;
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
            narrationManager.reset();

            // Nettoyer les éléments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Cacher le message
            cacherMessage();

            // Démarrer la narration complète P1 à P16
            setTimeout(() => {
                narrationManager.start();
            }, 1000);
        }

        // Nouvelle fonction pour les messages avec animation
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du cœur en rouge au début si spécifié
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">💔 ${motRouge.toUpperCase()} 💔</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il apparaît dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Callback pour gérer la fin de l'animation et le timing de disparition
            const onComplete = () => {
                console.log('Animation terminée, attente avant disparition...');
                // Attendre un peu après la fin de l'animation avant de faire disparaître
                setTimeout(() => {
                    cacherMessage();
                }, Math.max(1000, duree * 0.2)); // Au moins 1s d'attente après l'animation
            };

            console.log('Animation appelée:', animation, 'Texte:', texteComplet.substring(0, 50));

            // Créer une nouvelle instance TextAnimator avec le nouveau code optimisé
            const anim = new TextAnimator('message');

            switch(animation) {
                case 'typewriter':
                    console.log('Appel typewriter avec speed:', speed);
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'digital':
                    anim.digital(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fade':
                    anim.fade(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'glitch':
                    anim.glitch(texteComplet, {
                        duration: Math.max(2000, duree * 0.3),
                        onComplete: onComplete
                    });
                    break;
                case 'emboss':
                    anim.setColors('#ffffff', '#666666');
                    anim.applyEffect('emboss');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'neon':
                    anim.setColors('#64ffda', '#64ffda');
                    anim.applyEffect('neon');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'shadow3d':
                    anim.setColors('#ffffff', '#333333');
                    anim.applyEffect('shadow3d');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fire':
                    anim.setColors('#ff4444', '#ff8800');
                    anim.applyEffect('fire');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'ice':
                    anim.setColors('#ffffff', '#ffffff');
                    anim.applyEffect('none');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'outline':
                    anim.setColors('#ffffff', '#000000');
                    anim.applyEffect('outline');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                default:
                    msg.innerHTML = texteComplet.replace(/\n/g, '<br>');
                    onComplete();
            }
        }

        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du cœur en rouge au début si spécifié
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">💔 ${motRouge.toUpperCase()} 💔</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il apparaît dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // Garder le texte à sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Créer le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        🔄 Rejouer
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ➡️ Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte à sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }

        function afficherMessageNarratif(texte, duree = 0) {
            const msg = document.getElementById('message');

            // Ajouter la classe narratif pour le style cinématique
            msg.classList.remove('show');
            msg.classList.add('narratif');
            msg.innerHTML = texte;
            msg.classList.add('show');

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    setTimeout(() => {
                        msg.classList.remove('narratif');
                    }, 300);
                }, duree);
            }
        }

        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifié et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;

            // Couleur de la mer selon le chapitre
            const merGrad = ctx.createLinearGradient(0, merY, 0, C.H);
            if(periode === 'jour') {
                // Mer bleue paisible
                merGrad.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
                merGrad.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
                merGrad.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            } else {
                // Mer sombre et menaçante
                merGrad.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
                merGrad.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
                merGrad.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
            }
            ctx.fillStyle = merGrad;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // Vagues selon le chapitre
            if(periode === 'jour') {
                // Vagues paisibles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                // Vagues agitées
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = periode === 'jour' ? (8 - ligne * 2) : (12 - ligne * 3);
                const fréquence = 0.01 + ligne * 0.005;
                const vitesse = periode === 'jour' ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                for(let x = 0; x <= C.W; x += 10) {
                    const vague = Math.sin(x * fréquence + offset) * amplitude;
                    if(x === 0) ctx.moveTo(x, y + vague);
                    else ctx.lineTo(x, y + vague);
                }
                ctx.stroke();
            }

            // Ailerons de requin dans le chapitre 2 (disparaissent pendant le lever de soleil)
            if(periode === 'nuit' && !leverSoleil.active) {
                const requins = [
                    { x: 0.2, vitesse: 0.3, taille: 1.0 },
                    { x: 0.6, vitesse: 0.5, taille: 0.8 },
                    { x: 0.9, vitesse: 0.4, taille: 1.2 }
                ];

                requins.forEach(requin => {
                    const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                    const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                    const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;

                    // Aileron de requin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8); // Base gauche
                    ctx.lineTo(reqX, reqY - taille); // Pointe
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5); // Base droite
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8); // Retour base
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Sillage du requin
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // Déclarer les variables pour éviter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(periode === 'jour') {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% à 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui évolue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // Rayons du soleil (plus nombreux pendant le lever)
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3;
                const nbRayons = leverSoleil.active ? 16 : 8;
                for(let i = 0; i < nbRayons; i++) {
                    const rotationSoleil = Date.now() * 0.0005; // Rotation lente
                    const angle = (i / nbRayons) * Math.PI * 2 + rotationSoleil;
                    const longueurRayon = leverSoleil.active ? 25 : 15;
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            } else {
                // CHAPITRE 2: Lune inquiétante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(periode === 'jour') {
                // Vérifier si le soleil fait un clin d'œil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'œil pendant 2 secondes

                // Arrêter le clignotement après 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant à la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et fermés (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux fermés paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et modéré
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence à sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'œil ! Œil gauche fermé, œil droit ouvert
                        // Œil gauche fermé (clin d'œil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // Œil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'œil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au début
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inquiétante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre
            if(periode === 'jour') {
                // Nuages blancs paisibles
                const nuages = [
                    { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                    { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                    { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                ];

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.lineWidth = 2;

                nuages.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                    for(let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * taille * 0.8;
                        const rayonNuage = taille * (0.8 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                });
            } else {
                // Nuages d'orage gris avec éclairs
                const nuagesOrage = [
                    { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                    { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                    { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                ];

                nuagesOrage.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                    // Nuages gris menaçants
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                    ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                    ctx.lineWidth = 2;

                    for(let i = 0; i < 4; i++) {
                        const offsetX = (i - 1.5) * taille * 0.6;
                        const rayonNuage = taille * (0.7 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // Éclairs occasionnels
                    if(Math.random() < 0.02) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(nuageX, nuageY + taille);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                        ctx.stroke();
                    }
                });
            }
        }

        // Rendu principal
        function dessiner() {

            // Fond dégradé selon le chapitre
            const grad = ctx.createLinearGradient(0, 0, 0, C.H);
            if(periode === 'jour') {
                // Ciel diurne
                grad.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
                grad.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
                grad.addColorStop(1, 'rgba(240,248,255,0.98)');
            } else {
                // Ciel nocturne orageux
                grad.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
                grad.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
                grad.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, C.H);

            dessinerCiel();
            dessinerMer();
            dessinerInterface();
            dessinerPrejuges();
            dessinerPowerUps();
            dessinerCoeursBateau();
            dessinerPetitsCoeurs();
            dessinerBateau();
            afficherMunitions();
            dessinerStarsProjectiles(); // Étoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // Étoiles (phase briques)
            // Mode secret - utiliser le module
            if (secretModeModule && secretModeModule.isActive) {
                secretModeModule.render();
            } else if (modeSecret) {
                // Fallback si le module n'est pas disponible
                dessinerProjectilesSecret();
            }
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret

            // Obstacles gérés par le module secret seulement

            // Objets kawaii réservés au mode secret uniquement
            // (Les objets kawaii sont maintenant dans le module secret)

            dessinerParticules();

            // Rendu des drones feux d'artifice
            if (droneModule) {
                droneModule.render();
            }

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
            dessinerMessagePowerupSimple(); // Messages simples des powerups en haut
            dessinerMessageNarratifSimple(); // Messages narratifs centrés
            dessinerBoutonPasser(); // Bouton passer simple en haut
        }

        // Contrôles tactiles et souris unifiés
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left };
        }

        function deplacerRaquette(x) {
            if(!jeu) return;
            raquette.x = x - C.PW/2;
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));
        }

        // Événements tactiles
        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); tactile = true;

            // Vérifier le clic sur le bouton passer
            const pos = obtenirPosition(e);
            if (verifierClicBoutonPasser(pos.x, pos.y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && periode !== 'nuit' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
                return;
            }

            if(phaseJeu === 'stars') {
                // Phase stars : tir d'étoiles tactile
                const pos = obtenirPosition(e);
                tirerStarsProjectile(pos.x, pos.y);
                libererVaguesAmour(); // Libérer les cœurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction aléatoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('🏮 Lanterne lancée !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir étoiles activé par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const pos = obtenirPosition(e);
                        tirerStarsProjectile(pos.x, pos.y);
                    }
                } else {
                    // Si la balle est déjà en mouvement, déplacer la raquette
                    const pos = obtenirPosition(e);
                    deplacerRaquette(pos.x);
                }
            } else {
                const pos = obtenirPosition(e);
                deplacerRaquette(pos.x);
                libererVaguesAmour(); // Libérer une vague d'amour
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // Événements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();


            deplacerRaquette(e.clientX - rect.left);
        });

        canvas.addEventListener('click', (e) => {
            // Vérifier le clic sur le bouton passer
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (verifierClicBoutonPasser(x, y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement en phases lanterne/stars/fin_niveau - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && phaseJeu !== 'feux_artifice' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
            } else if(phaseJeu === 'stars') {
                // Phase stars : tir d'étoiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Libérer les cœurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction aléatoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('🏮 Lanterne lancée !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir étoiles activé par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const rect = canvas.getBoundingClientRect();
                        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                        tirerStarsProjectile(mouseX, mouseY);
                    }
                }
            } else {
                // Le système de clic sur les oiseaux est maintenant géré par les événements CSS
                // Voir la fonction setupBirdClickHandlers() plus bas

                // Clic normal sur canvas pour libérer l'amour
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, utiliser le module
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.createProjectile();
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        creerProjectile();
                    }
                }
            }
        });

        // Redimensionnement responsive
        window.addEventListener('resize', () => {
            size = setupCanvas();
            if(!jeu) initJeu();
        });

        // ========== MODULE MODE SECRET - INITIALISATION ==========
        function initSecretModeModule() {
            if (!canvas || !ctx) {
                console.error('Canvas ou contexte non disponible pour le module secret');
                return;
            }

            // Vérifier si la classe SecretModeModule est disponible
            if (typeof SecretModeModule === 'undefined') {
                console.warn('⚠️ SecretModeModule non trouvé - Utilisation du mode secret intégré');
                secretModeModule = null;
                return;
            }

            try {
                // Créer l'instance du module avec un objet gameState plus simple
                const gameStateRef = {
                    get modeSecret() { return modeSecret; },
                    set modeSecret(val) { modeSecret = val; },
                    get jeu() { return jeu; },
                    set jeu(val) { jeu = val; },
                    get score() { return score; },
                    set score(val) { score = val; },
                    get raquette() { return raquette; },
                    get C() { return C; },
                    get phaseJeu() { return phaseJeu; },
                    set phaseJeu(val) { phaseJeu = val; },
                    afficherMessage: (msg, duree) => afficherMessage(msg, duree),
                    ajouterParticules: (x, y, couleur, nb) => ajouterParticules(x, y, couleur, nb)
                };

                secretModeModule = new SecretModeModule(canvas, ctx, gameStateRef);
                console.log('🎮 Module Mode Secret initialisé avec succès');
            } catch (error) {
                console.error('❌ Erreur initialisation module secret:', error);
                secretModeModule = null;
            }
        }

        // ========== MODULE OBJETS KAWAII - INITIALISATION ==========
        // Les objets kawaii sont maintenant gérés uniquement par le module secret DOM
        // Plus besoin d'initialisation séparée

        // ========== MODULE OBJETS KAWAII - SUPPRIMÉ ==========
        // Les objets kawaii sont maintenant gérés uniquement par le module secret
        function activerObjetsKawaii() {
            console.log('💕 Objets kawaii réservés au mode secret uniquement');
        }

        function desactiverObjetsKawaii() {
            console.log('💕 Objets kawaii réservés au mode secret uniquement');
        }

        function configurerObjetsKawaii(config) {
            console.log('💕 Objets kawaii réservés au mode secret uniquement');
        }

        // ========== MODULE OISEAUX CSS - GESTIONNAIRE ÉVÉNEMENTS ==========
        function setupBirdClickHandlers() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            // Clic sur le corbeau
            crowElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Empêcher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'corbeau') {
                    handleBirdClick();
                }
            });

            // Clic sur la colombe
            doveElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Empêcher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'colombe') {
                    handleBirdClick();
                }
            });
        }

        function handleBirdClick() {
            corbeau.touches++;
            score += 100; // Points bonus pour toucher l'oiseau

            // Effet visuel
            ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

            if (corbeau.touches >= 3 && corbeau.type === 'corbeau') {
                // Transformer en colombe !
                corbeau.type = 'colombe';
                score += 1000; // Gros bonus pour la transformation

                // Débloquer le niveau secret !
                niveauSecretDebloque = true;

                afficherMessagePowerupSimple('🕊️ Miracle! +1000 pts - Niveau secret débloqué!');

                // Le soleil fait un clin d'œil
                soleil.clignotement = true;
                soleil.tempsClignotement = Date.now();

                // Déclencher le niveau secret après un délai
                setTimeout(() => {
                    if (secretModeModule) {
                        secretModeModule.activate();
                    } else {
                        console.error('Module secret non initialisé !');
                        lancerNiveauSecret(); // Fallback vers l'ancien système
                    }
                }, 4000);
            } else {
                // Message discret en bas à droite
                afficherMessageCorbeauBas(`🎯 ${corbeau.touches}/3 💰 +100`, 1000);
            }
        }

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas à droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu) return;

            // Initialiser le temps de départ si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire apparaître le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;

                // Alterner la direction à chaque passage
                if(corbeau.direction === 1) {
                    // Gauche vers droite
                    corbeau.x = -100;
                    corbeau.vx = 0.8 / 1.5;
                } else {
                    // Droite vers gauche
                    corbeau.x = C.W + 100;
                    corbeau.vx = -(0.8 / 1.5);
                }

                corbeau.y = C.H * 0.4; // Vers le milieu de l'écran
                corbeau.touches = 0; // Réinitialiser le compteur de touches

                // Alterner pour le prochain passage
                corbeau.direction *= -1;

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;

                console.log(`🐦 Corbeau spawn - Direction: ${corbeau.vx > 0 ? 'droite →' : '← gauche'}`);
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                corbeau.y += Math.sin(Date.now() * 0.0005) * 0.25; // Mouvement ondulant très doux et petit

                // Retirer le corbeau s'il sort de l'écran (dans les deux directions)
                if((corbeau.vx > 0 && corbeau.x > C.W + 100) || (corbeau.vx < 0 && corbeau.x < -100)) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        // ========== MODULE OISEAUX CSS - FONCTION MODIFIÉE ==========
        function dessinerCorbeau() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            if (!corbeau.actif) {
                // Masquer tous les oiseaux
                crowElement.classList.remove('bird-visible');
                crowElement.classList.add('bird-hidden');
                doveElement.classList.remove('bird-visible');
                doveElement.classList.add('bird-hidden');
                return;
            }

            // Positionner l'oiseau selon les coordonnées
            const activeElement = corbeau.type === 'corbeau' ? crowElement : doveElement;
            const inactiveElement = corbeau.type === 'corbeau' ? doveElement : crowElement;

            // Masquer l'oiseau inactif
            inactiveElement.classList.remove('bird-visible');
            inactiveElement.classList.add('bird-hidden');

            // Positionner et afficher l'oiseau actif
            activeElement.style.left = corbeau.x + 'px';
            activeElement.style.top = corbeau.y + 'px';

            // Orienter l'oiseau selon sa direction avec l'animation appropriée
            if (corbeau.vx < 0) {
                // Va vers la gauche - utiliser animation retournée
                activeElement.style.animation = 'crow-auto-flight-left calc(2s / var(--animation-speed)) infinite';
                console.log('🐦 Corbeau orienté GAUCHE ← (animation crow-auto-flight-left)');
            } else {
                // Va vers la droite - animation normale
                activeElement.style.animation = 'crow-auto-flight calc(2s / var(--animation-speed)) infinite';
                console.log('🐦 Corbeau orienté DROITE → (animation crow-auto-flight)');
            }

            activeElement.classList.remove('bird-hidden');
            activeElement.classList.add('bird-visible');
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y) {
            textesVolants.push({
                texte: texte,
                x: x,
                y: y,
                xDepart: x,
                yDepart: y,
                vy: 0, // Vitesse calculée dynamiquement
                taille: 12, // Taille initiale
                alpha: 1, // Opacité
                temps: 0,
                phase: 'descente' // 'descente' puis 'montee'
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.004; // Progression plus lente

                // Mouvement vers le centre horizontal
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Progression plus lente vers le centre
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis montée
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 200); // Descend plus bas (200px max)

                    // Fondu pendant la descente
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Fondu plus marqué

                    // Passer à la phase montée après plus de temps
                    if(texte.temps > 0.2) {
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 120); // Remonte moins vite

                    // Fondu retour pendant la montée
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 3);
                }

                // Grossissement très progressif et doux
                texte.taille = 12 + texte.temps * 20;

                // Disparition finale très progressive
                if(texte.temps > 0.6) {
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.6) * 2);
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu
        function boucleJeu() {
            // Gérer l'animation du bateau
            gererAnimationBateau();

            // Gérer la phase d'introduction
            gererPhaseIntro();

            // Phase bonus - Le Mur dans la Mer
            if (phaseJeu === 'bonus_mur' && window.phaseBonusMur) {
                window.phaseBonusMur.update();
            } else if(jeu || phaseIntro.active) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Système projectiles stars
                    mettreAJourProjectiles(); // Nouveau système de projectiles
                    mettreAJourBulle(); // Ancien système pour les autres phases
                }
                mettreAJourParticules();

                // Mise à jour du module de drones
                if (droneModule) {
                    droneModule.animate();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                mettreAJourPetitsCoeurs();
                mettreAJourTextesVolants();
                mettreAJourCorbeau(); // Gestion du corbeau secret
                mettreAJourMessageCorbeauBas(); // Messages discrets du corbeau

                // Obstacles gérés par le module secret seulement

                // Objets kawaii réservés au mode secret uniquement
                // (Les objets kawaii sont maintenant dans le module secret)
                // Mode secret - utiliser le module
                if (secretModeModule && secretModeModule.isActive) {
                    secretModeModule.update();
                } else if (modeSecret) {
                    // Fallback si le module n'est pas disponible
                    mettreAJourProjectilesSecret();
                }
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }

        // Démarrage avec intro forcée
        initJeu();

        // FORCER l'intro après initJeu (car initJeu peut modifier ces valeurs)
        phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        jeu = false; // Important: forcer jeu = false pour permettre l'intro

        // 🎯 AFFICHAGE IMMÉDIAT DE L'INTRO (solution radicale)
        console.log('🚀 FORÇAGE IMMÉDIAT DE L\'INTRO');
        setTimeout(() => {
            // 🎯 ACTIVER LE TITRE DANS LE CANVAS
            titreVoyage.active = true;
            titreVoyage.texte = 'L\'aube des doutes\nPhase 1';
            titreVoyage.fin = Date.now() + 30000; // Affiché pendant 30 secondes


            // Affichage direct de l'intro Phase 1 avec bouton passer
            // Utiliser notre système simple
            afficherMessageNarratifSimple(`"On m'a dit qu'ils étaient tous des monstres...
On m'a dit tant de mal, tant de malheurs sur eux...
Mais moi, j'ai préféré aller voir de mes propres yeux."`, 12000);

            // Activer le bouton passer pendant l'intro
            boutonPasser.actif = true;

            // Désactiver le bouton après l'intro
            setTimeout(() => {
                boutonPasser.actif = false;
            }, 15000);

            // Code bouton supprimé pour simplicité
            /*afficherMessage(`
                <div style="font-size: 22px; color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); line-height: 1.4;">
                    🌟 "On m'a dit qu'ils étaient tous des monstres...
                    <br>✨ On m'a dit tant de mal, tant de malheurs sur eux...
                    <br>🔍 Mais moi, j'ai préféré aller voir de mes propres yeux."
                </div>

                CODE BOUTON COMPLEXE SUPPRIMÉ POUR SIMPLICITÉ
            */

            // 🎯 AFFICHER LE MESSAGE "NON ON PEUT PAS LAISSER PASSER ÇA" À LA FIN
            setTimeout(() => {
                afficherMessageNarratifSimple('NON on peut pas laisser passer ça !', 3000);
            }, 12000); // À la fin de l'intro (12 secondes)

            // 🎯 DÉCLENCHER LA RÉCOMPENSE 100 POINTS APRÈS LE MESSAGE
            setTimeout(() => {
                console.log('🌟 Fin de l\'intro - Attribution 100 Points');

                try {
                    if (phaseJeu === 'tir_coeurs_haut') {
                        console.log('pointsConnaissance avant bonus intro:', pointsConnaissance);
                        pointsConnaissance += 100;
                        console.log('pointsConnaissance après bonus intro:', pointsConnaissance);
                    } else {
                        console.log('Score avant bonus intro:', score);
                        score += 100;
                        console.log('Score après bonus intro:', score);
                    }

                    // Message simple
                    afficherMessagePowerupSimple('🌟 +100 Points intro complète');
                } catch (error) {
                    console.error('❌ Erreur lors de l\'attribution points intro:', error);
                }
            }, 15000); // Déclencher après le message NON (12000ms + 3000ms)

        }, 500); // Attendre 0.5 seconde pour être sûr que l'interface est prête

        // === RACCOURCI TEST MENU ===
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                e.preventDefault();
                narrationManager.showFinalMenu();
            }
        });

        // === ANCIEN SYSTÈME NARRATION SUPPRIMÉ ===
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let phaseAvantSecret = null; // Sauvegarder la phase avant le mode secret
        let modeEtoileLance = false; // Pour tracker si on est en mode étoile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        // anciens messages supprimés

        // Fonction supprimée

        // Fonctions supprimées

        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer à la phase suivante (désactivé)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprimée pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Mode passe : Touche S pour niveau secret
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Mode passe : Touche R pour réduire la vie des briques à 1
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                reduireVieBriques();
            }

            // Mode passe : Touche E pour tir automatique étoiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

            // Cheat code : Touche X pour multiplier puissance x10
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                if (multiplicateurPuissance === 1) {
                    multiplicateurPuissance = 10;
                    console.log('🚀 CHEAT ACTIVÉ: Puissance x10!');
                } else {
                    multiplicateurPuissance = 1;
                    console.log('🔄 CHEAT DÉSACTIVÉ: Puissance normale');
                }
            }

        });

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            // Désactiver les objets kawaii pendant le mode secret
            desactiverObjetsKawaii();

            // Utiliser le module si disponible, sinon le système intégré
            if (secretModeModule) {
                secretModeModule.activate();
                return;
            }

            // Fallback vers l'ancien système
            // Sauvegarder la phase actuelle
            phaseAvantSecret = phaseJeu;

            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = []; // Réinitialiser les obstacles pour le fallback

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Mode secret utilise maintenant le module secret - pas d'obstacles de fallback

            afficherMessageAnime('🎯 NIVEAU SECRET : TIR DE PRÉCISION ! 🎯\n\n🧊 Tirez sur les icebergs et poubelles ! ♻\n🐋 ATTENTION : Les baleines sont protégées !\n🚫 Tirer sur une baleine = "NO GREAT!" et perte de vie\n👆 Chaque clic = un tir précis\n💰 +100 points par obstacle détruit !', 5000, 'glitch', 50);
        }



        function creerProjectile() {
            // Créer un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // Vérifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle déjà touché

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision détectée !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine protégée ! Perdre une vie
                            vies--;

                            // Messages amusants variés
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                // Restaurer la phase d'origine même en Game Over
                                if (phaseAvantSecret) {
                                    phaseJeu = phaseAvantSecret;
                                    phaseAvantSecret = null;
                                } else {
                                    phaseJeu = 'briques'; // Fallback par défaut
                                }

                                // Réactiver les objets kawaii après Game Over
                                activerObjetsKawaii();

                                afficherMessageAvecBoutons(`💀 ${messageAleatoire} 💀\n\n🐋 Tu as tiré sur une baleine protégée !\n😱 Toutes tes vies sont épuisées !\n🚫 Les baleines ne se tirent pas !\n🤪 HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 Les baleines sont protégées !\n💔 Vie perdue : ${vies} restantes\n😤 Tire seulement sur les icebergs !\n🙄 TSSS TSSS!`,
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 BALEINE = INTERDITE !\n💔 Oups : ${vies} vies restantes\n😤 ICEBERGS SEULEMENT !\n🤦‍♂️ PFFFFFF!`,
                                    `🚫 ${messageAleatoire} 🚫\n\n🐋 PAUVRE BALEINE !\n💔 Punition : ${vies} vies left\n😤 GLACE = OK, BALEINE = NON !\n😂 HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (colère)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK à détruire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle détruit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succès)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touché temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // SUPPRIMÉ: creerObstaclesMarins() - remplacé par le module secret

        // SUPPRIMÉ: mettreAJourObstacles() - remplacé par le module secret

        // SUPPRIMÉ: Module obstacles legacy - remplacé par le module secret

        // SUPPRIMÉ: dessinerObstacles() - remplacé par le module secret

        // L'animation démarre automatiquement via gererAnimationBateau()
        window.addEventListener('load', function() {
            console.log('🎮 Window load - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
            console.log('🎮 Window load - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');

            // Attente plus longue pour s'assurer que tous les scripts sont chargés
            setTimeout(() => {
                console.log('🎮 Démarrage du jeu - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
                console.log('🎮 Démarrage du jeu - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');
                boucleJeu();
            }, 500);
        });
    </script>


</body></html>