<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üëÅÔ∏è Voir la V√©rit√© üëÅÔ∏è</title>
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            touch-action: none; user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 25%, #f1f3f4 75%, #e9ecef 100%);
            min-height: 100vh; width: 100%; margin: 0; padding: 0;
            display: flex; align-items: center; justify-content: center;
            color: #2c3e50; overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 30%, #ffffff 70%, #f1f3f4 100%);
            border: none; border-radius: 0;
            image-rendering: crisp-edges; image-rendering: pixelated;
        }

        .message {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            background: transparent;
            backdrop-filter: none; -webkit-backdrop-filter: none;
            border: none;
            border-radius: 0; padding: 25px 113px;
            box-shadow: none;
            max-width: none; width: 100%; text-align: center; z-index: 200;
            display: none; font-size: clamp(21px, 5.25vw, 24px); color: #ffffff;
            line-height: 1.4; box-sizing: border-box; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 4px 4px 8px rgba(0,0,0,0.6);
        }

        .message.show {
            display: block;
        }

        /* Messages narratifs - style cin√©matique */
        .message.narratif {
            bottom: 80px; top: auto; left: 50%; transform: translateX(-50%);
            width: calc(100% - 40px); max-width: none;
            background: transparent;
            border: none;
            border-radius: 15px; padding: 20px 25px;
            color: #ffffff; font-size: clamp(13px, 3vw, 15px);
            text-align: left; line-height: 1.5;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 4px 4px 8px rgba(0,0,0,0.6);
        }

        /* Adaptations pour PC */
        @media (min-width: 500px) {
            .message {
                max-width: none; width: 100%;
                font-size: clamp(21px, 2.7vw, 24px);
                padding: 20px 113px;
            }

            .message.narratif {
                max-width: 380px; width: auto;
                font-size: 14px; padding: 18px 22px;
            }
        }

        .message-button {
            background: linear-gradient(145deg, #4f46e5, #7c3aed);
            border: none; border-radius: 18px; padding: 15px 30px; margin-top: 25px;
            color: white; font-size: clamp(16px, 4vw, 18px); font-weight: 700; cursor: pointer;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.4);
            transition: all 0.3s ease; display: inline-block;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            letter-spacing: 0.5px;
        }

        .message-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(79, 70, 229, 0.5);
            background: linear-gradient(145deg, #6366f1, #8b5cf6);
        }

        .message-button:active {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.4);
        }

        @media (min-width: 500px) {
            .message-button {
                font-size: 16px;
                padding: 12px 25px;
            }
        }

        .message.show {
            display: block; animation: messageIn 0.4s ease-out;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes crystal-pulse {
            0% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(0,26,62,0.9), inset 0 3px 6px rgba(255,255,255,0.4), inset 0 -3px 6px rgba(0,0,0,0.7), 0 0 40px rgba(0,102,204,0.8);
                background: linear-gradient(135deg, #002a5c 0%, #003d82 25%, #0056b3 50%, #003d82 75%, #002a5c 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(0,26,62,0.7), inset 0 2px 4px rgba(255,255,255,0.3), inset 0 -2px 4px rgba(0,0,0,0.6), 0 0 30px rgba(0,102,204,0.5);
                background: linear-gradient(135deg, #001a3e 0%, #002a5c 25%, #003d82 50%, #002a5c 75%, #001a3e 100%);
            }
        }

        @keyframes crystal-pulse-light {
            0% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
            50% {
                box-shadow: 0 8px 25px rgba(77,166,255,0.9), inset 0 3px 6px rgba(255,255,255,0.7), inset 0 -3px 6px rgba(0,0,0,0.4), 0 0 40px rgba(128,193,255,0.9);
                background: linear-gradient(135deg, #66b3ff 0%, #80c1ff 25%, #99ccff 50%, #80c1ff 75%, #66b3ff 100%);
            }
            100% {
                box-shadow: 0 6px 20px rgba(77,166,255,0.7), inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(128,193,255,0.6);
                background: linear-gradient(135deg, #4da6ff 0%, #66b3ff 25%, #80c1ff 50%, #66b3ff 75%, #4da6ff 100%);
            }
        }

        /* Indicateur d'√©tape */
        .etape-indicateur {
            display: none !important;
        }

        .etape-indicateur.show {
            display: block;
        }

        /* Animation shake pour le bouton skip */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes etapeGlow {
            0% {
                box-shadow:
                    0 4px 15px rgba(0,0,0,0.3),
                    0 0 20px rgba(77,166,255,0.2),
                    inset 0 1px 1px rgba(255,255,255,0.1);
            }
            100% {
                box-shadow:
                    0 4px 20px rgba(0,0,0,0.4),
                    0 0 30px rgba(77,166,255,0.5),
                    inset 0 1px 1px rgba(255,255,255,0.2);
            }
        }

        /* Mode PC - Ratio fixe portrait 9:16 */
        @media (min-width: 500px) {
            .game-container {
                width: 450px; height: 800px;
                margin: 0 auto; border-radius: 20px; overflow: hidden;
                box-shadow: 0 0 40px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* üé¨ STYLES TEXTANIMATOR OPTIMIS√â */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .text-animator-display {
            font-size: 1.2em;
            line-height: 1.6;
            background: transparent;
        }

        /* Animations de base */
        .ta-typewriter { border-right: 2px solid #ffffff; animation: ta-blink 1s infinite; }
        .ta-digital { color: #00cc44; text-shadow: 0 0 8px #00cc44; font-family: 'Courier New', monospace; letter-spacing: 2px; }
        .ta-fade-in { animation: ta-fadeIn 1s ease-in; }
        .ta-glitch { position: relative; color: #fff; animation: ta-glitch 2s infinite; }

        /* Effets 3D optimis√©s */
        .ta-effect-shadow3d { text-shadow: 2px 2px 0px var(--ta-effect-color, #64ffda), 4px 4px 0px rgba(0,0,0,0.5), 6px 6px 10px rgba(0,0,0,0.8); }
        .ta-effect-neon { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda), 0 0 80px var(--ta-effect-color, #64ffda); animation: ta-neonPulse 2s ease-in-out infinite alternate; }

        /* PAUSE DES ANIMATIONS CSS POUR LE MENU LANGUE */
        .game-paused * {
            animation-play-state: paused !important;
        }
        .ta-effect-emboss { text-shadow: 1px 1px 0px var(--ta-effect-color, #64ffda), -1px -1px 0px rgba(0,0,0,0.8), 2px 2px 5px rgba(0,0,0,0.6); color: var(--ta-text-color, #fff); }
        .ta-effect-outline { text-shadow: -2px -2px 0 var(--ta-effect-color, #64ffda), 2px -2px 0 var(--ta-effect-color, #64ffda), -2px 2px 0 var(--ta-effect-color, #64ffda), 2px 2px 0 var(--ta-effect-color, #64ffda), 0 0 10px rgba(0,0,0,0.5); }
        .ta-effect-fire { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; animation: ta-fireFlicker 1.5s ease-in-out infinite alternate; }
        .ta-effect-ice { background: linear-gradient(45deg, #87ceeb, #add8e6, #e0ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); animation: ta-iceShimmer 3s ease-in-out infinite; }

        /* Keyframes optimis√©es */
        @keyframes ta-blink { 0%, 50% { border-color: transparent; } 51%, 100% { border-color: #ffffff; } }
        @keyframes ta-fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes ta-glitch { 0%, 100% { text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000; transform: translate(0); } 20% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; transform: translate(-2px, 2px); } 40% { text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff; transform: translate(-2px, -2px); } 60% { text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; transform: translate(2px, 2px); } 80% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff; transform: translate(2px, -2px); } }
        @keyframes ta-neonPulse { from { text-shadow: 0 0 5px var(--ta-text-color, #fff), 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-effect-color, #64ffda), 0 0 40px var(--ta-effect-color, #64ffda); } to { text-shadow: 0 0 10px var(--ta-text-color, #fff), 0 0 20px var(--ta-text-color, #fff), 0 0 30px var(--ta-effect-color, #64ffda), 0 0 60px var(--ta-effect-color, #64ffda), 0 0 100px var(--ta-effect-color, #64ffda); } }
        @keyframes ta-fireFlicker { 0%, 100% { text-shadow: 0 0 10px #ff4500, 0 0 20px #ff8c00, 0 0 30px #ffd700; } 50% { text-shadow: 0 0 5px #ff4500, 0 0 15px #ff8c00, 0 0 25px #ffd700, 0 0 35px #ff4500; } }
        @keyframes ta-iceShimmer { 0%, 100% { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); } 50% { text-shadow: 1px 1px 3px rgba(0,0,0,1); } }
        /* ===========================================
           MODULE OISEAUX VOLANTS - INT√âGRATION
           Par Emmanuel Payet / Dreamer Unisona
           ========================================== */

        /* Variables CSS pour le module oiseaux */
        :root {
            --bird-scale: 1;
            --animation-speed: 1;
            --crow-color: #1A1A1A;
            --dove-color: #FFFFFF;
            --bat-color: #000000;
        }

        /* Container pour oiseaux sur canvas */
        .flying-birds-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 150;
        }

        /* Base commune pour tous les oiseaux */
        .bird-base {
            position: absolute;
            transform-origin: center;
            pointer-events: auto;
            transition: all 0.3s ease;
            transform: scale(var(--bird-scale));
            cursor: pointer;
        }

        /* √âtats de visibilit√© */
        .bird-hidden {
            opacity: 0;
            transform: scale(0) scale(var(--bird-scale));
        }


        .bird-visible {
            opacity: 1;
            transform: scale(1) scale(var(--bird-scale));
        }

        /* CORBEAU BADASS - ID: crow */
        #crow {
            width: 45px;
            height: 30px;
            background: linear-gradient(135deg, var(--crow-color), #000000);
            clip-path: polygon(10% 15%, 25% 0%, 75% 5%, 90% 25%, 95% 60%, 85% 90%, 15% 95%, 5% 70%);
            animation: crow-auto-flight calc(2s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
        }

        /* Aile du corbeau */
        #crow::before {
            content: '';
            position: absolute;
            width: 28px;
            height: 18px;
            background: linear-gradient(45deg, #4A4A4A, #2F2F2F, #1A1A1A);
            clip-path: polygon(0% 20%, 30% 0%, 70% 5%, 100% 30%, 90% 70%, 60% 100%, 20% 85%, 5% 50%);
            top: 5px;
            left: 2px;
            z-index: -1;
            animation: crow-wing-beat calc(0.15s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        /* ≈íil rouge du corbeau */
        #crow::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 5px;
            background: linear-gradient(135deg, #FF0000, #8B0000);
            clip-path: polygon(0% 40%, 30% 0%, 100% 20%, 80% 100%, 20% 80%);
            top: 9px;
            right: 8px;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
            animation: crow-evil-glow calc(1.5s / var(--animation-speed)) infinite;
        }

        /* COLOMBE √âL√âGANTE - ID: dove */
        #dove {
            width: 40px;
            height: 25px;
            background: linear-gradient(135deg, var(--dove-color), #F8F8FF, #E6E6FA);
            clip-path: polygon(15% 10%, 40% 0%, 85% 8%, 95% 35%, 90% 65%, 75% 90%, 25% 95%, 5% 60%, 10% 30%);
            animation: dove-auto-flight calc(3s / var(--animation-speed)) infinite;
            filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.15));
        }

        /* Aile de la colombe */
        #dove::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 12px;
            background: linear-gradient(45deg, #F8F8FF, #E6E6FA, #D6D6EA);
            clip-path: polygon(0% 30%, 25% 0%, 60% 5%, 85% 15%, 100% 40%, 95% 70%, 75% 100%, 40% 95%, 15% 85%, 5% 60%);
            top: 6px;
            left: 6px;
            z-index: -1;
            animation: dove-wing-beat calc(0.4s / var(--animation-speed)) infinite alternate;
            filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.2));
        }

        /* ≈íil bleu de la colombe */
        #dove::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle at 30% 30%, #87CEEB, #4169E1);
            clip-path: polygon(25% 0%, 75% 0%, 100% 25%, 100% 75%, 75% 100%, 25% 100%, 0% 75%, 0% 25%);
            top: 8px;
            right: 8px;
            box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
            animation: dove-sparkle calc(3s / var(--animation-speed)) infinite;
        }

        /* ANIMATIONS DU MODULE */
        @keyframes crow-auto-flight {
            0%, 100% {
                transform: translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: translateY(-15px) rotate(2deg) scale(var(--bird-scale));
            }
            50% {
                transform: translateY(-8px) rotate(-1deg) scale(var(--bird-scale));
            }
            75% {
                transform: translateY(-20px) rotate(1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-auto-flight-left {
            0%, 100% {
                transform: scaleX(-1) translateY(0px) rotate(0deg) scale(var(--bird-scale));
            }
            25% {
                transform: scaleX(-1) translateY(-15px) rotate(-2deg) scale(var(--bird-scale));
            }
            50% {
                transform: scaleX(-1) translateY(-8px) rotate(1deg) scale(var(--bird-scale));
            }
            75% {
                transform: scaleX(-1) translateY(-20px) rotate(-1deg) scale(var(--bird-scale));
            }
        }

        @keyframes crow-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-15deg) scaleX(1);
            }
            100% {
                transform: rotateY(-20deg) rotateZ(10deg) scaleX(1.1);
            }
        }

        @keyframes crow-evil-glow {
            0%, 100% {
                box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 0, 0, 1);
                filter: brightness(1.3);
            }
        }

        @keyframes dove-auto-flight {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(var(--bird-scale));
            }
            33% {
                transform: translateY(-12px) translateX(2px) scale(var(--bird-scale));
            }
            66% {
                transform: translateY(-8px) translateX(-1px) scale(var(--bird-scale));
            }
        }

        @keyframes dove-wing-beat {
            0% {
                transform: rotateY(0deg) rotateZ(-8deg) translateX(0px);
            }
            100% {
                transform: rotateY(-12deg) rotateZ(5deg) translateX(1px);
            }
        }

        @keyframes dove-sparkle {
            0%, 100% {
                box-shadow: 0 0 4px rgba(65, 105, 225, 0.4);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 8px rgba(135, 206, 235, 0.8);
                filter: brightness(1.2);
            }
        }

    </style>
<style id="kawaii-objects-styles">
/* ===============================
   OBJETS KAWAII - STYLES DE BASE
   =============================== */

.kawaii-object {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid #FF69B4;
    box-shadow: 0 4px 15px rgba(255,105,180,0.3);
    border-radius: 15px;
    background: transparent; /* FOND TRANSPARENT */
}

.kawaii-object:hover {
    transform: scale(1.15) rotate(-5deg);
    box-shadow: 0 8px 25px rgba(255,105,180,0.5);
    filter: brightness(1.1);
}

/* EXPLOSION KAWAII */
.explode {
    animation: explodeKawaii 0.6s ease-out forwards !important;
}

@keyframes explodeKawaii {
    0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1); }
    25% { transform: scale(1.3) rotate(10deg); opacity: 0.9; filter: brightness(1.3); }
    50% { transform: scale(1.8) rotate(-5deg); opacity: 0.7; filter: brightness(1.6); }
    100% { transform: scale(2.5) rotate(15deg); opacity: 0; filter: brightness(2); }
}

/* ===============================
   BALEINE KAWAII (ID: baleine)
   =============================== */

.obj-baleine {
    width: 60px;
    height: 70px;
    background: linear-gradient(180deg, #4FC3F7 0%, #4FC3F7 40%, #87CEEB 60%, #87CEEB 100%);
    border-radius: 8px 8px 30px 30px;
}

.obj-baleine::before {
    content: '';
    position: absolute;
    bottom: 15px;
    left: 18px;
    width: 8px;
    height: 8px;
    background: #000;
    border-radius: 50%;
    box-shadow: 
        0 0 0 2px #FFF,
        12px 0 0 -6px #000,
        12px 0 0 -4px #FFF,
        -5px 8px 0 -4px #FFB3BA,
        17px 8px 0 -4px #FFB3BA,
        6px 6px 0 -6px #FF69B4;
}

.obj-baleine::after {
    content: '';
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 25px solid #4FC3F7;
}

.baleine-nageoire-gauche {
    position: absolute;
    top: 15px;
    left: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 15px 0 0 15px;
    transform: rotate(45deg);
    animation: nageoireGauche 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

.baleine-nageoire-droite {
    position: absolute;
    top: 15px;
    right: -20px;
    width: 25px;
    height: 8px;
    background: linear-gradient(135deg, #87CEEB 0%, #4FC3F7 100%);
    border: 2px solid #FF69B4;
    border-radius: 0 15px 15px 0;
    transform: rotate(-45deg);
    animation: nageoireDroite 1.5s ease-in-out infinite;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
}

@keyframes nageoireGauche {
    0%, 100% { transform: rotate(45deg) translateY(0px); }
    25% { transform: rotate(55deg) translateY(-4px); }
    50% { transform: rotate(45deg) translateY(0px); }
    75% { transform: rotate(35deg) translateY(2px); }
}

@keyframes nageoireDroite {
    0%, 100% { transform: rotate(-45deg) translateY(0px); }
    25% { transform: rotate(-55deg) translateY(-4px); }
    50% { transform: rotate(-45deg) translateY(0px); }
    75% { transform: rotate(-35deg) translateY(2px); }
}

@keyframes heartFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.7; }
    50% { transform: translateY(-8px) rotate(10deg); opacity: 1; }
}

/* ===============================
   AST√âRO√èDE KAWAII (ID: asteroide)
   =============================== */

.obj-asteroide {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #654321 0%, #8B4513 30%, #A0522D 60%, #654321 100%);
    border-radius: 50%;
    position: relative;
    animation: asteroidFloat 3s ease-in-out infinite;
}

.obj-asteroide::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    box-shadow:
        /* Morceaux d√©tach√©s autour */
        -15px -10px 0 -20px #654321,
        20px -5px 0 -22px #8B4513,
        -8px 18px 0 -25px #A0522D,
        15px 15px 0 -23px #654321,
        /* Crat√®res sur la surface */
        inset -8px -8px 0 -15px rgba(0,0,0,0.4),
        inset 10px -5px 0 -18px rgba(0,0,0,0.3),
        inset -5px 12px 0 -20px rgba(0,0,0,0.2);
}

.obj-asteroide::after {
    content: '';
    position: absolute;
    top: -30px;
    left: 50%;
    width: 3px;
    height: 25px;
    background: linear-gradient(180deg, transparent 0%, #FFA500 30%, #FF6500 70%, transparent 100%);
    transform: translateX(-50%) skewY(-20deg);
    animation: trailingEffect 2s ease-in-out infinite;
}

@keyframes asteroidFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-3px) rotate(5deg); }
}

@keyframes trailingEffect {
    0% { opacity: 0.8; transform: translateX(-50%) skewY(-20deg) scaleY(1); }
    50% { opacity: 1; transform: translateX(-50%) skewY(-15deg) scaleY(1.2); }
    100% { opacity: 0.6; transform: translateX(-50%) skewY(-25deg) scaleY(0.8); }
}

/* ===============================
   √âTOILE KAWAII (ID: etoile)
   =============================== */

.obj-etoile {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #FFEE58 0%, #FFD54F 100%);
    border-radius: 50%;
}

.obj-etoile::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 6px;
    height: 3px;
    background: #000;
    border-radius: 3px 3px 0 0;
    box-shadow: 
        10px 0 0 #000,
        3px 8px 0 -4px #FF6B6B,
        1px 10px 0 -5px #000,
        7px 10px 0 -5px #000,
        -8px 6px 0 -2px #FFCDD2,
        18px 6px 0 -2px #FFCDD2;
}

.obj-etoile::after {
    content: '‚ú®';
    position: absolute;
    top: -10px;
    left: -8px;
    font-size: 16px;
    animation: sparkleKawaii 1.5s ease-in-out infinite;
}

@keyframes sparkleKawaii {
    0%, 100% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.1); }
}

/* ===============================
   TANK KAWAII (ID: tank)
   =============================== */

.obj-tank {
    width: 75px;
    height: 40px;
    background: linear-gradient(135deg, #2E7D32 0%, #4CAF50 50%, #388E3C 100%);
    border-radius: 8px 8px 3px 3px;
    border: 3px solid #1B5E20;
    position: relative;
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.3),
        inset 0 -3px 6px rgba(0,0,0,0.3),
        0 4px 12px rgba(0,0,0,0.4);
    animation: tankRumble 3s ease-in-out infinite;
}

/* Yeux s√©rieux et d√©termin√©s */
.obj-tank::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 25px;
    width: 6px;
    height: 6px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        14px 0 0 -2px #FFF,
        14px 0 0 0 #000,
        /* Petites pupilles noires mignonnes */
        1px 1px 0 -3px #000,
        15px 1px 0 -3px #000,
        /* Petits reflets blancs kawaii */
        -1px -1px 0 -4px #FFF,
        13px -1px 0 -4px #FFF,
        /* Sourcils s√©rieux plus marqu√©s */
        -3px -5px 0 -2px #1B5E20,
        17px -5px 0 -2px #1B5E20,
        /* Bouche souriante kawaii */
        7px 8px 0 -3px #FF69B4,
        4px 10px 0 -4px #FF69B4,
        10px 10px 0 -4px #FF69B4,
        /* Casque militaire */
        -5px -8px 0 -1px #795548,
        19px -8px 0 -1px #795548,
        /* Joues roses kawaii */
        -8px 2px 0 -2px #FFB6C1,
        22px 2px 0 -2px #FFB6C1;
}

/* Canon principal plus imposant */
.obj-tank::after {
    content: '';
    position: absolute;
    bottom: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 10px;
    height: 15px;
    background: linear-gradient(180deg, #263238 0%, #37474F 50%, #263238 100%);
    border: 2px solid #000;
    border-radius: 4px;
    box-shadow:
        0 -6px 0 -3px #FFD54F,
        inset 0 2px 4px rgba(255,255,255,0.2),
        0 0 8px rgba(0,0,0,0.5),
        /* Tourelle ronde au bout du canon */
        0 20px 0 -2px #37474F,      /* Tourelle gris fonc√© */
        0 20px 0 0px #000,          /* Contour noir */
        /* Mini yeux kawaii espac√©s */
        -3px 22px 0 -5px #FFF,      /* ≈íil gauche blanc */
        3px 22px 0 -5px #FFF,       /* ≈íil droit blanc */
        -2px 23px 0 -6px #000,      /* Pupille gauche */
        4px 23px 0 -6px #000;       /* Pupille droite */
}

@keyframes tankRumble {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-1px); }
    75% { transform: translateX(1px); }
}

@keyframes nervousEyes {
    0% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -4px 32px 0 -5px #FF0000,
            4px 32px 0 -5px #FF0000;
    }
    100% {
        box-shadow:
            0 -6px 0 -3px #FFD54F,
            inset 0 2px 4px rgba(255,255,255,0.2),
            0 0 8px rgba(0,0,0,0.5),
            0 30px 0 -2px #37474F,
            0 30px 0 0px #000,
            -3px 31px 0 -5px #FF0000,
            5px 31px 0 -5px #FF0000;
    }
}

@keyframes tankSmoke {
    0% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            7px -15px 0 -3px #FF8C00,
            5px -18px 0 -4px #FF6500,
            9px -18px 0 -4px #FF6500,
            6px -21px 0 -5px #FF4500,
            8px -21px 0 -5px #FF4500;
    }
    50% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            8px -16px 0 -3px #FF8C00,
            4px -19px 0 -4px #FF6500,
            10px -19px 0 -4px #FF6500,
            5px -22px 0 -5px #FF4500,
            9px -22px 0 -5px #FF4500;
    }
    100% {
        box-shadow:
            0 0 0 2px #000,
            14px 0 0 -2px #FFF,
            14px 0 0 0 #000,
            -3px -5px 0 -2px #1B5E20,
            17px -5px 0 -2px #1B5E20,
            7px 8px 0 -3px #1B5E20,
            -5px -8px 0 -1px #795548,
            19px -8px 0 -1px #795548,
            6px -17px 0 -3px #FF8C00,
            6px -20px 0 -4px #FF6500,
            8px -20px 0 -4px #FF6500,
            7px -23px 0 -5px #FF4500,
            7px -23px 0 -5px #FF4500;
    }
}

/* Syst√®me de chenilles complet */
.obj-tank {
    overflow: visible;
}

/* Rectangles noirs pour les chenilles */
.tank-track {
    position: absolute;
    width: 8px;
    height: 80px;
    background: #000;
    top: -5px;
    border-radius: 2px;
}

.tank-track.center {
    left: 50%;
    transform: translateX(-50%);
}

/* Fum√©e du tank */
.tank-smoke {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 30px;
    pointer-events: none;
}

.tank-smoke::before {
    content: 'üíï';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    animation: smokeAnimation 2s ease-in-out infinite;
}

.tank-smoke::after {
    content: '‚ú®';
    position: absolute;
    top: 3px;
    left: 70%;
    transform: translateX(-50%);
    font-size: 12px;
    animation: fireAnimation 1.5s ease-in-out infinite alternate;
}

@keyframes smokeAnimation {
    0% {
        opacity: 0.6;
        transform: translateX(-50%) scale(0.8) rotate(-5deg);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scale(1.1) rotate(5deg) translateY(-3px);
    }
    100% {
        opacity: 0.7;
        transform: translateX(-50%) scale(0.9) rotate(-3deg) translateY(-1px);
    }
}

@keyframes fireAnimation {
    0% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1);
    }
    100% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
    }
}


/* Anciennes classes tank supprim√©es - tout en CSS box-shadow maintenant */

@keyframes powerPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.2); }
}

/* ===============================
   LUNE KAWAII (ID: lune)
   =============================== */

.obj-lune {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #F8F8FF 0%, #E6E6FA 100%);
    border-radius: 50%;
}

.obj-lune::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 22px;
    width: 8px;
    height: 4px;
    background: #000;
    border-radius: 4px 4px 0 0;
    box-shadow: 
        12px 0 0 #000,
        6px 8px 0 -4px #DDA0DD,
        4px 10px 0 -5px #000,
        8px 10px 0 -5px #000,
        -8px 6px 0 -2px #F8BBD9,
        20px 6px 0 -2px #F8BBD9,
        -15px -8px 0 -3px #E0E0E0,
        25px 15px 0 -3px #E0E0E0;
}

.obj-lune::after {
    content: 'üí§';
    position: absolute;
    top: -15px;
    right: -10px;
    font-size: 12px;
    animation: sleepFloat 2s ease-in-out infinite;
}

@keyframes sleepFloat {
    0%, 100% { transform: translateY(0); opacity: 0.6; }
    50% { transform: translateY(-10px); opacity: 1; }
}

/* ===============================
   AUTRES OBJETS KAWAII
   =============================== */

.obj-banane {
    width: 60px;
    height: 60px;
    position: relative;
    border: 3px solid #FFD700;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,193,7,0.2) 100%);
}

.obj-banane::before {
    content: 'üçå';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-30deg);
    font-size: 35px;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
}

@keyframes bananaGlow {
    0% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.4),
            inset 0 -4px 8px rgba(0,0,0,0.3),
            0 6px 20px rgba(255,193,7,0.4),
            0 0 15px rgba(255,235,59,0.3);
    }
    100% {
        box-shadow:
            inset 0 4px 8px rgba(255,255,255,0.6),
            inset 0 -4px 8px rgba(0,0,0,0.2),
            0 8px 25px rgba(255,193,7,0.6),
            0 0 25px rgba(255,235,59,0.5);
        transform: rotate(-30deg) scale(1.05);
    }
}

/* IPHONE KAWAII üì± */
.obj-smartphone {
    width: 42px;
    height: 70px;
    background: linear-gradient(145deg, #1A1A1A 0%, #000 100%);
    border-radius: 12px;
    border: 1px solid #333;
    position: relative;
    box-shadow:
        0 6px 12px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 0 0 1px rgba(255,255,255,0.05);
}

.obj-smartphone::before {
    content: '';
    position: absolute;
    top: 6px;
    left: 3px;
    width: 34px;
    height: 56px;
    background: linear-gradient(145deg, #0066CC 0%, #004499 100%);
    border-radius: 8px;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.2),
        inset 0 -1px 2px rgba(0,0,0,0.3);
}

.obj-smartphone::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 3px;
    background: #333;
    border-radius: 2px;
    box-shadow: 0 0 0 1px #000;
}

/* POUBELLE KAWAII MIGNONNE üóëÔ∏è */
.obj-poubelle {
    width: 50px;
    height: 60px;
    background: linear-gradient(180deg, #4CAF50 0%, #388E3C 50%, #2E7D32 100%);
    border-radius: 8px 8px 12px 12px;
    border: 2px solid #2E7D32;
    position: relative;
    box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.2),
        0 4px 8px rgba(0,0,0,0.3);
    animation: binHappy 3s ease-in-out infinite;
}

.obj-poubelle::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    width: 8px;
    height: 8px;
    background: #FFF;
    border-radius: 50%;
    box-shadow:
        0 0 0 2px #000,
        12px 0 0 -2px #FFF,
        12px 0 0 0 #000,
        /* Pupilles mignonnes */
        1px 1px 0 -4px #000,
        11px 1px 0 -4px #000,
        /* Joues roses */
        -6px 8px 0 -3px #FFB6C1,
        18px 8px 0 -3px #FFB6C1,
        /* Sourire kawaii */
        6px 15px 0 -4px #FF69B4,
        3px 17px 0 -5px #FF69B4,
        9px 17px 0 -5px #FF69B4;
}

.obj-poubelle::after {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 35px;
    height: 6px;
    background: linear-gradient(90deg, #66BB6A 0%, #4CAF50 50%, #66BB6A 100%);
    border-radius: 3px;
    border: 1px solid #388E3C;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

@keyframes binHappy {
    0%, 100% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.05) rotate(1deg); }
}

/* BOMBARDIER FURTIF B-2 SPIRIT üõ©Ô∏è */
.obj-avion {
    width: 90px;
    height: 70px;
    background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 30%, #2c2c2c 60%, #000000 100%);
    border-radius: 0;
    border: none;
    position: relative;
    transform: rotate(180deg); /* Orient√© vers le bas - nez pointant vers le sol */
    /* Forme en triangle caract√©ristique du B-2 avec ailes diagonales */
    clip-path: polygon(
        50% 0%,      /* Nez pointu */
        15% 35%,     /* Aile gauche diagonale */
        0% 70%,      /* Bout aile gauche */
        30% 85%,     /* Arri√®re gauche */
        50% 100%,    /* Queue centrale */
        70% 85%,     /* Arri√®re droite */
        100% 70%,    /* Bout aile droite */
        85% 35%      /* Aile droite diagonale */
    );
    box-shadow:
        inset 0 3px 6px rgba(255,255,255,0.08),
        inset 0 -3px 6px rgba(0,0,0,0.7),
        0 8px 16px rgba(0,0,0,0.8),
        0 0 20px rgba(0,100,255,0.2);
    animation: stealthFly 4s ease-in-out infinite;
}

.obj-avion::before {
    content: '';
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 6px;
    background: linear-gradient(90deg, transparent, #00ffff 50%, transparent);
    border-radius: 2px;
    opacity: 0.6;
    box-shadow:
        0 0 10px rgba(0,255,255,0.5),
        0 0 20px rgba(0,255,255,0.3);
    animation: stealthLights 2s ease-in-out infinite alternate;
}

.obj-avion::after {
    content: '';
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 3px;
    background: linear-gradient(90deg,
        transparent 0%,
        #ff4500 20%,
        #ff6600 40%,
        #ffaa00 60%,
        #ff4500 80%,
        transparent 100%);
    border-radius: 50%;
    opacity: 0.9;
    box-shadow:
        0 0 8px rgba(255,69,0,0.6),
        0 0 16px rgba(255,102,0,0.4);
    animation: stealthJet 1s ease-in-out infinite;
}

@keyframes stealthFly {
    0%, 100% {
        transform: rotate(180deg) translateY(0);
        filter: brightness(0.8);
    }
    50% {
        transform: rotate(180deg) translateY(-3px) scale(1.02);
        filter: brightness(1.1);
    }
}

@keyframes stealthLights {
    0% {
        opacity: 0.6;
        box-shadow:
            0 0 8px #FF0000,
            8px 15px 0 -2px #FF0000,
            -8px 15px 0 -2px #FF0000;
    }
    100% {
        opacity: 1;
        box-shadow:
            0 0 15px #FF0000,
            8px 15px 0 -2px #FF4444,
            -8px 15px 0 -2px #FF4444,
            0 0 25px rgba(255,0,0,0.8);
    }
}

@keyframes stealthJet {
    0%, 100% {
        opacity: 0.8;
        transform: translateX(-50%) scaleY(1);
    }
    50% {
        opacity: 1;
        transform: translateX(-50%) scaleY(1.3);
    }
}

@keyframes phoneGlow {
    0%, 100% { text-shadow: 0 0 10px #FF69B4; }
    50% { text-shadow: 0 0 20px #FF1493; }
}


/* ===============================
   NOUVELLES ANIMATIONS D√âBRIS ET AVION FURTIF
   =============================== */

@keyframes debrisFloat {
    0%, 100% { transform: translate(0, 0) rotate(0deg); opacity: 0.8; }
    25% { transform: translate(-3px, -5px) rotate(90deg); opacity: 1; }
    50% { transform: translate(5px, -8px) rotate(180deg); opacity: 0.6; }
    75% { transform: translate(-2px, -3px) rotate(270deg); opacity: 1; }
}

@keyframes dustTrail {
    0%, 100% { transform: scale(0.8) rotate(0deg); opacity: 0.5; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 0.9; }
}

@keyframes reactorFlame {
    0%, 100% { transform: scale(0.8); opacity: 0.7; filter: hue-rotate(0deg); }
    50% { transform: scale(1.2); opacity: 1; filter: hue-rotate(60deg); }
}

@keyframes missileGlow {
    0%, 100% { transform: translateX(-50%) scale(0.8); opacity: 0.6; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
}

@keyframes sonicBoom {
    0%, 100% { transform: scale(0.9) translateX(0); opacity: 0.4; }
    50% { transform: scale(1.3) translateX(-5px); opacity: 0.8; }
}

        </style></head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="449" height="799" style="width: 449px; height: 799px;"></canvas>

        <!-- CHARGER LES MODULES AVANT LE SCRIPT PRINCIPAL -->
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20langage%20of_fichiers/kawaii_objects_module.js"></script>
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20langage%20of_fichiers/secret-mode.js"></script>

        <!-- MODULES I18N -->
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20langage%20of_fichiers/i18n.js"></script>
        <script src="%F0%9F%91%81%EF%B8%8F%20Voir%20la%20V%C3%A9rit%C3%A9%20%F0%9F%91%81%EF%B8%8F%20langage%20of_fichiers/language-selector.js"></script>

        <!-- MODULE OISEAUX VOLANTS CSS -->
        <div class="flying-birds-overlay">
            <!-- Corbeau Badass -->
            <div id="crow" class="bird-base bird-hidden" style="left: -99.5333px; top: 221.758px; animation: crow-auto-flight-left calc(2s / var(--animation-speed)) infinite;"></div>

            <!-- Colombe √âl√©gante -->
            <div id="dove" class="bird-base bird-hidden"></div>
        </div>
        <div id="message" class="message" style="transform: translate(-50%, -50%) scale(1); display: none;">üåü +100 Points pour avoir regard√© l'introduction compl√®te ! üåü</div>
        <div id="etapeIndicateur" class="etape-indicateur"></div>

    <div id="kawaii-secret-container" style="position: absolute; top: 110px; left: 0px; width: 100%; height: calc(-110px + 100vh); pointer-events: none; z-index: 30; overflow: visible; background: transparent;"></div></div>

    <!-- √âCRAN DE S√âLECTION DE LANGUE -->
    <div id="language-screen" class="language-screen hidden" style="display: none;">
        <div class="language-content">
            <h1 class="language-title">üåç Choose Your Language</h1>
            <div class="language-options">
                <button class="language-option" data-lang="fr">
                    <span class="flag">üá´üá∑</span>
                    <span class="lang-name">Fran√ßais</span>
                </button>
                <button class="language-option" data-lang="en">
                    <span class="flag">üá¨üáß</span>
                    <span class="lang-name">English</span>
                </button>
                <button class="language-option" data-lang="jp">
                    <span class="flag">üáØüáµ</span>
                    <span class="lang-name">Êó•Êú¨Ë™û</span>
                </button>
                <button class="language-option" data-lang="uk">
                    <span class="flag">üá∫üá¶</span>
                    <span class="lang-name">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</span>
                </button>
            </div>
        </div>
    </div>

    <style>
        .language-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .language-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .language-content {
            text-align: center;
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .language-title {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .language-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 400px;
        }

        .language-option {
            background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05));
            border: 2px solid rgba(100,255,218,0.3);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-height: 80px;
        }

        .language-option:hover {
            transform: translateY(-5px);
            background: linear-gradient(145deg, rgba(100,255,218,0.2), rgba(100,255,218,0.1));
            border-color: rgba(100,255,218,0.6);
            box-shadow: 0 10px 20px rgba(100,255,218,0.2);
        }

        .language-option .flag {
            font-size: 2em;
        }

        .language-option .lang-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
        }
    </style>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Syst√®me de pause globale - D√©fini en premier pour √©viter les erreurs
        window.jeuEnPause = false;
        window.tempsPause = 0;
        window.debutPause = 0;

        // Blocage du jeu pour s√©lection de langue (diff√©rent de la pause)
        window.jeuBloquePourLangue = true; // Bloqu√© jusqu'√† s√©lection de langue

        // ARR√äT TOTAL de tout le syst√®me jusqu'√† s√©lection de langue
        window.systemeArrete = true;

        // Gestion de l'√©cran de s√©lection de langue
        function initLanguageScreen() {
            console.log('üåç Initialisation √©cran langue...');

            const languageScreen = document.getElementById('language-screen');
            const languageOptions = document.querySelectorAll('.language-option');

            console.log('üåç √âcran trouv√©:', !!languageScreen);
            console.log('üåç Options trouv√©es:', languageOptions.length);

            // Bloquer le d√©marrage du jeu jusqu'√† s√©lection
            window.gameCanStart = false;

            languageOptions.forEach((option, index) => {
                console.log(`üåç Ajout listener sur option ${index}:`, option.dataset.lang);

                option.addEventListener('click', async (event) => {
                    console.log('üéØ CLIC D√âTECT√â !');
                    const selectedLang = option.dataset.lang;
                    console.log(`üåç Langue s√©lectionn√©e: ${selectedLang}`);

                    // Masquer l'√©cran de langue avec animation
                    languageScreen.classList.add('hidden');

                    // D√©bloquer le jeu apr√®s animation
                    setTimeout(() => {
                        console.log('üåç D√©marrage du jeu...');

                        // RED√âMARRER TOUT LE SYST√àME
                        window.jeuBloquePourLangue = false;
                        window.gameCanStart = true;
                        window.systemeArrete = false;
                        languageScreen.style.display = 'none';

                        console.log('üîß Variables syst√®me:', {
                            systemeArrete: window.systemeArrete,
                            jeuEnPause: window.jeuEnPause,
                            jeuBloquePourLangue: window.jeuBloquePourLangue
                        });

                        // Changer la langue si possible
                        if (window.i18n) {
                            window.i18n.setLanguage(selectedLang);
                        }

                        // D√©marrer tous les syst√®mes
                        console.log('üöÄ Initialisation du jeu...');

                        // Forcer l'initialisation m√™me si les fonctions n'existent pas encore
                        try {
                            if (typeof initJeu === 'function') {
                                initJeu();
                                console.log('‚úÖ initJeu() appel√©');
                            }
                        } catch(e) { console.log('‚ùå Erreur initJeu:', e); }

                        try {
                            if (typeof initSecretModeModule === 'function') {
                                initSecretModeModule();
                                console.log('‚úÖ initSecretModeModule() appel√©');
                            }
                        } catch(e) { console.log('‚ùå Erreur initSecretModeModule:', e); }

                        try {
                            if (typeof activerParticulesP5 === 'function') {
                                activerParticulesP5();
                                console.log('‚úÖ activerParticulesP5() appel√©');
                            }
                        } catch(e) { console.log('‚ùå Erreur activerParticulesP5:', e); }

                        // D√©marrer la boucle de jeu
                        try {
                            if (typeof boucleJeu === 'function') {
                                boucleJeu();
                                console.log('‚úÖ boucleJeu() d√©marr√©e');
                            }
                        } catch(e) { console.log('‚ùå Erreur boucleJeu:', e); }

                        console.log('üéÆ Syst√®mes d√©marr√©s !');
                    }, 500);
                });
            });
        }

        // Attendre que le DOM soit charg√© pour initialiser l'√©cran langue
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üåç DOM charg√©, initialisation...');
            initLanguageScreen();
        });

        // Au cas o√π DOMContentLoaded serait d√©j√† pass√©
        if (document.readyState === 'loading') {
            console.log('üåç En attente du DOM...');
        } else {
            console.log('üåç DOM d√©j√† pr√™t, initialisation imm√©diate...');
            setTimeout(initLanguageScreen, 100);
        }

        // Fonction Date.now() pausable - d√©finie d√®s le d√©but
        window.now = function() {
            return Date.now() - window.tempsPause;
        };

        // Configuration responsive avec ratio fixe
        function setupCanvas() {
            const container = document.querySelector('.game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            return { width, height };
        }

        let size = setupCanvas();
        const C = {
            W: size.width, H: size.height,
            PW: Math.max(size.width * 0.3, 100),  // Plus large
            PH: Math.max(size.height * 0.025, 15), // Plus haut
            BS: Math.max(Math.min(size.width, size.height) * 0.025, 10),
            SP: Math.max(Math.min(size.width, size.height) * 0.002, 1.5)
        };

        // Voyage de d√©couverte de la v√©rit√© - Le Jour : La Lumi√®re
        const JOUR = [
            { nom: 'ON M\'A DIT...', couleur: '#FFB6C1', msg: 'üó£Ô∏è Les manipulations s\'effacent devant la v√©rit√© !' },
            { nom: 'DES MONSTRES', couleur: '#87CEEB', msg: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Non... des humains comme nous !' },
            { nom: 'PR√âJUG√âS', couleur: '#DDA0DD', msg: 'üé≠ Les masques tombent un √† un...' },
            { nom: 'PEURS', couleur: '#98FB98', msg: 'üëÅÔ∏è J\'ai choisi de voir par moi-m√™me !' },
            { nom: 'M√âFIANCE', couleur: '#FFCCCB', msg: 'ü§ù La m√©fiance c√®de √† la compation...' },
            { nom: 'QUI SONT-ILS ?', couleur: '#F0E68C', msg: '‚ùì Cette question hante mes nuits...' },
            { nom: 'J\'AI VU...', couleur: '#E6E6FA', msg: 'üëÅÔ∏è Et mes yeux se sont ouverts...' },
            { nom: 'UN P√àRE', couleur: '#FFDAB9', msg: 'üë® Un homme qui aime ses enfants...' },
            { nom: 'UNE M√àRE', couleur: '#AFEEEE', msg: 'üë© Une femme courageuse...' },
            { nom: 'DES ENFANTS', couleur: '#F5DEB3', msg: 'üë∂ Des rires purs et innocents...' },
            { nom: 'L\'HUMANIT√â', couleur: '#FFE4E1', msg: 'üí´ L\'essence m√™me de ce que nous sommes...' },
            { nom: 'L\'AMOUR', couleur: '#E0FFFF', msg: '‚ù§Ô∏è Plus fort que toutes les barri√®res...' },
            { nom: 'LA COMPASSION', couleur: '#FFF8DC', msg: 'ü§ó Qui unit au-del√† des diff√©rences...' },
            { nom: 'L\'ESPOIR', couleur: '#F0FFF0', msg: 'üåÖ Une lumi√®re dans l\'obscurit√©...' },
            { nom: 'LA PAIX', couleur: '#F5F5DC', msg: 'üïäÔ∏è Possible quand on choisis d\'aimer...' },
            { nom: 'COMME MOI', couleur: '#FFFACD', msg: 'üåç On est tous des immigr√©s...' }
        ];

        // La Nuit : L'Obscurit√© - Les maux qui tentent de corrompre
        const NUIT = [
            { nom: 'DISCORDES', couleur: '#8B0000', msg: '‚ö° Des discordes... des haines... des destructions...' },
            { nom: 'HAINES', couleur: '#4B0000', msg: 'üíî Venues avec les maux de l\'ombre...' },
            { nom: 'DESTRUCTIONS', couleur: '#2F1B14', msg: 'üå™Ô∏è Le vol, le mensonge, la manipulation...' },
            { nom: 'VOL', couleur: '#36454F', msg: 'ü¶π Qui s\'empare de ce qui n\'appartient pas...' },
            { nom: 'MENSONGE', couleur: '#2F2F2F', msg: 'üé≠ Les masques de la tromperie...' },
            { nom: 'MANIPULATION', couleur: '#654321', msg: 'üï∑Ô∏è Les fils invisibles tirent les c≈ìurs...' },
            { nom: 'CUPIDIT√â', couleur: '#654321', msg: 'üí∞ La cupidit√© et l\'avidit√©...' },
            { nom: 'AVIDIT√â', couleur: '#483C32', msg: '‚õìÔ∏è Comme des cha√Ænes invisibles...' },
            { nom: 'CHA√éNES', couleur: '#2E4B2E', msg: 'üîó Serrant le c≈ìur des hommes...' },
            { nom: 'MURS DE FER', couleur: '#191970', msg: 'üß± Enferm√©s derri√®re des murs de fer et de peur...' },
            { nom: 'JALOUSIE', couleur: '#2E4B2E', msg: 'üíö Le poison vert de l\'envie...' },
            { nom: 'ORGUEIL', couleur: '#191970', msg: 'üëë La couronne qui aveugle...' },
            { nom: 'COL√àRE', couleur: '#8B1538', msg: 'üî• Les flammes qui consument la raison...' },
            { nom: 'VENGEANCE', couleur: '#4A4A4A', msg: '‚öîÔ∏è La spirale sans fin de la souffrance...' },
            { nom: 'INDIFF√âRENCE', couleur: '#708090', msg: 'üßä Le froid qui glace les √¢mes...' },
            { nom: '√âGO√èSME', couleur: '#5D5D5D', msg: 'ü™û Ne voir que son propre reflet...' },
            { nom: 'IGNORANCE', couleur: '#2F4F4F', msg: 'üôà Choisir de fermer les yeux...' },
            { nom: 'R√âSISTANCE', couleur: '#1C1C1C', msg: 'üõ°Ô∏è Mais je garde mon c≈ìur pur dans la temp√™te...' },
            { nom: 'LUMI√àRE', couleur: '#483D8B', msg: '‚ú® Car au-del√† des nuages, elle existe toujours...' }
        ];

        // Voyage actuel selon la p√©riode
        let VOYAGE = JOUR;

        // ===============================================
        // SYST√àME D'√âNIGMES COLLECTIBLES
        // ===============================================

        // Base de donn√©es des √©nigmes avec informations modulaires
        const ENIGMES_DATABASE = {
            humanite: {
                id: 'humanite',
                nom: 'Humanit√©',
                icone: 'ü§ù',
                description: 'La force qui unit tous les c≈ìurs',
                mystere: 'Qu\'est-ce qui nous rend v√©ritablement humains ?',
                revelation: 'L\'humanit√© r√©side dans notre capacit√© √† ressentir de la compassion pour autrui, m√™me pour ceux qui nous sont diff√©rents.',
                sagesse: 'Un p√®re, une m√®re, des enfants... Tous cherchant simplement √† vivre leur meilleure vie, comme nous.',
                collecte: false,
                phaseRequise: 'coeurs'
            },
            paix: {
                id: 'paix',
                nom: 'Paix',
                icone: 'üïäÔ∏è',
                description: 'L\'harmonie qui transcende les conflits',
                mystere: 'Comment trouve-t-on la paix dans un monde de chaos ?',
                revelation: 'La paix na√Æt lorsque nous choisissons d\'aimer plut√¥t que de ha√Ør, de comprendre plut√¥t que de juger.',
                sagesse: 'Au-del√† des nuages, il existe toujours une lumi√®re. Mais pour la voir, il faut d\'abord traverser la nuit.',
                collecte: false,
                phaseRequise: 'briques'
            },
            diversite: {
                id: 'diversite',
                nom: 'Diversit√©',
                icone: 'üåà',
                description: 'La beaut√© de nos diff√©rences',
                mystere: 'Pourquoi craignons-nous ce qui est diff√©rent ?',
                revelation: 'La diversit√© est la richesse du monde. Chaque couleur, chaque culture apporte sa propre beaut√© √† l\'arc-en-ciel humain.',
                sagesse: 'On m\'a dit tant de mal sur eux... Mais j\'ai pr√©f√©r√© aller voir de mes propres yeux.',
                collecte: false,
                phaseRequise: 'coeurs'
            },
            liberte: {
                id: 'liberte',
                nom: 'Libert√©',
                icone: 'üóΩ',
                description: 'Le droit de vivre sans cha√Ænes',
                mystere: 'Qu\'est-ce que la vraie libert√© ?',
                revelation: 'La libert√© n\'est pas l\'absence de contraintes, mais la capacit√© de choisir l\'amour malgr√© la peur.',
                sagesse: 'La cupidit√© et l\'avidit√©, comme des cha√Ænes invisibles, serrent le c≈ìur des hommes.',
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            foi: {
                id: 'foi',
                nom: 'Foi',
                icone: 'üôè',
                description: 'L\'espoir qui guide dans l\'obscurit√©',
                mystere: 'Comment garder foi quand tout semble perdu ?',
                revelation: 'La foi n\'est pas l\'absence de doute, mais la d√©cision de continuer malgr√© l\'incertitude.',
                sagesse: 'L\'orage, aussi bruyant qu\'il soit, ne dure jamais √©ternellement.',
                collecte: false,
                phaseRequise: 'briques'
            },
            respect: {
                id: 'respect',
                nom: 'Respect',
                icone: 'ü§≤',
                description: 'La dignit√© accord√©e √† chaque √™tre',
                mystere: 'Comment respecter ceux que nous ne comprenons pas ?',
                revelation: 'Le respect na√Æt de la reconnaissance que chaque √™tre porte en lui une √©tincelle divine.',
                sagesse: 'Ils s\'enfermaient derri√®re des murs de fer et de peur... Mais l\'humanit√© existait encore.',
                collecte: false,
                phaseRequise: 'coeurs'
            },
            entraide: {
                id: 'entraide',
                nom: 'Entraide',
                icone: 'üíû',
                description: 'La force de l\'union solidaire',
                mystere: 'Pourquoi aider ceux qui ne peuvent rien nous donner ?',
                revelation: 'Dans l\'entraide, nous d√©couvrons que donner nous enrichit plus que recevoir.',
                sagesse: 'L\'amour, plus fort que toutes les barri√®res, unit au-del√† des diff√©rences.',
                collecte: false,
                phaseRequise: 'nuit_coeurs'
            },
            hopital: {
                id: 'hopital',
                nom: 'Gu√©rison',
                icone: 'üè•',
                description: 'Le pouvoir de soigner les blessures',
                mystere: 'Comment gu√©rit-on les blessures invisibles ?',
                revelation: 'La v√©ritable gu√©rison commence par l\'acceptation et se poursuit par le pardon.',
                sagesse: 'Si la temp√™te gronde, c\'est pour rappeler qu\'au-del√† des nuages, il existe toujours une lumi√®re.',
                collecte: false,
                phaseRequise: 'briques'
            },
            restauration: {
                id: 'restauration',
                nom: 'Restauration',
                icone: 'üå±',
                description: 'Le renouveau apr√®s la destruction',
                mystere: 'Comment reb√¢tir apr√®s la d√©vastation ?',
                revelation: 'Chaque fin contient en elle les graines d\'un nouveau commencement.',
                sagesse: 'Une lumi√®re dans l\'obscurit√©... L\'espoir possible quand on choisit d\'aimer.',
                collecte: false,
                phaseRequise: 'coeurs'
            },
            ange: {
                id: 'ange',
                nom: 'Ange Gardien',
                icone: 'ü¶áüëº',
                description: 'La protection divine r√©v√©l√©e',
                mystere: 'Comment distinguer le bien du mal dans l\'obscurit√© ?',
                revelation: 'La perception du bien ou du mal est conditionn√©e √† notre c≈ìur. Un mauvais c≈ìur cache de profondes t√©n√®bres et la manipulation obscurcit m√™me le plus blanc des anges.',
                sagesse: 'Rester √©veill√© dans l\'amour. Bien que tout ne soit ni tout noir ni tout blanc, le c≈ìur bless√© fait du mal.',
                collecte: false,
                phaseRequise: 'lanterne'
            }
        };

        // Gestionnaire de collection d'√©nigmes (version simplifi√©e pour canvas)
        class EnigmaCollector {
            constructor() {
                this.enigmesCollectees = new Set();
                this.chargerProgression();
            }

            // Charger la progression depuis localStorage
            chargerProgression() {
                const saved = localStorage.getItem('vdv_enigmes_collectees');
                if (saved) {
                    this.enigmesCollectees = new Set(JSON.parse(saved));
                }
            }

            // Sauvegarder la progression
            sauvegarderProgression() {
                localStorage.setItem('vdv_enigmes_collectees',
                    JSON.stringify([...this.enigmesCollectees]));
            }

            // V√©rifier si une √©nigme peut √™tre collect√©e
            peutCollecterEnigme(enigmeId) {
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) return false;

                // L'ange est collect√© uniquement via la chauve-souris (pas automatiquement)
                if (enigmeId === 'ange') return false;

                // V√©rifier si la phase actuelle correspond
                return phaseJeu === enigme.phaseRequise ||
                       (phaseJeu === 'petits_coeurs' && enigme.phaseRequise === 'coeurs');
            }

            // Collecter une √©nigme pendant le voyage
            collecterEnigme(enigmeId, forceCollection = false) {
                // console.log(`üîç collecterEnigme appel√©: ${enigmeId}, force=${forceCollection}`);
                const enigme = ENIGMES_DATABASE[enigmeId];
                if (!enigme) {
                    // console.log(`‚ùå √ânigme ${enigmeId} introuvable dans ENIGMES_DATABASE`);
                    return false;
                }
                if (this.enigmesCollectees.has(enigmeId)) {
                    // console.log(`‚ùå √ânigme ${enigmeId} d√©j√† collect√©e`);
                    return false;
                }

                const peutCollecter = this.peutCollecterEnigme(enigmeId);
                // console.log(`üîç peutCollecterEnigme(${enigmeId}): ${peutCollecter}, phaseJeu: ${phaseJeu}, phaseRequise: ${enigme.phaseRequise}`);

                // Permettre la collection forc√©e (pour les √©nigmes sp√©ciales comme l'ange)
                if (forceCollection || peutCollecter) {
                    // console.log(`‚úÖ COLLECTION AUTORIS√âE pour ${enigmeId}`);
                    this.enigmesCollectees.add(enigmeId);
                    this.sauvegarderProgression();
                    this.afficherNotificationCollection(enigme);
                    // console.log(`üéâ √âNIGME ${enigmeId} AJOUT√âE AUX COLLECT√âES`);
                    return true;
                }
                // console.log(`‚ùå COLLECTION REFUS√âE pour ${enigmeId}`);
                return false;
            }

            // Afficher notification de collection
            afficherNotificationCollection(enigme) {
                // Cr√©er une notification styl√©e
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, #10d9c4, #64ffda);
                    color: #0a1428;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 10px 30px rgba(16, 217, 196, 0.5);
                    animation: enigmaNotif 3s ease forwards;
                `;
                notification.innerHTML = `üß© √ânigme collect√©e: ${enigme.icone} ${enigme.nom}`;

                // Ajouter les keyframes CSS si pas d√©j√† pr√©sents
                if (!document.querySelector('#enigma-notif-style')) {
                    const style = document.createElement('style');
                    style.id = 'enigma-notif-style';
                    style.textContent = `
                        @keyframes enigmaNotif {
                            0% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
                            20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }

            // V√©rifier et collecter automatiquement selon la phase
            verifierCollectionAutomatique() {
                // Mapper les phases aux √©nigmes
                const phaseEnigmeMap = {
                    'coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'petits_coeurs': ['humanite', 'diversite', 'respect', 'restauration'],
                    'briques': ['paix', 'foi', 'hopital'],
                    'nuit_coeurs': ['liberte', 'entraide']
                };

                const enigmesPourPhase = phaseEnigmeMap[phaseJeu] || [];

                // Collecter automatiquement une √©nigme al√©atoire pour cette phase
                const enigmesNonCollectees = enigmesPourPhase.filter(id => !this.enigmesCollectees.has(id));

                if (enigmesNonCollectees.length > 0) {
                    const enigmeAleatoire = enigmesNonCollectees[Math.floor(Math.random() * enigmesNonCollectees.length)];

                    // Chance de 30% de collecter l'√©nigme pendant cette phase
                    if (Math.random() < 0.3) {
                        setTimeout(() => {
                            this.collecterEnigme(enigmeAleatoire);
                        }, Math.random() * 5000 + 2000); // Entre 2 et 7 secondes
                    }
                }
            }
        }

        // Initialiser le syst√®me d'√©nigmes
        const enigmaCollector = new EnigmaCollector();

        // ===============================================
        // SYST√àME CHAUVE-SOURIS & ANGE GARDIEN
        // ===============================================

        // R√©v√©ler la chauve-souris quand la lanterne touche les oiseaux
        function revelerChauveSouris(x, y) {
            if(chauveSouris.revelee) return; // D√©j√† r√©v√©l√©e

            chauveSouris.revelee = true;
            chauveSouris.active = true;
            chauveSouris.x = x;
            chauveSouris.y = y;
            chauveSouris.vx = (Math.random() - 0.5) * 2; // Mouvement erratique
            chauveSouris.vy = -1 - Math.random(); // Monte vers le haut
            chauveSouris.tempApparition = window.now();
            chauveSouris.collectee = false;

            // Plus de message d'apparition - seulement √† la collection

            console.log('ü¶á Chauve-souris r√©v√©l√©e ! Position:', x, y);
        }

        // Mettre √† jour la chauve-souris
        function mettreAJourChauveSouris() {
            if (window.systemeArrete) return; // Arr√™t total
            if(!chauveSouris.active) return;

            const tempsEcoule = window.now() - chauveSouris.tempApparition;

            // Animation de vol erratique
            chauveSouris.x += chauveSouris.vx;
            chauveSouris.y += chauveSouris.vy;

            // Mouvement en zigzag
            chauveSouris.vx += (Math.random() - 0.5) * 0.2;
            chauveSouris.vy += Math.sin(window.now() * 0.01) * 0.1;

            // Limiter la vitesse
            chauveSouris.vx = Math.max(-3, Math.min(3, chauveSouris.vx));
            chauveSouris.vy = Math.max(-2, Math.min(1, chauveSouris.vy));

            // V√©rifier collision avec la lanterne pour collecter
            if(!chauveSouris.collectee && balle.visible) {
                const distanceX = Math.abs(chauveSouris.x - balle.x);
                const distanceY = Math.abs(chauveSouris.y - balle.y);
                const distanceCollision = 50;

                if(distanceX < distanceCollision && distanceY < distanceCollision) {
                    collecterChauveSouris();
                }
            }

            // Faire dispara√Ætre apr√®s la dur√©e de vie ou si elle sort de l'√©cran
            if(tempsEcoule > chauveSouris.dureeVie ||
               chauveSouris.x < -100 || chauveSouris.x > C.W + 100 ||
               chauveSouris.y < -100 || chauveSouris.y > C.H + 100) {
                chauveSouris.active = false;
            }
        }

        // Collecter la chauve-souris
        function collecterChauveSouris() {
            if(chauveSouris.collectee) return;

            chauveSouris.collectee = true;
            chauveSouris.active = false;

            // Ajouter 1000 XP
            score += 1000;
            window.score = score; // Synchroniser avec le score global

            // Collecter l'ic√¥ne d'ange (collection forc√©e)
            if(enigmaCollector) {
                enigmaCollector.collecterEnigme('ange', true);
            }

            // Effet visuel spectaculaire
            for(let i = 0; i < 20; i++) {
                particules.push({
                    x: chauveSouris.x,
                    y: chauveSouris.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    couleur: '#FFD700',
                    vie: 1,
                    taille: Math.random() * 6 + 4,
                    type: 'etoile'
                });
            }

            // Message de collection
            afficherMessageSpecial('üí° La lumi√®re chasse la nuit +1000 XP !', 4000);

            console.log('üëº Chauve-souris collect√©e ! +1000 XP et ic√¥ne ange gagn√©e !');
        }

        // Dessiner la chauve-souris
        function dessinerChauveSouris() {
            if(!chauveSouris.active) return;

            ctx.save();
            ctx.translate(chauveSouris.x, chauveSouris.y);

            // Animation de battement d'ailes plus lente et fluide
            const battement = Math.sin(window.now() * 0.008) * 0.2;
            ctx.rotate(battement);

            // Corps de la chauve-souris
            ctx.fillStyle = '#2C1810';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ailes
            ctx.fillStyle = '#1A0F08';
            ctx.beginPath();
            // Aile gauche
            ctx.ellipse(-12, -5, 10, 8, -0.5, 0, Math.PI * 2);
            // Aile droite
            ctx.ellipse(12, -5, 10, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Yeux rouges
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(-3, -3, 2, 0, Math.PI * 2);
            ctx.arc(3, -3, 2, 0, Math.PI * 2);
            ctx.fill();

            // Lueur dor√©e si proche de la collection
            if(!chauveSouris.collectee && balle.visible) {
                const distance = Math.sqrt(
                    Math.pow(chauveSouris.x - balle.x, 2) +
                    Math.pow(chauveSouris.y - balle.y, 2)
                );

                if(distance < 80) {
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ===============================================
        // ANIMATION IC√îNE VERS MENU √âNIGMES
        // ===============================================

        // D√©clencher l'animation de l'ic√¥ne vers le bouton du menu
        function lancerAnimationIconeVersMenu(icone) {
            if (animationIconeMenu.active) return; // √âviter les doublons

            // Position de d√©part (centre de l'ic√¥ne th√©matique)
            animationIconeMenu.startX = C.W / 2;
            animationIconeMenu.startY = C.H * 0.30;

            // Position cible (bouton menu √©nigmes - plus bas √† droite)
            animationIconeMenu.targetX = C.W - 65; // Position du bouton menu
            animationIconeMenu.targetY = 105; // Plus bas pour correspondre au bouton (80 + 25)

            // Initialiser l'animation
            animationIconeMenu.currentX = animationIconeMenu.startX;
            animationIconeMenu.currentY = animationIconeMenu.startY;
            animationIconeMenu.progress = 0;
            animationIconeMenu.startTime = window.now();
            animationIconeMenu.icone = icone;
            animationIconeMenu.active = true;

            console.log(`üé≠ Animation ic√¥ne ${icone} vers menu √©nigmes d√©clench√©e !`);
        }

        // Mettre √† jour l'animation de l'ic√¥ne
        function mettreAJourAnimationIconeMenu() {
            if (!animationIconeMenu.active) return;

            const tempsEcoule = window.now() - animationIconeMenu.startTime;
            const progression = Math.min(tempsEcoule / animationIconeMenu.duree, 1);

            // Appliquer l'easing
            const easedProgress = animationIconeMenu.easing(progression);

            // Calculer la position courante
            animationIconeMenu.currentX = animationIconeMenu.startX +
                (animationIconeMenu.targetX - animationIconeMenu.startX) * easedProgress;

            animationIconeMenu.currentY = animationIconeMenu.startY +
                (animationIconeMenu.targetY - animationIconeMenu.startY) * easedProgress;

            // Ajouter un arc parabolique pour plus de fluidit√©
            const arcHeight = 50;
            const arcY = Math.sin(progression * Math.PI) * arcHeight;
            animationIconeMenu.currentY -= arcY;

            // Terminer l'animation
            if (progression >= 1) {
                animationIconeMenu.active = false;

                // Effet visuel au moment de l'arriv√©e
                for(let i = 0; i < 10; i++) {
                    particules.push({
                        x: animationIconeMenu.targetX,
                        y: animationIconeMenu.targetY,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        couleur: '#64ffda',
                        vie: 1,
                        taille: Math.random() * 4 + 2,
                        type: 'rond'
                    });
                }

                console.log(`‚ú® Ic√¥ne ${animationIconeMenu.icone} arriv√©e au menu !`);
            }
        }

        // Dessiner l'ic√¥ne en animation
        function dessinerIconeEnAnimation() {
            if (!animationIconeMenu.active) return;

            ctx.save();
            ctx.translate(animationIconeMenu.currentX, animationIconeMenu.currentY);

            // Effet de rotation pendant le vol
            const rotation = (window.now() - animationIconeMenu.startTime) * 0.01;
            ctx.rotate(rotation);

            // Taille qui grandit l√©g√®rement pendant le vol
            const scale = 1 + Math.sin(animationIconeMenu.progress * Math.PI) * 0.3;
            ctx.scale(scale, scale);

            // Dessiner l'ic√¥ne avec effet lumineux
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Lueur dor√©e
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#FFD700';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            // Deuxi√®me couche plus claire
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(animationIconeMenu.icone, 0, 0);

            ctx.restore();
        }

        // ===============================================
        // BOUTON MENU √âNIGMES DANS LE CANVAS
        // ===============================================

        // Bouton menu HOME supprim√©

        // √âtat du menu √©nigmes dans le canvas
        let menuEnigmesCanvas = {
            visible: false,
            animation: 0, // 0 = ferm√©, 1 = ouvert
            animationStartTime: 0,
            animationDuration: 300,
            scrollY: 0,
            maxScrollY: 0,
            enigmaCards: [], // Position des cartes pour les clics
            closeButton: { x: 0, y: 0, width: 40, height: 40, hover: false },
            hoveredCard: null, // Carte actuellement survol√©e
            topIcons: [], // Positions des ic√¥nes en haut pour les clics
            centralIcon: { x: 0, y: 0, width: 60, height: 60, hover: false } // Zone cliquable de l'ic√¥ne centrale
        };

        // Dessiner les ic√¥nes d'√©nigmes collect√©es en haut du header
        // D√âSACTIV√â : Les √©nigmes ne s'affichent que dans le menu, pas en haut
        function dessinerIconesCollecteesEnHaut(headerHeight) {
            // FONCTION D√âSACTIV√âE - Les √©nigmes collect√©es ne s'affichent QUE dans le menu üß©
            // La chauve-souris et l'ange sont g√©r√©s s√©par√©ment et toujours visibles
            return;

            // Afficher les ic√¥nes de droite √† gauche
            enigmesCollectees.forEach((enigme, index) => {
                const x = startX - (index + 1) * spacing;

                // Zone cliquable
                const iconData = {
                    x: x - iconSize / 2,
                    y: iconY - iconSize / 2,
                    width: iconSize,
                    height: iconSize,
                    enigme: enigme
                };
                menuEnigmesCanvas.topIcons.push(iconData);

                // Effet de survol
                const isHovered = menuEnigmesCanvas.topIcons.some(icon =>
                    icon.enigme.id === enigme.id && icon.hover);

                // Fond de l'ic√¥ne avec effet lumineux
                ctx.fillStyle = isHovered ? 'rgba(100, 255, 218, 0.3)' : 'rgba(100, 255, 218, 0.15)';
                ctx.beginPath();
                ctx.arc(x, iconY, iconSize / 2 + 2, 0, Math.PI * 2);
                ctx.fill();

                // Bordure
                ctx.strokeStyle = '#64ffda';
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.stroke();

                // Ic√¥ne de l'√©nigme
                ctx.font = `${iconSize * 0.7}px Arial`;
                ctx.fillStyle = '#64ffda';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enigme.icone, x, iconY);

                // Badge de notification si c'est la premi√®re fois affich√©
                if (index < 3) { // Badge seulement pour les 3 derni√®res collect√©es
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x + iconSize / 3, iconY - iconSize / 3, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();
        }

        // Dessiner le bouton menu √©nigmes dans le canvas
        function dessinerBoutonMenuEnigmes() {
            // Position dans le header √† droite
            const headerH = Math.max(C.H * 0.045, 32);
            boutonMenuEnigmes.x = C.W - 65;
            boutonMenuEnigmes.y = Math.max(headerH / 2 - 25, 5); // Centr√© dans le header

            ctx.save();

            // Effet de survol
            const scale = boutonMenuEnigmes.hover ? 1.1 : 1;
            const alpha = boutonMenuEnigmes.hover ? 1 : 0.8;

            ctx.globalAlpha = alpha;
            ctx.translate(boutonMenuEnigmes.x + boutonMenuEnigmes.width/2,
                         boutonMenuEnigmes.y + boutonMenuEnigmes.height/2);
            ctx.scale(scale, scale);

            // Arri√®re-plan du bouton
            const gradient = ctx.createLinearGradient(-25, -25, 25, 25);
            gradient.addColorStop(0, '#1a2d4a');
            gradient.addColorStop(1, '#0a1428');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Ic√¥ne du puzzle
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#64ffda';
            ctx.fillText('üß©', 0, 0);

            // Indicateur du nombre d'√©nigmes collect√©es
            if (enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;

                if (collected > 0) {
                    // Badge de notification
                    ctx.fillStyle = '#10d9c4';
                    ctx.beginPath();
                    ctx.arc(15, -15, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#0a1428';
                    ctx.fillText(collected, 15, -15);
                }
            }

            ctx.restore();
        }

        // Fonctions menu HOME supprim√©es

        // ========================================
        // MENU PRINCIPAL - Acc√®s √† tous les menus
        // ========================================

        function ouvrirMenuPrincipal() {
            // Cr√©er un menu avec toutes les options
            const options = [
                { nom: 'üß© √ânigmes', action: () => ouvrirMenuEnigmesCanvas() },
                { nom: 'üìú √ânigmes Compl√®tes', action: () => ouvrirEnigmesCompletes() },
                { nom: 'üéÆ Menu Jeux', action: () => console.log('Menu jeux ouvert') },
                { nom: 'üìú Po√®me 1', action: () => console.log('Po√®me 1 ouvert') },
                { nom: 'üìñ Po√®me 2', action: () => console.log('Po√®me 2 ouvert') },
                { nom: 'üé® Info Artiste', action: () => ouvrirInfoArtiste() },
                { nom: 'üé¨ G√©n√©rique', action: () => console.log('G√©n√©rique ouvert') },
                { nom: 'ü¶áüëº Ic√¥nes', action: () => console.log('Menu ic√¥nes ouvert') }
            ];

            // Pour l'instant, ouvrir le menu √©nigmes (√† d√©velopper plus tard)
            ouvrirMenuEnigmesCanvas();
            console.log('üè† Menu HOME - acc√®s √† tous les menus !');
        }

        // Fonction pour ouvrir l'info artiste
        function ouvrirInfoArtiste() {
            // Version simplifi√©e pour √©viter les erreurs de syntaxe
            const infoArtistePage = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emmanuel Payet - Artiste</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            text-align: center;
        }
        h1 { color: #2c3e50; margin-bottom: 20px; }
        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="window.close()">√ó</button>
    <div class="container">
        <h1>Emmanuel Payet</h1>
        <p>Artiste Chretien - Createur - Inspirateur</p>
        <br>
        <div>
            <h3>Jeux & Deco</h3>
            <p>Decouvre mes creations visuelles et jeux interactifs</p>
            <a href="https://emmanuel.gallery" target="_blank">emmanuel.gallery</a>
        </div>
        <br>
        <div>
            <h3>Livres & Art</h3>
            <p>Mes oeuvres litteraires et artistiques</p>
            <a href="https://emmanuelpayet.art" target="_blank">emmanuelpayet.art</a>
        </div>
        <br>
        <div>
            <h3>Gospel Gratuit</h3>
            <p>Mes compositions gospel sur AudioMack</p>
            <a href="https://audiomack.com/emmanuelpayet888" target="_blank">AudioMack</a>
        </div>
    </div>
</body>
</html>`;

            // Ouvrir dans une nouvelle fen√™tre
            const newWindow = window.open('', '_blank', 'width=1000,height=800,scrollbars=yes,resizable=yes');
            newWindow.document.write(infoArtistePage);
            newWindow.document.close();

            console.log('üé® Page Info Artiste ouverte !');
        }

        // Fonction pour ouvrir les √©nigmes compl√®tes avec le nouveau style
        function ouvrirEnigmesCompletes() {
            // Ouvrir le fichier existant directement
            const newWindow = window.open('emmanuel-artist-module.html', '_blank', 'width=1200,height=900,scrollbars=yes,resizable=yes');
            console.log('üìú Page √ânigmes Compl√®tes ouverte !');
        }

        // Ouvrir le menu √©nigmes dans le canvas
        function ouvrirMenuEnigmesCanvas() {
            if (menuEnigmesCanvas.visible) return;

            menuEnigmesCanvas.visible = true;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.animationStartTime = window.now();
            menuEnigmesCanvas.showInfo = false;
            menuEnigmesCanvas.selectedEnigma = null;
            menuEnigmesCanvas.scrollY = 0;

            // G√©n√©rer les positions des cartes
            genererPositionsCartesEnigmes();
        }

        // Fermer le menu √©nigmes canvas
        function fermerMenuEnigmesCanvas() {
            menuEnigmesCanvas.visible = false;
            menuEnigmesCanvas.animation = 0;
            menuEnigmesCanvas.hoveredCard = null;
        }

        // G√©n√©rer les positions des cartes d'√©nigmes
        function genererPositionsCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards = [];

            // Calculer les dimensions du menu centr√©
            const menuWidth = Math.min(C.W - 80, 600);
            const menuHeight = Math.min(C.H - 80, 500);
            const menuX = (C.W - menuWidth) / 2;
            const menuY = (C.H - menuHeight) / 2;

            const startX = menuX + 30; // Marge √† l'int√©rieur du menu
            const startY = menuY + 100; // Apr√®s le titre et les stats
            const cardWidth = 90;
            const cardHeight = 110;
            const spacing = 15;
            const availableWidth = menuWidth - 60; // Largeur disponible moins les marges
            const cardsPerRow = Math.floor(availableWidth / (cardWidth + spacing));

            let index = 0;
            Object.values(ENIGMES_DATABASE).forEach(enigme => {
                const row = Math.floor(index / cardsPerRow);
                const col = index % cardsPerRow;

                menuEnigmesCanvas.enigmaCards.push({
                    id: enigme.id,
                    x: startX + col * (cardWidth + spacing),
                    y: startY + row * (cardHeight + spacing),
                    width: cardWidth,
                    height: cardHeight,
                    enigme: enigme,
                    hover: false
                });
                index++;
            });

            // Calculer le scroll max
            const totalRows = Math.ceil(Object.keys(ENIGMES_DATABASE).length / cardsPerRow);
            const totalHeight = totalRows * (cardHeight + spacing);
            menuEnigmesCanvas.maxScrollY = Math.max(0, totalHeight - (C.H - 200));
        }

        // Mettre √† jour l'animation du menu
        function mettreAJourMenuEnigmesCanvas() {
            if (!menuEnigmesCanvas.visible) return;

            const elapsed = window.now() - menuEnigmesCanvas.animationStartTime;
            const progress = Math.min(elapsed / menuEnigmesCanvas.animationDuration, 1);

            // Easing out
            menuEnigmesCanvas.animation = 1 - Math.pow(1 - progress, 3);
        }

        // Dessiner le menu √©nigmes dans le canvas
        function dessinerMenuEnigmesCanvas() {
            if (!menuEnigmesCanvas.visible) return;

            ctx.save();

            // Arri√®re-plan avec transparence
            ctx.fillStyle = `rgba(0, 20, 40, ${0.95 * menuEnigmesCanvas.animation})`;
            ctx.fillRect(0, 0, C.W, C.H);

            // Container principal
            const containerAlpha = menuEnigmesCanvas.animation;
            ctx.globalAlpha = containerAlpha;

            // Arri√®re-plan du menu - CENTR√â derri√®re l'ic√¥ne
            const menuWidth = Math.min(C.W - 80, 600); // Max 600px de large
            const menuHeight = Math.min(C.H - 80, 500); // Max 500px de haut
            const menuX = (C.W - menuWidth) / 2; // Centr√© horizontalement
            const menuY = (C.H - menuHeight) / 2; // Centr√© verticalement

            // Fond du menu avec d√©grad√©
            const gradient = ctx.createLinearGradient(menuX, menuY, menuX, menuY + menuHeight);
            gradient.addColorStop(0, '#0a1428');
            gradient.addColorStop(1, '#1a2d4a');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(menuX, menuY, menuWidth, menuHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Titre
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#64ffda';
            ctx.textAlign = 'center';
            ctx.fillText('üß© √ânigmes du Voyage', C.W / 2, menuY + 40);

            // Statistiques
            if (enigmaCollector) {
                const collected = enigmaCollector.enigmesCollectees.size;
                const total = Object.keys(ENIGMES_DATABASE).length;
                const percent = Math.round((collected / total) * 100);

                ctx.font = '16px Arial';
                ctx.fillStyle = '#10d9c4';
                ctx.fillText(`Collect√©es: ${collected}/${total} (${percent}%)`, C.W / 2, menuY + 65);
            }

            // Bouton de fermeture
            menuEnigmesCanvas.closeButton.x = menuX + menuWidth - 50;
            menuEnigmesCanvas.closeButton.y = menuY + 10;

            ctx.fillStyle = menuEnigmesCanvas.closeButton.hover ? '#ff6b6b' : '#64ffda';
            ctx.beginPath();
            ctx.arc(menuEnigmesCanvas.closeButton.x + 20, menuEnigmesCanvas.closeButton.y + 20, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.font = '16px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.fillText('‚úï', menuEnigmesCanvas.closeButton.x + 20, menuEnigmesCanvas.closeButton.y + 25);

            // Zone de contenu avec clipping
            ctx.save();
            ctx.beginPath();
            ctx.rect(menuX + 10, menuY + 90, menuWidth - 20, menuHeight - 120);
            ctx.clip();

            // Dessiner les cartes d'√©nigmes
            dessinerCartesEnigmes();

            ctx.restore();

            // Dessiner l'info-bulle si une carte est survol√©e
            if (menuEnigmesCanvas.hoveredCard) {
                dessinerInfoBulleEnigme();
            }

            ctx.restore();
        }

        // Dessiner les cartes d'√©nigmes
        function dessinerCartesEnigmes() {
            menuEnigmesCanvas.enigmaCards.forEach(card => {
                const y = card.y - menuEnigmesCanvas.scrollY;

                // Ne dessiner que les cartes visibles
                if (y + card.height < 110 || y > C.H - 40) return;

                const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                const alpha = card.hover ? 1 : 0.9;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Arri√®re-plan de la carte
                if (isCollected) {
                    const cardGradient = ctx.createLinearGradient(card.x, y, card.x, y + card.height);
                    cardGradient.addColorStop(0, '#1a4d4a');
                    cardGradient.addColorStop(1, '#0a2d28');
                    ctx.fillStyle = cardGradient;
                    ctx.strokeStyle = '#10d9c4';
                } else {
                    const cardGradient = ctx.createLinearGradient(card.x, y, card.x, y + card.height);
                    cardGradient.addColorStop(0, '#1a2d4a');
                    cardGradient.addColorStop(1, '#0a1428');
                    ctx.fillStyle = cardGradient;
                    ctx.strokeStyle = '#334155';
                }

                ctx.lineWidth = card.hover ? 3 : 1;
                ctx.beginPath();
                ctx.roundRect(card.x, y, card.width, card.height, 8);
                ctx.fill();
                ctx.stroke();

                // Ic√¥ne
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = isCollected ? '#10d9c4' : '#666';
                ctx.fillText(card.enigme.icone, card.x + card.width/2, y + 40);

                // Nom
                ctx.font = '12px Arial';
                ctx.fillStyle = isCollected ? '#10d9c4' : '#888';
                const lines = card.enigme.nom.split(' ');
                lines.forEach((line, i) => {
                    ctx.fillText(line, card.x + card.width/2, y + 65 + i * 15);
                });

                // Badge de collection
                if (isCollected) {
                    ctx.fillStyle = '#10d9c4';
                    ctx.beginPath();
                    ctx.arc(card.x + card.width - 15, y + 15, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#0a1428';
                    ctx.fillText('‚úì', card.x + card.width - 15, y + 19);
                }

                ctx.restore();
            });
        }

        // Dessiner une info-bulle simple pour l'√©nigme survol√©e
        function dessinerInfoBulleEnigme() {
            const card = menuEnigmesCanvas.hoveredCard;
            if (!card || !card.enigme) return;

            ctx.save();

            // Position de l'info-bulle
            const mouseX = card.x + card.width + 10;
            const mouseY = card.y - menuEnigmesCanvas.scrollY;

            // Texte de l'info-bulle (description courte)
            const texte = card.enigme.description;
            const maxWidth = 200;

            // Mesurer le texte pour dimensionner l'info-bulle
            ctx.font = '12px Arial';
            const lines = wrapText(ctx, texte, maxWidth);
            const tooltipWidth = maxWidth + 20;
            const tooltipHeight = lines.length * 16 + 20;

            // Ajuster la position si elle d√©passe l'√©cran
            let tooltipX = mouseX;
            let tooltipY = mouseY - tooltipHeight / 2;

            if (tooltipX + tooltipWidth > C.W - 20) {
                tooltipX = card.x - tooltipWidth - 10;
            }
            if (tooltipY < 10) tooltipY = 10;
            if (tooltipY + tooltipHeight > C.H - 10) tooltipY = C.H - tooltipHeight - 10;

            // Fond de l'info-bulle
            ctx.fillStyle = 'rgba(15, 20, 25, 0.95)';
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8);
            ctx.fill();
            ctx.stroke();

            // Texte de l'info-bulle
            ctx.fillStyle = '#10d9c4';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';

            lines.forEach((line, i) => {
                ctx.fillText(line, tooltipX + 10, tooltipY + 16 + i * 16);
            });

            ctx.restore();
        }

        // V√©rifier le survol des ic√¥nes en haut ET de l'ic√¥ne centrale
        function verifierSurvolIconesHaut(x, y) {
            // V√©rifier le survol de l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                centralIcon.hover = true;
            } else {
                centralIcon.hover = false;
            }

            // V√©rifier le survol des ic√¥nes en haut
            if (!menuEnigmesCanvas.topIcons || menuEnigmesCanvas.topIcons.length === 0) return;

            for (let icon of menuEnigmesCanvas.topIcons) {
                if (x >= icon.x && x <= icon.x + icon.width &&
                    y >= icon.y && y <= icon.y + icon.height) {
                    icon.hover = true;
                } else {
                    icon.hover = false;
                }
            }
        }

        // V√©rifier le survol des cartes d'√©nigmes
        function verifierSurvolCartes(x, y) {
            if (!menuEnigmesCanvas.visible) {
                menuEnigmesCanvas.hoveredCard = null;
                return;
            }

            let cardTrouvee = null;

            for (let card of menuEnigmesCanvas.enigmaCards) {
                const cardY = card.y - menuEnigmesCanvas.scrollY;

                // V√©rifier si la carte est visible et survol√©e
                if (cardY + card.height >= 110 && cardY <= C.H - 40 &&
                    x >= card.x && x <= card.x + card.width &&
                    y >= cardY && y <= cardY + card.height) {

                    const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                    if (isCollected) {
                        cardTrouvee = card;
                        card.hover = true;
                    }
                } else {
                    card.hover = false;
                }
            }

            menuEnigmesCanvas.hoveredCard = cardTrouvee;
        }

        // Fonction utilitaire pour d√©couper le texte en lignes
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Fonction utilitaire pour afficher des messages sp√©ciaux - style bulle discr√®te
        function afficherMessageSpecial(texte, duree = 3000) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 60%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: normal;
                z-index: 10001;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid rgba(255, 215, 0, 0.3);
                animation: messageSpecialAnim 4s ease forwards;
                text-align: center;
                border: 3px solid #FF8C00;
            `;
            messageDiv.innerHTML = texte;

            // Ajouter animation CSS si pas d√©j√† pr√©sente
            if (!document.querySelector('#message-special-style')) {
                const style = document.createElement('style');
                style.id = 'message-special-style';
                style.textContent = `
                    @keyframes messageSpecialAnim {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                        15%, 85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), duree);
        }

        // ===============================================
        // NOUVEAU SYST√àME DE NARRATION COMPLETE V2.0
        // ===============================================

        // Gestionnaire central de la narration
        class NarrationManager {
            constructor() {
                this.currentPhase = 1;
                this.isTransitioning = false;
                this.victoryTimers = new Map();
                this.phaseHistory = [];

                // Configuration des phases avec IDs uniques
                this.phases = [
                    {
                        id: 'VDV_NARR_P01_INTRO_LUMIERE',
                        phase: 1,
                        titre: 'Voyage ‚Äî L\'aube des doutes',
                        texte: "On m'a dit qu'ils √©taient tous\ndes monstres...\nOn m'a dit tant de mal,\ntant de malheurs\nsur eux...\nMais moi,\nj'ai pr√©f√©r√© aller voir\nde mes propres yeux...",
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P02_REVELATION_FAMILLE',
                        phase: 2,
                        titre: 'Voyage ‚Äî La lumi√®re',
                        texte: 'Qui √©taient-ils vraiment ?...\nEt j\'ai vu...\nUn p√®re... une m√®re...\ndes enfants...\nTous cherchant simplement √† vivre\nleur meilleure vie...\nComme moi.',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'neon',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P03_TRANSITION_OBSCURITE',
                        phase: 3,
                        titre: 'Voyage ‚Äî L\'ombre des nuages',
                        texte: 'Alors, la lune apparut.\nLe ciel s\'assombrit\ncomme une page br√ªl√©e\npar le temps.\nUn aileron fendit les vagues\nsombres...\nDes √©clairs z√©br√®rent\nles nuages gris.',
                        mode: 'coeurs',
                        duree: 8000,
                        transition: 'shadow3d',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P04_CHAPITRE2_NUAGES',
                        phase: 4,
                        titre: 'Voyage ‚Äî L\'ombre des nuages',
                        texte: 'Et avec eux vinrent les maux...\nLes discordes...\nLa haine...\nLa destruction...\nLe vol, le mensonge,\nLa manipulation...\nLa cupidit√© et l\'avidit√©,\nComme des cha√Ænes invisibles,\nSerrant le c≈ìur des hommes.',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P05_MAUX_CHAINES',
                        phase: 5,
                        titre: 'Voyage ‚Äî Le silence de l\'√¢me',
                        texte: 'On m\'a dit de ne pas √©couter\nleurs cris...\nOn m\'a dit de ne pas laisser\nl\'orage me faire peur.\nCar l\'orage,\naussi bruyant qu\'il soit,\nne dure jamais\n√©ternellement.',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'fire',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P06_ORAGE_TEMPORAIRE',
                        phase: 6,
                        titre: 'Voyage ‚Äî Le silence de l\'√¢me',
                        texte: 'Et si la temp√™te gronde,\nc\'est peut-√™tre\npour rappeler √† l\'homme\nqu\'au-del√† des nuages,\nil existe toujours\nune lumi√®re.\nMais pour la voir,\nil faut d\'abord traverser\nla nuit...',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P07_LUMIERE_NUAGES',
                        phase: 7,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'On m\'a dit...\nque l\'humanit√© n\'existait plus,\nqu\'elle s\'√©tait perdue\ndans les guerres\net les rancunes.\nOn m\'a dit que les hommes\nn\'accueillaient\nplus personne,\nqu\'ils s\'enfermaient\nderri√®re des murs de fer\net de peur...',
                        mode: 'coeurs',
                        duree: 12000,
                        transition: 'outline',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P08_CHAPITRE3_HUMANITE',
                        phase: 8,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'Mais moi, j\'ai vu‚Ä¶\nUne main tendue √† un √©tranger.\nUn sourire partag√©\nmalgr√© la faim.\nUne porte ouverte\npour celui qui tremblait\ndans la nuit...',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'digital',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P09_MAIN_TENDUE',
                        phase: 9,
                        titre: 'Voyage ‚Äî L\'humanit√© des c≈ìurs',
                        texte: 'C\'est cela,\nl\'hospitalit√© :\nnon pas donner ce qu\'on a de trop,\nmais partager\nm√™me ce qui manque...',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'typewriter',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P10_HOSPITALITE',
                        phase: 10,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'On m\'a dit que la libert√©\nn\'√©tait qu\'un mot,\nune illusion\nque les puissants\nvendaient aux faibles.\nMais j\'ai vu‚Ä¶\nUn enfant courir pieds nus\nsous la pluie,\nriant sans cha√Ænes,\net dans ses rires,\nj\'ai compris que la libert√©\nvit d\'abord dans l\'√¢me.',
                        mode: 'coeurs',
                        duree: 20000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P11_LIBERTE_AME',
                        phase: 11,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'On m\'a dit que les hommes\nn\'aidaient plus,\nque chacun ne vivait que pour soi.\nMais j\'ai vu‚Ä¶\nDes inconnus soulever ensemble\nune pierre trop lourde,\net dans cette force partag√©e,\nj\'ai vu l\'amour na√Ætre.',
                        mode: 'nuit_coeurs',
                        duree: 14000,
                        transition: 'neon',
                        speed: 40
                    },
                    {
                        id: 'VDV_NARR_P12_AMOUR_PARTAGE',
                        phase: 12,
                        titre: 'Voyage ‚Äî La sagesse des diff√©rences',
                        texte: 'On m\'a dit que l\'amour\n√©tait fragile,\nmais j\'ai vu\nqu\'il est plus fort\nque la haine,\ncar il construit\nquand la haine\nd√©truit...',
                        mode: 'briques',
                        duree: 16000,
                        transition: 'fire',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P13_AMOUR_CONSTRUCTION',
                        phase: 13,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'On m\'a dit que la tol√©rance\n√©tait une faiblesse,\nmais j\'ai vu qu\'elle est\nune sagesse :\ncelle de reconna√Ætre\nque nous ne sommes pas tous\nsemblables...\nEt c\'est l√†\nle tr√©sor de la vie,\nla voie vers\nla paix.',
                        mode: 'coeurs',
                        duree: 10000,
                        transition: 'shadow3d',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P14_TOLERANCE_SAGESSE',
                        phase: 14,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'La diversit√©‚Ä¶\nElle n\'est pas un danger,\nelle est un tr√©sor.\nComme les couleurs\nd\'un arc-en-ciel,\nc\'est leur diff√©rence\nqui fait na√Ætre la beaut√©.',
                        mode: 'nuit_coeurs',
                        duree: 12000,
                        transition: 'typewriter',
                        speed: 42
                    },
                    {
                        id: 'VDV_NARR_P15_DIVERSITE_TRESOR',
                        phase: 15,
                        titre: 'Voyage ‚Äî L\'unit√©',
                        texte: 'Et dans ce m√©lange\nd\'humanit√©,\nj\'ai compris\nque nous sommes\nun seul peuple,\nli√© par la m√™me\nsoif de vivre,\nde cr√©er,\net d\'aimer.',
                        mode: 'briques',
                        duree: 10000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P16_UNITE_HUMANITE',
                        phase: 16,
                        titre: 'L\'Unit√© de l\'Humanit√©',
                        texte: 'Nous avons construit des murs l√† o√π il fallait des ponts.\nDress√© des fronti√®res l√† o√π coulaient des rivi√®res communes.\n\nMais quand enfin nous comprenons,\nquand les murs tombent dans nos c≈ìurs,\nquand la peur c√®de place √† la curiosit√©,\nna√Æt cette unit√© qui engendre la paix v√©ritable.\n\nNon pas l\'uniformit√© qui efface,\nmais l\'harmonie qui respecte chaque diff√©rence,\ncette paix qui grandit quand nous r√©alisons\nque nous ne sommes qu\'un seul peuple sous les √©toiles.',
                        mode: 'briques',
                        duree: 15000,
                        transition: 'neon',
                        speed: 40
                    },
                    // === NOUVEAU CHAPITRE : LE MUR D'AVARICE ===
                    {
                        id: 'VDV_NARR_P17_MUR_VISION',
                        phase: 17,
                        titre: 'Voyage ‚Äî Le Mur d\'avarice',
                        texte: 'Au loin‚Ä¶ je vois un mur.\nUn mur dress√© dans la mer comme une cicatrice.\nUn mur qui n\'est pas fait de pierres,\nmais de lois, de papiers et de regards ferm√©s.',
                        mode: 'mur',
                        duree: 12000,
                        transition: 'emboss',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P18_MUR_PRISON',
                        phase: 18,
                        titre: 'Voyage ‚Äî Prison de libert√©',
                        texte: 'Ce mur est la prison de la libert√© des hommes.\nIl s√©pare ceux qui peuvent courir sans cha√Ænes,\net ceux qu\'on enferme dans des fronti√®res invisibles.',
                        mode: 'mur',
                        duree: 11000,
                        transition: 'glitch',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P19_MUR_PAUVRES',
                        phase: 19,
                        titre: 'Voyage ‚Äî Barbel√©s de refus',
                        texte: 'Pour les pauvres, il est barbel√© de refus,\nferm√© comme une porte rouill√©e.\nIls y frappent de leurs mains nues,\nleurs r√™ves bris√©s par le silence des gardiens.',
                        mode: 'mur',
                        duree: 12000,
                        transition: 'neon',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P20_MUR_RICHES',
                        phase: 20,
                        titre: 'Voyage ‚Äî Porte d\'or',
                        texte: 'Pour les riches, il est une porte d\'or.\nElle s\'ouvre sans effort,\net les laisse circuler comme le vent qui n\'a pas de patrie.',
                        mode: 'mur',
                        duree: 11000,
                        transition: 'emboss',
                        speed: 50
                    },
                    {
                        id: 'VDV_NARR_P21_MUR_QUESTION',
                        phase: 21,
                        titre: 'Voyage ‚Äî Question de libert√©',
                        texte: 'Alors je me demande‚Ä¶\nLa libert√© est-elle vraiment un droit,\nou est-elle devenue un privil√®ge vendu aux plus offrants ?',
                        mode: 'mur',
                        duree: 11000,
                        transition: 'glitch',
                        speed: 45
                    },
                    {
                        id: 'VDV_NARR_P22_MUR_ESPOIR',
                        phase: 22,
                        titre: 'Voyage ‚Äî L\'espoir des vagues',
                        texte: 'Mais dans le c≈ìur des vagues,\nla mer murmure une v√©rit√© :\naucun mur n\'est √©ternel.\nCar l\'eau finit toujours par user la pierre,\net la libert√©, t√¥t ou tard,\nreprendra son chemin.\n\n\n--- G√âN√âRIQUE ---\n\nUn r√©cit interactif sur l\'unit√© humaine\n\nMerci d\'avoir jou√©\n\n‚ú® FIN ‚ú®',
                        mode: 'final',
                        duree: 25000,
                        transition: 'neon',
                        speed: 40
                    }
                ];
            }

            // Obtenir la phase actuelle
            getCurrentPhase() {
                // Trouver la phase par son num√©ro au lieu d'utiliser l'index
                return this.phases.find(phase => phase.phase === this.currentPhase) || null;
            }

            // Obtenir la phase par ID
            getPhaseById(id) {
                return this.phases.find(phase => phase.id === id) || null;
            }

            // Avancer √† la prochaine phase
            nextPhase() {
                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    console.log('üö´ Mode secret actif, nextPhase bloqu√©');
                    return false;
                }
                if (modeSecret) {
                    console.log('üö´ Mode secret actif (fallback), nextPhase bloqu√©');
                    return false;
                }

                // Trouver la phase suivante par num√©ro
                const nextPhaseNumber = this.currentPhase + 1;
                const nextPhase = this.phases.find(phase => phase.phase === nextPhaseNumber);

                if (nextPhase) {
                    this.currentPhase = nextPhaseNumber;
                    return true;
                } else {
                    return false; // Fin de la narration
                }
            }

            // R√©initialiser la narration
            reset() {
                // // console.log(`[DEBUG] reset() appel√© - retour currentPhase √† 1`);
                this.currentPhase = 1;
                this.phaseHistory = [];
                this.isTransitioning = false;
                this.victoryTimers.clear();
                this.hideStepIndicator();
            }

            // D√©marrer la narration
            start() {
                // // console.log(`[DEBUG] start() appel√© - appel reset() puis executeCurrentPhase()`);
                // console.trace(`[DEBUG] Trace de l'appel start():`);
                this.reset();
                this.executeCurrentPhase(true); // true = afficher texte narratif
            }

            // Ex√©cuter la phase actuelle
            executeCurrentPhase(afficherTexte = false) {
                const phase = this.getCurrentPhase();
                if (!phase) {
                    this.finalizeNarration();
                    return;
                }

                // Afficher le titre du voyage au d√©but de la phase
                this.afficherTitreVoyage(true); // true = d√©but de phase

                console.log(`[NARRATION] Ex√©cution phase ${phase.phase}: ${phase.id}`);
                this.phaseHistory.push(phase.id);

                this.isTransitioning = true;

                // Mettre √† jour l'indicateur d'√©tape
                this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                // Plus besoin d'afficher le texte narratif DOM - toutes les phases utilisent maintenant afficherMessageNarratifSimple()
                if (false && afficherTexte && phase && phase.texte) {
                    this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);
                }

                // Pour les modes non-interactifs, programmer un nextPhase automatique
                if (phase.mode !== 'coeurs' && phase.mode !== 'briques' && phase.mode !== 'nuit_coeurs' && phase.mode !== 'etoiles') {
                    setTimeout(() => {
                        this.nextPhase();
                        this.executeCurrentPhase();
                    }, phase.duree);
                }

                // Configurer le mode de jeu
                this.configureGameMode(phase.mode);

                // Marquer la transition comme termin√©e apr√®s configuration
                this.isTransitioning = false;
            }

            // Afficher le titre du voyage
            afficherTitreVoyage(debutPhase = false) {
                const phase = this.currentPhase;
                let voyageNom = '';

                if (phase === 1) {
                    voyageNom = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageNom = 'La lumi√®re';
                } else if (phase >= 3 && phase <= 4) {
                    voyageNom = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageNom = 'Le silence de l\'√¢me';
                } else if (phase >= 7 && phase <= 9) {
                    voyageNom = 'L\'humanit√© des c≈ìurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageNom = 'La sagesse des diff√©rences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageNom = 'L\'unit√©';
                } else if (phase === 16) {
                    voyageNom = 'Animation finale';
                }

                if (voyageNom) {
                    // D√©lai de 15 secondes pour la phase 1 au d√©but, imm√©diat pour les autres cas
                    const delai = (phase === 1 && debutPhase) ? 15000 : 0;

                    setTimeout(() => {
                        titreVoyage.active = true;
                        titreVoyage.texte = voyageNom + '\nPhase ' + phase;
                        titreVoyage.fin = Date.now() + 5000; // 5 secondes
                    }, delai);
                }
            }

            // üìú MESSAGES NARRATIFS DES PHASES - Style simple centr√©
            afficherMessageAnime(texte, animation = 'emboss', speed = 45, onComplete) {
                // Utiliser afficherMessage() pour un affichage simple et direct
                afficherMessage(texte, 12000);

                // Appeler onComplete apr√®s la dur√©e du message si fourni
                if (onComplete) {
                    setTimeout(onComplete, 12000);
                }

                return; // Sortir pour √©viter l'ancien code

                switch(animation) {
                    case 'emboss':
                        anim.setColors('#ffffff', '#666666');
                        anim.applyEffect('emboss');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'neon':
                        anim.setColors('#64ffda', '#4da6ff');
                        anim.applyEffect('neon');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'shadow3d':
                        anim.setColors('#ffffff', '#333333');
                        anim.applyEffect('shadow3d');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'glitch':
                        anim.setColors('#ff4444', '#ff6666');
                        anim.applyEffect('glitch');
                        anim.digital(texte, speed, onComplete);
                        break;
                    case 'fire':
                        anim.setColors('#ff4444', '#ff8800');
                        anim.applyEffect('fire');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    case 'ice':
                        anim.setColors('#ffffff', '#ffffff');
                        anim.applyEffect('none');
                        anim.typewriter(texte, speed, onComplete);
                        break;
                    default:
                        anim.typewriter(texte, speed, onComplete);
                        break;
                }

                // Note: isTransitioning est maintenant remis √† false directement dans executeCurrentPhase
            }

            // Mettre √† jour l'indicateur d'√©tape
            updateStepIndicator(phase, titre, mode) {
                const indicateur = document.getElementById('etapeIndicateur');
                if (!indicateur) return;

                // Ic√¥ne selon le mode
                let icone = '';
                switch(mode) {
                    case 'coeurs': icone = 'üíñ'; break;
                    case 'nuit_coeurs': icone = 'üåôüíñ'; break;
                    case 'briques': icone = 'üß±'; break;
                    case 'etoiles': icone = '‚≠ê'; break;
                    case 'mur': icone = 'üß±'; break;
                    case 'final': icone = '‚ú®'; break;
                    default: icone = 'üìñ'; break;
                }

                // Mettre √† jour le contenu
                indicateur.innerHTML = `
                    <div>${icone} ${phase}/22</div>
                    <div style="font-size: 10px; margin-top: 2px; opacity: 0.8;">${titre}</div>
                `;

                // Afficher l'indicateur
                indicateur.classList.add('show');
            }

            // Cacher l'indicateur d'√©tape
            hideStepIndicator() {
                const indicateur = document.getElementById('etapeIndicateur');
                if (indicateur) {
                    indicateur.classList.remove('show');
                }
            }

            // Configurer le mode de jeu selon la phase
            configureGameMode(mode) {
                // Ne pas reconfigurer si on est d√©j√† dans le bon mode
                if (phaseJeu === mode ||
                    (mode === 'coeurs' && phaseJeu === 'tir_coeurs_haut') ||
                    (mode === 'nuit_coeurs' && phaseJeu === 'tir_coeurs_nuit') ||
                    (mode === 'briques' && phaseJeu === 'lanterne') ||
                    (mode === 'etoiles' && phaseJeu === 'stars')) {
                    // console.log(`[DEBUG] D√©j√† dans le bon mode: ${phaseJeu} pour ${mode}`);
                    return;
                }

                switch(mode) {
                    case 'coeurs':
                        this.setupCoeursMode();
                        break;
                    case 'nuit_coeurs':
                        this.setupNuitCoeursMode();
                        break;
                    case 'briques':
                        this.setupBriquesMode();
                        break;
                    case 'etoiles':
                        this.setupEtoilesMode();
                        break;
                    case 'mur':
                        this.setupMurMode();
                        break;
                    case 'final':
                        this.setupFinalMode();
                        break;
                }
            }

            // D√©terminer la p√©riode selon la phase (P3, P5, P11, P12 = nuit)
            getPeriodeFromPhase(phaseNumber) {
                return (phaseNumber === 3 || phaseNumber === 5 || phaseNumber === 11 || phaseNumber === 12) ? 'nuit' : 'jour';
            }

            // Configuration mode c≈ìurs
            setupCoeursMode() {
                const phase = this.getCurrentPhase();

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet nuit selon la p√©riode
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les √©toiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les √©clairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = window.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode nuit c≈ìurs (parties ambigu√´s)
            setupNuitCoeursMode() {
                const phase = this.getCurrentPhase();

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'tir_coeurs_haut';
                jeu = true;
                initJeu();
                creerPetitsCoeurs();
                // Effet visuel de nuit - fond sombre sans affecter les √©toiles/lanterne
                document.body.style.backgroundColor = '#1a1a2e';
                document.body.style.filter = '';

                // Initialiser les √©clairs pour le mode nuit
                eclairNuit.tempsProchainEclair = Date.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
            }

            // Configuration mode briques
            setupBriquesMode() {
                const phase = this.getCurrentPhase();

                // TOUTES LES PHASES : Utiliser afficherMessageNarratifSimple() pour les textes narratifs
                if (this.currentPhase === 1) {
                    // TEST I18N: utiliser le syst√®me de traduction
                    const narrativeText = window.t ? window.t('phases.phase1.narrative') :
                        `üåü "On m'a dit qu'ils √©taient tous des monstres...
‚ú® On m'a dit tant de mal, tant de malheurs sur eux...
üîç Mais moi, j'ai pr√©f√©r√© aller voir de mes propres yeux."`;
                    afficherMessageNarratifSimple(narrativeText, 8000);
                } else if (this.currentPhase === 2) {
                    afficherMessageNarratifSimple(`ü§î "Qui √©taient-ils vraiment ?...
Et j'ai vu...

üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Un p√®re... une m√®re... des enfants...

üíô Tous cherchant simplement
√† vivre
leur meilleure vie...
Comme moi."`, 10000);
                } else if (this.currentPhase === 3) {
                    afficherMessageNarratifSimple(`üåô "Alors, la lune apparut.
üìñ Le ciel s'assombrit comme une page br√ªl√©e par le temps.
ü¶à Un aileron fendit les vagues sombres...
‚ö° Des √©clairs z√©br√®rent les nuages gris."`, 8000);
                } else if (this.currentPhase === 4) {
                    afficherMessageNarratifSimple(`‚ö° "Le chapitre 2 commen√ßa dans l'obscurit√©...
üåä Les vagues devinrent plus hautes, plus mena√ßantes.
üíÄ Et dans cette obscurit√©, j'ai vu autre chose...
üëÅÔ∏è Des regards qui me fixaient depuis les profondeurs."`, 9000);
                } else if (this.currentPhase === 5) {
                    afficherMessageNarratifSimple(`üëÅÔ∏è "Dans l'obscurit√©, une premi√®re vision m'apparut...
üîÆ Des formes √©tranges dansaient dans les t√©n√®bres.
üåü √âtait-ce r√©el ? √âtait-ce un r√™ve ?
‚ùì Je ne savais plus faire la diff√©rence."`, 8500);
                } else if (this.currentPhase === 6) {
                    afficherMessageNarratifSimple(`ü§∑ "Mais plus j'avan√ßais, plus mes certitudes s'√©branlaient...
üí≠ Qui avait raison ? Qui avait tort ?
üåä Les vagues emportaient mes convictions.
üîç Il me fallait creuser plus profond."`, 9500);
                } else if (this.currentPhase === 7) {
                    afficherMessageNarratifSimple(`üí° "Soudain, une lumi√®re per√ßa les nuages...
üìú Une v√©rit√© partielle se r√©v√©la √† moi.
‚öñÔ∏è Ni tout blanc, ni tout noir...
üåà Mais un d√©grad√© de couleurs complexes."`, 8000);
                } else if (this.currentPhase === 8) {
                    afficherMessageNarratifSimple(`üìñ "Ainsi se termina le premier chapitre de mon voyage...
üé≠ Entre les masques et les visages r√©els.
üö™ Une porte s'ouvrait vers de nouveaux myst√®res.
‚û°Ô∏è Il √©tait temps de continuer l'exploration."`, 10000);
                } else if (this.currentPhase === 9) {
                    afficherMessageNarratifSimple(`üí≠ "On m'a dit...
que l'humanit√© n'existait plus,
qu'elle s'√©tait perdue dans les guerres et les rancunes.
üè† On m'a dit que les hommes n'accueillaient plus personne,
qu'ils s'enfermaient derri√®re des murs de fer et de peur."`, 9000);
                } else if (this.currentPhase === 10) {
                    afficherMessageNarratifSimple(`‚úã "Mais moi, j'ai vu‚Ä¶
Une main tendue √† un √©tranger.
üòä Un sourire partag√© malgr√© la faim.
üö™ Une porte ouverte pour celui qui tremblait dans la nuit."`, 8500);
                } else if (this.currentPhase === 11) {
                    afficherMessageNarratifSimple(`ü§ù "C'est cela, l'hospitalit√© :
non pas donner ce qu'on a de trop,
mais partager m√™me ce qui manque."`, 7000);
                } else if (this.currentPhase === 12) {
                    afficherMessageNarratifSimple(`üóΩ "On m'a dit que la libert√© n'√©tait qu'un mot,
une illusion que les puissants vendaient aux faibles.
üèÉ‚Äç‚ôÇÔ∏è Mais j'ai vu‚Ä¶
Un enfant courir pieds nus sous la pluie,
riant sans cha√Ænes,
‚ú® et dans ses rires, j'ai compris que la libert√© vit d'abord dans l'√¢me."`, 10000);
                } else if (this.currentPhase === 13) {
                    afficherMessageNarratifSimple(`üí™ "On m'a dit que les hommes n'aidaient plus,
que chacun ne vivait que pour soi.
ü™® Mais j'ai vu‚Ä¶
Des inconnus soulever ensemble une pierre trop lourde,
‚ù§Ô∏è et dans cette force partag√©e, j'ai vu l'amour na√Ætre."`, 9000);
                } else if (this.currentPhase === 14) {
                    afficherMessageNarratifSimple(`üíî "On m'a dit que l'amour √©tait fragile,
üíù mais j'ai vu qu'il est plus fort que la haine,
üèóÔ∏è car il construit quand la haine d√©truit."`, 7500);
                } else if (this.currentPhase === 15) {
                    afficherMessageNarratifSimple(`ü§ù "On m'a dit que la tol√©rance √©tait une faiblesse,
üß† mais j'ai vu qu'elle est une sagesse,
celle de reconna√Ætre que nous ne sommes pas tous semblables,
üåà et que c'est bien ainsi."`, 8500);
                } else if (this.currentPhase === 16) {
                    afficherMessageNarratifSimple(`üåÖ "Ainsi se termine mon premier voyage...

üåà J'ai vu la diversit√© comme un tr√©sor,
l'humanit√© comme une famille,
et la v√©rit√© comme un arc-en-ciel de nuances.

‚öì Mon bateau touche maintenant le rivage...
Mais au loin, dans la brume,
je vois quelque chose d'√©trange...

üß± Un mur... dans la mer..."`, 12000);
                } else if (this.currentPhase === 17) {
                    afficherMessageNarratifSimple(`üåä "Au loin‚Ä¶ je vois un mur.
Un mur dress√© dans la mer comme une cicatrice.
Un mur qui n'est pas fait de pierres,
mais de lois, de papiers et de regards ferm√©s."`, 9000);
                } else if (this.currentPhase === 18) {
                    afficherMessageNarratifSimple(`‚õìÔ∏è "Ce mur est la prison de la libert√© des hommes.
Il s√©pare ceux qui peuvent courir sans cha√Ænes,
et ceux qu'on enferme dans des fronti√®res invisibles."`, 8500);
                } else if (this.currentPhase === 19) {
                    afficherMessageNarratifSimple(`üíî "Pour les pauvres, il est barbel√© de refus,
ferm√© comme une porte rouill√©e.
Ils y frappent de leurs mains nues,
leurs r√™ves bris√©s par le silence des gardiens."`, 10000);
                } else if (this.currentPhase === 20) {
                    afficherMessageNarratifSimple(`üí∞ "Pour les riches, il est une porte d'or.
Elle s'ouvre sans effort,
et les laisse circuler comme le vent qui n'a pas de patrie."`, 12000);
                } else if (this.currentPhase === 21) {
                    afficherMessageNarratifSimple(`‚ùì "Alors je me demande‚Ä¶
La libert√© est-elle vraiment un droit,
ou est-elle devenue un privil√®ge vendu aux plus offrants ?"`, 11000);
                } else if (this.currentPhase === 22) {
                    afficherMessageNarratifSimple(`üåä "Mais dans le c≈ìur des vagues,
la mer murmure une v√©rit√© :
aucun mur n'est √©ternel.
Car l'eau finit toujours par user la pierre,
et la libert√©, t√¥t ou tard,
reprendra son chemin."`, 15000);
                } else if (this.currentPhase === 23) {
                    afficherMessageNarratifSimple(`üß± "Le mur dans la mer ne retient ni les vagues ni les r√™ves.
Il s'√©l√®ve, orgueilleux et vain,
et prive l'humanit√© de sa libert√©."`, 10000);
                }

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;

                // En mode nuit, alterner entre briques et √©toiles apr√®s phase 3
                if(periode === 'nuit') {
                    if(this.currentPhase <= 3) {
                        // Phase 3 et avant : toujours √©toiles
                        phaseJeu = 'stars';
                    } else {
                        // Apr√®s phase 3 : alterner entre les phases nocturnes restantes
                        // Phase 5 = √©toiles | Phase 11 = √©toiles | Phase 12 = briques
                        if(this.currentPhase === 12) {
                            phaseJeu = 'lanterne'; // Mode briques en mode nuit
                            balle.visible = true;
                            balle.enAttente = true;
                            balle.dx = 0;
                            balle.dy = 0;
                        } else {
                            phaseJeu = 'stars'; // Mode √©toiles tirables pour P5 et P11
                        }
                    }
                } else {
                    phaseJeu = 'lanterne'; // Mode classique casse-briques avec lanterne
                    balle.visible = true;
                    balle.enAttente = true;
                    balle.dx = 0;
                    balle.dy = 0;
                }

                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
                // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                // lanterne.active et lanterne.intensite conserv√©s

                // Effet nuit selon la p√©riode
                if(periode === 'nuit') {
                    // Fond sombre sans affecter les √©toiles/lanterne
                    document.body.style.backgroundColor = '#1a1a2e';
                    // Initialiser les √©clairs pour le mode nuit
                    eclairNuit.tempsProchainEclair = window.now() + Math.random() * 10000 + 5000; // Premier √©clair dans 5-15s
                } else {
                    // Retour au fond normal
                    document.body.style.backgroundColor = '';
                }
                document.body.style.filter = '';
            }

            // Configuration mode √©toiles
            setupEtoilesMode() {
                const phase = this.getCurrentPhase();

                // D√©terminer automatiquement la p√©riode selon la phase
                periode = this.getPeriodeFromPhase(this.currentPhase);
                VOYAGE = (periode === 'nuit') ? NUIT : JOUR;
                phaseJeu = 'stars';
                jeu = true;
                initJeu();
                dedoublerCoeursEnBriques();
            }

            // Configuration mode mur - gameplay de destruction du mur
            setupMurMode() {
                const phase = this.getCurrentPhase();

                // Configuration du mode mur
                periode = 'jour'; // Le mur est en plein jour
                VOYAGE = JOUR;
                phaseJeu = 'mur'; // Nouveau mode de jeu
                jeu = true;

                // Initialiser le jeu avec des briques en forme de mur
                initJeu();
                creerMurDansLaMer();
            }

            // Configuration mode final
            setupFinalMode() {
                const phase = this.getCurrentPhase();

                setTimeout(() => {
                    this.finalizeNarration();
                }, phase.duree + 2000);
            }

            // Finaliser la narration
            finalizeNarration() {
                phaseJeu = 'feux_artifice';
                jeu = false;

                // Cacher l'indicateur d'√©tape
                this.hideStepIndicator();

                // S√©quence finale avec feux d'artifice
                if (droneModule) {
                    const formations = ['hexagon', 'star', 'heart', 'cross'];
                    const formationsChoixies = [];

                    for(let i = 0; i < 3; i++) {
                        const index = Math.floor(Math.random() * formations.length);
                        formationsChoixies.push(formations[index]);
                    }

                    formationsChoixies.forEach((formation, index) => {
                        setTimeout(() => {
                            const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                            const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                            droneModule.moveFormationTo(x, y);
                            droneModule.setFormation(formation);

                            setTimeout(() => {
                                droneModule.explode(x, y);
                            }, 800);
                        }, index * 1500);
                    });
                }

                setTimeout(() => {
                    this.showFinalMenu();
                }, 6000);
            }

            // G√©n√©rer un r√©sum√© √©l√©gant en 3 lignes
            generateElegantSummary() {
                const completedCount = Math.min(this.currentPhase, this.phases.length);
                const progressPercent = Math.round((completedCount / this.phases.length) * 100);

                return `
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: linear-gradient(145deg, rgba(100,255,218,0.1), rgba(100,255,218,0.05)); border-radius: 12px; border: 1px solid rgba(100,255,218,0.3);">
                        <div style="color: #64ffda; font-size: 16px; font-weight: 600; margin-bottom: 6px;">
                            ‚ú® ${completedCount}/16 CHAPITRES (${progressPercent}%) ‚ú®
                        </div>
                        <div style="color: #ffffff; font-size: 14px; margin: 4px 0; opacity: 0.9;">
                            üìö De "La Lumi√®re" √† "L'Unit√© de l'Humanit√©"
                        </div>
                        <div style="color: #cccccc; font-size: 12px; font-style: italic; opacity: 0.8;">
                            Un voyage √† travers la v√©rit√© de l'humanit√©
                        </div>
                    </div>
                `;
            }

            // Afficher le menu final
            showFinalMenu() {
                const msg = document.getElementById('message');
                msg.classList.remove('narratif');
                msg.classList.add('show');
                msg.style.transform = 'translate(-50%, -50%) scale(1)';
                msg.style.transition = '';

                const summaryHTML = this.generateElegantSummary();

                const boutonsHTML = `
                    <div style="margin-top: 15px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="narrationManager.restart()"
                                style="background: linear-gradient(45deg, #64ffda, #4da6ff);
                                       color: #1a1a1a; border: none; padding: 12px 24px;
                                       border-radius: 25px; font-size: 14px; font-weight: 600;
                                       cursor: pointer; transform: scale(1);
                                       transition: all 0.3s ease;
                                       box-shadow: 0 3px 10px rgba(100,255,218,0.3);
                                       text-shadow: 0 1px 2px rgba(0,0,0,0.2);
                                       letter-spacing: 0.5px;">
                            üîÑ Recommencer
                        </button>
                    </div>
                `;

                const titleHTML = `
                    <div style="text-align: center; margin-bottom: 8px;">
                        <div style="color: #64ffda; text-shadow: 0 0 10px rgba(100,255,218,0.8); margin: 0; font-size: 22px; font-weight: 600; letter-spacing: 1px;">
                            üëÅÔ∏è VOIR LA V√âRIT√â
                        </div>
                        <div style="color: #ffffff; margin: 5px 0; font-size: 16px; font-weight: 300; opacity: 0.9;">
                            Aventure termin√©e ‚ú®
                        </div>
                    </div>
                `;

                msg.innerHTML = titleHTML + summaryHTML + boutonsHTML;
            }

            // Red√©marrer la narration
            restart() {
                cacherMessage();

                // R√©initialiser compl√®tement
                periode = 'jour';
                VOYAGE = JOUR;
                phaseJeu = 'tir_coeurs_haut';
                score = 0;
                vies = 3;
                brises = 0;
                jeu = false;

                // R√©initialiser les syst√®mes
                animationBateau.active = false;
                phaseIntro.active = true;
                narrationManager.reset();

                // Nettoyer les √©l√©ments
                briques = [];
                projectiles = [];
                starsProjectiles = [];
                particules = [];
                powerUps = [];

                initJeu();
                creerPetitsCoeurs();

                // Continuer √† la phase courante apr√®s un d√©lai (sans reset)
                setTimeout(() => {
                    this.executeCurrentPhase();
                }, 1000);
            }

            // Fonction appel√©e √† la fin d'une phase
            onPhaseComplete() {
                if (this.isTransitioning) return;

                // Cr√©er un timer de victoire unique
                const timerId = `victory_${Date.now()}_${Math.random()}`;

                this.victoryTimers.set(timerId, setTimeout(() => {
                    this.victoryTimers.delete(timerId);
                    // R√©initialiser les compteurs pour la prochaine phase
                    brises = 0;

                    if (this.nextPhase()) {
                        this.executeCurrentPhase();
                    } else {
                        this.finalizeNarration();
                    }
                }, 1500));
            }

            // M√©thode pour avancer directement √† la phase suivante sans narration
            goToNextPhase() {
                if (this.isTransitioning) return;

                // console.log(`[DEBUG] goToNextPhase - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    // console.log(`[DEBUG] goToNextPhase - currentPhase apr√®s nextPhase: ${this.currentPhase}`);
                    this.executeCurrentPhase();
                } else {
                    this.finalizeNarration();
                }
            }

            // Progression directe sans narration - pour la fin des modes
            goToNextPhaseDirect() {
                if (this.isTransitioning) {
                    console.log('üö´ Transition d√©j√† en cours, ignore goToNextPhaseDirect');
                    return;
                }

                // Bloquer les changements de phase si le mode secret est actif
                if (secretModeModule && secretModeModule.isActive) {
                    console.log('üö´ Mode secret actif, changement de phase bloqu√©');
                    return;
                }
                if (modeSecret) {
                    console.log('üö´ Mode secret actif (fallback), changement de phase bloqu√©');
                    return;
                }

                console.log(`üé¨ goToNextPhaseDirect - currentPhase avant: ${this.currentPhase}`);
                this.isTransitioning = true;
                brises = 0;

                if (this.nextPhase()) {
                    console.log(`‚úÖ goToNextPhaseDirect - currentPhase apr√®s nextPhase: ${this.currentPhase}`);
                    const phase = this.getCurrentPhase();
                    if (phase) {
                        // Afficher le titre du voyage
                        this.afficherTitreVoyage();

                        // Mettre √† jour l'indicateur d'√©tape
                        this.updateStepIndicator(phase.phase, phase.titre, phase.mode);

                        // Plus besoin d'afficher le texte narratif DOM - toutes les phases utilisent maintenant afficherMessageNarratifSimple()
                        if (false && phase.texte) {
                            this.afficherMessageAnime(phase.texte, phase.transition, phase.speed);
                        }

                        // console.log(`[DEBUG] Configuration mode ${phase.mode} pour phase ${phase.phase}: ${phase.id}`);

                        // Configurer directement le mode de jeu
                        this.configureGameMode(phase.mode);

                        // Marquer la transition comme termin√©e apr√®s tout
                        setTimeout(() => {
                            this.isTransitioning = false;
                        }, 100);
                    }
                } else {
                    this.finalizeNarration();
                }
            }

            // Alias pour compatibilit√© avec l'ancien code
            onLevelComplete() {
                this.onPhaseComplete();
            }
        }

        // Instance globale du gestionnaire de narration
        const narrationManager = new NarrationManager();

        // ===============================================
        // COMPATIBILIT√â AVEC L'ANCIEN SYST√àME
        // ===============================================

        // ===============================================
        // MODULE FEUX D'ARTIFICE DRONES - VERSION JEU
        // Par Emmanuel Payet - Dreamer Unisona
        // ===============================================

        class DroneFireworksModule {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = {
                    droneCount: options.droneCount || 12,
                    size: options.size || 150,
                    speed: options.speed || 0.03,
                    showTrails: options.showTrails !== false,
                    autoMode: options.autoMode || false,
                    formations: options.formations || ['hexagon', 'star', 'heart', 'cross'],
                    ...options
                };

                this.drones = [];
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
                this.currentFormation = 'hexagon';
                this.explosionMode = false;
                this.autoMode = false;
                this.autoInterval = null;
                this.currentFormationIndex = 0;

                this.init();
            }

            init() {
                this.createDrones();
                // Ne pas appliquer de formation au d√©but - les drones restent hors √©cran
                // Animation continue mais sans efface de fond
            }

            createDrones() {
                this.drones = [];
                for (let i = 0; i < this.options.droneCount; i++) {
                    this.drones.push(new Drone(
                        -100, // Commencer hors √©cran √† gauche
                        -100, // Commencer hors √©cran en haut
                        i
                    ));
                }
            }

            setFormation(formation) {
                this.currentFormation = formation;
                const positions = this.getFormationPositions(formation, this.drones.length, this.options.size);

                this.drones.forEach((drone, index) => {
                    if (positions[index]) {
                        drone.setTarget(positions[index].x, positions[index].y);
                    }
                });
            }

            explode(x, y) {
                const explosionRadius = 120;

                this.drones.forEach(drone => {
                    const distance = Math.sqrt(
                        Math.pow(drone.x - x, 2) + Math.pow(drone.y - y, 2)
                    );

                    if (distance < explosionRadius) {
                        drone.explode(x, y, explosionRadius);
                    }
                });

                setTimeout(() => {
                    this.drones.forEach(drone => {
                        drone.resetToFormation();
                    });
                }, 2000);
            }

            fireworks() {
                this.drones.forEach(drone => {
                    drone.firework();
                });

                setTimeout(() => {
                    this.createDrones();
                    this.setFormation(this.currentFormation);
                }, 3000);
            }

            getFormationPositions(formation, count, size) {
                const positions = [];
                const centerX = this.targetX;
                const centerY = this.targetY;

                switch (formation) {
                    case 'hexagon':
                        let angle = 0, radius = 0, pointsOnRing = 6, pointsPlaced = 0;
                        for (let i = 0; i < count; i++) {
                            if (i === 0) {
                                positions.push({x: centerX, y: centerY});
                            } else {
                                positions.push({
                                    x: centerX + Math.cos(angle) * radius,
                                    y: centerY + Math.sin(angle) * radius
                                });
                                angle += (Math.PI * 2) / pointsOnRing;
                                pointsPlaced++;
                                if (pointsPlaced >= pointsOnRing) {
                                    radius += size / 4;
                                    pointsOnRing += 6;
                                    pointsPlaced = 0;
                                    angle = 0;
                                }
                            }
                        }
                        break;

                    case 'star':
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const starRadius = (i % 2 === 0) ? size : size * 0.6;
                            positions.push({
                                x: centerX + Math.cos(angle) * starRadius,
                                y: centerY + Math.sin(angle) * starRadius
                            });
                        }
                        break;

                    case 'heart':
                        for (let i = 0; i < count; i++) {
                            const t = (i / count) * Math.PI * 2;
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            positions.push({
                                x: centerX + x * size / 50,
                                y: centerY + y * size / 50
                            });
                        }
                        break;

                    case 'cross':
                        const armWidth = Math.floor(count / 4);
                        for (let i = 0; i < armWidth * 2; i++) {
                            positions.push({
                                x: centerX,
                                y: centerY - size + (i * size * 2) / (armWidth * 2)
                            });
                        }
                        for (let i = 0; i < count - armWidth * 2; i++) {
                            positions.push({
                                x: centerX - size + (i * size * 2) / (count - armWidth * 2),
                                y: centerY
                            });
                        }
                        break;
                }

                return positions;
            }

            animate() {
                // Animation s√©par√©e pour mise √† jour seulement (sans rendu)
                this.drones.forEach(drone => {
                    drone.update(this.options);
                });
            }

            render() {
                // Rendu s√©par√© √† appeler depuis la boucle de jeu
                this.drones.forEach(drone => {
                    drone.draw(this.ctx, this.options);
                });
            }

            moveFormationTo(x, y) {
                this.targetX = x;
                this.targetY = y;
                this.setFormation(this.currentFormation);
            }
        }

        class Drone {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.color = this.getRandomColor();
                this.brightness = Math.random() * 0.4 + 0.6;
                this.trail = [];
                this.explosionVelX = 0;
                this.explosionVelY = 0;
                this.life = 1.0;
                this.inExplosion = false;
            }

            getRandomColor() {
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            explode(explosionX, explosionY, radius) {
                const distance = Math.sqrt(Math.pow(this.x - explosionX, 2) + Math.pow(this.y - explosionY, 2));
                if (distance < radius) {
                    const angle = Math.atan2(this.y - explosionY, this.x - explosionX);
                    const force = (radius - distance) / radius * 18;

                    this.explosionVelX = Math.cos(angle) * force;
                    this.explosionVelY = Math.sin(angle) * force - 6;
                    this.inExplosion = true;
                    this.life = 1.0;

                    const explosionColors = ['#FF4444', '#FF8800', '#FFFF00'];
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                }
            }

            firework() {
                this.explosionVelX = (Math.random() - 0.5) * 12;
                this.explosionVelY = (Math.random() - 0.5) * 12 - 7;
                this.inExplosion = true;
                this.life = 1.0;
            }

            resetToFormation() {
                this.inExplosion = false;
                this.color = this.getRandomColor();
                this.life = 1.0;
            }

            update(options) {
                if (this.inExplosion) {
                    this.x += this.explosionVelX;
                    this.y += this.explosionVelY;
                    this.explosionVelY += 0.3;
                    this.life -= 0.015;
                    if (this.life <= 0) this.life = 0;
                } else {
                    this.x += (this.targetX - this.x) * options.speed;
                    this.y += (this.targetY - this.y) * options.speed;
                }

                if (options.showTrails) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) this.trail.shift();
                }

                this.brightness = 0.6 + Math.sin(window.now() * 0.008 + this.id) * 0.2;
            }

            draw(ctx, options) {
                if (this.life <= 0) return;

                if (options.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = this.color + '60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                const glowSize = 8 + Math.sin(window.now() * 0.004 + this.id) * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, this.color + Math.floor(this.brightness * this.life * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(0.8, this.color + '30');
                gradient.addColorStop(1, this.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Variables globales pour les drones
        let droneModule = null;

        // ===============================================
        // MODULE D'ANIMATION DE TEXTE - VERSION JEU
        // Adapt√© pour int√©gration dans le jeu
        // ===============================================

        class TextAnimationModule {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentIndex = 0;
                this.timeoutId = null;
                this.text = '';
                this.options = {};
            }

            // Configuration des couleurs
            setColors(element, textColor = '#ffffff', effectColor = '#64ffda') {
                element.style.setProperty('--ta-text-color', textColor);
                element.style.setProperty('--ta-effect-color', effectColor);
                element.style.color = textColor;
            }

            // Arr√™te l'animation
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
            }

            // Reset
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.text = '';
            }

            // Animation machine √† √©crire avec support HTML complet
            typewriter(element, text, speed = 50, onComplete = null) {
                console.log('TextAnimationModule.typewriter appel√© avec:', {text: text.substring(0, 50), speed, element});
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.innerHTML = '';
                element.style.borderRight = '2px solid #64ffda';
                this.isRunning = true;
                console.log('D√©marrage _typewriterStep');

                this._typewriterStep(element);
            }

            _typewriterStep(element) {
                if (!this.isRunning) return;

                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    this.timeoutId = setTimeout(() => this._typewriterStep(element), 50);
                    return;
                }

                if (this.currentIndex < this.text.length) {
                    // Gestion des balises HTML et des \n
                    let currentChar = this.text.charAt(this.currentIndex);

                    // Si on trouve une balise HTML, on l'ajoute enti√®rement
                    if (currentChar === '<') {
                        let tagEnd = this.text.indexOf('>', this.currentIndex);
                        if (tagEnd !== -1) {
                            let fullTag = this.text.substring(this.currentIndex, tagEnd + 1);
                            element.innerHTML += fullTag;
                            this.currentIndex = tagEnd + 1;
                        } else {
                            element.innerHTML += currentChar;
                            this.currentIndex++;
                        }
                    } else if (currentChar === '\n') {
                        // G√©rer les sauts de ligne
                        element.innerHTML += '<br>';
                        this.currentIndex++;
                    } else {
                        element.innerHTML += currentChar;
                        this.currentIndex++;
                    }

                    this.timeoutId = setTimeout(() => this._typewriterStep(element), this.options.speed);
                } else {
                    element.style.borderRight = 'none';
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                }
            }

            // Animation fade avec support HTML
            fadeIn(element, text, duration = 1000, onComplete = null) {
                this.reset();
                element.innerHTML = text.replace(/\n/g, '<br>');
                element.style.opacity = '0';
                element.style.transition = `opacity ${duration}ms ease-in`;

                setTimeout(() => {
                    element.style.opacity = '1';
                }, 50);

                setTimeout(() => {
                    element.style.transition = '';
                    if (onComplete) onComplete();
                }, duration);
            }

            // Animation digital avec support HTML
            digital(element, text, speed = 50, onComplete = null) {
                this.text = text;
                this.options = {
                    speed: speed,
                    onComplete: onComplete
                };

                this.reset();
                element.style.color = '#00cc44';
                element.style.textShadow = '0 0 8px #00cc44';
                this.isRunning = true;

                this._digitalStep(element);
            }

            _digitalStep(element) {
                if (!this.isRunning) return;

                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    this.timeoutId = setTimeout(() => this._digitalStep(element), 50);
                    return;
                }

                if (this.currentIndex < this.text.length) {
                    let displayText = '';
                    let textOnly = this.text.replace(/<[^>]*>/g, '').replace(/\n/g, ' '); // Texte sans balises
                    let currentTextIndex = 0;

                    // Reconstitue le texte avec balises jusqu'√† la position actuelle
                    for (let i = 0; i < this.text.length && currentTextIndex < this.currentIndex; i++) {
                        if (this.text.charAt(i) === '<') {
                            let tagEnd = this.text.indexOf('>', i);
                            if (tagEnd !== -1) {
                                displayText += this.text.substring(i, tagEnd + 1);
                                i = tagEnd;
                            }
                        } else if (this.text.charAt(i) === '\n') {
                            displayText += '<br>';
                            currentTextIndex++;
                        } else {
                            displayText += this.text.charAt(i);
                            currentTextIndex++;
                        }
                    }

                    // Ajoute un caract√®re al√©atoire si on n'est pas √† la fin
                    if (this.currentIndex < textOnly.length) {
                        const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                        displayText += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }

                    element.innerHTML = displayText;

                    setTimeout(() => {
                        this.currentIndex++;
                        if (this.currentIndex < textOnly.length) {
                            this.timeoutId = setTimeout(() => this._digitalStep(element), this.options.speed);
                        } else {
                            element.innerHTML = this.text.replace(/\n/g, '<br>');
                            this.isRunning = false;
                            if (this.options.onComplete) this.options.onComplete();
                        }
                    }, this.options.speed / 2);
                }
            }

            // Animation glitch avec support HTML
            glitch(element, text, duration = 2000, onComplete = null) {
                this.reset();

                // Effet de glitch en pr√©servant le HTML
                let textOnly = text.replace(/<[^>]*>/g, '').replace(/\n/g, ' ');
                let glitchText = '';
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';

                // Reconstitue le texte avec des caract√®res glitch
                for (let i = 0; i < text.length; i++) {
                    if (text.charAt(i) === '<') {
                        let tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            glitchText += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text.charAt(i) === '\n') {
                        glitchText += '<br>';
                    } else {
                        if (Math.random() < 0.1 && text.charAt(i) !== ' ') {
                            glitchText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
                        } else {
                            glitchText += text.charAt(i);
                        }
                    }
                }

                element.innerHTML = glitchText;
                element.style.animation = 'ta-glitch 0.3s infinite';

                // Ajouter les keyframes pour l'animation glitch si pas d√©j√† pr√©sentes
                if (!document.querySelector('#glitch-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'glitch-keyframes';
                    style.textContent = `
                        @keyframes ta-glitch {
                            0%, 100% {
                                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
                                transform: translate(0);
                            }
                            20% {
                                text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
                                transform: translate(-2px, 2px);
                            }
                            40% {
                                text-shadow: 0 0 5px #0000ff, 0 0 10px #0000ff;
                                transform: translate(-2px, -2px);
                            }
                            60% {
                                text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00;
                                transform: translate(2px, 2px);
                            }
                            80% {
                                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
                                transform: translate(2px, -2px);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                setTimeout(() => {
                    element.innerHTML = text.replace(/\n/g, '<br>');
                    element.style.animation = 'none';
                    if (onComplete) onComplete();
                }, duration);
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üé¨ NOUVELLE CLASSE TEXTANIMATOR OPTIMIS√âE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class TextAnimator {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('TextAnimator: Element non trouv√©:', elementId);
                    return;
                }
                this.reset();
            }

            // √âtat et m√©thodes utilitaires optimis√©es
            reset() {
                this.stop();
                this.currentIndex = 0;
                this.element.innerHTML = '';
                // Garder les classes originales du message
                const originalClasses = this.element.className;
                this.element.className = originalClasses.replace(/ta-\w+/g, '').trim();
            }

            stop() {
                this.isRunning = false;
                if (this.timeoutId) clearTimeout(this.timeoutId);
            }

            setColors(textColor = '#ffffff', effectColor = '#64ffda') {
                this.element.style.setProperty('--ta-text-color', textColor);
                this.element.style.setProperty('--ta-effect-color', effectColor);
                this.element.style.color = textColor;
            }

            applyEffect(effect = 'none') {
                const effects = ['shadow3d', 'neon', 'emboss', 'outline', 'fire', 'ice'];
                effects.forEach(e => this.element.classList.remove(`ta-effect-${e}`));
                if (effect !== 'none') this.element.classList.add(`ta-effect-${effect}`);
            }

            // Animation machine √† √©crire optimis√©e
            typewriter(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-typewriter');
                this.isRunning = true;
                this._typewriterStep();
            }

            _typewriterStep() {
                if (!this.isRunning || this.currentIndex >= this.text.length) {
                    this.element.classList.remove('ta-typewriter');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    this.timeoutId = setTimeout(() => this._typewriterStep(), 50);
                    return;
                }

                const char = this.text.charAt(this.currentIndex);
                if (char === '<') {
                    const tagEnd = this.text.indexOf('>', this.currentIndex);
                    if (tagEnd !== -1) {
                        this.element.innerHTML += this.text.substring(this.currentIndex, tagEnd + 1);
                        this.currentIndex = tagEnd + 1;
                    } else {
                        this.element.innerHTML += char;
                        this.currentIndex++;
                    }
                } else if (char === '\n') {
                    this.element.innerHTML += '<br>';
                    this.currentIndex++;
                } else {
                    this.element.innerHTML += char;
                    this.currentIndex++;
                }

                this.timeoutId = setTimeout(() => this._typewriterStep(), this.options.speed);
            }

            // Animation code digital optimis√©e
            digital(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-digital');
                this.isRunning = true;
                this._digitalStep();
            }

            _digitalStep() {
                if (!this.isRunning) return;

                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    this.timeoutId = setTimeout(() => this._digitalStep(), 50);
                    return;
                }

                const textOnly = this.text.replace(/<[^>]*>/g, '');
                if (this.currentIndex >= textOnly.length) {
                    this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                    this.isRunning = false;
                    if (this.options.onComplete) this.options.onComplete();
                    return;
                }

                let displayText = this._buildHtmlText(this.currentIndex);
                const digitalChars = '01230456789ABCDEF<>{}[]()+-=*/\\\\|~^&%$#@!?';
                displayText += digitalChars[Math.floor(Math.random() * digitalChars.length)];

                this.element.innerHTML = displayText;

                setTimeout(() => {
                    this.currentIndex++;
                    if (this.currentIndex < textOnly.length) {
                        this.timeoutId = setTimeout(() => this._digitalStep(), this.options.speed);
                    } else {
                        this.element.innerHTML = this.text.replace(/\n/g, '<br>');
                        this.isRunning = false;
                        if (this.options.onComplete) this.options.onComplete();
                    }
                }, this.options.speed / 2);
            }

            // Animation fade
            fade(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-fade-in');
                this.element.innerHTML = text.replace(/\n/g, '<br>');

                setTimeout(() => {
                    this.element.classList.remove('ta-fade-in');
                    if (this.options.onComplete) this.options.onComplete();
                }, 1000);
            }

            // Animation glitch optimis√©e
            glitch(text, options = {}) {
                this.setupAnimation(text, options);
                this.element.classList.add('ta-glitch');

                const glitchText = this._createGlitchText(text);
                this.element.innerHTML = glitchText;

                this.timeoutId = setTimeout(() => {
                    this.element.innerHTML = text.replace(/\n/g, '<br>');
                    this.element.classList.remove('ta-glitch');
                    if (this.options.onComplete) this.options.onComplete();
                }, this.options.speed * 5);
            }

            // M√©thodes utilitaires optimis√©es
            setupAnimation(text, options) {
                this.text = text;
                this.options = {
                    speed: options.speed || 50,
                    textColor: options.textColor || '#ffffff',
                    effectColor: options.effectColor || '#64ffda',
                    effect: options.effect || 'none',
                    onComplete: options.onComplete
                };
                this.reset();
                this.setColors(this.options.textColor, this.options.effectColor);
                this.applyEffect(this.options.effect);
            }

            _buildHtmlText(index) {
                let result = '';
                let textIndex = 0;
                for (let i = 0; i < this.text.length && textIndex < index; i++) {
                    if (this.text[i] === '<') {
                        const tagEnd = this.text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += this.text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (this.text[i] === '\n') {
                        result += '<br>';
                        textIndex++;
                    } else {
                        result += this.text[i];
                        textIndex++;
                    }
                }
                return result;
            }

            _createGlitchText(text) {
                const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?`~';
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '<') {
                        const tagEnd = text.indexOf('>', i);
                        if (tagEnd !== -1) {
                            result += text.substring(i, tagEnd + 1);
                            i = tagEnd;
                        }
                    } else if (text[i] === '\n') {
                        result += '<br>';
                    } else if (Math.random() < 0.1 && text[i] !== ' ') {
                        result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        result += text[i];
                    }
                }
                return result;
            }

            // V√©rifier si une animation est en cours
            isAnimating() {
                return this.isRunning;
            }
        }

        // Instance globale du module d'animation de texte
        let textAnimator = new TextAnimationModule();

        // Variables de jeu
        let score = 0, vies = 3, brises = 0, jeu = false, tactile = false;

        // Rendre score accessible globalement pour les modules
        window.score = score;
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (value) => { score = value; }
        });
        let titreVoyage = { active: false, texte: '', fin: 0 }; // Affichage titre voyage
        let raquette = {}, balle = {}, briques = [], particules = [];
        let starsProjectiles = []; // Projectiles √©toiles du mode stars (tir simple)
        let projectiles = [], munitions = 0, rechargement = 0; // Projectiles √©toiles (phase briques) - commence √† 0
        let projectilesSecret = []; // Projectiles simples (mode secret)
        let powerUps = [], lanterne = { active: false, intensite: 0 };
        let coeursBateau = []; // C≈ìurs lanc√©s par le bateau
        let derniereCreeRafale = 0; // Temps de la derni√®re rafale
        let petitsCoeurs = []; // Petits c≈ìurs d√©coratifs en haut
        let pauseBalle = { active: false, fin: 0 }; // Pause apr√®s explosion
        let textesVolants = []; // Textes qui montent au ciel
        let corbeau = { actif: false, x: 0, y: 0, touches: 0, type: 'corbeau', tempsApparition: 0, prochainPassage: 10000, direction: 1 }; // Corbeau secret (10s pour test)

        // Syst√®me de chauve-souris r√©v√©l√©e par la lanterne
        let chauveSouris = {
            revelee: false,
            x: 0, y: 0,
            vx: 0, vy: 0,
            active: false,
            tempApparition: 0,
            dureeVie: 5000, // 5 secondes
            collectee: false
        };

        // Animation de l'ic√¥ne vers le menu √©nigmes
        let animationIconeMenu = {
            active: false,
            startX: 0, startY: 0,
            targetX: 0, targetY: 0,
            currentX: 0, currentY: 0,
            progress: 0,
            duree: 1500, // 1.5 secondes
            startTime: 0,
            icone: '',
            easing: function(t) {
                // Easing out cubic pour un effet naturel
                return 1 - Math.pow(1 - t, 3);
            }
        };
        let soleil = { clignotement: false, tempsClignotement: 0 }; // √âtat du soleil
        let multiplicateurPuissance = 1; // Cheat code x10 puissance
        let leverSoleil = { active: false, debut: 0, duree: 8000 }; // Lever de soleil pour transition
        let messageCorbeauBas = { actif: false, texte: '', tempsFin: 0 }; // Message discret en bas pour corbeau
        let secretModeModule = null; // Module mode secret
        // let kawaiiObjectsModule = null; // SUPPRIM√â - utilisation via module secret seulement
        let modeNarration = true; // Mode narration actif au d√©but
        let messageNarratif = { actif: false, texte: '', etape: 0 }; // Syst√®me de messages narratifs
        let periode = 'jour'; // P√©riode actuelle : 'jour' ou 'nuit'
        let transitionPeriode = { active: false, progression: 0 };
        let phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: window.now() }; // Phase d'introduction
        let pointsConnaissance = 0; // Points de connaissance
        /*
         * ORGANISATION DES PHASES DE JEU :
         * 1. 'tir_coeurs_haut' : Tir de c≈ìurs vers les petits c≈ìurs du haut (phase d'√©veil)
         * 2. 'lanterne' : Casse-briques avec la lanterne comme balle (phase d'apprentissage)
         * 3. 'stars' : Tir d'√©toiles vers les briques en mode nuit (phase de r√©v√©lation)
         * 4. 'feux_artifice' : C√©l√©bration finale avec feux d'artifice
         */
        let phaseJeu = 'tir_coeurs_haut';

        // Animation du bateau
        let animationBateau = {
            active: true,
            phase: 'arrivee', // 'arrivee', 'arret', 'attente', 'depart'
            positionCible: 0,
            tempsDebut: 0,
            dureeArret: 20000 // 20 secondes d'arr√™t
        };

        // Initialisation
        function initJeu() {
            // Recalculer les constantes
            C.W = size.width; C.H = size.height;
            C.PW = Math.max(C.W * 0.3, 100);  // Plus large
            C.PH = Math.max(C.H * 0.025, 15); // Plus haut
            C.BS = Math.max(Math.min(C.W, C.H) * 0.04, 16); // Taille de balle agrandie
            C.SP = Math.max(Math.min(C.W, C.H) * 0.0006, 0.4); // Vitesse r√©duite 10x

            // Les objets kawaii seront activ√©s apr√®s l'animation d'intro
            // activerObjetsKawaii(); // Trop t√¥t, on attend la fin de l'intro

            // Initialiser le module de drones si pas encore fait
            if (!droneModule && canvas) {
                droneModule = new DroneFireworksModule(canvas, {
                    droneCount: 8,
                    size: Math.min(C.W, C.H) * 0.3,
                    speed: 0.04,
                    showTrails: true,
                    formations: ['hexagon', 'star', 'heart', 'cross']
                });
            }

            // Initialiser les gestionnaires d'√©v√©nements des oiseaux CSS
            setupBirdClickHandlers();

            // Initialiser le module mode secret
            initSecretModeModule();

            // Les objets kawaii sont maintenant g√©r√©s par le module secret seulement

            // Position initiale selon l'animation
            if(animationBateau.active && animationBateau.phase === 'arrivee') {
                raquette = { x: -C.PW, y: C.H - C.PH - 25 }; // Commence hors √©cran √† gauche
                animationBateau.positionCible = C.W/2 - C.PW/2; // Position centrale
                animationBateau.tempsDebut = window.now();
            } else {
                raquette = { x: C.W/2 - C.PW/2, y: C.H - C.PH - 25 }; // Position normale
            }
            starsProjectiles = [];
            projectiles = [];
            projectilesSecret = [];
            munitions = 0; // Commencer sans munitions en phase stars
            rechargement = 0;

            briques = [];

            // Cr√©er les briques si on est en phase stars (nuit) - FORC√â
            if(phaseJeu === 'stars') {
                // FORCER l'arr√™t de tous les syst√®mes bloquants
                animationBateau.active = false;
                phaseIntro.active = false;
                // Introduction termin√©e

                // Les objets kawaii sont r√©serv√©s au mode secret seulement
                // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                // FORCER la cr√©ation des briques
                briques = []; // Vider d'abord
                dedoublerCoeursEnBriques(); // Cr√©er
                // S'assurer qu'elles sont visibles
                briques.forEach(brique => {
                    brique.visible = true;
                });
            }

            const startY = Math.max(C.H * 0.15, 80);
            const zoneH = C.H * 0.5; // Zone disponible pour les c≈ìurs
            const zoneW = C.W - 40;

            // Positions dispers√©es et tailles diff√©rentes pour chaque c≈ìur
            const positions = [
                { x: 0.15, y: 0.2, taille: 0.8 },
                { x: 0.7, y: 0.15, taille: 1.2 },
                { x: 0.25, y: 0.45, taille: 0.9 },
                { x: 0.8, y: 0.4, taille: 1.0 },
                { x: 0.05, y: 0.65, taille: 1.1 },
                { x: 0.45, y: 0.25, taille: 0.7 },
                { x: 0.6, y: 0.6, taille: 1.3 },
                { x: 0.35, y: 0.7, taille: 0.85 },
                { x: 0.85, y: 0.65, taille: 0.95 },
                { x: 0.15, y: 0.85, taille: 1.05 }
            ];

            // Les briques seront cr√©√©es √† partir des petits c≈ìurs du haut
            // Initialisation vide, elles appara√Ætront lors du d√©doublement des c≈ìurs
            briques = [];
            particules = [];
            powerUps = [];
            // Garder l'√©tat de la lanterne pendant initJeu() - ne pas la remettre √† z√©ro
            // lanterne conserve son √©tat pr√©c√©dent
            coeursBateau = [];
            derniereCreeRafale = 0;
            pauseBalle = { active: false, fin: 0 };
            textesVolants = [];

            // Initialiser la balle avec les bonnes propri√©t√©s selon la phase
            if(phaseJeu === 'lanterne') {
                balle = {
                    x: C.W/2,
                    y: C.H - C.PH - C.BS - 10,
                    dx: 0, // Immobile au d√©but
                    dy: 0, // Immobile au d√©but
                    visible: true, // Visible en phase lanterne
                    enAttente: true // Attendre le clic de l'utilisateur
                };
            } else if(phaseJeu === 'stars') {
                // En phase stars, pas de balle du tout - seulement des projectiles √©toiles
                balle = {
                    x: 0,
                    y: 0,
                    dx: 0,
                    dy: 0,
                    visible: false, // Invisible en phase stars
                    enAttente: false
                };
            } else {
                balle = {
                    x: raquette.x + C.PW * 0.7,
                    y: raquette.y - C.BS - 12,
                    dx: C.SP,
                    dy: -C.SP,
                    visible: false // Invisible dans les autres phases
                };
            }

            // Cr√©er les 10 petits c≈ìurs d√©coratifs en haut (seulement en mode coeurs)
            if(phaseJeu !== 'lanterne' && phaseJeu !== 'stars') {
                creerPetitsCoeurs();
            }

            // Cacher les c≈ìurs et nettoyer les particules pendant l'animation du bateau
            if(animationBateau.active) {
                petitsCoeurs.forEach(coeur => coeur.visible = false);
                particules = []; // Nettoyer toutes les particules
            }

            // Plus besoin d'√©toile principale - utiliser les projectiles stars

            // R√©initialiser la phase d'intro (activ√©e apr√®s l'animation du bateau)
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: window.now() };
        }

        // Gestion de l'animation du bateau
        function gererAnimationBateau() {
            if (window.systemeArrete) return; // Arr√™t total
            if (!animationBateau.active) return;

            const tempsActuel = window.now();
            const tempsEcoule = tempsActuel - animationBateau.tempsDebut;

            switch(animationBateau.phase) {
                case 'arrivee':
                    // Animation d'arriv√©e depuis la gauche vers le centre
                    const dureeArrivee = 2000; // 2 secondes pour arriver
                    const progression = Math.min(tempsEcoule / dureeArrivee, 1);

                    // Easing pour une arriv√©e fluide
                    const easeProgress = 1 - Math.pow(1 - progression, 3);

                    raquette.x = -C.PW + (animationBateau.positionCible + C.PW) * easeProgress;

                    if (progression >= 1) {
                        // Bateau arriv√© au centre
                        raquette.x = animationBateau.positionCible;
                        animationBateau.phase = 'arret';
                        animationBateau.tempsDebut = tempsActuel;

                        // Intro d√©j√† g√©r√©e par gererPhaseIntro()
                        // narrationManager.start();
                    }
                    break;

                case 'arret':
                    // Bateau arr√™t√©, attendre la fin du texte
                    if (tempsEcoule >= animationBateau.dureeArret) {
                        animationBateau.phase = 'depart';
                        animationBateau.tempsDebut = tempsActuel;

                        // Cacher le message et commencer le jeu
                        cacherMessage();
                    }
                    break;

                case 'depart':
                    // Animation de d√©part vers l'avant
                    const dureeDepart = 1500; // 1.5 secondes pour partir
                    const progressionDepart = Math.min(tempsEcoule / dureeDepart, 1);

                    // Le bateau continue vers la droite et sort de l'√©cran
                    raquette.x = animationBateau.positionCible + (C.W + C.PW) * progressionDepart;

                    if (progressionDepart >= 1) {
                        // Animation termin√©e, d√©marrer le jeu
                        animationBateau.active = false;
                        phaseIntro.active = false;
                        // Introduction termin√©e // Phase de jeu

                        // Les objets kawaii sont r√©serv√©s au mode secret seulement
                        // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret

                        // Repositionner le bateau normalement et d√©marrer la phase 1
                        raquette.x = C.W/2 - C.PW/2;

                        // V√©rifier si la langue a √©t√© choisie avant de d√©marrer le jeu
                        if (!window.jeuBloquePourLangue) {
                            jeu = true; // Activer le jeu
                            phaseJeu = 'tir_coeurs_haut'; // Commencer par la premi√®re phase
                        } else {
                            console.log('üåç Jeu pr√™t mais en attente du choix de langue');
                        }

                        // R√©v√©ler les petits c≈ìurs du haut
                        petitsCoeurs.forEach(coeur => coeur.visible = true);
                    }
                    break;
            }

            // Plus besoin de mettre √† jour l'√©toile principale
        }

        // Gestion de la phase d'introduction
        function gererPhaseIntro() {
            if (window.systemeArrete) return; // Arr√™t total
            if (!phaseIntro.active) {
                // Intro termin√©e - comportement normal
                return;
            }

            const tempsEcoule = window.now() - phaseIntro.tempsDebut;
            // Log d√©sactiv√© : gererPhaseIntro

            if (phaseIntro.etape === 'arrivee_bateau') {
                // Phase d'introduction: D√©marrer l'intro tr√®s rapidement
                if (tempsEcoule >= 200) { // R√©duire √† 0.2 seconde
                    // D√©marrer le syst√®me narratif avec la premi√®re phase (une seule fois)
                    if (narrationManager && !window.narrationStarted) {
                        window.narrationStarted = true; // Marquer comme d√©j√† d√©marr√©
                        console.log('üéØ D√©marrage forc√© de l\'intro narrative');

                        // Forcer l'affichage de l'intro imm√©diatement
                        if (narrationManager.narrativeData && narrationManager.narrativeData.phases) {
                            console.log('‚úÖ Donn√©es narratives disponibles, d√©marrage normal');
                            narrationManager.start();
                        } else {
                            console.log('‚ö†Ô∏è Donn√©es narratives non disponibles, utilisation intro simple');

                            // Utiliser notre syst√®me simple unifi√©
                            afficherMessageNarratifSimple(`On m'a dit qu'ils √©taient tous
des monstres...
On m'a dit tant de mal,
tant de malheurs
sur eux...
Mais moi,
j'ai pr√©f√©r√© aller voir
de mes propres yeux...`, 12000);

                            // Activer le bouton passer pendant l'intro
                            boutonPasser.actif = true;

                            // D√©sactiver le bouton apr√®s l'intro
                            setTimeout(() => {
                                boutonPasser.actif = false;
                            }, 12000);
                        }
                    }
                    phaseIntro.etape = 'rafales';
                    phaseIntro.tempsDebut = window.now();
                }
            } else if (phaseIntro.etape === 'rafales') {
                // Phase 1: R√©duire l'attente pour un flux plus rapide
                if (tempsEcoule >= 1000) { // R√©duire de 2s √† 1s
                    phaseIntro.etape = 'apparition_balle';
                    phaseIntro.tempsDebut = window.now();
                }
            } else if (phaseIntro.etape === 'apparition_balle') {
                // Phase 3: Apparition de la balle
                if (tempsEcoule >= 1000) {
                    phaseIntro.active = false;
                    jeu = true; // D√©marrer le jeu
                    // Ne pas forcer le mode - conserver le mode d√©j√† configur√© par narrationManager
                    // Message g√©r√© par le nouveau syst√®me narratif
                }
            }
        }

        // Interface int√©gr√©e compl√®te
        function dessinerInterface() {
            ctx.save();

            // Header optimis√© tr√®s compact - bleu roi
            const headerH = Math.max(C.H * 0.045, 32);
            ctx.fillStyle = '#1e3a8a'; // Bleu roi
            ctx.fillRect(0, 0, C.W, headerH);

            // Lignes ondul√©es en fond transparent blanc
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const waveY = headerH * (0.2 + i * 0.3);
                const waveLength = C.W / 8;
                for(let x = 0; x <= C.W; x += 10) {
                    const y = waveY + Math.sin((x / waveLength) * Math.PI * 2) * 3;
                    if(x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();

            // Bordure header
            ctx.strokeStyle = '#3b82f6'; // Bordure bleu plus clair
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, C.W, headerH);

            // Titre centr√© en hauteur
            const titleY = headerH / 2 + 4; // Centr√© verticalement dans le header
            const iconSize = Math.max(C.H * 0.008, 8); // Tr√®s petits bateaux

            ctx.save();
            // Titre moderne et plus gros
            ctx.fillStyle = '#ffffff';
            ctx.font = `800 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = '2px';
            ctx.fillText('PETIT BATEAU', C.W/2, titleY);

            // Tr√®s petits bateaux discrets
            const leftBoatX = C.W/2 - 120;
            const rightBoatX = C.W/2 + 120;
            drawBoatIcon(ctx, leftBoatX, titleY - iconSize, iconSize, 'red');
            drawBoatIcon(ctx, rightBoatX, titleY - iconSize, iconSize, 'blue');

            // Menu HOME supprim√©

            ctx.restore();

            // Afficher le titre du voyage si actif
            if (titreVoyage.active && Date.now() < titreVoyage.fin) {
                const voyageY = Math.max(C.H * 0.10, 70); // Tr√®s l√©g√®rement plus bas
                ctx.save();

                // Style moderne avec blanc et ombres
                ctx.fillStyle = '#ffffff';
                ctx.font = `700 ${Math.max(C.H * 0.022, 20)}px 'Segoe UI', system-ui, sans-serif`;
                ctx.textAlign = 'center';

                // Ombres multiples pour effet profondeur
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 8;

                // S√©parer le nom du voyage et la phase
                const lignes = titreVoyage.texte.split('\n');
                const voyageNom = lignes[0];
                const phaseTexte = lignes[1] || '';

                // Premi√®re ombre (arri√®re) pour le titre voyage
                ctx.fillText(`üó∫Ô∏è Voyage ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Deuxi√®me couche avec ombre plus subtile pour le titre
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 4;
                ctx.fillText(`üó∫Ô∏è Voyage ‚Äî ${voyageNom}`, C.W/2, voyageY);

                // Sous-titre phase masqu√© - d√©j√† affich√© dans le header
                // if (phaseTexte) {
                //     ctx.font = `600 ${Math.max(C.H * 0.018, 16)}px 'Segoe UI', system-ui, sans-serif`;
                //     ctx.fillStyle = '#ffffff';
                //     ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                //     ctx.shadowOffsetX = 2;
                //     ctx.shadowOffsetY = 2;
                //     ctx.shadowBlur = 6;
                //     ctx.fillText(phaseTexte, C.W/2, voyageY + Math.max(C.H * 0.035, 28));
                // }

                ctx.restore();
            } else if (titreVoyage.active && Date.now() >= titreVoyage.fin) {
                titreVoyage.active = false; // D√©sactiver apr√®s 4 secondes
            }

            // Stats ligne avec fond blanc plus pr√®s du header
            const statsY = Math.max(C.H * 0.045, 30); // Beaucoup plus pr√®s du header
            const padding = 8;
            const bgHeight = Math.max(C.H * 0.025, 20);

            // Fond blanc pour toute la barre de stats
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, statsY - bgHeight/2, C.W, bgHeight);

            // Bordure subtile
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, statsY - bgHeight/2, C.W, bgHeight);

            ctx.font = `600 ${Math.max(C.H * 0.02, 12)}px sans-serif`;
            ctx.fillStyle = '#2c3e50';

            // Score et Points XP - centr√© verticalement dans la barre
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            if(phaseJeu === 'tir_coeurs_haut') {
                ctx.fillText(`‚≠ê XP: ${pointsConnaissance}`, 15, statsY);
            } else {
                ctx.fillText(`üïäÔ∏è ${score}`, 15, statsY);
            }

            // Progression avec voyage et phase
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            let phaseInfo = '';
            if (narrationManager && narrationManager.currentPhase) {
                const phase = narrationManager.currentPhase; // Phase 1 = intro simple
                let voyageIcon = '';
                let voyageName = '';

                if (phase === 1) {
                    voyageIcon = 'üåÖ'; voyageName = 'L\'aube des doutes';
                } else if (phase === 2) {
                    voyageIcon = '‚òÄÔ∏è'; voyageName = 'La lumi√®re';
                } else if (phase >= 3 && phase <= 4) {
                    voyageIcon = '‚òÅÔ∏è'; voyageName = 'L\'ombre des nuages';
                } else if (phase >= 5 && phase <= 6) {
                    voyageIcon = 'ü§´'; voyageName = 'Le silence de l\'√¢me';
                } else if (phase >= 7 && phase <= 9) {
                    voyageIcon = '‚ù§Ô∏è'; voyageName = 'L\'humanit√© des c≈ìurs';
                } else if (phase >= 10 && phase <= 12) {
                    voyageIcon = 'üß†'; voyageName = 'La sagesse des diff√©rences';
                } else if (phase >= 13 && phase <= 15) {
                    voyageIcon = 'üåç'; voyageName = 'L\'unit√©';
                } else if (phase === 16) {
                    voyageIcon = 'üéÜ'; voyageName = 'L\'Unit√© de l\'Humanit√©';
                } else if (phase >= 17 && phase <= 22) {
                    voyageIcon = 'üß±'; voyageName = 'Le Mur d\'avarice';
                } else {
                    voyageIcon = 'üó∫Ô∏è'; voyageName = 'Voyage';
                }

                phaseInfo = `üó∫Ô∏è Phase ${phase}/22`;
            } else {
                phaseInfo = `üß± ${brises}/${VOYAGE.length}`;
            }
            ctx.fillText(phaseInfo, C.W/2, statsY);

            // Vies
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle'; // Centrer verticalement
            const coeurs = vies > 0 ? '‚ù§Ô∏è'.repeat(vies) : 'üíî';
            ctx.fillText(coeurs, C.W - 15, statsY);

            // Affichage des commandes mode passe d√©sactiv√©
            /*
            ctx.save();
            ctx.font = `${Math.max(10, C.W * 0.012)}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.textAlign = 'right';

            const commandesY = C.H - 15;
            const commandes = [
                'üîë MODE PASSE:',
                'T = Chapitre',
                'P = Phase',
                'V = Vie',
                'R = Vie briques',
                'E = Tir √©toiles',
                'S = Secret'
            ];

            commandes.forEach((cmd, index) => {
                const y = commandesY - (commandes.length - 1 - index) * 14;
                ctx.strokeText(cmd, C.W - 15, y);
                ctx.fillText(cmd, C.W - 15, y);
            });
            ctx.restore();
            */

            ctx.restore();
        }

        // Tirer un projectile √©toile dans le mode stars
        function tirerStarsProjectile(mouseX, mouseY) {
            // Ne tirer que dans la phase stars (phase 3)
            if (phaseJeu !== 'stars') return;

            const startX = raquette.x + C.PW/2;
            const startY = raquette.y;

            // Calculer la direction vers la cible
            const dx = mouseX - startX;
            const dy = mouseY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if(distance === 0) return;

            const vitesse = 1.2;
            const velX = (dx / distance) * vitesse;
            const velY = (dy / distance) * vitesse;

            starsProjectiles.push({
                x: startX,
                y: startY,
                dx: velX,
                dy: velY,
                taille: 13,
                couleur: '#FFD700',
                scintillement: Math.random()
            });

            // Pas de consommation de munitions en mode stars normal
        }

        // Dessiner les projectiles stars
        function dessinerStarsProjectiles() {
            // Dessiner pendant la phase stars, feux_artifice ET lanterne (pour Poxerstart)
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice' && phaseJeu !== 'lanterne') return;

            starsProjectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = projectile.taille || 13;

                // Animation √©toile filante
                ctx.translate(posX, posY);

                // Calculer l'angle de d√©placement pour la tra√Æn√©e
                const angleDirection = Math.atan2(projectile.dy, projectile.dx);
                ctx.rotate(angleDirection);

                // Tra√Æn√©e d'√©toile filante
                const longueurTrainee = rayonEtoile * 3;
                const largeurTrainee = rayonEtoile * 0.3;

                // Gradient de la tra√Æn√©e
                const gradientTrainee = ctx.createLinearGradient(-longueurTrainee, 0, 0, 0);
                // Tra√Æn√©e dor√©e normale
                gradientTrainee.addColorStop(0, 'rgba(255, 215, 0, 0)');
                gradientTrainee.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradientTrainee.addColorStop(1, projectile.couleur || '#FFD700');

                // Dessiner la tra√Æn√©e
                ctx.fillStyle = gradientTrainee;
                ctx.beginPath();
                ctx.moveTo(-longueurTrainee, -largeurTrainee);
                ctx.lineTo(0, 0);
                ctx.lineTo(-longueurTrainee, largeurTrainee);
                ctx.closePath();
                ctx.fill();

                // Rotation scintillante pour l'√©toile elle-m√™me
                const rotation = Date.now() * 0.02;
                ctx.rotate(rotation);

                // √âtoile principale avec halo
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    // Halo lumineux
                    const gradientHalo = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile * 1.5);
                    gradientHalo.addColorStop(0, projectile.couleur || '#FFD700');
                    gradientHalo.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradientHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = gradientHalo;
                    ctx.beginPath();
                    ctx.arc(0, 0, rayonEtoile * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // √âtoile centrale brillante
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.3, projectile.couleur || '#FFD700');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0.8)');

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;

                    // √âtoile √† 5 branches
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angle1 = (i * 2 * Math.PI) / 5;
                        const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                        const x1 = Math.cos(angle1) * rayonEtoile;
                        const y1 = Math.sin(angle1) * rayonEtoile;
                        const x2 = Math.cos(angle2) * (rayonEtoile * 0.4);
                        const y2 = Math.sin(angle2) * (rayonEtoile * 0.4);

                        if(i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Mettre √† jour les projectiles stars
        function mettreAJourStarsProjectiles() {
            if (phaseJeu !== 'stars' && phaseJeu !== 'feux_artifice') {
                // Nettoyer les projectiles si on n'est pas dans la bonne phase
                if (starsProjectiles.length > 0) {
                    starsProjectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = starsProjectiles.length - 1; i >= 0; i--) {
                const proj = starsProjectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    starsProjectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques en phase stars
                if(phaseJeu === 'stars') {
                    let briqueTouchee = false;
                    briques.forEach(brique => {
                        if(briqueTouchee) return;
                        if(!brique.visible) return;
                        if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                           proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            const tempsActuel = Date.now();
                            if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                                briqueTouchee = true;
                                // Endommager la brique
                                brique.vie--;
                                brique.clignotement = 10;
                                brique.dernierCoup = tempsActuel;

                                // Supprimer le projectile
                                starsProjectiles.splice(i, 1);

                                // Particules d'impact
                                ajouterParticules(brique.x + brique.w/2, brique.y + brique.h/2, brique.couleur, 6);

                                if(brique.vie <= 0) {
                                    brique.visible = false;
                                    brises++;
                                    // console.log(`üß± Brique cass√©e ! Total: ${brises}/${VOYAGE.length}, phase: ${phaseJeu}`);
                                    ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);
                                    // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom);

                                    // V√©rifier la condition de fin apr√®s destruction de brique
                                    const briquesRestantes = briques.filter(b => b.visible).length;
                                    // console.log(`üîç V√©rif briques restantes (√©toile): ${briquesRestantes}`);
                                    if(briquesRestantes === 0) {
                                        console.log('üéØ Toutes les briques d√©truites (√©toile)! Animation d\'explosion...');
                                        // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                        animerExplosionIconeCollector(() => {
                                            console.log('üéÜ Animation √©toile termin√©e, passage √† la phase suivante');
                                            narrationManager.goToNextPhaseDirect();
                                        });
                                    }
                                }
                                score += 50;
                                return;
                            }
                        }
                    });
                    if(briqueTouchee) continue;
                }

                // Collision avec les petits c≈ìurs
                petitsCoeurs.forEach((petitCoeur, j) => {
                    if(!petitCoeur.visible) return;

                    if(proj.x >= petitCoeur.x - petitCoeur.w/2 &&
                       proj.x <= petitCoeur.x + petitCoeur.w/2 &&
                       proj.y >= petitCoeur.y - petitCoeur.h/2 &&
                       proj.y <= petitCoeur.y + petitCoeur.h/2) {

                        // C≈ìur touch√© !
                        petitCoeur.visible = false;
                        pointsConnaissance += 10;

                        // Effets visuels
                        ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                        ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                        // Supprimer le projectile
                        starsProjectiles.splice(i, 1);

                        // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                        const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                        // console.log(`[DEBUG] Condition fin coeurs: restants=${coeurRestants}, phaseJeu=${phaseJeu}`);
                        if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                            console.log(`üéÜ TOUS LES C≈íURS CASS√âS ! Animation d'explosion !`);

                            // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                console.log('üéÜ Animation c≈ìurs termin√©e, passage √† la phase suivante');
                                narrationManager.goToNextPhaseDirect();

                                // Cr√©er quelques c≈ìurs d√©coratifs qui flottent - APR√àS la phase suivante
                                setTimeout(() => {
                                    for(let k = 0; k < 10; k++) {
                                        particules.push({
                                            x: Math.random() * C.W,
                                            y: C.H + Math.random() * 50,
                                            vx: (Math.random() - 0.5) * 2,
                                            vy: -(Math.random() * 3 + 1),
                                            couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][k % 5],
                                            vie: 1,
                                            taille: Math.random() * 4 + 3,
                                            type: 'coeur'
                                        });
                                    }
                                    // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                    // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                }, 3000);
                            });
                        }
                        return;
                    }
                });
            }
        }

        // Vraie lanterne volante avec halo bougie et nouveaux effets
        function dessinerLanterne() {
            // Dessiner la lanterne √©teinte comme balle du jeu UNIQUEMENT pendant la phase casse-briques
            if (animationBateau.active || !balle.visible || phaseJeu !== 'lanterne') return;

            ctx.save();

            const posX = balle.x || 0; // Position de la balle
            const posY = balle.y || 0; // Position de la balle
            const temps = Date.now() * 0.001;

            // V√©rification de s√©curit√© pour √©viter les valeurs non finies
            if (!isFinite(posX) || !isFinite(posY) || !isFinite(C.BS)) {
                ctx.restore();
                return;
            }

            // EFFET TRA√éN√âE VERTE (power-up vitesse)
            if(balle.traineeVerte && balle.vitesseActive) {
                // Tra√Æn√©e verte dynamique
                for(let i = 0; i < 5; i++) {
                    const alpha = (5 - i) / 5 * 0.6;
                    const size = C.BS * (1 - i * 0.15);
                    const offsetX = (balle.dx || 0) * -i * 2;
                    const offsetY = (balle.dy || 0) * -i * 2;

                    const grad = ctx.createRadialGradient(
                        posX + offsetX, posY + offsetY, 0,
                        posX + offsetX, posY + offsetY, size
                    );
                    grad.addColorStop(0, `rgba(0, 255, 0, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 255, 50, ${alpha * 0.5})`);
                    grad.addColorStop(1, `rgba(0, 255, 0, 0)`);

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(posX + offsetX, posY + offsetY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 1. HALO DE BOUGIE SIMPLE (seulement si lanterne active)
            if(lanterne.active) {
                // Halo simple statique
                const haloSize = C.BS * 1.5;
                const haloIntensity = 0.4;

                // Halo principal simple avec v√©rification
                if (isFinite(haloSize) && haloSize > 0) {
                    const haloGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, haloSize);
                haloGrad.addColorStop(0, `rgba(255, 220, 150, ${haloIntensity})`);
                haloGrad.addColorStop(0.3, `rgba(255, 180, 100, ${haloIntensity * 0.7})`);
                haloGrad.addColorStop(0.7, `rgba(255, 140, 60, ${haloIntensity * 0.3})`);
                haloGrad.addColorStop(1, 'rgba(255, 100, 30, 0)');

                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, haloSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 2. LANTERNE CYLINDRIQUE CLASSIQUE

            // Dimensions de la lanterne avec multiplicateur de taille si actif
            const multiplTaille = balle.multiplicateurTaille || 1;
            const rayon = C.BS * 0.4 * multiplTaille;        // Rayon du cylindre
            const corpsH = C.BS * 1.2 * multiplTaille;       // Hauteur du corps cylindrique
            const domeH = C.BS * 0.1 * multiplTaille;        // Hauteur du d√¥me
            const baseH = C.BS * 0.1 * multiplTaille;        // Hauteur de la base

            // LUEUR DOUCE AUTOUR DE LA LANTERNE
            if(lanterne.active) {
                // Halo de lueur douce adapt√© √† la taille
                const lueurSize = rayon * 1.25;
                if (isFinite(rayon) && isFinite(lueurSize) && rayon > 0 && lueurSize > 0) {
                    const lueurGrad = ctx.createRadialGradient(posX, posY, rayon, posX, posY, lueurSize);
                lueurGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                lueurGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.2)');
                lueurGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
                ctx.fillStyle = lueurGrad;
                    ctx.beginPath();
                    ctx.arc(posX, posY, lueurSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Armature m√©tallique de la lanterne
            const armatureColor = lanterne.active ? '#B8860B' : '#654321';
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;

            // BASE RONDE plus petite
            const baseY = posY + corpsH/2;
            ctx.fillStyle = armatureColor;
            ctx.beginPath();
            ctx.ellipse(posX, baseY, rayon * 1.05, baseH, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // CORPS CYLINDRIQUE
            const corpsTop = posY - corpsH/2;
            const corpsBottom = posY + corpsH/2;

            // Vitres cylindriques
            if(lanterne.active) {
                // Vitres dor√©es lumineuses
                if (isFinite(rayon) && rayon > 0) {
                    const vitreGrad = ctx.createRadialGradient(posX, posY, 0, posX, posY, rayon);
                    vitreGrad.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    vitreGrad.addColorStop(0.7, 'rgba(255, 200, 0, 0.6)');
                    vitreGrad.addColorStop(1, 'rgba(255, 180, 0, 0.4)');
                    ctx.fillStyle = vitreGrad;
                } else {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                }
            } else {
                // Vitres √©teintes
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            }
            ctx.beginPath();
            ctx.ellipse(posX, posY, rayon, corpsH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Contour du cylindre
            ctx.strokeStyle = armatureColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Barreaux en forme de croix
            ctx.beginPath();
            // Barre verticale
            ctx.moveTo(posX, corpsTop);
            ctx.lineTo(posX, corpsBottom);
            // Barre horizontale
            ctx.moveTo(posX - rayon, posY);
            ctx.lineTo(posX + rayon, posY);
            ctx.stroke();

            // D√îME SUP√âRIEUR
            const domeTop = corpsTop - domeH;
            ctx.fillStyle = armatureColor;
            ctx.strokeStyle = '#CD7F32';
            ctx.lineWidth = 2;

            // D√¥me en forme d'ellipse plus petit
            ctx.beginPath();
            ctx.ellipse(posX, domeTop + domeH/2, rayon * 0.9, domeH/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // 3. FLAMME AVEC ANIMATIONS TR√àS LENTES
            if(lanterne.active) {
                // Flamme avec mouvement encore plus lent et doux
                const flammeX = posX + Math.sin(temps * 0.1) * 1 * multiplTaille; // Encore plus lent
                const flammeY = posY - C.BS * 0.3 * multiplTaille;
                const flammeH = C.BS * 0.6 * multiplTaille;
                const flammeW = C.BS * 0.3 * multiplTaille;

                // Flamme principale avec danse tr√®s douce
                if (isFinite(flammeX) && isFinite(flammeY) && isFinite(flammeH) && flammeH > 0) {
                    const flammeGrad = ctx.createRadialGradient(flammeX, flammeY, 0, flammeX, flammeY, flammeH);
                flammeGrad.addColorStop(0, '#FFFF99');
                flammeGrad.addColorStop(0.3, '#FFD700');
                flammeGrad.addColorStop(0.6, '#FFA500');
                flammeGrad.addColorStop(1, '#FF6347');

                    ctx.fillStyle = flammeGrad;
                    ctx.beginPath();
                    // Forme de flamme avec variations encore plus lentes
                    ctx.ellipse(flammeX, flammeY, flammeW * (0.6 + Math.sin(temps * 0.12) * 0.05), flammeH * (0.8 + Math.cos(temps * 0.1) * 0.05), Math.sin(temps * 0.06) * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    // C≈ìur de la flamme plus lumineux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.ellipse(flammeX, flammeY, flammeW * 0.3, flammeH * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // M√®che de la bougie
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1 * multiplTaille, posY, 2 * multiplTaille, C.BS * 0.2 * multiplTaille);
            } else {
                // M√®che √©teinte
                ctx.fillStyle = '#654321';
                ctx.fillRect(posX - 1, posY - 2, 2, 4);

                // C≈ìur d'humanit√© au repos
                const coeurSize = C.BS * 0.4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(posX, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX, posY, posX - coeurSize*0.5, posY, posX - coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX - coeurSize*0.5, posY + coeurSize*0.7, posX, posY + coeurSize*0.7, posX, posY + coeurSize);
                ctx.bezierCurveTo(posX, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.7, posX + coeurSize*0.5, posY + coeurSize*0.3);
                ctx.bezierCurveTo(posX + coeurSize*0.5, posY, posX, posY, posX, posY + coeurSize*0.3);
                ctx.fill();
            }

            // 4. SYST√àME DE SUSPENSION SIMPLE
            const cordeLength = C.BS * 1;
            ctx.strokeStyle = lanterne.active ? '#8B4513' : '#4a4a4a';
            ctx.lineWidth = 2;

            // Cordes depuis le d√¥me adapt√©es √† la taille
            ctx.beginPath();
            ctx.moveTo(posX - rayon*0.6, domeTop); // Gauche du d√¥me
            ctx.lineTo(posX - rayon*0.2, posY - cordeLength);
            ctx.moveTo(posX + rayon*0.6, domeTop); // Droite du d√¥me
            ctx.lineTo(posX + rayon*0.2, posY - cordeLength);
            ctx.stroke();

            // Corde centrale
            ctx.beginPath();
            ctx.moveTo(posX, domeTop); // Centre du d√¥me
            ctx.lineTo(posX, posY - cordeLength);
            ctx.stroke();

            ctx.restore();
        }

        // Fonction pour dessiner les ic√¥nes de bateaux miniatures
        function drawBoatIcon(ctx, x, y, size, color) {
            ctx.save();

            // Couleurs selon le type
            let coqueColors, borderColor;
            if (color === 'red') {
                coqueColors = ['#ff6b6b', '#e74c3c', '#c0392b'];
                borderColor = '#a93226';
            } else {
                coqueColors = ['#74b9ff', '#0984e3', '#2d3436'];
                borderColor = '#2d3436';
            }

            // Coque simplifi√©e
            const coqueW = size * 1.5;
            const coqueH = size * 0.8;

            const coqueGrad = ctx.createLinearGradient(x, y, x, y + coqueH);
            coqueGrad.addColorStop(0, coqueColors[0]);
            coqueGrad.addColorStop(0.5, coqueColors[1]);
            coqueGrad.addColorStop(1, coqueColors[2]);

            ctx.fillStyle = coqueGrad;
            ctx.beginPath();
            ctx.ellipse(x, y + coqueH/2, coqueW/2, coqueH/2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bordure
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // M√¢t
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + coqueH/2);
            ctx.lineTo(x, y - size);
            ctx.stroke();

            // Voile triangulaire
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size/2, y);
            ctx.lineTo(x + size/3, y - size/3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#ced4da';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // Petit bateau √©l√©gant g√©om√©trique rouge avec voile blanche
        function dessinerBateau() {
            ctx.save();

            // EFFET POXERSTART (aura rose pulsante)
            if(raquette.poxerstart && Date.now() < raquette.poxerstartFin) {
                const tempsRestant = (raquette.poxerstartFin - Date.now()) / 7000; // 0 √† 1
                const pulsation = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                const alpha = tempsRestant * pulsation * 0.6;

                // Aura rose autour du bateau
                const grad = ctx.createRadialGradient(
                    raquette.x + C.PW/2, raquette.y + C.PH/2, 0,
                    raquette.x + C.PW/2, raquette.y + C.PH/2, C.PW * 1.5
                );
                grad.addColorStop(0, `rgba(255, 105, 180, ${alpha})`);
                grad.addColorStop(0.7, `rgba(255, 105, 180, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 105, 180, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(
                    raquette.x - C.PW * 0.5, raquette.y - C.PH * 0.5,
                    C.PW * 2, C.PH * 2
                );

                // √âtoiles qui scintillent autour
                for(let i = 0; i < 3; i++) {
                    const angle = Date.now() * 0.005 + i * Math.PI * 2 / 3;
                    const rayon = C.PW * 0.8;
                    const x = raquette.x + C.PW/2 + Math.cos(angle) * rayon;
                    const y = raquette.y + C.PH/2 + Math.sin(angle) * rayon * 0.5;

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', x, y);
                }
            } else if(raquette.poxerstart) {
                // Nettoyer l'effet quand fini
                raquette.poxerstart = false;
            }

            // Ombre du bateau
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(raquette.x + 3, raquette.y + 3, C.PW, C.PH);

            if(modeSecret) {
                // === BATEAU MILITAIRE POUR LE MODE SECRET ===

                // Coque du destroyer - forme militaire avec √©trave pointue
                const coquePoints = [
                    [raquette.x + C.PW * 0.1, raquette.y + C.PH],        // Arri√®re gauche
                    [raquette.x, raquette.y + C.PH * 0.6],               // Pointe arri√®re
                    [raquette.x + C.PW * 0.2, raquette.y],               // Proue gauche
                    [raquette.x + C.PW * 0.8, raquette.y],               // Proue droite
                    [raquette.x + C.PW, raquette.y + C.PH * 0.6],        // Pointe avant
                    [raquette.x + C.PW * 0.9, raquette.y + C.PH]         // Arri√®re droite
                ];

                // Gradient bleu pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#74b9ff'); // Bleu clair
                coqueGrad.addColorStop(0.5, '#0984e3'); // Bleu moyen
                coqueGrad.addColorStop(1, '#2d3436'); // Bleu fonc√©

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');
                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // === BATEAU ROUGE NORMAL ===

                // Coque du bateau - forme en V tr√®s grosse qui touche le m√¢t
                const coquePoints = [
                    [raquette.x, raquette.y + C.PH * 0.3],               // Arri√®re gauche (pont plus haut)
                    [raquette.x + C.PW * 0.02, raquette.y + C.PH * 1.3], // Fond gauche (descend en V)
                    [raquette.x + C.PW * 0.5, raquette.y + C.PH * 1.5],  // Point le plus bas du V (quille)
                    [raquette.x + C.PW * 0.98, raquette.y + C.PH * 1.3], // Fond droit (remonte du V)
                    [raquette.x + C.PW, raquette.y + C.PH * 0.3]         // Arri√®re droite (pont plus haut)
                ];

                // Gradient rouge pour la coque
                const coqueGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH);
                coqueGrad.addColorStop(0, '#ff6b6b');
                coqueGrad.addColorStop(0.5, '#e74c3c');
                coqueGrad.addColorStop(1, '#c0392b');

                ctx.fillStyle = coqueGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la coque
                ctx.strokeStyle = '#a93226';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Reflet sur la coque
                const refletGrad = ctx.createLinearGradient(raquette.x, raquette.y, raquette.x, raquette.y + C.PH*0.4);
                refletGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                refletGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = refletGrad;
                ctx.beginPath();
                ctx.moveTo(coquePoints[0][0], coquePoints[0][1]);
                for(let i = 1; i < coquePoints.length; i++) {
                    ctx.lineTo(coquePoints[i][0], coquePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // M√¢t central plus haut
                const matX = raquette.x + C.PW/2;
                const matY = raquette.y - C.PH * 3.75; // Voile 1.5x plus haute
                const matH = C.PH * 4.5;

                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(matX, raquette.y + C.PH*0.3);
                ctx.lineTo(matX, matY);
                ctx.stroke();

                // Voile blanche triangulaire plus haute
                const voilePoints = [
                    [matX, matY],                              // Haut du m√¢t
                    [matX - C.PW*0.4, raquette.y - C.PH*0.5], // Bas gauche plus haut
                    [matX + C.PW*0.25, raquette.y - C.PH*0.1] // Bas droite plus haut
                ];

                // Gradient blanc pour la voile
                const voileGrad = ctx.createLinearGradient(matX - C.PW*0.4, matY, matX + C.PW*0.25, raquette.y);
                voileGrad.addColorStop(0, '#ffffff');
                voileGrad.addColorStop(0.6, '#f8f9fa');
                voileGrad.addColorStop(1, '#e9ecef');

                ctx.fillStyle = voileGrad;
                ctx.beginPath();
                ctx.moveTo(voilePoints[0][0], voilePoints[0][1]);
                for(let i = 1; i < voilePoints.length; i++) {
                    ctx.lineTo(voilePoints[i][0], voilePoints[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Bordure de la voile
                ctx.strokeStyle = '#ced4da';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Lignes de contrainte de la voile
                ctx.strokeStyle = '#adb5bd';
                ctx.lineWidth = 1;
                for(let i = 0; i < 3; i++) {
                    const y = matY + (raquette.y - C.PH*0.5 - matY) * (i + 1) / 4;
                    ctx.beginPath();
                    ctx.moveTo(matX - C.PW*0.3 * (1 - i/3), y);
                    ctx.lineTo(matX + C.PW*0.2 * (1 - i/3), y);
                    ctx.stroke();
                }

                // Hublots g√©om√©triques
                ctx.fillStyle = '#457b9d';
                for(let i = 0; i < 3; i++) {
                    const hublotX = raquette.x + C.PW*0.25 + i * C.PW*0.25;
                    const hublotY = raquette.y + C.PH*0.5;
                    ctx.beginPath();
                    ctx.arc(hublotX, hublotY, C.PH*0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // Vraies briques avec c≈ìurs √† l'int√©rieur pour le casse-brique
        function dessinerPrejuges() {
            briques.forEach((brique, index) => {
                if(!brique.visible) return;

                const centreX = brique.x + brique.w/2;
                const centreY = brique.y + brique.h/2;
                const couleur = brique.couleur || brique.etape.couleur;

                // Dessiner la brique rectangulaire avec √©tat de d√©g√¢ts
                ctx.save();

                // Couleur selon la vie restante
                let couleurBrique = couleur;
                if (brique.vieMax === 2) {
                    // Phase lanterne : 2 vies maximum
                    if (brique.vie === 1) {
                        // Brique endommag√©e (1er coup re√ßu sur 2)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.6)`;
                    }
                } else {
                    // Phase stars : 3 vies maximum
                    if (brique.vie === 2) {
                        // Brique l√©g√®rement endommag√©e (1er coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.8)`;
                    } else if (brique.vie === 1) {
                        // Brique tr√®s endommag√©e (2√®me coup re√ßu sur 3)
                        couleurBrique = `rgba(${parseInt(couleur.slice(1,3), 16)}, ${parseInt(couleur.slice(3,5), 16)}, ${parseInt(couleur.slice(5,7), 16)}, 0.5)`;
                    }
                }

                ctx.fillStyle = couleurBrique;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                // Clignotement si r√©cemment touch√©e
                if (brique.clignotement > 0) {
                    ctx.fillStyle = '#FFFFFF';
                    brique.clignotement--;
                }

                // Rectangle de brique
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h);
                ctx.strokeRect(brique.x, brique.y, brique.w, brique.h);


                // Effet 3D de brique
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brique.x, brique.y, brique.w, brique.h * 0.3); // Highlight du haut

                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(brique.x, brique.y + brique.h * 0.8, brique.w, brique.h * 0.2); // Ombre du bas

                // Dessiner les fissures zigzag blanches selon les d√©g√¢ts
                if ((brique.vieMax === 2 && brique.vie <= 1) || (brique.vieMax === 3 && brique.vie <= 2)) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    // Premi√®re fissure zigzag apr√®s le 1er coup
                    ctx.beginPath();
                    const startX1 = brique.x + brique.w * 0.3;
                    const endX1 = brique.x + brique.w * 0.2;
                    const segments = 4; // Nombre de segments zigzag
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX1 + (endX1 - startX1) * progress + (i % 2 === 0 ? 0 : brique.w * 0.05) * Math.sin(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                if (brique.vie <= 1) {
                    // Deuxi√®me fissure zigzag apr√®s le 2√®me coup
                    ctx.beginPath();
                    const startX2 = brique.x + brique.w * 0.7;
                    const endX2 = brique.x + brique.w * 0.8;
                    const segments = 4;
                    for(let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const y = brique.y + progress * brique.h;
                        const x = startX2 + (endX2 - startX2) * progress + (i % 2 === 1 ? 0 : brique.w * 0.04) * Math.cos(progress * Math.PI);
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.restore();

                // Dessiner le c≈ìur √† l'int√©rieur de la brique
                dessinerCoeurPixelArt(centreX, centreY, brique.taille * 0.6, couleur);

                // En phase stars (nuit), afficher les mots pour guider le joueur
                if(phaseJeu === 'stars' && brique.etape && brique.etape.nom) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = `bold ${Math.max(12, brique.w * 0.15)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Contour noir pour la lisibilit√©
                    ctx.strokeText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                    // Texte blanc par-dessus
                    ctx.fillText(brique.etape.nom, centreX, centreY + brique.h * 0.3);
                }

                // En phase lanterne, le texte reste cach√© - il n'appara√Æt que lors de l'explosion
                // Le myst√®re reste entier jusqu'√† la lib√©ration du c≈ìur !
            });
        }

        // Messages simples centr√©s pour powerups et narratifs
        let messagePowerupActif = null;
        let messageNarratifActif = null;

        // Syst√®me d'√©clairs pour le mode nuit
        let eclairNuit = {
            actif: false,
            flashBlanc: false,
            intensite: 0,
            duree: 0,
            tempsProchainEclair: 0,
            delaiMinimum: 8000,  // 8 secondes minimum entre les √©clairs
            delaiMaximum: 20000  // 20 secondes maximum entre les √©clairs
        };

        // Bouton simple "Passer" avec juste texte et ombre
        let boutonPasser = {
            actif: false,
            x: 0,
            y: 0,
            largeur: 150, // Ajust√© pour le texte encore plus gros
            hauteur: 50,  // Ajust√© pour le texte encore plus gros
            texte: "PASSER",
            hover: false,
            pulse: 0 // Animation de pulsation
        };

        function afficherMessagePowerupSimple(texte) {
            messagePowerupActif = {
                texte: texte,
                temps: Date.now() + 2000, // 2 secondes
                alpha: 1.0
            };
        }

        function afficherMessageNarratifSimple(texte, duree = 12000) {
            messageNarratifActif = {
                texte: texte,
                temps: window.now() + duree,
                alpha: 1.0
            };
        }

        // Fonctions pour les √©clairs en mode nuit
        function initierEclairNuit() {
            if (periode !== 'nuit') return;

            const maintenant = Date.now();
            if (maintenant >= eclairNuit.tempsProchainEclair) {
                // D√©clencher un √©clair
                eclairNuit.actif = true;
                eclairNuit.flashBlanc = true;
                eclairNuit.intensite = 1.0;
                eclairNuit.duree = maintenant + 150; // Flash blanc de 150ms

                // Programmer le prochain √©clair
                const delai = eclairNuit.delaiMinimum + Math.random() * (eclairNuit.delaiMaximum - eclairNuit.delaiMinimum);
                eclairNuit.tempsProchainEclair = maintenant + delai;
            }
        }

        function mettreAJourEclairNuit() {
            if (!eclairNuit.actif) return;

            const maintenant = Date.now();

            if (eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase de flash blanc - intensit√© maximale
                eclairNuit.intensite = 1.0;
            } else if (eclairNuit.flashBlanc && maintenant > eclairNuit.duree) {
                // Fin du flash blanc, commencer l'√©clair bleu
                eclairNuit.flashBlanc = false;
                eclairNuit.duree = maintenant + 300; // √âclair bleu de 300ms
                eclairNuit.intensite = 0.7;
            } else if (!eclairNuit.flashBlanc && maintenant <= eclairNuit.duree) {
                // Phase d'√©clair bleu qui s'estompe
                const progression = (eclairNuit.duree - maintenant) / 300;
                eclairNuit.intensite = 0.7 * progression;
            } else {
                // Fin de l'√©clair
                eclairNuit.actif = false;
                eclairNuit.intensite = 0;
            }
        }

        function dessinerEclairNuit() {
            if (!eclairNuit.actif || periode !== 'nuit') return;

            ctx.save();

            if (eclairNuit.flashBlanc) {
                // Flash blanc aveuglant
                ctx.fillStyle = `rgba(255, 255, 255, ${eclairNuit.intensite * 0.8})`;
                ctx.fillRect(0, 0, C.W, C.H);
            } else {
                // √âclair bleu-√©lectrique
                ctx.fillStyle = `rgba(173, 216, 230, ${eclairNuit.intensite * 0.4})`;
                ctx.fillRect(0, 0, C.W, C.H);

                // Dessiner quelques √©clairs en zigzag
                ctx.strokeStyle = `rgba(255, 255, 255, ${eclairNuit.intensite})`;
                ctx.lineWidth = 2;
                ctx.beginPath();

                // √âclair principal diagonal
                const startX = Math.random() * C.W;
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H * 0.3);
                ctx.lineTo(startX + (Math.random() - 0.5) * 150, C.H * 0.6);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, C.H);

                ctx.stroke();
            }

            ctx.restore();
        }

        // Fonction pour dessiner le message powerup simple sous les titres narratifs
        function dessinerMessagePowerupSimple() {
            if (!messagePowerupActif) return;

            const maintenant = Date.now();
            if (maintenant > messagePowerupActif.temps) {
                messagePowerupActif = null;
                return;
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messagePowerupActif.temps - maintenant;
            if (tempsRestant < 500) {
                messagePowerupActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messagePowerupActif.alpha;

            // Position sous les titres narratifs
            const voyageY = Math.max(C.H * 0.10, 70);
            const posY = voyageY + Math.max(C.H * 0.035, 28) + 25; // Sous le sous-titre + 25px

            // Pas de fond - texte blanc avec contour noir pour lisibilit√©
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Contour noir √©pais pour lisibilit√© sur tous les arri√®re-plans
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(messagePowerupActif.texte, C.W/2, posY);
            ctx.fillText(messagePowerupActif.texte, C.W/2, posY);

            ctx.restore();
        }

        // Fonction pour dessiner le message narratif discret (en bas, sans fond)
        function dessinerMessageNarratifSimple() {
            if (!messageNarratifActif) return;

            const maintenant = window.now();
            if (maintenant > messageNarratifActif.temps) {
                messageNarratifActif = null;
                return;
            }

            // Fade out dans les derni√®res 500ms
            const tempsRestant = messageNarratifActif.temps - maintenant;
            if (tempsRestant < 500) {
                messageNarratifActif.alpha = tempsRestant / 500;
            }

            ctx.save();
            ctx.globalAlpha = messageNarratifActif.alpha;

            // Position selon la phase
            let posY = C.H * 0.40; // 40% de la hauteur par d√©faut

            // Position plus basse pour la phase 2
            if(narrationManager && narrationManager.currentPhase === 2) {
                posY = C.H * 0.75; // 75% de la hauteur - plus bas
            }

            // Effet de d√©filement pour la phase finale (g√©n√©rique)
            if(phaseJeu === 'feux_artifice' || (narrationManager && narrationManager.currentPhase === 16)) {
                const tempsEcoule = Date.now() - (messageNarratifActif.temps - 25000); // temps depuis le d√©but
                const vitesseDefilement = 0.03; // vitesse lente
                posY = C.H + 100 - (tempsEcoule * vitesseDefilement); // commence en bas et monte
            }

            // Diviser le texte en lignes pour les longs messages
            const lignes = messageNarratifActif.texte.split('\n');

            // Pas de fond - style discret mais bien visible
            // Texte blanc bold avec ombre noire marqu√©e
            ctx.fillStyle = '#FFFFFF';

            // Texte plus petit pour la phase finale (g√©n√©rique)
            if(phaseJeu === 'feux_artifice' || (narrationManager && narrationManager.currentPhase === 16)) {
                ctx.font = '14px Arial'; // Texte petit pour le g√©n√©rique
            } else {
                ctx.font = 'bold 20px Arial'; // Texte normal
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Ombre fine et subtile pour lisibilit√©
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;

            // Traiter chaque ligne pour un formatage optimal
            const hauteurLigne = 26;
            const margeHorizontale = 40;
            const largeurMax = C.W - (margeHorizontale * 2);

            let lignesFinales = [];

            // Pr√©-traiter toutes les lignes pour g√©rer le retour √† la ligne intelligent
            lignes.forEach(ligne => {
                const largeurTexte = ctx.measureText(ligne).width;

                if (largeurTexte > largeurMax) {
                    // Diviser intelligemment la ligne trop longue
                    const mots = ligne.split(' ');
                    let ligneActuelle = '';

                    for (let mot of mots) {
                        const testLigne = ligneActuelle + (ligneActuelle ? ' ' : '') + mot;
                        const testLargeur = ctx.measureText(testLigne).width;

                        if (testLargeur > largeurMax && ligneActuelle !== '') {
                            lignesFinales.push(ligneActuelle);
                            ligneActuelle = mot;
                        } else {
                            ligneActuelle = testLigne;
                        }
                    }

                    if (ligneActuelle) {
                        lignesFinales.push(ligneActuelle);
                    }
                } else {
                    lignesFinales.push(ligne);
                }
            });

            // Calculer la position de d√©part pour centrer verticalement le bloc de texte
            const hauteurTotale = lignesFinales.length * hauteurLigne;
            const yDebut = posY - hauteurTotale / 2;

            // Dessiner toutes les lignes finales
            lignesFinales.forEach((ligne, index) => {
                const y = yDebut + (index + 1) * hauteurLigne;
                ctx.fillText(ligne, C.W/2, y);
            });

            ctx.restore();
        }

        // Fonction pour dessiner le bouton "Passer" simple
        function dessinerBoutonPasser() {
            if (!boutonPasser.actif) return;

            // Animation de pulsation
            boutonPasser.pulse += 0.03; // 5x plus lent (0.15 / 5 = 0.03)
            const scale = 1 + Math.sin(boutonPasser.pulse) * 0.15; // Pulsation entre 0.85 et 1.15
            const alpha = 0.8 + Math.sin(boutonPasser.pulse) * 0.2; // Alpha entre 0.6 et 1.0

            // Position en bas du texte d'intro
            boutonPasser.x = C.W/2 - boutonPasser.largeur/2;
            boutonPasser.y = C.H * 0.55; // Positionn√© sous le texte d'intro (40% + espace)

            ctx.save();

            // Appliquer la transformation de pulsation
            const centerX = boutonPasser.x + boutonPasser.largeur/2;
            const centerY = boutonPasser.y + boutonPasser.hauteur/2;
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            // Juste du texte avec ombre - pas de fond ni bordure
            ctx.globalAlpha = alpha;
            ctx.fillStyle = boutonPasser.hover ? '#ff6666' : '#ff0000';
            ctx.font = 'bold 32px "Orbitron", "Exo 2", "Rajdhani", monospace'; // Police futuriste encore plus grosse
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Ombre fine et moderne
            ctx.shadowColor = '#000000';
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;

            ctx.fillText(boutonPasser.texte, centerX, centerY);

            ctx.restore();
        }

        // Fonction pour v√©rifier si on clique sur le bouton
        function verifierClicBoutonPasser(x, y) {
            if (!boutonPasser.actif) return false;

            return x >= boutonPasser.x && x <= boutonPasser.x + boutonPasser.largeur &&
                   y >= boutonPasser.y && y <= boutonPasser.y + boutonPasser.hauteur;
        }

        // Power-Up Bleu √âtincelant
        function creerPowerUp(x, y) {
            // allume_lanterne n'appara√Æt pas al√©atoirement - seulement via creerPowerUpLanterne()
            const types = ['etoile_montante', 'poxerstart', 'vitesse', 'bonus_points'];
            const typeAleatoire = types[Math.floor(Math.random() * types.length)];

            const nouveauPowerUp = {
                x, y,
                w: C.BS * 1.5, h: C.BS * 1.5,
                type: typeAleatoire,
                temps: 0,
                etincelles: []
            };

            powerUps.push(nouveauPowerUp);
            console.log(`üéØ Power-up cr√©√©: ${typeAleatoire} √† (${x}, ${y}), total: ${powerUps.length}`);
        }

        function dessinerPowerUps() {
            if(powerUps.length > 0) {
                // console.log(`üé® Dessin de ${powerUps.length} power-ups`);
            }
            powerUps.forEach(power => {
                ctx.save();

                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(power.x + 3, power.y + 3, power.w, power.h);

                // Couleur selon le type
                let couleur1, couleur2, couleur3;
                switch(power.type) {
                    case 'etoile_montante':
                        couleur1 = '#FFD700'; couleur2 = '#FFA500'; couleur3 = '#FF8C00'; // Dor√©
                        break;
                    case 'poxerstart':
                        couleur1 = '#FF69B4'; couleur2 = '#FF1493'; couleur3 = '#DC143C'; // Rose/Rouge
                        break;
                    case 'vitesse':
                        couleur1 = '#00FF00'; couleur2 = '#32CD32'; couleur3 = '#228B22'; // Vert
                        break;
                    case 'bonus_points':
                        couleur1 = '#9400D3'; couleur2 = '#8A2BE2'; couleur3 = '#7B68EE'; // Violet
                        break;
                    case 'allume_lanterne':
                        couleur1 = '#FFA500'; couleur2 = '#FF8C00'; couleur3 = '#FF6347'; // Orange/Rouge (feu)
                        break;
                    default:
                        couleur1 = '#00aaff'; couleur2 = '#0099dd'; couleur3 = '#0088cc'; // Bleu
                }

                // D√©grad√© selon le type
                const grad = ctx.createLinearGradient(power.x, power.y, power.x + power.w, power.y + power.h);
                grad.addColorStop(0, couleur1);
                grad.addColorStop(0.5, couleur2);
                grad.addColorStop(1, couleur3);

                ctx.fillStyle = grad;
                ctx.fillRect(power.x, power.y, power.w, power.h);

                // Bordure scintillante
                ctx.strokeStyle = `hsl(${(power.temps * 15) % 360}, 100%, 90%)`;
                ctx.lineWidth = 3;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 10;
                ctx.strokeRect(power.x, power.y, power.w, power.h);
                ctx.shadowBlur = 0;

                // Ic√¥ne lanterne üèÆ
                ctx.fillStyle = '#ffffff';
                ctx.font = `${power.h * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('üèÆ', power.x + power.w/2, power.y + power.h*0.7);

                // √âtincelles autour
                for(let i = 0; i < 3; i++) {
                    const angle = (power.temps * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = power.w * 0.8;
                    const ex = power.x + power.w/2 + Math.cos(angle) * dist;
                    const ey = power.y + power.h/2 + Math.sin(angle) * dist;

                    ctx.fillStyle = `hsl(${(power.temps * 10 + i * 120) % 360}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                power.temps += 1;
                ctx.restore();
            });
        }

        function mettreAJourPowerUps() {
            // Collision avec la balle (seulement en phase lanterne)
            if (balle && balle.visible && phaseJeu === 'lanterne') {
                if(powerUps.length > 0) {
                    // console.log(`üîç V√©rif collision balle(${balle.x.toFixed(1)}, ${balle.y.toFixed(1)}) avec ${powerUps.length} power-ups`);
                }
                for(let i = powerUps.length - 1; i >= 0; i--) {
                    const power = powerUps[i];
                    if(balle.x + C.BS >= power.x && balle.x - C.BS <= power.x + power.w &&
                       balle.y + C.BS >= power.y && balle.y - C.BS <= power.y + power.h) {

                    // Effets selon le type de power-up
                    console.log(`‚ö° Power-up activ√©: ${power.type}`);
                    switch(power.type) {
                        case 'etoile_montante':
                            // Cr√©er une √©toile qui monte au ciel + 1000 XP
                            creerEtoileMontante(power.x + power.w/2, power.y + power.h/2);
                            score += 1000;
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFD700', 8);
                            console.log('‚≠ê √âtoile montante cr√©√©e + 1000 XP');

                            // Message simple
                            afficherMessagePowerupSimple('‚≠ê √âtoile montante +1000 XP');
                            break;

                        case 'poxerstart':
                            // Active le mode tir √©toiles normal pendant 7 secondes
                            if(!window.modeTirStars || !window.modeTirStars.actif) {
                                const finTirStars = Date.now() + 7000;
                                window.modeTirStars = { actif: true, fin: finTirStars };
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FF69B4', 8);
                                console.log('üåü Mode tir √©toiles POXERSTART activ√© (7s)');

                                // Message simple
                                afficherMessagePowerupSimple('üåü Poxerstart activ√© - 7 secondes');

                                // Indicateur visuel sur la raquette
                                raquette.poxerstart = true;
                                raquette.poxerstartFin = finTirStars;
                            } else {
                                console.log('üö´ Mode tir √©toiles d√©j√† actif - ignor√©');
                            }
                            break;

                        case 'vitesse':
                            // Balle plus rapide pendant 8 secondes (ne pas cumuler)
                            if(!balle.vitesseActive) {
                                balle.multiplicateurVitesse = 1.8; // Fixe √† 1.8x pour √©viter l'accumulation
                                balle.vitesseActive = true;
                                balle.vitesseFinTime = Date.now() + 8000; // 8s

                                // Effet visuel de tra√Æn√©e verte
                                balle.traineeVerte = true;

                                setTimeout(() => {
                                    balle.multiplicateurVitesse = 1; // Reset √† 1 au lieu de diviser
                                    balle.vitesseActive = false;
                                    balle.traineeVerte = false;
                                    console.log('üí® Mode vitesse termin√©');
                                }, 8000);

                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#00FF00', 15);
                                console.log('üí® Mode vitesse TURBO activ√© (8s) - 1.8x plus rapide!');

                                // Message simple
                                afficherMessagePowerupSimple('üí® Vitesse turbo activ√©e !');
                            } else {
                                console.log('üö´ Vitesse d√©j√† active - ignor√©');
                            }
                            break;

                        case 'bonus_points':
                            // Points bonus (toujours cumulable) - augment√© !
                            score += 500; // 500 au lieu de 200
                            ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#9400D3', 10);
                            console.log('üíé +500 points bonus!');

                            // Message simple
                            afficherMessagePowerupSimple('üíé Bonus points +500');
                            break;

                        case 'allume_lanterne':
                            // Allumer la lanterne si elle est √©teinte
                            if(!lanterne.active) {
                                lanterne.active = true;
                                lanterne.intensite = 1.0;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 12);
                                console.log('üèÆ Lanterne allum√©e!');

                                // Message simple
                                afficherMessagePowerupSimple('üèÆ Lanterne allum√©e !');
                            } else {
                                // Si d√©j√† allum√©e, donner des points bonus
                                score += 300;
                                ajouterParticules(power.x + power.w/2, power.y + power.h/2, '#FFA500', 8);
                                console.log('üèÆ Lanterne d√©j√† allum√©e - +300 points bonus');
                                afficherMessagePowerupSimple('üèÆ Lanterne +300 bonus');
                            }
                            break;
                    }

                    // Toujours supprimer le power-up apr√®s contact (m√™me si effet ignor√©)
                    powerUps.splice(i, 1);
                    }
                }
            }
        }

        // Fonction sp√©ciale pour cr√©er le power-up lanterne sur la premi√®re brique en bas
        function creerPowerUpLanterne() {
            // Trouver la brique la plus en bas (plus grand Y)
            let briqueLoPlus = null;
            let yMax = -1;

            briques.forEach(brique => {
                if(brique.visible && brique.y > yMax) {
                    yMax = brique.y;
                    briqueLoPlus = brique;
                }
            });

            // Si on a trouv√© une brique en bas, y placer le power-up lanterne
            if(briqueLoPlus) {
                const powerUpLanterne = {
                    x: briqueLoPlus.x + briqueLoPlus.w/2 - C.BS * 0.75,
                    y: briqueLoPlus.y + briqueLoPlus.h/2 - C.BS * 0.75,
                    w: C.BS * 1.5,
                    h: C.BS * 1.5,
                    type: 'allume_lanterne',
                    temps: 0,
                    etincelles: [],
                    special: true // Marquer comme power-up sp√©cial
                };

                powerUps.push(powerUpLanterne);
                console.log('üèÆ Power-up LANTERNE plac√© sur la brique du bas!');
            }
        }

        // Cr√©er une √©toile qui monte vers le ciel
        function creerEtoileMontante(x, y) {
            // Cr√©er l'√©toile montante
            const etoile = {
                x: x,
                y: y,
                taille: 30,
                vitesseY: -3,
                temps: 0,
                alpha: 1,
                particules: []
            };

            // Animation de l'√©toile qui monte
            const animer = () => {
                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    requestAnimationFrame(animer);
                    return;
                }

                etoile.y += etoile.vitesseY;
                etoile.temps += 1;
                etoile.alpha = Math.max(0, 1 - etoile.temps / 120); // Dispara√Æt en 2 secondes √† 60fps

                // Dessiner l'√©toile
                ctx.save();
                ctx.globalAlpha = etoile.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.font = `${etoile.taille}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê', etoile.x, etoile.y);

                // Effet de tra√Æn√©e dor√©e
                for(let i = 0; i < 3; i++) {
                    const particuleX = etoile.x + (Math.random() - 0.5) * 20;
                    const particuleY = etoile.y + i * 15;
                    ctx.globalAlpha = etoile.alpha * (1 - i * 0.3);
                    ctx.fillStyle = `hsl(45, 100%, ${70 - i * 10}%)`;
                    ctx.font = `${etoile.taille * (1 - i * 0.2)}px serif`;
                    ctx.fillText('‚ú®', particuleX, particuleY);
                }
                ctx.restore();

                // Continuer l'animation si l'√©toile est encore visible
                if(etoile.alpha > 0 && etoile.y > -50) {
                    requestAnimationFrame(animer);
                }
            };

            requestAnimationFrame(animer);
        }

        function mettreAJourLanterne() {
            if(animationBateau.active) return; // Pas de mise √† jour pendant l'animation
            if(lanterne.active && phaseJeu === 'lanterne') {
                // Effet de pulsation encore plus douce
                lanterne.intensite = 0.7 + 0.3 * Math.sin(Date.now() * 0.001);

                // Cr√©er quelques particules dor√©es plus rarement (seulement en mode lanterne)
                if(Math.random() < 0.02) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = C.BS + Math.random() * 10;
                    ajouterParticules(
                        balle.x + Math.cos(angle) * dist,
                        balle.y + Math.sin(angle) * dist,
                        '#FFD700', 1
                    );
                }
            }
        }

        // Vagues d'amour multicolores qui dansent vers le ciel
        function creerRafaleCoeurs() {
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];

            // Cr√©er une rafale de 1-3 c≈ìurs
            const nombreCoeurs = 1 + Math.floor(Math.random() * 3);

            for(let i = 0; i < nombreCoeurs; i++) {
                setTimeout(() => {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * (40 * Math.PI / 180); // √âventail 40¬∞
                    const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];

                    coeursBateau.push({
                        x: raquette.x + C.PW/2 + (Math.random() - 0.5) * C.PW/4, // D√©part l√©g√®rement dispers√©
                        y: raquette.y - C.PH/2, // Tir depuis le haut du bateau
                        vx: Math.sin(angle) * C.SP * (0.6 + Math.random() * 0.8), // Plus de mouvement horizontal (2x plus rapide)
                        vy: -Math.abs(Math.cos(angle) * C.SP * (3 + Math.random() * 2)), // Vitesses variables (2x plus rapide)
                        taille: C.BS * [1.2, 1.5, 1.8][Math.floor(Math.random() * 3)], // 3 tailles plus grosses: moyen, grand, tr√®s grand
                        couleur: couleur,
                        flottemment: Math.random() * Math.PI * 2, // Phase de flottement
                        vitesseFlottement: 0.02 + Math.random() * 0.02, // Vitesse de flottement
                        vie: 1,
                        luminosite: 1,
                        scintillement: Math.random() * Math.PI * 2
                    });
                }, i * 100); // D√©lai entre chaque c≈ìur de la rafale
            }
        }

        function mettreAJourCoeursBateau() {
            const tempsActuel = Date.now();

            // Plus de c≈ìurs automatiques pendant l'intro
            // Pendant le jeu normal : plus de d√©clenchement automatique
            // Les rafales se d√©clenchent seulement sur clic/touche

            // Mettre √† jour les c≈ìurs de lumi√®re
            for(let i = coeursBateau.length - 1; i >= 0; i--) {
                const coeur = coeursBateau[i];
                coeur.x += coeur.vx;
                coeur.y += coeur.vy; // Mont√©e rapide
                coeur.vx *= 0.98; // Convergence vers le centre

                // Animation de flottement gauche-droite
                if(coeur.vitesseFlottement !== undefined) {
                    coeur.flottemment += coeur.vitesseFlottement;
                    // Ajouter un mouvement oscillant horizontal
                    coeur.x += Math.sin(coeur.flottemment) * 0.5;
                }

                // Animation de scintillement
                coeur.scintillement += 0.2;
                coeur.luminosite = 0.7 + 0.3 * Math.sin(coeur.scintillement);

                // Supprimer si sort de l'√©cran par le haut
                if(coeur.y < -100) {
                    coeursBateau.splice(i, 1);
                    continue;
                }

                // Collision avec les petits c≈ìurs du haut en phase 1
                if(phaseJeu === 'tir_coeurs_haut') {
                    petitsCoeurs.forEach((petitCoeur, j) => {
                        if(!petitCoeur.visible) return;

                        // V√©rifier collision
                        if(coeur.x + coeur.taille/2 >= petitCoeur.x - petitCoeur.w/2 &&
                           coeur.x - coeur.taille/2 <= petitCoeur.x + petitCoeur.w/2 &&
                           coeur.y + coeur.taille/2 >= petitCoeur.y - petitCoeur.h/2 &&
                           coeur.y - coeur.taille/2 <= petitCoeur.y + petitCoeur.h/2) {

                            // C≈ìur touch√© !
                            petitCoeur.visible = false;
                            pointsConnaissance += 10;

                            // Effets visuels
                            ajouterParticulesCoeurs(petitCoeur.x, petitCoeur.y, petitCoeur.couleur, 8);
                            ajouterTexteVolant(`+${petitCoeur.etape.nom}`, petitCoeur.x, petitCoeur.y);

                            // Supprimer le c≈ìur du bateau
                            coeursBateau.splice(i, 1);

                            // V√©rifier si tous les c≈ìurs du haut sont touch√©s
                            const coeurRestants = petitsCoeurs.filter(c => c.visible).length;
                            if(coeurRestants === 0 && phaseJeu === 'tir_coeurs_haut') {
                                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    console.log('üéÜ Animation c≈ìurs petits termin√©e, passage √† la phase suivante');
                                    narrationManager.goToNextPhaseDirect();
                                    dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 1);
                                    // Forcer la balle visible en phase lanterne et la mettre en attente
                                    balle.visible = true;
                                    balle.enAttente = true;
                                    balle.dx = 0;
                                    balle.dy = 0;
                                    // Garder l'√©tat de la lanterne de la phase pr√©c√©dente
                                    // lanterne.active et lanterne.intensite conserv√©s
                                    // Initialiser les briques pour la phase 2
                                    dedoublerCoeursEnBriques();
                                    // Message g√©r√© par le nouveau syst√®me narratif

                                    // Cr√©er quelques c≈ìurs d√©coratifs qui flottent (diff√©rents de ceux du haut)
                                    setTimeout(() => {
                                        // Cr√©er des c≈ìurs d√©coratifs flottants au lieu de recr√©er les c≈ìurs du haut
                                        for(let i = 0; i < 10; i++) {
                                            particules.push({
                                                x: Math.random() * C.W,
                                                y: C.H + Math.random() * 50,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: -(Math.random() * 3 + 1),
                                                couleur: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'][i % 5],
                                                vie: 1,
                                                taille: Math.random() * 4 + 3,
                                                type: 'coeur'
                                            });
                                        }

    
                                        // Transition vers le jeu de briques apr√®s 3 secondes (seulement si on est en phase petits_coeurs)
                                        // Plus de transition automatique vers stars - on reste en phase lanterne pour la phase 2
                                    }, 3000);
                                });
                            }
                            return;
                        }
                    });
                }

                // Collision avec les briques
                // Bloquer compl√®tement les collisions pendant le mode secret
                if (secretModeModule && secretModeModule.isActive) {
                    return; // Pas de collision avec les briques en mode secret
                }
                if (modeSecret) {
                    return; // Pas de collision avec les briques en mode secret (fallback)
                }

                // V√©rifier d'abord s'il reste plus d'une brique pour √©viter le passage automatique
                const briquesRestantes = briques.filter(b => b.visible).length;

                briques.forEach(brique => {
                    if(!brique.visible) return;

                    // Si il ne reste qu'une brique, les c≈ìurs ne peuvent plus la casser
                    if(briquesRestantes <= 1 && (phaseJeu === 'lanterne' || phaseJeu === 'stars')) {
                        return; // Arr√™ter les collisions pour √©viter la transition automatique
                    }

                    const dx = coeur.x - (brique.x + brique.w/2);
                    const dy = coeur.y - (brique.y + brique.h/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if(distance < coeur.taille + brique.w/4) {
                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames

                        // Supprimer le c≈ìur volant
                        coeursBateau.splice(i, 1);

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                            brique.visible = false;
                            brises++;

                            // Explosion en 3 petits c≈ìurs seulement
                            for(let j = 0; j < 3; j++) {
                                particules.push({
                                    x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                    y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: -(Math.random() * 8 + 4),
                                    couleur: brique.couleur,
                                    vie: 1,
                                    taille: Math.random() * 3 + 4,
                                    type: 'coeur'
                                });
                            }

                            // Texte du c≈ìur qui grossit et monte au ciel
                            ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                            // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge
                        }

                        score += 50; // 50 points par coup

                        // V√©rifier la condition de fin selon le mode de jeu
                        if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                            // Mode briques : v√©rifier si presque toutes les briques sont d√©truites (garder la derni√®re)
                            const briquesRestantes = briques.filter(b => b.visible).length;
                            // console.log(`üîç V√©rif briques restantes: ${briquesRestantes}`);
                            // Ne pas d√©clencher automatiquement si il reste seulement 1 brique
                            // Le joueur doit d√©cider quand passer √† la phase suivante
                            if(briquesRestantes === 0) {
                                console.log('üéÜ TOUTES LES BRIQUES D√âTRUITES ! Animation d\'explosion !');

                                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    console.log('üéÜ Animation briques termin√©e, passage √† la phase suivante');
                                    narrationManager.goToNextPhaseDirect();
                                });
                            }
                        } else if(brises >= VOYAGE.length) {
                            // Mode c≈ìurs : progression classique bas√©e sur VOYAGE
                            console.log(`üéÜ NIVEAU TERMIN√â ! brises: ${brises}, VOYAGE.length: ${VOYAGE.length}, phase: ${phaseJeu}`);

                            // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante apr√®s animation
                                console.log('üéÜ Animation termin√©e, passage √† la phase suivante');
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                            });
                        }
                    }
                });
            }
        }

        // üéÜ ANIMATION D'EXPLOSION DE L'IC√îNE COLLECTOR ET COLLECTION AUTOMATIQUE D'√âNIGME
        function animerExplosionIconeCollector(callback = null) {
            console.log('üéÜ ANIMATION EXPLOSION D√âCLENCH√âE !');

            // Position de l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;

            // Si l'ic√¥ne n'est pas encore positionn√©e, utiliser le centre de l'√©cran
            let explosionX, explosionY;
            if (centralIcon.x === 0 && centralIcon.y === 0) {
                explosionX = C.W / 2;
                explosionY = C.H / 2;
            } else {
                explosionX = centralIcon.x + centralIcon.width / 2;
                explosionY = centralIcon.y + centralIcon.height / 2;
            }

            // Animation d'explosion avec particules dor√©es
            if (typeof ajouterParticules === 'function') {
                ajouterParticules(explosionX, explosionY, '#FFD700', 15); // Explosion dor√©e
                ajouterParticules(explosionX, explosionY, '#FFA500', 10); // Explosion orange
                ajouterParticules(explosionX, explosionY, '#FFFF00', 8); // Explosion jaune
                ajouterParticules(explosionX, explosionY, '#FF4500', 5); // Explosion rouge-orange
            }

            // üåßÔ∏è Pluie de c√©l√©bration lors des transitions de phase
            setTimeout(() => {
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }, 1000); // D√©clencher apr√®s 1 seconde d'explosion

            // Collection automatique d'√©nigme bas√©e sur la phase actuelle
            if (enigmaCollector) {
                let enigmeAColleter = null;

                // D√©terminer quelle √©nigme collecter selon la phase
                switch(phaseJeu) {
                    case 'tir_coeurs_haut':
                    case 'petits_coeurs':
                    case 'coeurs':
                        // Phase c≈ìurs - collecter une √©nigme de type "coeurs"
                        const enigmesCoeurs = ['humanite', 'diversite', 'respect', 'restauration'];
                        enigmeAColleter = enigmesCoeurs.find(id => !enigmaCollector.enigmesCollectees.has(id));
                        break;

                    case 'lanterne':
                        // Phase lanterne - collecter les √©nigmes de type "briques"
                        const enigmesBriques = ['paix', 'foi', 'hopital'];
                        enigmeAColleter = enigmesBriques.find(id => !enigmaCollector.enigmesCollectees.has(id));
                        break;

                    case 'stars':
                    case 'nuit_coeurs':
                        // Phase nuit c≈ìurs - collecter les √©nigmes correspondantes
                        const enigmesNuit = ['liberte', 'entraide'];
                        enigmeAColleter = enigmesNuit.find(id => !enigmaCollector.enigmesCollectees.has(id));
                        break;

                    default:
                        // Fallback - collecter n'importe quelle √©nigme disponible
                        const toutesEnigmes = Object.keys(ENIGMES_DATABASE).filter(id => id !== 'ange');
                        enigmeAColleter = toutesEnigmes.find(id => !enigmaCollector.enigmesCollectees.has(id));
                        break;
                }

                // Collecter l'√©nigme avec animation
                if (enigmeAColleter) {
                    // console.log(`üß© TENTATIVE COLLECTION: ${enigmeAColleter} (phase: ${phaseJeu})`);
                    setTimeout(() => {
                        const success = enigmaCollector.collecterEnigme(enigmeAColleter, true);
                        // console.log(`üß© R√âSULTAT COLLECTION: ${success ? 'SUCC√àS' : '√âCHEC'} pour ${enigmeAColleter}`);
                        if (success) {
                            // console.log(`üéÜ √âNIGME COLLECT√âE AVEC SUCC√àS: ${enigmeAColleter}`);
                            // Message sp√©cial d'explosion et collection
                            const enigme = ENIGMES_DATABASE[enigmeAColleter];
                            if (enigme && typeof afficherMessage === 'function') {
                                afficherMessage('üéÜüí• EXPLOSION MYSTIQUE ! üí•üéÜ\n\n‚ú® √âNIGME R√âV√âL√âE ! ‚ú®\n\n' + enigme.icone + ' "' + enigme.nom + '" collect√©e !\n\nüí≠ "' + enigme.mystere + '"\n\nüåü Consultez le menu des √©nigmes ! üåü', 5000);
                            }
                        } else {
                            // console.log(`‚ùå √âCHEC COLLECTION pour ${enigmeAColleter}: d√©j√† collect√©e ou erreur`);
                        }
                    }, 200);
                }
            }

            // Animation d'explosion plus visible avec flash et zoom dramatique
            let animationFrame = 0;
            const maxFrames = 300; // 5 secondes √† 60 FPS - animation encore plus lente

            // Cr√©er un flash blanc sur tout l'√©cran
            const createFlash = () => {
                const flashDiv = document.createElement('div');
                flashDiv.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: white;
                    z-index: 9999;
                    opacity: 0.8;
                    pointer-events: none;
                `;
                document.body.appendChild(flashDiv);

                // Fade out du flash
                let opacity = 0.8;
                const fadeFlash = () => {
                    // Respecter la pause du jeu
                    if (window.jeuEnPause) {
                        requestAnimationFrame(fadeFlash);
                        return;
                    }

                    opacity -= 0.05;
                    flashDiv.style.opacity = opacity;
                    if (opacity <= 0) {
                        document.body.removeChild(flashDiv);
                    } else {
                        requestAnimationFrame(fadeFlash);
                    }
                };
                requestAnimationFrame(fadeFlash);
            };

            // Flash imm√©diat
            createFlash();

            const animer = () => {
                // Respecter la pause du jeu
                if (window.jeuEnPause) {
                    requestAnimationFrame(animer);
                    return;
                }

                if (animationFrame < maxFrames) {
                    animationFrame++;

                    // Effet de zoom plus dramatique
                    const progress = animationFrame / maxFrames;
                    let zoom;
                    if (progress < 0.2) {
                        // Implosion rapide
                        zoom = 1 - progress * 2;
                    } else if (progress < 0.6) {
                        // Explosion dramatique
                        zoom = 0.6 + (progress - 0.2) * 5;
                    } else {
                        // Retour normal avec oscillation
                        const oscillation = Math.sin((progress - 0.6) * Math.PI * 4) * 0.2;
                        zoom = 1.2 - (progress - 0.6) * 0.5 + oscillation;
                    }

                    // Sauvegarder l'√©tat original de l'ic√¥ne
                    if (animationFrame === 1) {
                        menuEnigmesCanvas.centralIcon.originalSize = menuEnigmesCanvas.centralIcon.width;
                    }

                    // Modifier la taille de l'ic√¥ne
                    const newSize = Math.max(5, menuEnigmesCanvas.centralIcon.originalSize * zoom); // Minimum 5px
                    menuEnigmesCanvas.centralIcon.width = newSize;
                    menuEnigmesCanvas.centralIcon.height = newSize;

                    // Debug d√©sactiv√© pour r√©duire les logs

                    requestAnimationFrame(animer);
                } else {
                    // Restaurer la taille originale
                    if (menuEnigmesCanvas.centralIcon.originalSize) {
                        menuEnigmesCanvas.centralIcon.width = menuEnigmesCanvas.centralIcon.originalSize;
                        menuEnigmesCanvas.centralIcon.height = menuEnigmesCanvas.centralIcon.originalSize;
                        delete menuEnigmesCanvas.centralIcon.originalSize;
                    }

                    // Ex√©cuter le callback apr√®s l'animation avec un d√©lai pour les textes narratifs
                    if (callback && typeof callback === 'function') {
                        setTimeout(() => {
                            callback();
                        }, 500); // D√©lai de 500ms pour permettre aux textes narratifs de s'afficher
                    }
                }
            };

            animer();
        }

        function dessinerCoeursBateau() {
            coeursBateau.forEach(coeur => {
                const couleurCoeur = coeur.couleur || '#FFFFFF';

                // Forme √©toile/diamant pour les c≈ìurs du bateau
                ctx.save();
                ctx.fillStyle = couleurCoeur;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;

                const t = coeur.taille;

                ctx.translate(coeur.x, coeur.y);

                // C≈ìur en polygone pour le bateau
                ctx.beginPath();

                // Lobe gauche
                ctx.moveTo(-t * 0.25, 0);
                ctx.lineTo(-t * 0.15, -t * 0.15);
                ctx.lineTo(-t * 0.05, -t * 0.1);
                ctx.lineTo(-t * 0.02, 0);

                // Lobe droit
                ctx.lineTo(t * 0.02, 0);
                ctx.lineTo(t * 0.05, -t * 0.1);
                ctx.lineTo(t * 0.15, -t * 0.15);
                ctx.lineTo(t * 0.25, 0);

                // Descente vers la pointe
                ctx.lineTo(t * 0.1, t * 0.15);
                ctx.lineTo(0, t * 0.3);
                ctx.lineTo(-t * 0.1, t * 0.15);

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            });
        }

        // Petits c≈ìurs d√©coratifs en haut
        function creerPetitsCoeurs() {
            petitsCoeurs = [];
            const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502', '#26de81', '#fd79a8'];

            // Cr√©er un visage rond avec les c≈ìurs - PLUS GRAND
            const centreX = C.W / 2;
            const centreY = C.H * 0.3;
            const rayon = Math.min(C.W, C.H) * 0.22; // Rayon du visage agrandi (0.22 au lieu de 0.15)

            for(let i = 0; i < 40; i++) { // 40 c≈ìurs pour former le visage
                const taille = C.BS * (1.5 + Math.random() * 2.5); // Tailles vari√©es

                // Position en cercle
                const angle = (i / 40) * 2 * Math.PI; // R√©partir sur 360¬∞
                const x = centreX + Math.cos(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation
                const y = centreY + Math.sin(angle) * rayon + (Math.random() - 0.5) * 20; // L√©g√®re variation

                petitsCoeurs.push({
                    x: x,
                    y: y,
                    w: taille, h: taille, // Dimensions pour collision
                    taille: taille,
                    couleur: couleurs[i % couleurs.length],
                    visible: true, // Peut √™tre cass√©
                    etape: VOYAGE[Math.min(i, VOYAGE.length - 1)], // Associer une √©tape narrative
                    scintillement: Math.random() * Math.PI * 2,
                    vitesseScintillement: 0.05 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    vitesseRotation: (Math.random() - 0.5) * 0.02,
                    pulsation: Math.random() * Math.PI * 2,
                    vitessePulsation: 0.03 + Math.random() * 0.02,
                });
            }
        }

        // üß± Cr√©er un mur vertical dans la mer
        function creerMurDansLaMer() {
            // Cacher/supprimer tous les petits c≈ìurs et √©l√©ments pr√©c√©dents
            petitsCoeurs = [];
            coeursBateau = [];

            // Dimensions des briques du mur
            const largeurBrique = Math.min(C.W, C.H) * 0.08;
            const hauteurBrique = Math.min(C.W, C.H) * 0.04;
            const espacement = 2;

            // Position du mur au centre de l'√©cran
            const centreX = C.W * 0.5;
            const nombreBriquesHauteur = 8;
            const nombreBriquesLargeur = 4;
            const hauteurTotaleMur = nombreBriquesHauteur * (hauteurBrique + espacement);
            const largeurTotaleMur = nombreBriquesLargeur * (largeurBrique + espacement);

            // Position de d√©part (centr√©)
            const startX = centreX - largeurTotaleMur / 2;
            const startY = C.H * 0.25;

            // Cr√©er les briques du mur
            let briqueIndex = 0;
            for(let rangee = 0; rangee < nombreBriquesHauteur; rangee++) {
                for(let colonne = 0; colonne < nombreBriquesLargeur; colonne++) {
                    if(briqueIndex < VOYAGE.length) {
                        const etape = VOYAGE[briqueIndex];

                        // Couleurs altern√©es pour l'effet mur
                        const couleurs = ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#BC8F8F'];
                        const couleur = couleurs[briqueIndex % couleurs.length];

                        briques.push({
                            x: startX + colonne * (largeurBrique + espacement),
                            y: startY + rangee * (hauteurBrique + espacement),
                            largeur: largeurBrique,
                            hauteur: hauteurBrique,
                            couleur: couleur,
                            visible: true,
                            etape: etape,
                            scintillement: Math.random() * Math.PI * 2,
                            type: 'mur' // Marquer comme brique de mur
                        });

                        briqueIndex++;
                    }
                }
            }
        }

        // G√©n√©rer des positions en forme de c≈ìur
        function genererPositionsCoeur(nbBriques, largeurBrique, hauteurBrique, espacement, margeHaut) {
            const positions = [];
            const centreX = C.W / 2;
            const centreY = margeHaut + C.H * 0.15;
            const taille = Math.min(C.W, C.H) * 0.3; // Taille du c≈ìur

            // G√©n√©rer des positions selon l'√©quation param√©trique d'un c≈ìur
            for(let i = 0; i < nbBriques; i++) {
                const t = (i / nbBriques) * 2 * Math.PI; // Param√®tre de 0 √† 2œÄ

                // √âquation param√©trique d'un c≈ìur : x = 16sin¬≥(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));

                // Mise √† l'√©chelle et centrage
                const posX = centreX + (x * taille / 32) - largeurBrique / 2;
                const posY = centreY + (y * taille / 32) - hauteurBrique / 2;

                positions.push({ x: posX, y: posY });
            }

            return positions;
        }

        function dedoublerCoeursEnBriques() {
            // Cacher/supprimer tous les petits c≈ìurs du haut avant le jeu de briques
            petitsCoeurs = [];

            // Supprimer tous les c≈ìurs r√©siduels du bateau
            coeursBateau = [];

            // Taille des briques
            const tailleUniforme = Math.min(C.W, C.H) * 0.06; // Plus petites pour le c≈ìur
            const largeurBrique = tailleUniforme * 1.2;
            const hauteurBrique = tailleUniforme * 0.8;
            const espacement = 5;
            const margeHaut = C.H * 0.15;

            // G√©n√©rer les positions en forme de c≈ìur
            const positionsCoeur = genererPositionsCoeur(VOYAGE.length, largeurBrique, hauteurBrique, espacement, margeHaut);

            // Cr√©er les briques selon la disposition en c≈ìur
            for(let i = 0; i < VOYAGE.length; i++) {
                const etape = VOYAGE[i];
                const couleur = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFA502'][i % 8];
                const pos = positionsCoeur[i];

                briques.push({
                    x: pos.x,
                    y: pos.y,
                    w: largeurBrique,
                    h: hauteurBrique,
                    visible: true,
                    etape: etape,
                    taille: tailleUniforme,
                    couleur: couleur,
                    vieMax: phaseJeu === 'lanterne' ? 2 : 3,     // 2 coups en phase lanterne, 3 en phase stars
                    vie: phaseJeu === 'lanterne' ? 2 : 3,        // Vie actuelle
                    clignotement: 0, // Animation quand touch√©e
                    // Animation de d√©doublement
                    animationDedoublement: {
                        originX: C.W / 2,
                        originY: C.H * 0.15,
                        progress: 0,
                        duree: 2000
                    }
                });
            }

            // Placer automatiquement le power-up lanterne sur la premi√®re brique en bas
            // Mais seulement en phase lanterne et si la lanterne n'est pas d√©j√† allum√©e
            if(phaseJeu === 'lanterne' && !lanterne.active) {
                setTimeout(() => {
                    creerPowerUpLanterne();
                }, 500); // Petit d√©lai pour laisser les briques se placer
            }
        }

        function libererVaguesAmour() {
            // Ne lib√©rer des vagues d'amour que si le jeu est actif
            if (!jeu || phaseIntro.active) return;

            const tempsActuel = Date.now();

            // Mode √©toile c≈ìur activ√© par power-up
            if(window.modeEtoileCoeur && window.modeEtoileCoeur.actif) {
                if(Date.now() > window.modeEtoileCoeur.fin) {
                    window.modeEtoileCoeur.actif = false;
                } else if(tempsActuel - derniereCreeRafale >= 200) { // Plus fr√©quent pendant le power-up
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
            // Mode normal
            else if (tempsActuel - derniereCreeRafale >= 500) { // Au minimum 0.5s entre les vagues
                if(phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'stars') {
                    // Phase 1 et 3 : lib√©rer des vagues d'amour qui montent doucement
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                } else if(phaseJeu === 'stars' && briques.filter(b => b.visible).length === 1) {
                    // Phase 3 : lib√©rer l'amour seulement pour la derni√®re brique
                    creerRafaleCoeurs();
                    derniereCreeRafale = tempsActuel;
                }
            }
        }

        function mettreAJourPetitsCoeurs() {
            petitsCoeurs.forEach((coeur, index) => {
                // Animation de scintillement
                coeur.scintillement += coeur.vitesseScintillement;

                // Animation de rotation
                coeur.rotation += coeur.vitesseRotation;

                // Animation de pulsation (taille)
                coeur.pulsation += coeur.vitessePulsation;

            });
        }

        // Fonction pour dessiner des c≈ìurs avec 20 triangles (pour les briques)
        function dessinerCoeurPixelArt(x, y, taille, couleur) {
            ctx.save();
            ctx.translate(x, y);

            const t = taille;
            const temps = Date.now() * 0.003;
            const pulsation = 1 + Math.sin(temps) * 0.15; // Pulsation douce

            // Appliquer la pulsation
            ctx.scale(pulsation, pulsation);

            // Style simple et clair
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            const triangleSize = t * 0.08;

            // C≈ìur super mignon pour les briques qui pulse
            ctx.beginPath();

            // Lobe gauche (forme arrondie avec segments)
            ctx.moveTo(-t * 0.3, -t * 0.02);
            ctx.lineTo(-t * 0.22, -t * 0.18);
            ctx.lineTo(-t * 0.12, -t * 0.2);
            ctx.lineTo(-t * 0.05, -t * 0.1);
            ctx.lineTo(-t * 0.02, -t * 0.02);

            // Lobe droit (forme arrondie avec segments)
            ctx.lineTo(t * 0.02, -t * 0.02);
            ctx.lineTo(t * 0.05, -t * 0.1);
            ctx.lineTo(t * 0.12, -t * 0.2);
            ctx.lineTo(t * 0.22, -t * 0.18);
            ctx.lineTo(t * 0.3, -t * 0.02);

            // Descente vers la pointe avec courbe
            ctx.lineTo(t * 0.18, t * 0.15);
            ctx.lineTo(t * 0.08, t * 0.3);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.08, t * 0.3);
            ctx.lineTo(-t * 0.18, t * 0.15);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // D√©tails mignons - petits c≈ìurs √† l'int√©rieur
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';

            // Petit c≈ìur gauche
            ctx.beginPath();
            ctx.moveTo(-t * 0.15, -t * 0.05);
            ctx.lineTo(-t * 0.12, -t * 0.08);
            ctx.lineTo(-t * 0.09, -t * 0.05);
            ctx.lineTo(-t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Petit c≈ìur droit
            ctx.beginPath();
            ctx.moveTo(t * 0.09, -t * 0.05);
            ctx.lineTo(t * 0.12, -t * 0.08);
            ctx.lineTo(t * 0.15, -t * 0.05);
            ctx.lineTo(t * 0.12, t * 0.02);
            ctx.closePath();
            ctx.fill();

            // Point lumineux central
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, t * 0.05, t * 0.02, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function dessinerCoeurPolygonal(x, y, taille, couleur, rotation = 0, intensite = 1) {
            ctx.save();
            ctx.translate(x, y);
            if(rotation) ctx.rotate(rotation);

            const t = taille;

            // Style simple
            ctx.fillStyle = couleur;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            // C≈ìur fait avec plusieurs triangles pour former une vraie forme
            ctx.beginPath();

            // Lobe gauche (plusieurs triangles pour arrondir)
            ctx.moveTo(-t * 0.3, -t * 0.05);
            ctx.lineTo(-t * 0.2, -t * 0.2);
            ctx.lineTo(-t * 0.1, -t * 0.15);
            ctx.lineTo(-t * 0.05, -t * 0.05);

            // Lobe droit (plusieurs triangles pour arrondir)
            ctx.lineTo(t * 0.05, -t * 0.05);
            ctx.lineTo(t * 0.1, -t * 0.15);
            ctx.lineTo(t * 0.2, -t * 0.2);
            ctx.lineTo(t * 0.3, -t * 0.05);

            // C√¥t√©s qui descendent vers la pointe
            ctx.lineTo(t * 0.15, t * 0.1);
            ctx.lineTo(0, t * 0.4);
            ctx.lineTo(-t * 0.15, t * 0.1);

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function dessinerPetitsCoeurs() {
            // Ne pas dessiner les petits c≈ìurs pendant l'animation du bateau, la phase lanterne ou la phase stars
            if(animationBateau.active || phaseJeu === 'lanterne' || phaseJeu === 'stars') return;

            petitsCoeurs.forEach(coeur => {
                if(!coeur.visible) return;

                // Calculs d'animation
                const intensite = (Math.sin(coeur.scintillement) + 1) * 0.5;
                const taillePulsee = coeur.taille * (1 + Math.sin(coeur.pulsation) * 0.1);

                // Dessiner le c≈ìur polygonal
                dessinerCoeurPolygonal(coeur.x, coeur.y, taillePulsee, coeur.couleur, coeur.rotation, intensite);
            });

            // Dessiner l'ic√¥ne th√©matique au centre du cercle de c≈ìurs
            dessinerIconeThematique();
        }

        // Ic√¥nes th√©matiques au centre du cercle de c≈ìurs
        function dessinerIconeThematique() {
            // Ne pas afficher l'ic√¥ne si l'animation est en cours
            if (animationIconeMenu.active) return;

            // Position haute et centr√©e horizontalement
            const centerX = C.W / 2;
            const centerY = C.H * 0.30; // Encore un petit peu plus bas (30% au lieu de 28%)

            // Mettre √† jour la zone cliquable de l'ic√¥ne centrale
            const iconSize = 60;
            menuEnigmesCanvas.centralIcon.x = centerX - iconSize / 2;
            menuEnigmesCanvas.centralIcon.y = centerY - iconSize / 2;
            menuEnigmesCanvas.centralIcon.width = iconSize;
            menuEnigmesCanvas.centralIcon.height = iconSize;

            // Animation de pulsation PLUS FORTE (augment√©e si survol√©e)
            const temps = Date.now() * 0.003; // Fr√©quence l√©g√®rement augment√©e
            const pulsationBase = menuEnigmesCanvas.centralIcon.hover ? 0.25 : 0.15; // Plus forte si survol√©e
            const pulsation = 1 + Math.sin(temps) * pulsationBase;
            const rotation = Math.sin(temps * 0.5) * 0.08; // Rotation plus visible (0.08 au lieu de 0.05)

            ctx.save();

            // Effet de bordure cliquable si survol√©e
            if (menuEnigmesCanvas.centralIcon.hover) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(pulsation, pulsation);

                // Bordure lumineuse blanche
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            ctx.scale(pulsation, pulsation);

            // Mapping des ic√¥nes selon les phases
            const iconesThematiques = {
                'humanite': 'ü§ù',        // Humanit√©
                'paix': 'üïäÔ∏è',           // Paix
                'diversite': 'üåà',       // Diversit√©
                'liberte': 'üóΩ',         // Libert√©
                'foi': 'üôè',             // Foi
                'respect': 'ü§≤',         // Respect
                'entraide': 'üíû',        // Entraide
                'hopital': 'üè•',         // H√¥pital
                'restauration': 'üå±',    // Restauration
                // Phases par d√©faut avec des ic√¥nes g√©n√©riques
                'coeurs': 'üíñ',          // Phase c≈ìurs g√©n√©rique
                'liberation': 'üïäÔ∏è',     // Phase lib√©ration
                'guerison': '‚ú®',        // Phase gu√©rison
                'renaissance': 'üå∏',     // Phase renaissance
                'transformation': 'ü¶ã', // Phase transformation
                'elevation': 'üåü',      // Phase √©l√©vation
                'illumination': 'üí´'     // Phase illumination
            };

            // D√©terminer quelle ic√¥ne afficher selon la phase actuelle
            let icone = iconesThematiques[phaseJeu] || 'üíñ'; // C≈ìur par d√©faut

            // Plus d'animation - l'ic√¥ne reste affich√©e et les ic√¥nes en haut servent de menu
            detecterFinNiveau(); // D√©tecter quand m√™me la fin pour autres logiques

            // Debug d√©sactiv√© pour r√©duire le spam de logs

            // Affichage de l'ic√¥ne avec style - PLUS PETITE
            ctx.font = '28px Arial'; // R√©duit de 48px √† 28px
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Effet de lueur douce - R√©duit
            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowBlur = 10; // R√©duit de 20 √† 10
            ctx.fillStyle = '#ffffff';
            ctx.fillText(icone, 0, 0);

            // Deuxi√®me couche sans ombre pour plus de clart√©
            ctx.shadowBlur = 0;
            ctx.fillText(icone, 0, 0);

            ctx.restore();
        }

        // D√©tecter quand un niveau est termin√©
        function detecterFinNiveau() {
            let niveauTermine = false;

            // Pour les phases de c≈ìurs : quand tous les c≈ìurs sont cass√©s
            if (phaseJeu === 'petits_coeurs') {
                const coeursVisibles = petitsCoeurs.filter(coeur => coeur.visible).length;
                niveauTermine = coeursVisibles === 0;
            }

            // Pour les phases de briques : quand toutes les briques sont cass√©es
            else if (phaseJeu === 'briques' || phaseJeu === 'lanterne') {
                const briquesVisibles = briques.filter(brique => brique.visible).length;
                niveauTermine = briquesVisibles === 0;
            }

            // Pour les autres phases bas√©es sur la variable brises
            else if (phaseJeu === 'tir_coeurs_haut' || phaseJeu === 'coeurs' || phaseJeu === 'stars' || phaseJeu === 'nuit_coeurs') {
                niveauTermine = brises >= VOYAGE.length;
            }

            // üéÜ Si le niveau est termin√©, d√©clencher l'animation d'explosion
            if (niveauTermine && !window.niveauTermineDejaDeclenche) {
                console.log(`üéÜ NIVEAU TERMIN√â d√©tect√© par detecterFinNiveau ! Phase: ${phaseJeu}, brises: ${brises}, VOYAGE.length: ${VOYAGE.length}`);

                // √âviter les d√©clenchements multiples
                window.niveauTermineDejaDeclenche = true;

                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante apr√®s animation
                    console.log('üéÜ Animation termin√©e par detecterFinNiveau, passage √† la phase suivante');
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                        // R√©initialiser le flag pour le prochain niveau
                        window.niveauTermineDejaDeclenche = false;
                    }, 500);
                });
            }

            return niveauTermine;
        }

        // Syst√®me de particules d'espoir
        function ajouterParticules(x, y, couleur, nombre = 8) {
            // Limite stricte pour √©viter les bugs de performance
            const maxParticules = 200; // R√©duire pour de meilleures performances
            if(particules.length + nombre > maxParticules) {
                const aSupprimer = (particules.length + nombre) - maxParticules;
                particules.splice(0, aSupprimer); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 4, // Vitesse r√©duite
                    vy: (Math.random() - 0.5) * 4,
                    couleur,
                    vie: Math.random() * 60 + 30, // Vie plus longue
                    taille: Math.random() * 6 + 2, // Plus grosses
                    type: ['rond', 'etoile', 'trait_lumineux'][Math.floor(Math.random() * 3)], // Types vari√©s
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    longueur: Math.random() * 30 + 15, // Pour les traits lumineux
                    angle: Math.random() * Math.PI * 2 // Angle du trait
                });
            }
        }

        // ‚ú® PLUIE R√äVEUSE - Traits blancs lumineux avec tra√Æn√©es fines
        function declencherPluieLumineuse() {
            for(let i = 0; i < 80; i++) {
                setTimeout(() => {
                    // Cr√©er des traits blancs oniriques
                    particules.push({
                        x: Math.random() * C.W,
                        y: -30,
                        vx: 0, // Pas de d√©rive horizontale
                        vy: Math.random() * 2 + 4, // Chute verticale pure
                        couleur: ['#FFFFFF', '#F8F8FF', '#FFFACD'][Math.floor(Math.random() * 3)], // Blancs nuanc√©s
                        vie: 120,
                        taille: 2, // Plus √©pais pour √™tre visible
                        type: 'trait_lumineux',
                        longueur: Math.random() * 35 + 30, // Tra√Æn√©es plus longues
                        angle: Math.PI / 2, // Parfaitement vertical
                        rotation: 0,
                        rotationSpeed: 0,
                        opacity: Math.random() * 0.4 + 0.6 // Plus opaque
                    });
                }, i * 80); // Plus espac√© dans le temps
            }
        }

        // üåßÔ∏è SYST√àME PLUIE SEULEMENT - Activation manuelle uniquement
        function activerParticulesP5() {
            // Pluie uniquement sur d√©clenchement manuel (touche P)
            console.log('üåßÔ∏è Syst√®me pluie activ√© - Appuyez sur P pour d√©clencher');
        }

        // Particules en forme de petits c≈ìurs qui volent vers le haut
        function ajouterParticulesCoeurs(x, y, couleur, nombre = 8) {
            // Limiter le nombre total de particules pour les performances
            const maxParticules = 200;
            if(particules.length >= maxParticules) {
                particules.splice(0, nombre); // Supprimer les plus anciennes
            }

            for(let i = 0; i < nombre; i++) {
                particules.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 2, // Dispersion horizontale r√©duite
                    vy: -(Math.random() * 3 + 2),  // Vitesse verticale r√©duite
                    couleur, vie: 1,
                    taille: Math.random() * 3 + 2,
                    type: 'coeur'
                });
            }
        }

        function mettreAJourParticules() {
            // Permettre la pluie √©motionnelle m√™me pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIM√â - autoriser les particules

            for(let i = particules.length - 1; i >= 0; i--) {
                const p = particules[i];
                p.x += p.vx;
                p.y += p.vy;

                // üåü Rotation pour les √©toiles
                if(p.rotation !== undefined) {
                    p.rotation += p.rotationSpeed;
                }

                if(p.type === 'coeur') {
                    // C≈ìurs : pas de gravit√©, continuent vers le haut
                    p.vy *= 0.99; // L√©g√®re d√©c√©l√©ration
                } else if(p.type === 'etoile') {
                    // √âtoiles : mouvement flottant avec scintillement
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.vy += Math.sin(Date.now() * 0.005 + i) * 0.1; // Mouvement ondulant
                } else if(p.type === 'trait_lumineux') {
                    // ‚ú® Traits r√™veurs : chute verticale pure
                    p.vy += 0.05; // Gravit√© tr√®s l√©g√®re
                    // Pas d'oscillation horizontale - pluie droite
                    // Angle reste vertical
                    p.angle = Math.PI / 2;
                } else {
                    // Particules normales : gravit√©
                    p.vy += 0.15;
                }

                p.vie -= 0.01; // Vie plus longue

                // Supprimer les particules qui sortent de l'√©cran ou qui ont fini leur vie
                if(p.vie <= 0 || p.x < -50 || p.x > C.W + 50 || p.y < -50 || p.y > C.H + 50) {
                    particules.splice(i, 1);
                }
            }
        }

        function dessinerParticules() {
            // Permettre la pluie √©motionnelle m√™me pendant l'animation du bateau
            // if(animationBateau.active) return; // SUPPRIM√â - autoriser les particules

            particules.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.vie * 0.8;
                ctx.fillStyle = p.couleur;

                if(p.type === 'coeur') {
                    // Dessiner petit c≈ìur
                    const taille = p.taille;
                    ctx.beginPath();
                    // Partie gauche du c≈ìur
                    ctx.arc(p.x - taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Partie droite du c≈ìur
                    ctx.arc(p.x + taille*0.3, p.y - taille*0.2, taille*0.4, 0, Math.PI, true);
                    // Pointe du c≈ìur
                    ctx.lineTo(p.x, p.y + taille*0.6);
                    ctx.closePath();
                    ctx.fill();
                } else if(p.type === 'etoile') {
                    // üåü Dessiner √©toile √† 5 branches avec rotation
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        const angleExt = (i * 2 * Math.PI) / 5;
                        const angleInt = ((i + 0.5) * 2 * Math.PI) / 5;
                        const xExt = Math.cos(angleExt) * p.taille;
                        const yExt = Math.sin(angleExt) * p.taille;
                        const xInt = Math.cos(angleInt) * p.taille * 0.5;
                        const yInt = Math.sin(angleInt) * p.taille * 0.5;

                        if(i === 0) ctx.moveTo(xExt, yExt);
                        else ctx.lineTo(xExt, yExt);
                        ctx.lineTo(xInt, yInt);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Effet brillant
                    ctx.shadowColor = p.couleur;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                } else if(p.type === 'trait_lumineux') {
                    // ‚ú® Dessiner trait blanc r√™veur avec tra√Æn√©e fine
                    ctx.lineWidth = p.taille;
                    ctx.lineCap = 'round';

                    // Tra√Æn√©e avec gradient tr√®s doux
                    const gradient = ctx.createLinearGradient(
                        p.x, p.y,
                        p.x - Math.cos(p.angle) * p.longueur,
                        p.y - Math.sin(p.angle) * p.longueur
                    );

                    // Utiliser l'opacit√© personnalis√©e si disponible
                    const alpha = p.opacity || (p.vie * 0.01);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.7, `rgba(248, 248, 255, ${alpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); // Transparent √† la fin

                    ctx.strokeStyle = gradient;

                    // Lueur tr√®s douce
                    ctx.shadowColor = '#FFFFFF';
                    ctx.shadowBlur = 2;

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(
                        p.x - Math.cos(p.angle) * p.longueur,
                        p.y - Math.sin(p.angle) * p.longueur
                    );
                    ctx.stroke();
                } else {
                    // Particule ronde avec effet brillant
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.taille, 0, Math.PI * 2);
                    ctx.fill();
                    // Effet de lueur
                    ctx.shadowColor = p.couleur;
                    ctx.shadowBlur = p.taille * 2;
                    ctx.fill();
                }

                ctx.restore();
            });
        }

        // Afficher les munitions - D√âSACTIV√â (interface simplifi√©e)
        function afficherMunitions() {
            // Fonction d√©sactiv√©e - plus d'affichage de munitions en mode √©toiles
            return;
        }

        // Dessiner les projectiles √©toiles
        function dessinerProjectiles() {
            // Dessiner les projectiles √©toiles pendant la phase stars ET lanterne (pour le mode Pluton)
            if(phaseJeu !== 'stars' && phaseJeu !== 'lanterne') return;

            projectiles.forEach(projectile => {
                ctx.save();

                const posX = projectile.x;
                const posY = projectile.y;
                const rayonEtoile = 8;

                // Calcul pour l'effet de rotation scintillante
                const rotation = Date.now() * 0.01;

                ctx.translate(posX, posY);
                ctx.rotate(rotation);

                // Dessiner l'√©toile avec effet de lueur (couleur selon le type)
                if (isFinite(rayonEtoile) && rayonEtoile > 0) {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, rayonEtoile + 3);

                // Projectiles dor√©s
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                ctx.strokeStyle = '#FFD700';

                ctx.fillStyle = gradient;
                ctx.lineWidth = 1;

                // √âtoile √† 5 branches
                ctx.beginPath();
                for(let i = 0; i < 5; i++) {
                    const angle1 = (i * 2 * Math.PI) / 5;
                    const angle2 = ((i + 0.5) * 2 * Math.PI) / 5;

                    if(i === 0) {
                        ctx.moveTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    } else {
                        ctx.lineTo(Math.cos(angle1) * rayonEtoile, Math.sin(angle1) * rayonEtoile);
                    }

                    ctx.lineTo(Math.cos(angle2) * rayonEtoile * 0.4, Math.sin(angle2) * rayonEtoile * 0.4);
                }
                ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        // Tirer un projectile √©toile depuis le bateau
        function tirerProjectile(mouseX, mouseY) {
            // Ne tirer des projectiles QUE pendant la phase lanterne
            if (rechargement > 0 || phaseJeu !== 'lanterne') return;

            // Tant qu'il y a des munitions, tirer des √©toiles
            if (munitions > 0) {
                // Tir d'√©toiles
                const startX = raquette.x + C.PW * 0.7;
                const startY = raquette.y - 10;

                const dx = mouseX - startX;
                const dy = mouseY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const vitesse = 8;
                const velX = (dx / distance) * vitesse;
                const velY = (dy / distance) * vitesse;


                projectiles.push({
                    x: startX,
                    y: startY,
                    dx: velX,
                    dy: velY
                });

                munitions--;

                // V√©rifier si c'√©tait la derni√®re munition
                if (munitions === 0) {
                    setTimeout(() => {
                        phaseJeu = 'lanterne';
                        balle.dx = 0; // Immobile au d√©but
                        balle.dy = 0; // Immobile au d√©but
                        balle.visible = true; // S'assurer que la lanterne est visible
                        balle.enAttente = true; // Attendre le clic
                        // Message g√©r√© par le nouveau syst√®me narratif
                    }, 500);
                }
            }

            rechargement = 20; // D√©lai entre les tirs
        }

        // Mettre √† jour les projectiles
        function mettreAJourProjectiles() {
            if (animationBateau.active || phaseJeu !== 'lanterne') {
                // Nettoyer les projectiles si on n'est pas en phase lanterne
                if (projectiles.length > 0) {
                    projectiles = [];
                }
                return;
            }

            // D√©placer les projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.dx;
                proj.y += proj.dy;

                // Supprimer les projectiles qui sortent de l'√©cran
                if(proj.x < 0 || proj.x > C.W || proj.y < 0 || proj.y > C.H) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision avec les briques
                let briqueTouchee = false;
                briques.forEach(brique => {
                    if(briqueTouchee) return;
                    if(!brique.visible) return;

                    if(proj.x >= brique.x && proj.x <= brique.x + brique.w &&
                       proj.y >= brique.y && proj.y <= brique.y + brique.h) {

                        const tempsActuel = Date.now();
                        if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 500) {
                            // Bloquer les collisions pendant le mode secret
                            if (secretModeModule && secretModeModule.isActive) {
                                return; // Pas de collision avec les briques en mode secret
                            }
                            if (modeSecret) {
                                return; // Pas de collision avec les briques en mode secret (fallback)
                            }

                            briqueTouchee = true;

                            // Endommager la brique
                            brique.vie--;
                            brique.clignotement = 10;
                            brique.dernierCoup = tempsActuel;

                            // Supprimer le projectile
                            projectiles.splice(i, 1);

                            // Si la brique est d√©truite
                            if (brique.vie <= 0) {
                                brique.visible = false;
                                brises++;

                                // Explosion en 3 petits c≈ìurs
                                for(let j = 0; j < 3; j++) {
                                    particules.push({
                                        x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                        y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: -(Math.random() * 8 + 4),
                                        couleur: brique.couleur,
                                        vie: 1,
                                        taille: Math.random() * 3 + 4,
                                        type: 'coeur'
                                    });
                                }

                                // Power-ups occasionnels
                                if(Math.random() < 0.3) {
                                    creerPowerUp(brique.x + brique.w/2, brique.y + brique.h/2);
                                }

                                // V√©rifier si toutes les briques sont d√©truites
                                if(briques.every(b => !b.visible)) {
                                    console.log('üéØ Toutes les briques d√©truites! Transition vers phase suivante...');

                                    // Auto-r√©cup√©rer les powerups restants
                                    if(powerUps && powerUps.length > 0) {
                                        console.log(`üéÅ Auto-r√©cup√©ration de ${powerUps.length} powerups restants`);
                                        powerUps.forEach(powerup => {
                                            // D√©clencher les effets selon le type
                                            switch(powerup.type) {
                                                case 'etoile_montante':
                                                    score += 1000;
                                                    break;
                                                case 'bonus_points':
                                                    score += 500;
                                                    break;
                                                case 'allume_lanterne':
                                                    lanterne.active = true;
                                                    lanterne.intensite = 1.0;
                                                    break;
                                            }
                                            // Particules d'effet
                                            if(window.ajouterParticules) {
                                                ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                            }
                                        });
                                        powerUps = []; // Vider la liste
                                    }

                                    phaseJeu = 'fin_niveau';
                                    // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                    animerExplosionIconeCollector(() => {
                                        console.log('üéÜ Animation fin niveau termin√©e, passage √† la phase suivante');
                                        narrationManager.goToNextPhaseDirect();
                                    });
                                }
                            }
                        }
                    }
                });
            }

            // R√©duire le rechargement
            if(rechargement > 0) {
                rechargement--;
            }
        }

        // Physique zen de la bulle - UNIQUEMENT pour le mode casse-briques
        function mettreAJourBulle() {
            // G√©rer la balle pour le mode casse-briques uniquement
            if(phaseJeu !== 'lanterne') {
                return; // Ignorer dans les autres phases
            }

            // V√©rifier si la pause est active
            if(pauseBalle.active) {
                if(Date.now() > pauseBalle.fin) {
                    pauseBalle.active = false;
                }
                return; // Ne pas bouger pendant la pause
            }

            // Attendre le clic de l'utilisateur avant de commencer
            if(balle.enAttente) {
                return; // Ne pas bouger tant que l'utilisateur n'a pas cliqu√©
            }

            // Appliquer le multiplicateur de vitesse s'il existe
            const vitesseMulti = balle.multiplicateurVitesse || 1;
            balle.x += balle.dx * vitesseMulti;
            balle.y += balle.dy * vitesseMulti;

            // Mode casse-briques : rebonds classiques (uniquement en phase casse_briques)
            if(phaseJeu === 'lanterne') {
                // Rebonds sur les bords gauche/droite
                if(balle.x <= 0 || balle.x >= C.W) {
                    balle.dx = -balle.dx;
                    balle.x = Math.max(0, Math.min(C.W, balle.x));
                }

                // Rebond sur le haut
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y <= hauteurInterface) {
                    balle.dy = -balle.dy;
                    balle.y = hauteurInterface;
                }

                // Rebond sur le bateau
                if(balle.y + C.BS >= raquette.y &&
                   balle.x >= raquette.x && balle.x <= raquette.x + C.PW) {
                    balle.dy = -Math.abs(balle.dy); // Toujours vers le haut
                    balle.y = raquette.y - C.BS;

                    // Modifier l'angle selon la position sur le bateau
                    const centreRaquette = raquette.x + C.PW/2;
                    const ecart = (balle.x - centreRaquette) / (C.PW/2);
                    balle.dx = (phaseJeu === 'lanterne' ? C.SP * 1.5 : C.SP) * ecart * 0.8 * multiplicateurPuissance;
                }
            } else if(phaseJeu === 'tir_coeurs_haut') {
                // Mode √©toiles : traverser les bords avec t√©l√©portation
                if(balle.x < -C.BS) {
                    balle.x = C.W + C.BS; // R√©appara√Æt √† droite
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
                if(balle.x > C.W + C.BS) {
                    balle.x = -C.BS; // R√©appara√Æt √† gauche
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }

                // T√©l√©portation verticale aussi
                const hauteurInterface = Math.max(C.H * 0.12, 60);
                if(balle.y < hauteurInterface - C.BS) {
                    balle.y = C.H + C.BS; // R√©appara√Æt en bas
                    ajouterParticules(balle.x, balle.y, '#FFD700', 8);
                }
            }

            // Perte de v√©rit√© (bas) - seulement dans les phases o√π la balle rebondit
            if(balle.y >= C.H && phaseJeu !== 'tir_coeurs_haut') {
                perdreVie();
                return;
            }

            // L'√©toile traverse aussi le bateau sans rebondir
            // Effet magique lors du passage
            if(balle.y + C.BS >= raquette.y &&
               balle.y <= raquette.y + C.PH + C.BS &&
               balle.x >= raquette.x - C.BS &&
               balle.x <= raquette.x + C.PW + C.BS) {

                // Effet magique de passage
                ajouterParticules(balle.x, balle.y, '#e74c3c', 10);
                ajouterParticules(balle.x, balle.y, '#27ae60', 8);
                ajouterParticules(balle.x, balle.y, '#FFD700', 12);

                // Pas de rebond, l'√©toile continue sa trajectoire
            }

            // Briser les pr√©jug√©s - une seule brique par frame maximum
            let briqueTouchee = false;
            briques.forEach(brique => {
                if(briqueTouchee) return; // Arr√™ter si on a d√©j√† touch√© une brique
                if(!brique.visible) return;

                if(balle.x + C.BS >= brique.x && balle.x - C.BS <= brique.x + brique.w &&
                   balle.y + C.BS >= brique.y && balle.y - C.BS <= brique.y + brique.h) {

                    // Protection anti-rebond multiple - temps minimum entre coups
                    const tempsActuel = Date.now();
                    if(!brique.dernierCoup || tempsActuel - brique.dernierCoup > 1000) {
                        // Bloquer les collisions pendant le mode secret
                        if (secretModeModule && secretModeModule.isActive) {
                            return; // Pas de collision avec les briques en mode secret
                        }
                        if (modeSecret) {
                            return; // Pas de collision avec les briques en mode secret (fallback)
                        }

                        // Marquer qu'on a touch√© une brique
                        briqueTouchee = true;

                        // Endommager la brique
                        brique.vie--;
                        brique.clignotement = 10; // Clignotement pour 10 frames
                        brique.dernierCoup = tempsActuel;

                        // Rebond plus pr√©cis selon la position de contact
                        const centreBalleX = balle.x;
                        const centreBriqueX = brique.x + brique.w/2;
                        const centreBalleY = balle.y;
                        const centreBriqueY = brique.y + brique.h/2;

                        // L'√©toile traverse sans rebondir
                        // Effet magique de passage √† travers les pr√©jug√©s

                        // Si la brique est d√©truite
                        if (brique.vie <= 0) {
                        brique.visible = false;
                        brises++;

                        // Explosion en 3 petits c≈ìurs seulement
                        for(let i = 0; i < 3; i++) {
                            particules.push({
                                x: brique.x + brique.w/2 + (Math.random() - 0.5) * 20,
                                y: brique.y + brique.h/2 + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -(Math.random() * 8 + 4),
                                couleur: brique.couleur,
                                vie: 1,
                                taille: Math.random() * 3 + 4,
                                type: 'coeur'
                            });
                        }

                        // Texte du c≈ìur qui grossit et monte au ciel
                        ajouterTexteVolant(brique.etape.nom, brique.x + brique.w/2, brique.y + brique.h/2);

                        // D√©sactiv√© : afficherMessage(brique.etape.msg, 4000, brique.etape.nom); // Affichage 4s avec mot en rouge

                        // D√©sactiv√© : Pause de la balle pendant 4 secondes
                        // pauseBalle.active = true;
                        // pauseBalle.fin = Date.now() + 4000;
                        }

                        score += 50; // 50 points par coup (au lieu de 100 pour destruction)

                        // Chance de cr√©er un power-up bleu
                        if(Math.random() < 0.3) {
                            creerPowerUp(brique.x + brique.w/2 - C.BS*0.75, brique.y + brique.h/2 - C.BS*0.75);
                        }
                    }

                    // V√©rifier la condition de fin selon le mode de jeu
                    if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                        // Mode briques : v√©rifier si toutes les briques sont d√©truites
                        const briquesRestantes = briques.filter(b => b.visible).length;
                        // console.log(`üîç V√©rif briques restantes (balle): ${briquesRestantes}`);
                        if(briquesRestantes === 0) {
                            console.log('üéØ Toutes les briques d√©truites (balle)! Transition vers phase suivante...');

                            // Auto-r√©cup√©rer les powerups restants
                            if(powerUps && powerUps.length > 0) {
                                console.log(`üéÅ Auto-r√©cup√©ration de ${powerUps.length} powerups restants (balle)`);
                                powerUps.forEach(powerup => {
                                    switch(powerup.type) {
                                        case 'etoile_montante': score += 1000; break;
                                        case 'bonus_points': score += 500; break;
                                        case 'allume_lanterne': lanterne.active = true; lanterne.intensite = 1.0; break;
                                    }
                                    if(window.ajouterParticules) {
                                        ajouterParticules(powerup.x + powerup.w/2, powerup.y + powerup.h/2, '#FFD700', 15);
                                    }
                                });
                                powerUps = [];
                            }

                            if(!modeEtoileLance) {
                                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                                animerExplosionIconeCollector(() => {
                                    console.log('üéÜ Animation balle termin√©e, passage √† la phase suivante');
                                    narrationManager.goToNextPhaseDirect();
                                });

                                // La fin sera g√©r√©e par finalizeNarration() automatiquement
                            } else if(modeEtoileLance) {
                                // Mode √©toile infini : relancer le m√™me niveau stars
                                jeu = false;
                                relancerModeEtoileInfini();
                            } else {
                                veriteLiberee();
                            }
                        }
                    } else if(brises >= VOYAGE.length) {
                        if(!modeEtoileLance) {
                            // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                            animerExplosionIconeCollector(() => {
                                // Callback : phase suivante apr√®s animation
                                setTimeout(() => {
                                    narrationManager.goToNextPhaseDirect();
                                }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                            });

                            // La fin sera g√©r√©e par finalizeNarration() automatiquement
                        } else if(modeEtoileLance) {
                            // Mode √©toile infini : relancer le m√™me niveau stars
                            jeu = false;
                            relancerModeEtoileInfini();
                        } else {
                            veriteLiberee();
                        }
                    }
                }
            });
        }

        // √âv√©nements
        function perdreVie() {
            vies--;
            if(vies <= 0) {
                finDuVoyage();
                return;
            }

            balle.x = raquette.x + C.PW * 0.7; // Position √† l'avant du bateau
            balle.y = raquette.y - C.BS - 12;

            if(phaseJeu === 'lanterne') {
                // En phase lanterne, remettre en attente
                balle.dx = 0;
                balle.dy = 0;
                balle.enAttente = true;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© !\n\nüëÜ Cliquez pour relancer la lanterne ! üëÅÔ∏è', 4000);
            } else {
                // Autres phases
                balle.dx = C.SP * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance;
                balle.dy = -C.SP * multiplicateurPuissance;
                afficherMessage('üíî Les mensonges r√©sistent ! Continue √† chercher la v√©rit√© ! üëÅÔ∏è', 3000);
            }
        }

        function finDuVoyage() {
            jeu = false;
            afficherMessage('üò¢ Le voyage vers la v√©rit√© continue...\n\nüí™ "La v√©rit√© finit toujours par triompher !"\n\n‚ú® Touchez pour recommencer ‚ú®', 6000);
        }

        function veriteLiberee() {
            jeu = false;

            // Feu d'artifice de victoire avec drones
            if (droneModule) {
                droneModule.moveFormationTo(C.W/2, C.H/2);
                droneModule.setFormation('star');
                setTimeout(() => {
                    droneModule.fireworks();
                }, 300);
            }

            // D√©lai de 5 secondes avant l'affichage du message final
            setTimeout(() => {
                if(periode === 'jour') {
                    // Fin du chapitre 1 : transition vers le chapitre 2
                    // Message g√©r√© par le nouveau syst√®me narratif
                } else {
                    // Fin du chapitre 2 : d√©clencher la s√©quence finale des feux d'artifice
                    // Phase finale : s√©quence compl√®te avec bateau + feux + lever soleil
                    phaseJeu = 'feux_artifice';
                    jeu = false;

                    // FORCER L'ARR√äT DU SYST√àME NARRATIF pour √©viter les interf√©rences
                    phaseIntro.active = false;
                    // Introduction termin√©e

                    // √âTAPE 1 : Animation bateau 2s
                    animationBateau.active = true;
                    animationBateau.phase = 'arrivee'; // Important pour que le bateau bouge
                    animationBateau.vitesse = 3; // Plus rapide pour finale
                    animationBateau.tempsDebut = window.now();
                    animationBateau.positionCible = C.W + C.PW; // Sortir par la droite

                    setTimeout(() => {
                        // √âTAPE 2 : Feux d'artifice 5s
                        console.log("Fin animation bateau, d√©but feux d'artifice");
                        animationBateau.active = false;

                        // Cr√©er des feux d'artifice spectaculaires pendant 5s
                        for(let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const x = Math.random() * C.W;
                                const y = Math.random() * C.H * 0.7;
                                const couleurs = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#FFD93D', '#6BCF7F'];
                                const couleur = couleurs[Math.floor(Math.random() * couleurs.length)];
                                ajouterParticules(x, y, couleur, 20);
                            }, i * 200);
                        }

                        setTimeout(() => {
                            // √âTAPE 3 : Lever de soleil + fin normale via finalizeNarration
                            console.log("D√©marrage lever de soleil final");
                            leverSoleilFinal();
                            setTimeout(() => {
                                console.log("Appel finalizeNarration pour menu correct");
                                narrationManager.finalizeNarration();
                            }, 1000);
                        }, 5000);

                    }, 2000);
                }
            }, 5000); // 5 secondes de d√©lai
        }

        function reprendreAuDernierNiveau() {
            // Toujours recommencer depuis le d√©but pour √©viter les probl√®mes
            chapitre = 1;
            VOYAGE = JOUR;
            score = 0; vies = 3; brises = 0; jeu = true;
            phaseJeu = 'tir_coeurs_haut';
            initJeu();
            cacherMessage();
        }

        function recommencer() {
            // Bloquer les changements de phase si le mode secret est actif
            if (secretModeModule && secretModeModule.isActive) {
                console.log('üö´ Mode secret actif, recommencer bloqu√©');
                return;
            }
            if (modeSecret) {
                console.log('üö´ Mode secret actif (fallback), recommencer bloqu√©');
                return;
            }

            // V√©rifier la condition de fin selon le mode de jeu
            if(phaseJeu === 'lanterne' || phaseJeu === 'stars') {
                // Mode briques : v√©rifier si toutes les briques sont d√©truites
                const briquesRestantes = briques.filter(b => b.visible).length;
                if(briquesRestantes === 0) {
                    // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                    animerExplosionIconeCollector(() => {
                        console.log('üéÜ Animation briques termin√©e (lanterne/stars), passage √† la phase suivante');
                        narrationManager.goToNextPhaseDirect();
                    });
                }
            } else if(brises >= VOYAGE.length) {
                // üéÜ ANIMATION D'EXPLOSION PUIS PHASE SUIVANTE
                animerExplosionIconeCollector(() => {
                    // Callback : phase suivante apr√®s animation
                    setTimeout(() => {
                        narrationManager.goToNextPhaseDirect();
                    }, 500); // Petit d√©lai suppl√©mentaire apr√®s l'animation
                });
            }

            // Forcer l'affichage des briques
            briques.forEach(brique => {
                brique.visible = true;
            });

            // Forcer la visibilit√© de la balle et activer le jeu
            if(balle) {
                balle.visible = true;
            }
            jeu = true;

            cacherMessage();
        }

        // Fonction pour passer au chapitre suivant (pour les tests)
        function passerChapitreTest() {
            // Mode passe phase d√©sactiv√©
            return;
            if(periode === 'jour') {
                periode = 'nuit';
                VOYAGE = NUIT;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'stars'; // Directement en phase stars pour les tests
                initJeu();

                // Cr√©er les briques pour la phase stars
                dedoublerCoeursEnBriques();

                // Forcer la visibilit√© de la balle et activer le jeu
                if(balle) {
                    balle.visible = true;
                }
                jeu = true;

                cacherMessage();
            } else {
                periode = 'jour';
                VOYAGE = JOUR;
                score = 0; vies = 3; brises = 0; jeu = true;
                phaseJeu = 'tir_coeurs_haut';
                initJeu();

                // Recr√©er les petits coeurs du haut pour le chapitre 1
                creerPetitsCoeurs();

                // Rendre les petits c≈ìurs visibles et d√©sactiver la balle
                petitsCoeurs.forEach(coeur => coeur.visible = true);
                if(balle) {
                    balle.visible = false;
                }
                jeu = true;

                cacherMessage();
            }
        }


        function reduireVieBriques() {
            if(!briques || briques.length === 0) {
                afficherMessagePowerupSimple('‚ùå Aucune brique trouv√©e');
                return;
            }

            let briquesModifiees = 0;
            briques.forEach(brique => {
                if(brique.visible && brique.vie > 1) {
                    brique.vie = 1;
                    brique.vieMax = 1;
                    briquesModifiees++;
                }
            });

            if(briquesModifiees > 0) {
                afficherMessagePowerupSimple(`‚ö° Mode rapide activ√© - ${briquesModifiees} briques`);
            } else {
                afficherMessagePowerupSimple('‚ÑπÔ∏è Toutes les briques d√©j√† √† 1 vie');
            }
        }

        let tirEtoilesActif = false;
        let intervalTirEtoiles = null;

        function activerTirEtoiles() {
            if(tirEtoilesActif) {
                // D√©sactiver le tir automatique
                tirEtoilesActif = false;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                    intervalTirEtoiles = null;
                }
                afficherMessagePowerupSimple('‚≠ê Tir √©toiles d√©sactiv√©');
            } else {
                // Activer le tir automatique
                tirEtoilesActif = true;

                // Forcer l'activation du jeu pour permettre les collisions
                if(phaseJeu === 'stars') {
                    jeu = true;
                }

                afficherMessagePowerupSimple('üåü Tir √©toiles automatique activ√©');

                // Lancer le tir automatique toutes les 200ms
                intervalTirEtoiles = setInterval(() => {
                    // Respecter la pause du jeu
                    if(window.jeuEnPause) return;

                    if(phaseJeu === 'stars') {
                        // Forcer l'activation du jeu si n√©cessaire
                        if(!jeu) jeu = true;

                        // Viser une brique al√©atoire visible
                        const briquesVisibles = briques.filter(b => b.visible);
                        if(briquesVisibles.length > 0) {
                            const cible = briquesVisibles[Math.floor(Math.random() * briquesVisibles.length)];
                            const targetX = cible.x + cible.w/2;
                            const targetY = cible.y + cible.h/2;
                            tirerStarsProjectile(targetX, targetY);
                            libererVaguesAmour(); // Lib√©rer les c≈ìurs aussi
                        }
                    }
                }, 200);
            }
        }

        function leverSoleilFinal() {
            // Passage simple du mode nuit au mode jour
            console.log("Lever de soleil : passage en mode jour");
            chapitre = 1; // Retour au chapitre 1 pour avoir le soleil

            // Forcer la mise √† jour de l'affichage
            leverSoleil.active = false; // Pas besoin d'animation complexe
        }

        function lancerModeEtoileTest() {
            // Lancer directement le mode √©toile test
            console.log("Lancement du mode √©toile test");

            // Configuration pour mode √©toile infini (directement en mode stars)
            chapitre = 2;
            VOYAGE = NUIT;
            phaseJeu = 'stars';
            score = 0;
            vies = 3;
            brises = 0;
            jeu = true;
            modeEtoileLance = true; // Marquer qu'on est en mode √©toile depuis le menu

            // Forcer l'arr√™t des syst√®mes
            animationBateau.active = false;
            phaseIntro.active = false;
            etapeIntro = 3;
            leverSoleil.active = false;

            // Activer le tir d'√©toiles automatique en mode √©toile
            tirEtoilesActif = true;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
            }
            intervalTirEtoiles = setInterval(() => {
                // Respecter la pause du jeu
                if(window.jeuEnPause) return;

                if(jeu && tirEtoilesActif) {
                    tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                }
            }, 400); // Tir toutes les 400ms

            // Nettoyer les √©l√©ments
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Initialiser le jeu
            initJeu();
            dedoublerCoeursEnBriques(); // Cr√©er les briques pour mode stars

            // Cacher le message et afficher le message test
            cacherMessage();
            afficherMessagePowerupSimple('üåü Mode √©toile infini activ√©');
        }

        function relancerModeEtoileInfini() {
            // Petits feux d'artifice avec drones √† chaque fin de niveau
            if (droneModule) {
                // Formation hexagonale centr√©e
                droneModule.moveFormationTo(C.W * 0.5, C.H * 0.4);
                droneModule.setFormation('hexagon');

                // Explosion apr√®s 500ms
                setTimeout(() => {
                    if (droneModule) {
                        droneModule.fireworks();
                    }
                }, 500);
            }

            // D√©lai pour voir les feux avant de relancer
            setTimeout(() => {
                // Relancer le m√™me niveau stars infini
                phaseJeu = 'stars';
                periode = 'nuit';
                VOYAGE = NUIT;
                brises = 0;
                initJeu();
                dedoublerCoeursEnBriques();
                afficherMessagePowerupSimple('üåü Niveau termin√© - Nouveau niveau stars');

                // Relancer le jeu pour le nouveau niveau
                jeu = true;

                // Maintenir le tir d'√©toiles actif
                tirEtoilesActif = true;
                if(intervalTirEtoiles) {
                    clearInterval(intervalTirEtoiles);
                }
                intervalTirEtoiles = setInterval(() => {
                    // Respecter la pause du jeu
                    if(window.jeuEnPause) return;

                    if(jeu && tirEtoilesActif) {
                        tirerStarsProjectile(Math.random() * C.W, Math.random() * C.H * 0.7);
                    }
                }, 400);
            }, 1200); // D√©lai de 1.2s pour voir les feux
        }

        function lancerFeuxAvantMenuFin() {
            // S√©quence finale : 3 formations al√©atoires avec explosions
            console.log("Lancement de la s√©quence finale avec 3 formations");

            if (droneModule) {
                const formations = ['hexagon', 'star', 'heart', 'cross'];
                const formationsChoixies = [];

                // Choisir 3 formations al√©atoires diff√©rentes
                while (formationsChoixies.length < 3) {
                    const formation = formations[Math.floor(Math.random() * formations.length)];
                    if (!formationsChoixies.includes(formation)) {
                        formationsChoixies.push(formation);
                    }
                }

                // S√©quence des 3 formations
                formationsChoixies.forEach((formation, index) => {
                    setTimeout(() => {
                        // Position al√©atoire pour chaque formation
                        const x = Math.random() * C.W * 0.4 + C.W * 0.3;
                        const y = Math.random() * C.H * 0.3 + C.H * 0.3;

                        droneModule.moveFormationTo(x, y);
                        droneModule.setFormation(formation);

                        console.log(`Formation ${index + 1}: ${formation} √† (${x}, ${y})`);

                        // Explosion apr√®s formation
                        setTimeout(() => {
                            droneModule.explode(x, y);
                        }, 800);

                    }, index * 1500);
                });
            }

            // Afficher le menu apr√®s la s√©quence compl√®te (3 √ó 1.5s + explosions)
            setTimeout(() => {
                afficherMenuFinModeEtoile();
            }, 6000);
        }

        function afficherMenuFinModeEtoile() {
            // Arr√™ter le tir automatique √† la fin du mode √©toile
            tirEtoilesActif = false;
            if(intervalTirEtoiles) {
                clearInterval(intervalTirEtoiles);
                intervalTirEtoiles = null;
            }

            // Rediriger vers le menu final standard correct
            narrationManager.showFinalMenu();
        }


        function afficherMessageFinal() {
            const msg = document.getElementById('message');

            // Menu simple et √©l√©gant
            msg.innerHTML = `
                <div style="text-align: center; background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); max-width: 400px; margin: 0 auto;">
                    <h2 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 24px; font-weight: 300;">‚ú® Voyage Termin√© ‚ú®</h2>

                    <p style="margin: 15px 0 30px 0; color: #5a6c7d; font-size: 16px; line-height: 1.5;">
                        Merci d'avoir d√©couvert la v√©rit√©
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <button onclick="lancerPhaseBonus()"
                                style="background: linear-gradient(145deg, #4a90e2, #357abd); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            üìñ √âpilogue
                        </button>

                        <button onclick="location.reload()"
                                style="background: linear-gradient(145deg, #6c7b7f, #5a6c7d); border: none; border-radius: 12px; padding: 15px 35px; color: white; font-size: 16px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(108, 123, 127, 0.3); transition: all 0.2s ease; min-width: 200px;">
                            üîÑ Rejouer
                        </button>
                    </div>
                </div>
            `;

            msg.classList.add('show');
            msg.style.display = 'block';
        }

        // Lancer la phase bonus
        function lancerPhaseBonus() {
            // Charger le module de phase bonus
            if (!window.PhaseBonusMur) {
                const script = document.createElement('script');
                script.src = 'modules/phase-bonus-mur.js';
                script.onload = () => {
                    demarrerPhaseBonus();
                };
                document.head.appendChild(script);
            } else {
                demarrerPhaseBonus();
            }
        }

        function demarrerPhaseBonus() {
            // Donner le bonus XP AVANT de cr√©er la phase bonus
            giveXPBonus(200);

            // Cr√©er et initialiser la phase bonus
            if (!window.phaseBonusMur) {
                window.phaseBonusMur = new window.PhaseBonusMur({ angel: angel });
                window.phaseBonusMur.init(canvas, ctx);
            }

            // Passer en mode phase bonus
            jeu = false;
            phaseJeu = 'bonus_mur';

            // D√©marrer la phase bonus
            window.phaseBonusMur.start();

            // Ajouter la gestion dans la boucle de jeu
            window.gameManager = window.gameManager || {};
            window.gameManager.startBonusPoem = () => {
                window.phaseBonusMur.startBonusPoem();
            };
            window.gameManager.restart = () => {
                window.location.reload();
            };
        }

        // Fonction d√©di√©e pour donner XP bonus (simple avec score)
        function giveXPBonus(amount) {
            try {
                console.log('üåü Attribution bonus score:', amount);
                console.log('Score avant:', score);

                // Ajouter au score directement
                score += amount;

                console.log('Score apr√®s:', score);

                // Message simple
                afficherMessagePowerupSimple('üåü +' + amount + ' Points bonus fin de jeu');

                return true;
            } catch (error) {
                console.error('‚ùå Erreur attribution bonus score:', error);
                return false;
            }
        }

        function afficherCreditsFinaux() {
            const msg = document.getElementById('message');
            msg.innerHTML = `
                <div style="text-align: center; background: linear-gradient(135deg, #8B4513, #A0522D); padding: 25px; border-radius: 15px; margin: 20px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin-bottom: 20px; color: #ffffff;">üìú Menu Artistique Emmanuel üìú</h2>
                    <p style="color: #ffd700; margin-bottom: 20px;"><strong>‚ú® Signature Artistique :</strong> Dreamer Unisona</p>

                    <!-- Section Cr√©dits avec style am√©lior√© -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FFD700; text-align: center; margin-bottom: 15px;">üé® Cr√©ation Artistique</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>üéÆ Cr√©ation & D√©veloppement :</strong> Emmanuel Payet</p>
                            <p><strong>üé® Design & Concept :</strong> Emmanuel Payet</p>
                            <p><strong>‚úçÔ∏è Narration & Po√©sie :</strong> Emmanuel Payet</p>
                            <p><strong>üéµ Vision Artistique :</strong> Emmanuel Payet</p>
                        </div>
                    </div>

                    <!-- Section Projet avec ic√¥nes -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #87CEEB; text-align: center; margin-bottom: 15px;">üåü Fable Interactive</h3>
                        <div style="color: #ffffff; line-height: 1.6; margin: 15px 0;">
                            <p><strong>üíù Projet :</strong> "Voir la V√©rit√©"</p>
                            <p><strong>üåü Message :</strong> Une fable interactive sur les pr√©jug√©s</p>
                            <p><strong>üìÖ Ann√©e :</strong> 2025</p>
                            <p><strong>üè∑Ô∏è Copyright :</strong> ¬© Emmanuel Payet - Tous droits r√©serv√©s</p>
                        </div>
                    </div>

                    <!-- Section Syst√®mes de Jeu -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #FF6B35; text-align: center; margin-bottom: 15px;">üìä Syst√®mes Impl√©ment√©s</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>‚≠ê XP :</strong> Points de Connaissance (phase d'apprentissage)</p>
                            <p><strong>üïäÔ∏è Score d'Ange :</strong> Performance de jeu principal</p>
                            <p><strong>‚ù§Ô∏è Vies :</strong> Syst√®me de survie (3 maximum)</p>
                            <p><strong>üß± Briques :</strong> Progression par niveau</p>
                            <p><strong>üìú √ânigmes :</strong> 10 r√©v√©lations po√©tiques d√©bloquables</p>
                            <p><strong>üéÆ Mode Secret :</strong> Mini-jeu kawaii cach√©</p>
                        </div>
                    </div>

                    <!-- Section √ânigmes Collectables -->
                    <div style="background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border: 2px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 20px; margin: 15px 0; text-align: left;">
                        <h3 style="color: #8A2BE2; text-align: center; margin-bottom: 15px;">üìú Collection d'√ânigmes</h3>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 0.9rem;">
                            <p><strong>üíñ Phase C≈ìurs :</strong> Humanit√©, Diversit√©, Respect, Restauration</p>
                            <p><strong>üß± Phase Briques :</strong> Paix, Foi, Gu√©rison</p>
                            <p><strong>üåôüíñ Phase Nuit C≈ìurs :</strong> Libert√©, Entraide</p>
                            <p><strong>üèÆ Phase Lanterne :</strong> Ange Gardien (sp√©ciale)</p>
                        </div>
                    </div>

                    <!-- Citation Po√©tique am√©lior√©e -->
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1)); border: 3px solid #FFD700; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: center;">
                        <p style="font-style: italic; color: #ffd700; font-size: 1.1rem; line-height: 1.5;">
                            "Aucun mur n'est √©ternel.<br>
                            Car l'eau finit toujours par user la pierre,<br>
                            et la libert√© reprendra son chemin."
                        </p>
                        <p style="font-style: italic; color: #87CEEB; margin-top: 15px; font-size: 1rem;">
                            ‚Äî Dreamer Unisona
                        </p>
                        <hr style="margin: 15px 0; border: 1px solid rgba(255,255,255,0.3);">
                        <p style="font-style: italic; color: #ffffff; font-size: 0.9rem;">
                            "Dans chaque √©nigme se cache une v√©rit√©,<br>
                            dans chaque v√©rit√© se r√©v√®le notre humanit√©."
                        </p>
                    </div>

                    <!-- Boutons de navigation am√©lior√©s -->
                    <div style="margin-top: 25px;">
                        <button onclick="window.open('emmanuel-artist-module.html', '_blank')"
                                style="background: linear-gradient(145deg, #4169E1, #1E90FF); border: none; border-radius: 25px; padding: 12px 25px; margin: 8px; color: white; font-size: 14px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            üìú Voir Collection Compl√®te
                        </button>
                        <br>
                        <button onclick="narrationManager.showFinalMenu()"
                                style="background: linear-gradient(145deg, #2E8B57, #3CB371); border: none; border-radius: 25px; padding: 15px 30px; margin: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            ‚Üê Retour au Menu Principal
                        </button>
                    </div>
                </div>
            `;
        }

        function recommencerJeu() {
            // R√©initialiser compl√®tement le jeu
            chapitre = 1;
            VOYAGE = JOUR;
            phaseJeu = 'tir_coeurs_haut';
            score = 0;

            // Les objets kawaii sont r√©serv√©s au mode secret seulement
            // activerObjetsKawaii(); // SUPPRIM√â - uniquement pour mode secret
            vies = 3;
            brises = 0;
            jeu = false; // Commencer avec jeu d√©sactiv√© pour l'intro

            // R√©initialiser les syst√®mes
            animationBateau.active = false;
            phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: window.now() };
            narrationManager.reset();

            // Nettoyer les √©l√©ments de jeu
            briques = [];
            projectiles = [];
            starsProjectiles = [];
            particules = [];
            powerUps = [];

            // Relancer l'initialisation
            initJeu();
            creerPetitsCoeurs();

            // Cacher le message
            cacherMessage();

            // D√©marrer la narration compl√®te P1 √† P16
            setTimeout(() => {
                narrationManager.start();
            }, 1000);
        }

        // üé≠ MESSAGES AVEC ANIMATIONS TYPEWRITER - Pour mode secret et effets sp√©ciaux
        function afficherMessageAnime(texte, duree, animation = 'typewriter', speed = 40, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Callback pour g√©rer la fin de l'animation et le timing de disparition
            const onComplete = () => {
                // Attendre un peu apr√®s la fin de l'animation avant de faire dispara√Ætre
                setTimeout(() => {
                    cacherMessage();
                }, Math.max(1000, duree * 0.2)); // Au moins 1s d'attente apr√®s l'animation
            };

            // Cr√©er une nouvelle instance TextAnimator avec le nouveau code optimis√©
            const anim = new TextAnimator('message');

            switch(animation) {
                case 'typewriter':
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'digital':
                    anim.digital(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fade':
                    anim.fade(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'glitch':
                    anim.glitch(texteComplet, {
                        duration: Math.max(2000, duree * 0.3),
                        onComplete: onComplete
                    });
                    break;
                case 'emboss':
                    anim.setColors('#ffffff', '#666666');
                    anim.applyEffect('emboss');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'neon':
                    anim.setColors('#64ffda', '#64ffda');
                    anim.applyEffect('neon');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'shadow3d':
                    anim.setColors('#ffffff', '#333333');
                    anim.applyEffect('shadow3d');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'fire':
                    anim.setColors('#ff4444', '#ff8800');
                    anim.applyEffect('fire');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'ice':
                    anim.setColors('#ffffff', '#ffffff');
                    anim.applyEffect('none');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                case 'outline':
                    anim.setColors('#ffffff', '#000000');
                    anim.applyEffect('outline');
                    anim.typewriter(texteComplet, {
                        speed: speed,
                        onComplete: onComplete
                    });
                    break;
                default:
                    msg.innerHTML = texteComplet.replace(/\n/g, '<br>');
                    onComplete();
            }
        }

        // üìù FONCTION PRINCIPALE D'AFFICHAGE - Messages standard blancs centr√©s
        function afficherMessage(texte, duree, motRouge = null) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Ajouter le mot du c≈ìur en rouge au d√©but si sp√©cifi√©
            let texteComplet = texte;
            if(motRouge) {
                texteComplet = `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444; font-size: 1.2em;">üíî ${motRouge.toUpperCase()} üíî</span>\n\n${texte}`;

                // Mettre aussi en surbrillance le mot s'il appara√Æt dans le texte original
                const regex = new RegExp(`\\b${motRouge}\\b`, 'gi');
                texteComplet = texteComplet.replace(regex, `<span style="color: #FF4444; font-weight: bold; text-shadow: 0 0 8px #FF4444;">${motRouge.toUpperCase()}</span>`);
            }

            msg.innerHTML = texteComplet;
            msg.classList.add('show');

            // FORCER le display en JavaScript pour override le style inline
            msg.style.display = 'block';

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            if(duree > 0) {
                setTimeout(() => {
                    msg.classList.remove('show');
                    msg.style.display = 'none'; // Remettre display none apr√®s la dur√©e
                }, duree);
            }
        }

        function afficherMessageAvecBoutons(texte, onRejouer, onContinuer) {
            const msg = document.getElementById('message');

            // Retirer la classe narratif si elle existe
            msg.classList.remove('narratif');

            // Cr√©er le contenu avec boutons
            const boutonsHTML = `
                <div style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="cacherMessage(); (${onRejouer})()"
                            style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(255,107,107,0.4);
                                   transition: all 0.3s ease;">
                        üîÑ Rejouer
                    </button>
                    <button onclick="cacherMessage(); (${onContinuer})()"
                            style="background: linear-gradient(45deg, #00b894, #00a085);
                                   color: white; border: none; padding: 12px 24px;
                                   border-radius: 25px; font-size: 16px; font-weight: bold;
                                   cursor: pointer; box-shadow: 0 4px 15px rgba(0,184,148,0.4);
                                   transition: all 0.3s ease;">
                        ‚û°Ô∏è Continuer
                    </button>
                </div>
            `;

            msg.innerHTML = texte + boutonsHTML;
            msg.classList.add('show');

            // Garder le texte √† sa taille normale
            msg.style.transform = 'translate(-50%, -50%) scale(1)';
            msg.style.transition = '';

            // Ajouter les effets hover via CSS inline
            const style = document.createElement('style');
            style.textContent = `
                #message button:hover {
                    transform: translateY(-2px) scale(1.05);
                    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                }
            `;
            document.head.appendChild(style);
        }


        function cacherMessage() {
            const msg = document.getElementById('message');
            msg.classList.remove('show');
            msg.style.display = 'none'; // Forcer la disparition
        }

        // Mer avec mouvement simplifi√© et ailerons de requin
        function dessinerMer() {
            const temps = Date.now() * 0.0005;
            const merY = C.H - 60;

            // Couleur de la mer selon le chapitre
            const merGrad = ctx.createLinearGradient(0, merY, 0, C.H);
            if(periode === 'jour') {
                // Mer bleue paisible
                merGrad.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
                merGrad.addColorStop(0.5, 'rgba(100, 150, 200, 0.9)');
                merGrad.addColorStop(1, 'rgba(30, 100, 140, 0.95)');
            } else {
                // Mer sombre et mena√ßante
                merGrad.addColorStop(0, 'rgba(47, 79, 79, 0.9)');
                merGrad.addColorStop(0.5, 'rgba(25, 25, 112, 0.95)');
                merGrad.addColorStop(1, 'rgba(0, 0, 139, 0.98)');
            }
            ctx.fillStyle = merGrad;
            ctx.fillRect(0, merY, C.W, C.H - merY);

            // Vagues selon le chapitre
            if(periode === 'jour') {
                // Vagues paisibles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
            } else {
                // Vagues agit√©es
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 3;
            }

            // Lignes de vagues
            for(let ligne = 0; ligne < 3; ligne++) {
                const y = merY + ligne * 15;
                const amplitude = periode === 'jour' ? (8 - ligne * 2) : (12 - ligne * 3);
                const fr√©quence = 0.01 + ligne * 0.005;
                const vitesse = periode === 'jour' ? 1 : 1.5;
                const offset = temps * vitesse * (1 + ligne * 0.3);

                ctx.beginPath();
                for(let x = 0; x <= C.W; x += 10) {
                    const vague = Math.sin(x * fr√©quence + offset) * amplitude;
                    if(x === 0) ctx.moveTo(x, y + vague);
                    else ctx.lineTo(x, y + vague);
                }
                ctx.stroke();
            }

            // Ailerons de requin dans le chapitre 2 (disparaissent pendant le lever de soleil)
            if(periode === 'nuit' && !leverSoleil.active) {
                const requins = [
                    { x: 0.2, vitesse: 0.3, taille: 1.0 },
                    { x: 0.6, vitesse: 0.5, taille: 0.8 },
                    { x: 0.9, vitesse: 0.4, taille: 1.2 }
                ];

                requins.forEach(requin => {
                    const reqX = (C.W * requin.x + temps * requin.vitesse * 80) % (C.W + 100) - 50;
                    const reqY = merY + 25 + Math.sin(temps * 2 + requin.x * 10) * 8;
                    const taille = Math.min(C.W, C.H) * 0.03 * requin.taille;

                    // Aileron de requin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.strokeStyle = '#1C1C1C';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(reqX - taille*0.5, reqY + taille*0.8); // Base gauche
                    ctx.lineTo(reqX, reqY - taille); // Pointe
                    ctx.lineTo(reqX + taille*0.3, reqY + taille*0.5); // Base droite
                    ctx.lineTo(reqX - taille*0.2, reqY + taille*0.8); // Retour base
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Sillage du requin
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(reqX - taille, reqY + taille*0.5);
                    ctx.lineTo(reqX - taille*2, reqY + taille*0.3);
                    ctx.stroke();
                });
            }
        }

        // Ciel qui s'adapte au chapitre
        function dessinerCiel() {
            const temps = Date.now() * 0.0003;

            // Ne pas dessiner le soleil pendant l'animation du bateau
            if(animationBateau.active) return;

            // D√©clarer les variables pour √©viter les erreurs
            let soleilX, soleilY, soleilR, luneX, luneY, luneR;

            if(periode === 'jour') {
                // CHAPITRE 1: Soleil heureux avec lever progressif
                soleilX = C.W * 0.8;

                // Lever de soleil en phase feux_artifice
                if(leverSoleil.active) {
                    const progression = Math.min(1, (Date.now() - leverSoleil.debut) / leverSoleil.duree);
                    soleilY = C.H * (0.9 - 0.75 * progression); // Monte de 90% √† 15%
                    soleilR = Math.min(C.W, C.H) * (0.03 + 0.03 * progression); // Grandit

                    // Couleur qui √©volue vers l'or
                    const rouge = Math.floor(255 * (1 - progression * 0.3));
                    const vert = Math.floor(215 * (0.7 + progression * 0.3));
                    const bleu = Math.floor(progression * 50);
                    ctx.fillStyle = `rgb(${rouge}, ${vert}, ${bleu})`;
                } else {
                    soleilY = C.H * 0.15;
                    soleilR = Math.min(C.W, C.H) * 0.06;
                    ctx.fillStyle = '#FFD700';
                }

                // Corps du soleil
                ctx.beginPath();
                ctx.arc(soleilX, soleilY, soleilR, 0, Math.PI * 2);
                ctx.fill();

                // Rayons du soleil (plus nombreux pendant le lever)
                ctx.strokeStyle = leverSoleil.active ? ctx.fillStyle : '#FFD700';
                ctx.lineWidth = leverSoleil.active ? 4 : 3;
                const nbRayons = leverSoleil.active ? 16 : 8;
                for(let i = 0; i < nbRayons; i++) {
                    const rotationSoleil = Date.now() * 0.0005; // Rotation lente
                    const angle = (i / nbRayons) * Math.PI * 2 + rotationSoleil;
                    const longueurRayon = leverSoleil.active ? 25 : 15;
                    const x1 = soleilX + Math.cos(angle) * (soleilR + 5);
                    const y1 = soleilY + Math.sin(angle) * (soleilR + 5);
                    const x2 = soleilX + Math.cos(angle) * (soleilR + longueurRayon);
                    const y2 = soleilY + Math.sin(angle) * (soleilR + longueurRayon);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            } else {
                // CHAPITRE 2: Lune inqui√©tante
                luneX = C.W * 0.2;
                luneY = C.H * 0.15;
                luneR = Math.min(C.W, C.H) * 0.06;

                // Corps de la lune
                ctx.fillStyle = '#E6E6FA';
                ctx.beginPath();
                ctx.arc(luneX, luneY, luneR, 0, Math.PI * 2);
                ctx.fill();

                // Ombre de la lune (croissant)
                ctx.fillStyle = '#B0C4DE';
                ctx.beginPath();
                ctx.arc(luneX + luneR * 0.3, luneY, luneR * 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Halo lunaire - avec protection contre les valeurs non-finies
                if (isFinite(luneX) && isFinite(luneY) && isFinite(luneR) && luneR > 0) {
                    const haloGrad = ctx.createRadialGradient(luneX, luneY, luneR, luneX, luneY, luneR * 2);
                    haloGrad.addColorStop(0, 'rgba(230, 230, 250, 0.3)');
                    haloGrad.addColorStop(1, 'rgba(230, 230, 250, 0)');
                    ctx.fillStyle = haloGrad;
                    ctx.beginPath();
                    ctx.arc(luneX, luneY, luneR * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Visage selon le chapitre et la progression
            if(periode === 'jour') {
                // V√©rifier si le soleil fait un clin d'≈ìil
                const tempsClignotement = Date.now() - soleil.tempsClignotement;
                const faitClinOeil = soleil.clignotement && tempsClignotement < 2000; // Clin d'≈ìil pendant 2 secondes

                // Arr√™ter le clignotement apr√®s 2 secondes
                if(tempsClignotement > 2000) {
                    soleil.clignotement = false;
                }

                // Visage du soleil (progresse avec le joueur)
                if(brises >= VOYAGE.length) {
                    // Soleil paisible et bienveillant √† la fin
                    ctx.fillStyle = '#FF8C00';

                    // Yeux doux et ferm√©s (paix)
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Yeux ferm√©s paisibles en forme de croissants
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.15, soleilR*0.15, 0.3, Math.PI - 0.3);
                    ctx.stroke();

                    // Sourire doux et mod√©r√©
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.2, soleilR*0.3, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if(brises > 0) {
                    // Soleil qui commence √† sourire
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();

                    if(faitClinOeil) {
                        // Clin d'≈ìil ! ≈íil gauche ferm√©, ≈ìil droit ouvert
                        // ≈íil gauche ferm√© (clin d'≈ìil)
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0.3, Math.PI - 0.3);
                        ctx.stroke();

                        // ≈íil droit ouvert (normal)
                        ctx.fillStyle = '#FF8C00';
                        ctx.beginPath();
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Sourire extra large pour le clin d'≈ìil
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.5, 0, Math.PI);
                        ctx.stroke();
                    } else {
                        // Yeux normaux
                        ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.2, soleilR*0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FF8C00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(soleilX, soleilY + soleilR*0.1, soleilR*0.4, 0, Math.PI);
                        ctx.stroke();
                    }
                } else {
                    // Soleil qui boude au d√©but
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(soleilX - soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.arc(soleilX + soleilR*0.3, soleilY - soleilR*0.1, soleilR*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(soleilX, soleilY + soleilR*0.3, soleilR*0.3, Math.PI, 0, true);
                    ctx.stroke();
                }
            } else {
                // Visage de la lune inqui√©tante
                ctx.fillStyle = '#8B8B8B';
                // Yeux sombres et inquiets
                ctx.beginPath();
                ctx.arc(luneX - luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.arc(luneX + luneR*0.3, luneY - luneR*0.1, luneR*0.12, 0, Math.PI * 2);
                ctx.fill();

                // Sourire malsain
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(luneX, luneY + luneR*0.2, luneR*0.3, 0, Math.PI);
                ctx.stroke();
            }

            // Nuages selon le chapitre
            if(periode === 'jour') {
                // Nuages blancs paisibles
                const nuages = [
                    { x: 0.2, y: 0.2, taille: 0.8, vitesse: 1 },
                    { x: 0.6, y: 0.25, taille: 1, vitesse: 0.7 },
                    { x: 0.1, y: 0.35, taille: 0.6, vitesse: 1.2 }
                ];

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.lineWidth = 2;

                nuages.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 50) % (C.W + 100) - 50;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.04 * nuage.taille;

                    for(let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * taille * 0.8;
                        const rayonNuage = taille * (0.8 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                });
            } else {
                // Nuages d'orage gris avec √©clairs
                const nuagesOrage = [
                    { x: 0.3, y: 0.25, taille: 1.2, vitesse: 0.8 },
                    { x: 0.7, y: 0.2, taille: 1.5, vitesse: 0.5 },
                    { x: 0.1, y: 0.3, taille: 1.0, vitesse: 1.0 }
                ];

                nuagesOrage.forEach(nuage => {
                    const nuageX = (C.W * nuage.x + temps * nuage.vitesse * 30) % (C.W + 150) - 75;
                    const nuageY = C.H * nuage.y;
                    const taille = Math.min(C.W, C.H) * 0.05 * nuage.taille;

                    // Nuages gris mena√ßants
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';
                    ctx.strokeStyle = 'rgba(60, 60, 60, 0.8)';
                    ctx.lineWidth = 2;

                    for(let i = 0; i < 4; i++) {
                        const offsetX = (i - 1.5) * taille * 0.6;
                        const rayonNuage = taille * (0.7 + i * 0.1);
                        ctx.beginPath();
                        ctx.arc(nuageX + offsetX, nuageY, rayonNuage, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // √âclairs occasionnels
                    if(Math.random() < 0.02) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(nuageX, nuageY + taille);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 60, nuageY + taille + Math.random() * 80);
                        ctx.lineTo(nuageX + (Math.random() - 0.5) * 40, nuageY + taille + Math.random() * 120);
                        ctx.stroke();
                    }
                });
            }
        }

        // Rendu principal
        function dessiner() {

            // Fond d√©grad√© selon le chapitre
            const grad = ctx.createLinearGradient(0, 0, 0, C.H);
            if(periode === 'jour') {
                // Ciel diurne
                grad.addColorStop(0, 'rgba(135, 206, 250, 0.98)');
                grad.addColorStop(0.7, 'rgba(176, 224, 230, 0.98)');
                grad.addColorStop(1, 'rgba(240,248,255,0.98)');
            } else {
                // Ciel nocturne orageux
                grad.addColorStop(0, 'rgba(25, 25, 112, 0.98)'); // Bleu nuit
                grad.addColorStop(0.5, 'rgba(47, 79, 79, 0.98)'); // Gris sombre
                grad.addColorStop(1, 'rgba(105, 105, 105, 0.98)'); // Gris
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, C.W, C.H);

            dessinerCiel();
            dessinerMer();

            // Effet d'√©clairs en mode nuit
            if (periode === 'nuit') {
                dessinerEclairNuit();
            }

            dessinerInterface();
            dessinerPrejuges();
            dessinerPowerUps();
            dessinerCoeursBateau();
            dessinerPetitsCoeurs();
            dessinerBateau();
            afficherMunitions();
            dessinerStarsProjectiles(); // √âtoiles mode stars (phases tir coeurs)
            dessinerProjectiles(); // √âtoiles (phase briques)
            // Mode secret - utiliser le module
            if (secretModeModule && secretModeModule.isActive) {
                secretModeModule.render();
            } else if (modeSecret) {
                // Fallback si le module n'est pas disponible
                dessinerProjectilesSecret();
            }
            dessinerLanterne(); // Lanterne (mode casse-briques)
            dessinerCorbeau(); // Corbeau secret
            dessinerChauveSouris(); // Chauve-souris r√©v√©l√©e
            // Animation d'ic√¥ne supprim√©e - les ic√¥nes en haut servent de menu direct
            // Les ic√¥nes en haut servent maintenant de menu direct

            // Obstacles g√©r√©s par le module secret seulement

            // Objets kawaii r√©serv√©s au mode secret uniquement
            // (Les objets kawaii sont maintenant dans le module secret)

            dessinerParticules();

            // Rendu des drones feux d'artifice
            if (droneModule) {
                droneModule.render();
            }

            dessinerTextesVolants();
            dessinerMessageCorbeauBas(); // Messages discrets du corbeau
            dessinerEtoileCompteur(); // √âtoile avec compteur de clics corbeau
            dessinerMessagePowerupSimple(); // Messages simples des powerups en haut
            dessinerMessageNarratifSimple(); // Messages narratifs centr√©s
            dessinerBoutonPasser(); // Bouton passer simple en haut

            // Menu √©nigmes en dernier pour qu'il soit au premier plan
            dessinerMenuEnigmesCanvas();
        }

        // Contr√¥les tactiles et souris unifi√©s
        function obtenirPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left };
        }

        function deplacerRaquette(x) {
            if(!jeu) return;
            raquette.x = x - C.PW/2;
            raquette.x = Math.max(0, Math.min(raquette.x, C.W - C.PW));
        }

        // √âv√©nements tactiles
        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); tactile = true;

            // V√©rifier le clic sur le bouton passer
            const pos = obtenirPosition(e);
            if (verifierClicBoutonPasser(pos.x, pos.y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && periode !== 'nuit' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
                return;
            }

            if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles tactile
                const pos = obtenirPosition(e);
                tirerStarsProjectile(pos.x, pos.y);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction al√©atoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('üèÆ Lanterne lanc√©e !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir √©toiles activ√© par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const pos = obtenirPosition(e);
                        tirerStarsProjectile(pos.x, pos.y);
                    }
                } else {
                    // Si la balle est d√©j√† en mouvement, d√©placer la raquette
                    const pos = obtenirPosition(e);
                    deplacerRaquette(pos.x);
                }
            } else {
                const pos = obtenirPosition(e);
                deplacerRaquette(pos.x);
                libererVaguesAmour(); // Lib√©rer une vague d'amour
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(animationBateau.active || !tactile) return; // Bloquer pendant l'animation
            const pos = obtenirPosition(e);
            deplacerRaquette(pos.x);
        });

        canvas.addEventListener('touchend', e => {
            e.preventDefault(); tactile = false;
        });

        // √âv√©nements souris
        canvas.addEventListener('mousemove', e => {
            if(animationBateau.active || tactile) return; // Bloquer pendant l'animation
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Menu HOME supprim√©

            // V√©rifier le survol des ic√¥nes en haut
            verifierSurvolIconesHaut(x, y);

            // V√©rifier le survol des cartes d'√©nigmes
            verifierSurvolCartes(x, y);

            deplacerRaquette(e.clientX - rect.left);
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // V√©rifier d'abord les clics sur l'ic√¥ne centrale th√©matique
            const centralIcon = menuEnigmesCanvas.centralIcon;
            if (x >= centralIcon.x && x <= centralIcon.x + centralIcon.width &&
                y >= centralIcon.y && y <= centralIcon.y + centralIcon.height) {
                // Clic sur l'ic√¥ne centrale - ouvrir le menu √©nigmes
                ouvrirMenuEnigmesCanvas();
                console.log('üé≠ Menu √©nigmes ouvert via ic√¥ne centrale !');
                return;
            }

            // V√©rifier les clics sur les ic√¥nes en haut (si elles existent)
            if (menuEnigmesCanvas.topIcons && menuEnigmesCanvas.topIcons.length > 0) {
                for (let icon of menuEnigmesCanvas.topIcons) {
                    if (x >= icon.x && x <= icon.x + icon.width &&
                        y >= icon.y && y <= icon.y + icon.height) {
                        // Clic sur une ic√¥ne en haut - ouvrir le menu √©nigmes
                        ouvrirMenuEnigmesCanvas();
                        console.log('üß© Menu √©nigmes ouvert via ic√¥ne collect√©e !');
                        return;
                    }
                }
            }

            // V√©rifier les clics dans le menu √©nigmes si ouvert
            if (menuEnigmesCanvas.visible) {
                // Bouton de fermeture du menu principal
                if (x >= menuEnigmesCanvas.closeButton.x &&
                    x <= menuEnigmesCanvas.closeButton.x + menuEnigmesCanvas.closeButton.width &&
                    y >= menuEnigmesCanvas.closeButton.y &&
                    y <= menuEnigmesCanvas.closeButton.y + menuEnigmesCanvas.closeButton.height) {
                    fermerMenuEnigmesCanvas();
                    return;
                }

                // Clics sur les cartes d'√©nigmes (pas de fonction sp√©ciale, juste pour la navigation)
                for (let card of menuEnigmesCanvas.enigmaCards) {
                    const cardY = card.y - menuEnigmesCanvas.scrollY;
                    if (x >= card.x && x <= card.x + card.width &&
                        y >= cardY && y <= cardY + card.height) {

                        const isCollected = enigmaCollector && enigmaCollector.enigmesCollectees.has(card.id);
                        if (isCollected) {
                            console.log(`üß© √ânigme: ${card.enigme.nom} - ${card.enigme.description}`);
                        }
                        return;
                    }
                }

                // Clic en dehors du menu centr√© = fermer
                const menuWidth = Math.min(C.W - 80, 600);
                const menuHeight = Math.min(C.H - 80, 500);
                const menuX = (C.W - menuWidth) / 2;
                const menuY = (C.H - menuHeight) / 2;

                if (x < menuX || x > menuX + menuWidth || y < menuY || y > menuY + menuHeight) {
                    fermerMenuEnigmesCanvas();
                }
                return; // Ne pas traiter d'autres clics si le menu est ouvert
            }

            // L'ancien bouton menu √©nigmes est remplac√© par les ic√¥nes en haut

            // V√©rifier le clic sur le bouton passer
            if (verifierClicBoutonPasser(x, y)) {
                // Bouton fictif - afficher "NON!" au lieu de passer
                afficherMessagePowerupSimple('NON!');
                return;
            }

            if(animationBateau.active || narrationManager.isTransitioning) { return; } // Bloquer pendant l'animation et la narration
            // Ne PAS recommencer automatiquement en phases lanterne/stars/fin_niveau - laisser les transitions automatiques se faire
            if(!jeu && narrationManager.currentPhase > 1 && phaseJeu !== 'feux_artifice' && !narrationManager.isTransitioning && phaseJeu !== 'lanterne' && phaseJeu !== 'stars' && phaseJeu !== 'fin_niveau') {
                recommencer();
            } else if(phaseJeu === 'stars') {
                // Phase stars : tir d'√©toiles en mode nuit
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                // Munitions infinies en mode stars
                tirerStarsProjectile(mouseX, mouseY);
                libererVaguesAmour(); // Lib√©rer les c≈ìurs d'amour en phase stars
            } else if(phaseJeu === 'lanterne') {
                // Mode casse-briques : lancer la balle si elle est en attente
                if(balle.enAttente) {
                    // Lancer la balle vers le haut
                    balle.dx = C.SP * 1.5 * (Math.random() > 0.5 ? 1 : -1) * multiplicateurPuissance; // Direction al√©atoire
                    balle.dy = -C.SP * 1.5 * multiplicateurPuissance; // Vers le haut
                    balle.enAttente = false; // Plus en attente
                    afficherMessagePowerupSimple('üèÆ Lanterne lanc√©e !');
                } else if(window.modeTirStars && window.modeTirStars.actif) {
                    // Mode tir √©toiles activ√© par power-up
                    if(Date.now() > window.modeTirStars.fin) {
                        window.modeTirStars.actif = false;
                    } else {
                        const rect = canvas.getBoundingClientRect();
                        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                        tirerStarsProjectile(mouseX, mouseY);
                    }
                }
            } else {
                // Le syst√®me de clic sur les oiseaux est maintenant g√©r√© par les √©v√©nements CSS
                // Voir la fonction setupBirdClickHandlers() plus bas

                // Clic normal sur canvas pour lib√©rer l'amour
                if(!modeSecret) {
                    libererVaguesAmour();
                } else {
                    // En mode secret, utiliser le module
                    if (secretModeModule && secretModeModule.isActive) {
                        secretModeModule.createProjectile(x, y);
                    } else if (modeSecret) {
                        // Fallback si le module n'est pas disponible
                        creerProjectile();
                    }
                }
            }
        });

        // Redimensionnement responsive
        window.addEventListener('resize', () => {
            size = setupCanvas();
            if(!jeu) initJeu();
        });

        // ========== MODULE MODE SECRET - INITIALISATION ==========
        function initSecretModeModule() {
            if (!canvas || !ctx) {
                console.error('Canvas ou contexte non disponible pour le module secret');
                return;
            }

            // V√©rifier si la classe SecretModeModule est disponible
            if (typeof SecretModeModule === 'undefined') {
                console.warn('‚ö†Ô∏è SecretModeModule non trouv√© - Utilisation du mode secret int√©gr√©');
                secretModeModule = null;
                return;
            }

            try {
                // Cr√©er l'instance du module avec un objet gameState plus simple
                const gameStateRef = {
                    get modeSecret() { return modeSecret; },
                    set modeSecret(val) { modeSecret = val; },
                    get jeu() { return jeu; },
                    set jeu(val) { jeu = val; },
                    get score() { return score; },
                    set score(val) { score = val; },
                    get raquette() { return raquette; },
                    get C() { return C; },
                    get phaseJeu() { return phaseJeu; },
                    set phaseJeu(val) { phaseJeu = val; },
                    get animationBateau() { return animationBateau; },
                    afficherMessage: (msg, duree) => afficherMessage(msg, duree),
                    ajouterParticules: (x, y, couleur, nb) => ajouterParticules(x, y, couleur, nb)
                };

                secretModeModule = new SecretModeModule(canvas, ctx, gameStateRef);
                console.log('üéÆ Module Mode Secret initialis√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur initialisation module secret:', error);
                secretModeModule = null;
            }
        }

        // ========== MODULE OBJETS KAWAII - INITIALISATION ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret DOM
        // Plus besoin d'initialisation s√©par√©e

        // ========== MODULE OBJETS KAWAII - SUPPRIM√â ==========
        // Les objets kawaii sont maintenant g√©r√©s uniquement par le module secret
        function activerObjetsKawaii() {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        function desactiverObjetsKawaii() {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        function configurerObjetsKawaii(config) {
            console.log('üíï Objets kawaii r√©serv√©s au mode secret uniquement');
        }

        // ========== MODULE OISEAUX CSS - GESTIONNAIRE √âV√âNEMENTS ==========
        function setupBirdClickHandlers() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            // Clic sur le corbeau
            crowElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'corbeau') {
                    handleBirdClick();
                }
            });

            // Clic sur la colombe
            doveElement.addEventListener('click', function(e) {
                e.stopPropagation(); // Emp√™cher la propagation au canvas
                if (corbeau.actif && corbeau.type === 'colombe') {
                    handleBirdClick();
                }
            });
        }

        function handleBirdClick() {
            corbeau.touches++;
            score += 100; // Points bonus pour toucher l'oiseau

            // Effet visuel
            ajouterParticules(corbeau.x, corbeau.y, '#FFD700', 8);

            // Afficher l'√©toile avec le compteur de clics
            afficherEtoileCompteur();

            if (corbeau.touches >= 3 && corbeau.type === 'corbeau') {
                // Transformer en colombe !
                corbeau.type = 'colombe';
                score += 1000; // Gros bonus pour la transformation

                // D√©bloquer le niveau secret !
                niveauSecretDebloque = true;

                afficherMessagePowerupSimple('üïäÔ∏è Miracle! +1000 pts - Niveau secret d√©bloqu√©!');

                // Le soleil fait un clin d'≈ìil
                soleil.clignotement = true;
                soleil.tempsClignotement = Date.now();

                // D√©clencher le niveau secret apr√®s un d√©lai
                setTimeout(() => {
                    if (secretModeModule) {
                        secretModeModule.activate();
                    } else {
                        console.error('Module secret non initialis√© !');
                        lancerNiveauSecret(); // Fallback vers l'ancien syst√®me
                    }
                }, 4000);
            } else {
                // Message discret en bas √† droite
                afficherMessageCorbeauBas(`üéØ ${corbeau.touches}/3 üí∞ +100`, 1000);
            }
        }

        // ========== CORBEAU SECRET ==========
        function afficherMessageCorbeauBas(texte, duree) {
            messageCorbeauBas.actif = true;
            messageCorbeauBas.texte = texte;
            messageCorbeauBas.tempsFin = Date.now() + duree;
        }

        // Variables pour l'√©toile compteur
        let etoileCompteur = {
            actif: false,
            x: 0,
            y: 0,
            tempsFin: 0,
            alpha: 1
        };

        function afficherEtoileCompteur() {
            // Positionner l'√©toile pr√®s du corbeau
            etoileCompteur.x = corbeau.x + 30;
            etoileCompteur.y = corbeau.y - 20;
            etoileCompteur.actif = true;
            etoileCompteur.tempsFin = Date.now() + 2000; // Afficher 2 secondes
            etoileCompteur.alpha = 1;
        }

        function mettreAJourEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            const tempsRestant = etoileCompteur.tempsFin - Date.now();
            if (tempsRestant <= 0) {
                etoileCompteur.actif = false;
                return;
            }

            // Fade out progressif
            if (tempsRestant < 500) {
                etoileCompteur.alpha = tempsRestant / 500;
            }
        }

        function dessinerEtoileCompteur() {
            if (!etoileCompteur.actif) return;

            ctx.save();
            ctx.globalAlpha = etoileCompteur.alpha;

            // Dessiner l'√©toile blanche
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;

            const x = etoileCompteur.x;
            const y = etoileCompteur.y;
            const rayon = 15;

            // Forme d'√©toile √† 5 branches
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const x1 = x + Math.cos(angle) * rayon;
                const y1 = y + Math.sin(angle) * rayon;

                const angleInterne = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                const x2 = x + Math.cos(angleInterne) * (rayon * 0.4);
                const y2 = y + Math.sin(angleInterne) * (rayon * 0.4);

                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Texte du compteur
            ctx.fillStyle = 'black';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(corbeau.touches.toString(), x, y);

            ctx.restore();
        }

        function mettreAJourMessageCorbeauBas() {
            if(messageCorbeauBas.actif && Date.now() > messageCorbeauBas.tempsFin) {
                messageCorbeauBas.actif = false;
            }
        }

        function dessinerMessageCorbeauBas() {
            if(!messageCorbeauBas.actif) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Position en bas √† droite
            const x = C.W - 120;
            const y = C.H - 40;

            // Fond semi-transparent
            const largeur = 200;
            const hauteur = 30;
            ctx.fillRect(x - largeur/2, y - hauteur/2, largeur, hauteur);

            // Texte en blanc
            ctx.fillStyle = '#FFD700';
            ctx.fillText(messageCorbeauBas.texte, x, y);

            ctx.restore();
        }

        function mettreAJourCorbeau() {
            if(!jeu || phaseIntro.active) return; // Attendre la fin de l'intro

            // Initialiser le temps de d√©part si pas encore fait
            if(corbeau.tempsApparition === 0) {
                corbeau.tempsApparition = Date.now();
            }

            const tempsJeu = Date.now() - corbeau.tempsApparition;

            // Faire appara√Ætre le corbeau toutes les 30 secondes
            if(!corbeau.actif && tempsJeu >= corbeau.prochainPassage) {
                corbeau.actif = true;

                // Alterner la direction √† chaque passage
                if(corbeau.direction === 1) {
                    // Gauche vers droite
                    corbeau.x = -100;
                    corbeau.vx = 0.8 / 1.5;
                } else {
                    // Droite vers gauche
                    corbeau.x = C.W + 100;
                    corbeau.vx = -(0.8 / 1.5);
                }

                corbeau.y = C.H * 0.4; // Vers le milieu de l'√©cran
                corbeau.touches = 0; // R√©initialiser le compteur de touches

                // Alterner pour le prochain passage
                corbeau.direction *= -1;

                // Prochain passage dans 30 secondes
                corbeau.prochainPassage += 30000;

                // console.log(`üê¶ Corbeau spawn - Direction: ${corbeau.vx > 0 ? 'droite ‚Üí' : '‚Üê gauche'}`);
            }

            // Animer le corbeau s'il est actif
            if(corbeau.actif) {
                corbeau.x += corbeau.vx;
                corbeau.y += Math.sin(Date.now() * 0.0005) * 0.25; // Mouvement ondulant tr√®s doux et petit

                // V√©rifier collision avec la lanterne allum√©e
                if(lanterne.active && balle.visible && !chauveSouris.revelee) {
                    const distanceX = Math.abs(corbeau.x - balle.x);
                    const distanceY = Math.abs(corbeau.y - balle.y);
                    const distanceCollision = 60; // Distance de collision

                    if(distanceX < distanceCollision && distanceY < distanceCollision) {
                        // R√©v√©ler la chauve-souris !
                        revelerChauveSouris(corbeau.x, corbeau.y);

                        // Faire dispara√Ætre l'oiseau
                        corbeau.actif = false;
                        corbeau.x = 0;
                        corbeau.y = 0;

                        console.log('ü¶á Collision d√©tect√©e ! R√©v√©lation de la chauve-souris');
                    }
                }

                // Retirer le corbeau s'il sort de l'√©cran (dans les deux directions)
                if((corbeau.vx > 0 && corbeau.x > C.W + 100) || (corbeau.vx < 0 && corbeau.x < -100)) {
                    corbeau.actif = false;
                    corbeau.x = 0;
                    corbeau.y = 0;
                }
            }
        }

        // ========== MODULE OISEAUX CSS - FONCTION MODIFI√âE ==========
        function dessinerCorbeau() {
            const crowElement = document.getElementById('crow');
            const doveElement = document.getElementById('dove');

            if (!corbeau.actif || phaseIntro.active) {
                // Masquer tous les oiseaux
                crowElement.classList.remove('bird-visible');
                crowElement.classList.add('bird-hidden');
                doveElement.classList.remove('bird-visible');
                doveElement.classList.add('bird-hidden');
                return;
            }

            // Positionner l'oiseau selon les coordonn√©es
            const activeElement = corbeau.type === 'corbeau' ? crowElement : doveElement;
            const inactiveElement = corbeau.type === 'corbeau' ? doveElement : crowElement;

            // Masquer l'oiseau inactif
            inactiveElement.classList.remove('bird-visible');
            inactiveElement.classList.add('bird-hidden');

            // Positionner et afficher l'oiseau actif
            activeElement.style.left = corbeau.x + 'px';
            activeElement.style.top = corbeau.y + 'px';

            // Orienter l'oiseau selon sa direction avec l'animation appropri√©e
            if (corbeau.vx < 0) {
                // Va vers la gauche - utiliser animation retourn√©e
                activeElement.style.animation = 'crow-auto-flight-left calc(2s / var(--animation-speed)) infinite';
                // console.log('üê¶ Corbeau orient√© GAUCHE ‚Üê (animation crow-auto-flight-left)');
            } else {
                // Va vers la droite - animation normale
                activeElement.style.animation = 'crow-auto-flight calc(2s / var(--animation-speed)) infinite';
                // console.log('üê¶ Corbeau orient√© DROITE ‚Üí (animation crow-auto-flight)');
            }

            activeElement.classList.remove('bird-hidden');
            activeElement.classList.add('bird-visible');
        }

        // Textes volants qui grossissent et montent tout doucement vers le centre
        function ajouterTexteVolant(texte, x, y) {
            textesVolants.push({
                texte: texte,
                x: x,
                y: y,
                xDepart: x,
                yDepart: y,
                vy: 0, // Vitesse calcul√©e dynamiquement
                taille: 12, // Taille initiale
                alpha: 1, // Opacit√©
                temps: 0,
                phase: 'descente' // 'descente' puis 'montee'
            });
        }

        function mettreAJourTextesVolants() {
            for(let i = textesVolants.length - 1; i >= 0; i--) {
                const texte = textesVolants[i];
                texte.temps += 0.004; // Progression plus lente

                // Mouvement vers le centre horizontal
                const centreX = C.W / 2;
                const progression = Math.min(1, texte.temps * 1.5); // Progression plus lente vers le centre
                texte.x = texte.xDepart + (centreX - texte.xDepart) * progression;

                // Animation en deux phases : descente puis mont√©e
                if(texte.phase === 'descente') {
                    // Phase 1 : Le texte descend lentement et plus bas
                    texte.y = texte.yDepart + (texte.temps * 200); // Descend plus bas (200px max)

                    // Fondu pendant la descente
                    texte.alpha = Math.max(0.3, 1 - texte.temps * 2); // Fondu plus marqu√©

                    // Passer √† la phase mont√©e apr√®s plus de temps
                    if(texte.temps > 0.2) {
                        texte.phase = 'montee';
                        texte.yTournant = texte.y; // Marquer le point de retournement
                        texte.tempsRetournement = texte.temps;
                        texte.alpha = 0.3; // Alpha minimum au tournant
                    }
                } else {
                    // Phase 2 : Le texte remonte vers le haut avec fondu retour
                    const tempsDepuisRetournement = texte.temps - texte.tempsRetournement;
                    texte.y = texte.yTournant - (tempsDepuisRetournement * 120); // Remonte moins vite

                    // Fondu retour pendant la mont√©e
                    texte.alpha = Math.min(1, 0.3 + tempsDepuisRetournement * 3);
                }

                // Grossissement tr√®s progressif et doux
                texte.taille = 12 + texte.temps * 20;

                // Disparition finale tr√®s progressive
                if(texte.temps > 0.6) {
                    texte.alpha = Math.max(0, texte.alpha - (texte.temps - 0.6) * 2);
                }

                // Supprimer si invisible ou trop haut
                if(texte.alpha <= 0 || texte.y < -50) {
                    textesVolants.splice(i, 1);
                }
            }
        }

        function dessinerTextesVolants() {
            textesVolants.forEach(texte => {
                ctx.save();
                ctx.globalAlpha = texte.alpha;
                ctx.font = `800 ${texte.taille}px monospace`;
                ctx.textAlign = 'center';

                // Contour blanc
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, texte.taille * 0.1);
                ctx.strokeText(texte.texte, texte.x, texte.y);

                // Texte principal
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(texte.texte, texte.x, texte.y);

                ctx.restore();
            });
        }

        // Boucle de jeu

        function boucleJeu() {
            // ARR√äT TOTAL du syst√®me jusqu'√† s√©lection de langue
            if (window.systemeArrete) {
                console.log('üõë Boucle bloqu√©e par systemeArrete');
                // Ne m√™me pas red√©marrer la boucle, arr√™t complet
                return;
            }

            // Pause pour le menu langue
            if (window.jeuEnPause) {
                requestAnimationFrame(boucleJeu);
                return;
            }
            // Debug : boucle active
            console.log('üîÑ Boucle de jeu active');

            // G√©rer l'animation du bateau
            gererAnimationBateau();

            // G√©rer la phase d'introduction
            gererPhaseIntro();

            // Phase bonus - Le Mur dans la Mer
            if (phaseJeu === 'bonus_mur' && window.phaseBonusMur) {
                window.phaseBonusMur.update();
            } else if(jeu || phaseIntro.active) {
                if(jeu) {
                    mettreAJourStarsProjectiles(); // Syst√®me projectiles stars
                    mettreAJourProjectiles(); // Nouveau syst√®me de projectiles
                    mettreAJourBulle(); // Ancien syst√®me pour les autres phases
                }
                mettreAJourParticules();

                // Mise √† jour du module de drones
                if (droneModule) {
                    droneModule.animate();
                }

                mettreAJourPowerUps();
                mettreAJourLanterne();
                mettreAJourCoeursBateau();
                mettreAJourPetitsCoeurs();
                mettreAJourTextesVolants();
                mettreAJourCorbeau(); // Gestion du corbeau secret
                mettreAJourMessageCorbeauBas(); // Messages discrets du corbeau
                mettreAJourChauveSouris(); // Gestion de la chauve-souris
                // Animation ic√¥ne supprim√©e - les ic√¥nes en haut servent de menu direct
                mettreAJourMenuEnigmesCanvas(); // Animation menu √©nigmes canvas

                // V√©rification automatique des √©nigmes collectibles
                if (enigmaCollector && Math.random() < 0.01) { // 1% de chance par frame
                    enigmaCollector.verifierCollectionAutomatique();
                }
                mettreAJourEtoileCompteur(); // Mise √† jour √©toile compteur

                // Mise √† jour des effets d'√©clairs en mode nuit
                if (periode === 'nuit') {
                    mettreAJourEclairNuit();
                }

                // Obstacles g√©r√©s par le module secret seulement

                // Objets kawaii r√©serv√©s au mode secret uniquement
                // (Les objets kawaii sont maintenant dans le module secret)
                // Mode secret - utiliser le module
                if (secretModeModule && secretModeModule.isActive) {
                    secretModeModule.update();
                } else if (modeSecret) {
                    // Fallback si le module n'est pas disponible
                    mettreAJourProjectilesSecret();
                }
            }
            dessiner();
            requestAnimationFrame(boucleJeu);
        }


        // D√©marrage avec intro forc√©e - mais seulement apr√®s s√©lection de langue
        // initJeu(); // D√©plac√© vers l'√©cran de s√©lection de langue

        // Initialiser le module secret - diff√©r√© jusqu'√† s√©lection de langue
        // initSecretModeModule(); // D√©plac√© vers l'√©cran de s√©lection

        // Variables d'√©tat - initialis√©es mais pas d√©marr√©es
        // phaseIntro = { active: true, etape: 'arrivee_bateau', tempsDebut: Date.now() };
        // jeu = false; // Sera initialis√© apr√®s s√©lection de langue

        // üéØ D√âMARRAGE AUTOMATIQUE D√âSACTIV√â jusqu'√† s√©lection de langue
        console.log('üåç Attente de la s√©lection de langue avant d√©marrage');

        // TOUT LE CODE DE D√âMARRAGE AUTOMATIQUE A √âT√â SUPPRIM√â
        // Il sera red√©marr√© par l'√©cran de s√©lection de langue

        console.log('üåç Script initialis√© - En attente de s√©lection de langue');

        // === RACCOURCIS TEST ===
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                e.preventDefault();
                narrationManager.showFinalMenu();
            }

            // Touche 1 pour aller directement √† la phase 11
            if (e.key === '1') {
                e.preventDefault();
                console.log('üöÄ RACCOURCI: Saut vers la phase 11');
                narrationManager.currentPhase = 11;
                narrationManager.goToNextPhase();
            }

            // Touche 2 pour passer √† la phase suivante
            if (e.key === '2') {
                e.preventDefault();
                console.log('üöÄ RACCOURCI: Phase suivante');
                narrationManager.goToNextPhase();
            }

            // Touche M pour menu final
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                console.log('üöÄ RACCOURCI: Menu final');
                narrationManager.showFinalMenu();
            }
        });

        // === ANCIEN SYST√àME NARRATION SUPPRIM√â ===
        let niveauSecretDebloque = false;
        let modeSecret = false;
        let dernierNiveauAtteint = 0; // Sauvegarder le dernier niveau atteint
        let phaseAvantSecret = null; // Sauvegarder la phase avant le mode secret
        let modeEtoileLance = false; // Pour tracker si on est en mode √©toile depuis le menu final
        let obstacles = [];
        let tempsDebutSecret = 0;
        let tempsDernierObstacle = 0;

        // anciens messages supprim√©s

        // Fonction supprim√©e

        // Fonctions supprim√©es

        // Gestionnaire clavier pour mode passe
        document.addEventListener('keydown', (e) => {
            // Mode passe : Touche T pour passer au chapitre suivant
            if(e.key === 't' || e.key === 'T') {
                e.preventDefault();
                passerChapitreTest();
            }

            // Mode passe : Touche P pour passer √† la phase suivante (d√©sactiv√©)
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                // Fonction supprim√©e pour nettoyage du code
            }

            // Mode passe : Touche V pour ajouter des vies
            if(e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                vies = Math.min(vies + 1, 9);
            }

            // Mode passe : Touche S pour niveau secret
            if(e.key === 's' || e.key === 'S') {
                e.preventDefault();
                lancerNiveauSecret();
            }

            // Mode passe : Touche R pour r√©duire la vie des briques √† 1
            if(e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                reduireVieBriques();
            }

            // üéÜ TEST : Touche X pour tester l'animation d'explosion
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                console.log('üéÜ TEST : Animation d\'explosion forc√©e !');
                animerExplosionIconeCollector(() => {
                    console.log('üéÜ TEST : Animation d\'explosion termin√©e');
                });
            }

            // üîÑ RESET : Touche Z pour r√©initialiser √† z√©ro
            if(e.key === 'z' || e.key === 'Z') {
                e.preventDefault();
                console.log('üîÑ R√âINITIALISATION COMPL√àTE !');

                // Effacer toutes les donn√©es localStorage
                localStorage.removeItem('vdv_enigmes_collectees');
                localStorage.removeItem('voir_la_verite_progression');
                localStorage.removeItem('vdv_gameState');

                console.log('üîÑ Donn√©es localStorage effac√©es !');
                console.log('üîÑ Rechargement de la page...');

                // Recharger la page
                location.reload();
            }

            // üåßÔ∏è PLUIE : Touche P pour d√©clencher pluie de traits lumineux
            if(e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                console.log('üåßÔ∏è PLUIE : D√©clencher pluie de traits lumineux !');
                if(typeof declencherPluieLumineuse === 'function') {
                    declencherPluieLumineuse();
                }
            }

            // Mode passe : Touche E pour tir automatique √©toiles
            if(e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activerTirEtoiles();
            }

            // Cheat code : Touche X pour multiplier puissance x10
            if(e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                if (multiplicateurPuissance === 1) {
                    multiplicateurPuissance = 10;
                    console.log('üöÄ CHEAT ACTIV√â: Puissance x10!');
                } else {
                    multiplicateurPuissance = 1;
                    console.log('üîÑ CHEAT D√âSACTIV√â: Puissance normale');
                }
            }

        });

        // ======== NIVEAU SECRET : PACMAN ========
        function lancerNiveauSecret() {
            // D√©sactiver les objets kawaii pendant le mode secret
            desactiverObjetsKawaii();

            // Utiliser le module si disponible, sinon le syst√®me int√©gr√©
            if (secretModeModule) {
                secretModeModule.activate();
                return;
            }

            // Fallback vers l'ancien syst√®me
            // Sauvegarder la phase actuelle
            phaseAvantSecret = phaseJeu;

            modeSecret = true;
            tempsDebutSecret = Date.now();
            tempsDernierObstacle = Date.now();
            obstacles = []; // R√©initialiser les obstacles pour le fallback

            // Changer l'ambiance pour le mode secret
            phaseJeu = 'secret_obstacles';
            dernierNiveauAtteint = Math.max(dernierNiveauAtteint, 4);
            jeu = true;

            // Mode secret utilise maintenant le module secret - pas d'obstacles de fallback

            afficherMessageAnime('üéØ NIVEAU SECRET : TIR DE PR√âCISION ! üéØ\n\nüßä Tirez sur les icebergs et poubelles ! ‚ôª\nüêã ATTENTION : Les baleines sont prot√©g√©es !\nüö´ Tirer sur une baleine = "NO GREAT!" et perte de vie\nüëÜ Chaque clic = un tir pr√©cis\nüí∞ +100 points par obstacle d√©truit !', 5000, 'glitch', 50);
        }



        function creerProjectile() {
            // Cr√©er un projectile simple depuis le bateau (mode secret)
            projectilesSecret.push({
                x: raquette.x + C.PW/2, // Centre du bateau
                y: raquette.y,
                vitesse: 8, // Vitesse vers le haut
                taille: 5
            });
        }

        function mettreAJourProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach((projectile, pIndex) => {
                // Faire monter le projectile
                projectile.y -= projectile.vitesse;

                // Supprimer les projectiles qui sortent en haut
                if(projectile.y < -10) {
                    projectilesSecret.splice(pIndex, 1);
                    return;
                }

                // V√©rifier collision avec les obstacles
                obstacles.forEach((obstacle, oIndex) => {
                    if(obstacle.touche) return; // Obstacle d√©j√† touch√©

                    const distance = Math.sqrt(
                        Math.pow(projectile.x - obstacle.x, 2) +
                        Math.pow(projectile.y - obstacle.y, 2)
                    );

                    if(distance < obstacle.taille/2 + projectile.taille) {
                        // Collision d√©tect√©e !
                        projectilesSecret.splice(pIndex, 1); // Supprimer le projectile

                        if(obstacle.type === 'baleine') {
                            // Baleine prot√©g√©e ! Perdre une vie
                            vies--;

                            // Messages amusants vari√©s
                            const messagesRigolo = [
                                'NO GREAT! HAAAH!',
                                'BOOOO! PAS BIEN!',
                                'OOOH NON! VILAIN!',
                                'HAAAH! CATASTROPHE!',
                                'BEURK! MECHANT!',
                                'AIEEEE! MONSTER!',
                                'GRRRR! STUPID!',
                                'PFFFFFF! IDIOT!',
                                'TSSS TSSS! SHAME!'
                            ];
                            const messageAleatoire = messagesRigolo[Math.floor(Math.random() * messagesRigolo.length)];

                            if(vies <= 0) {
                                modeSecret = false;
                                jeu = false;
                                // Restaurer la phase d'origine m√™me en Game Over
                                if (phaseAvantSecret) {
                                    phaseJeu = phaseAvantSecret;
                                    phaseAvantSecret = null;
                                } else {
                                    phaseJeu = 'briques'; // Fallback par d√©faut
                                }

                                // R√©activer les objets kawaii apr√®s Game Over
                                activerObjetsKawaii();

                                afficherMessageAvecBoutons(`üíÄ ${messageAleatoire} üíÄ\n\nüêã Tu as tir√© sur une baleine prot√©g√©e !\nüò± Toutes tes vies sont √©puis√©es !\nüö´ Les baleines ne se tirent pas !\nü§™ HAHAHAHA! GAME OVER!`,
                                    'lancerNiveauSecret', 'recommencer');
                            } else {
                                const messagesVie = [
                                    `üö´ ${messageAleatoire} üö´\n\nüêã Les baleines sont prot√©g√©es !\nüíî Vie perdue : ${vies} restantes\nüò§ Tire seulement sur les icebergs !\nüôÑ TSSS TSSS!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã BALEINE = INTERDITE !\nüíî Oups : ${vies} vies restantes\nüò§ ICEBERGS SEULEMENT !\nü§¶‚Äç‚ôÇÔ∏è PFFFFFF!`,
                                    `üö´ ${messageAleatoire} üö´\n\nüêã PAUVRE BALEINE !\nüíî Punition : ${vies} vies left\nüò§ GLACE = OK, BALEINE = NON !\nüòÇ HAHAHAHA!`
                                ];
                                const messageVieAleatoire = messagesVie[Math.floor(Math.random() * messagesVie.length)];
                                afficherMessage(messageVieAleatoire, 3000);
                            }

                            // Effet visuel rouge (col√®re)
                            ajouterParticules(obstacle.x, obstacle.y, '#FF0000', 8);
                        } else {
                            // Iceberg ou Poubelle : OK √† d√©truire
                            obstacle.vie--;
                            if(obstacle.vie <= 0) {
                                // Obstacle d√©truit
                                obstacles.splice(oIndex, 1);
                                score += 100; // Points bonus

                                // Effet visuel vert (succ√®s)
                                ajouterParticules(obstacle.x, obstacle.y, '#00FF00', 6);
                            } else {
                                obstacle.touche = true; // Marquer comme touch√© temporairement
                                setTimeout(() => { obstacle.touche = false; }, 200);
                            }
                        }
                    }
                });
            });
        }

        function dessinerProjectilesSecret() {
            if(!modeSecret) return;

            projectilesSecret.forEach(projectile => {
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.taille, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // SUPPRIM√â: creerObstaclesMarins() - remplac√© par le module secret

        // SUPPRIM√â: mettreAJourObstacles() - remplac√© par le module secret

        // SUPPRIM√â: Module obstacles legacy - remplac√© par le module secret

        // SUPPRIM√â: dessinerObstacles() - remplac√© par le module secret

        // L'animation d√©marre automatiquement via gererAnimationBateau()
        window.addEventListener('load', function() {
            console.log('üéÆ Window load - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
            console.log('üéÆ Window load - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');

            // Attente plus longue pour s'assurer que tous les scripts sont charg√©s
            setTimeout(() => {
                console.log('üéÆ D√©marrage du jeu - SecretModeModule disponible:', typeof SecretModeModule !== 'undefined');
                console.log('üéÆ D√©marrage du jeu - KawaiiObjects disponible:', typeof KawaiiObjects !== 'undefined');

                // üåç INITIALISER LE SYST√àME I18N
                if (window.i18n && window.languageSelector) {
                    window.i18n.init().then(() => {
                        console.log('üåç Syst√®me i18n initialis√© !');
                        window.languageSelector.create();
                        window.languageSelector.updateButton();
                    });
                }

                // üåü Activer le syst√®me P5 de particules
                activerParticulesP5();
                console.log('üåü Syst√®me P5 particules activ√© !');

                // boucleJeu(); // D√©marrage diff√©r√© jusqu'√† s√©lection de langue
            }, 500);
        });
    </script>


<div id="language-button" style="position: fixed; top: 80px; left: 50%; transform: translateX(-50%); width: 60px; height: 60px; background: linear-gradient(145deg, rgba(100, 255, 218, 0.2), rgba(100, 255, 218, 0.1)); border: 2px solid rgba(100, 255, 218, 0.4); border-radius: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 28px; z-index: 1000; transition: 0.3s; backdrop-filter: blur(10px); opacity: 0; pointer-events: none;">üá´üá∑</div><div id="language-dropdown" style="position: fixed; top: 150px; left: 50%; transform: translateX(-50%) translateY(-10px); background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9)); border: 2px solid rgba(100, 255, 218, 0.4); border-radius: 12px; padding: 15px; z-index: 2000; display: none; backdrop-filter: blur(15px); min-width: 220px; max-height: 300px; overflow-y: auto; box-shadow: rgba(0, 0, 0, 0.15) 0px 10px 25px; opacity: 0;"><div class="language-option-simple" data-lang="fr" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; display: flex; align-items: center; transition: 0.2s; margin: 3px 0px;">
                <span style="font-size: 20px; margin-right: 10px;">üá´üá∑</span>
                <span style="font-size: 16px; font-weight: 500; color: #334155;">Fran√ßais</span>
            </div><div class="language-option-simple" data-lang="en" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; display: flex; align-items: center; transition: 0.2s; margin: 3px 0px;">
                <span style="font-size: 20px; margin-right: 10px;">üá¨üáß</span>
                <span style="font-size: 16px; font-weight: 500; color: #334155;">English</span>
            </div><div class="language-option-simple" data-lang="jp" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; display: flex; align-items: center; transition: 0.2s; margin: 3px 0px;">
                <span style="font-size: 20px; margin-right: 10px;">üáØüáµ</span>
                <span style="font-size: 16px; font-weight: 500; color: #334155;">Êó•Êú¨Ë™û</span>
            </div><div class="language-option-simple" data-lang="uk" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; display: flex; align-items: center; transition: 0.2s; margin: 3px 0px;">
                <span style="font-size: 20px; margin-right: 10px;">üá∫üá¶</span>
                <span style="font-size: 16px; font-weight: 500; color: #334155;">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</span>
            </div></div></body></html>