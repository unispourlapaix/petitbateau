/**
 * Module Supabase Scores - Gestion des scores multi-jeux
 * @author Emmanuel Payet (Dreamer Unisona)
 * @version 1.0.0
 */

class SupabaseScores {
    constructor() {
        // üîß MODE DEBUG ACTIV√â
        this.debugMode = true;
        
        // Configuration Supabase
        this.supabaseUrl = 'https://dmszyxowetilvsanqsxm.supabase.co';
        this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtc3p5eG93ZXRpbHZzYW5xc3htIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk3NzM0NDUsImV4cCI6MjA3NTM0OTQ0NX0.EukDYFVt0sCrDb0_V4ZPMv5B4gkD43V8Cw7CEuvl0C8';

        if (this.debugMode) {
            console.log('üîß MODE DEBUG ACTIV√â');
            console.log('üì° Supabase URL:', this.supabaseUrl);
            console.log('üîë API Key (20 premiers chars):', this.supabaseKey.substring(0, 20) + '...');
        }

        // Charger la librairie Supabase
        this.loadSupabaseLibrary();

        // Utilisateur actuel (null si pas connect√©)
        this.currentUser = null;

        // ID du jeu actuel (sera d√©fini par le jeu)
        this.currentGameId = null;

        console.log('üéÆ SupabaseScores initialis√©');
    }

    log(...args) {
        if (this.debugMode) {
            console.log('üîß [DEBUG]', ...args);
        }
    }

    error(...args) {
        if (this.debugMode) {
            console.error('‚ùå [DEBUG]', ...args);
        }
    }

    // Charger la librairie Supabase depuis CDN
    loadSupabaseLibrary() {
        if (window.supabase) {
            this.initSupabase();
            return;
        }

        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/dist/umd/supabase.js';
        script.onload = () => {
            console.log('‚úÖ Librairie Supabase charg√©e');
            this.initSupabase();
        };
        script.onerror = () => {
            console.error('‚ùå Erreur chargement Supabase - Mode hors ligne activ√©');
            this.isOffline = true;
        };
        document.head.appendChild(script);
    }

    // Initialiser le client Supabase
    initSupabase() {
        console.log('üîß [DEBUG] Cr√©ation du client Supabase...');
        this.client = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
        console.log('üîß [DEBUG] Client cr√©√©:', !!this.client);
        console.log('‚úÖ Client Supabase initialis√©');
        
        // Test de connexion imm√©diat
        if (this.debugMode) {
            this.testConnection();
        }
    }

    // Test de connexion (mode debug)
    async testConnection() {
        console.log('üîß [DEBUG] üß™ Test de connexion √† la base de donn√©es...');
        try {
            const { data, error } = await this.client
                .from('games')
                .select('count');
            
            if (error) {
                console.error('‚ùå [DEBUG] Erreur connexion:', error);
            } else {
                console.log('üîß [DEBUG] ‚úÖ Connexion OK - Nombre de jeux:', data);
            }
        } catch (e) {
            console.error('‚ùå [DEBUG] Exception connexion:', e);
        }
    }

    // Cr√©er ou r√©cup√©rer un utilisateur (stocke localement pour saveScore Edge Function)
    async getOrCreateUser(email, pseudo, options = {}) {
        try {
            // Stocker les informations localement pour la fonction Edge
            this.currentUser = {
                email: email,
                pseudo: pseudo,
                avatar: options.avatar || null,
                ville: options.ville || null,
                pays: options.pays || null,
                age: options.age || null,
                genre: options.genre || null
            };

            console.log('üë§ Utilisateur configur√© localement pour Edge Function:', pseudo);
            return this.currentUser;

        } catch (error) {
            console.error('‚ùå Erreur getOrCreateUser:', error);
            return null;
        }
    }

    // D√©finir le jeu actuel
    async setCurrentGame(gameName) {
        console.log('üîß [DEBUG] setCurrentGame appel√© avec:', gameName);
        try {
            const { data, error } = await this.client
                .from('games')
                .select('*')
                .eq('nom', gameName)
                .single();

            if (error) {
                console.error('‚ùå [DEBUG] Erreur setCurrentGame:', error);
                throw error;
            }

            this.currentGameId = data.id;
            console.log('üîß [DEBUG] ‚úÖ Game ID d√©fini:', this.currentGameId);
            console.log('üéÆ Jeu actuel:', data.nom, data.icone);
            return data;

        } catch (error) {
            console.error('‚ùå [DEBUG] Exception setCurrentGame:', error);
            console.error('‚ùå Erreur setCurrentGame:', error);
            return null;
        }
    }

    // Sauvegarder un score via la fonction Edge (s√©curis√© avec RLS)
    async saveScore(score, options = {}) {
        try {
            // Utiliser la fonction Edge au lieu de l'insertion directe
            const response = await fetch(`${this.client.supabaseUrl}/functions/v1/save-game-score`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.supabaseKey}`
                },
                body: JSON.stringify({
                    email: this.currentUser?.email,
                    pseudo: this.currentUser?.pseudo,
                    score: score,
                    niveau_atteint: options.niveau_atteint || null,
                    temps_jeu: options.temps_jeu || null,
                    donnees_extra: options.donnees_extra || null,
                    ville: this.currentUser?.ville,
                    pays: this.currentUser?.pays,
                    age: this.currentUser?.age,
                    genre: this.currentUser?.genre,
                    avatar: this.currentUser?.avatar
                })
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || 'Erreur lors de la sauvegarde');
            }

            // Stocker le user_id retourn√© par la fonction Edge
            if (result.user_id && this.currentUser) {
                this.currentUser.id = result.user_id;
                console.log('‚úÖ user_id stock√©:', result.user_id);
            }

            console.log('‚úÖ Score enregistr√© via Edge Function:', result);
            return result;

        } catch (error) {
            console.error('‚ùå Erreur saveScore:', error);
            return null;
        }
    }

    // M√©thode directe (sans Edge Function) - Fonctionne imm√©diatement
    async saveScoreDirect(score, options = {}) {
        this.log('=== saveScoreDirect D√âBUT ===');
        this.log('Score:', score);
        this.log('Options:', options);
        this.log('currentUser:', this.currentUser);
        this.log('currentGameId:', this.currentGameId);
        
        if (!this.currentUser) {
            this.error('Aucun utilisateur connect√©');
            console.error('‚ùå Aucun utilisateur connect√©');
            return { success: false, error: 'Aucun utilisateur' };
        }

        if (!this.currentGameId) {
            this.error('Aucun jeu s√©lectionn√©');
            console.error('‚ùå Aucun jeu s√©lectionn√©');
            return { success: false, error: 'Aucun jeu s√©lectionn√©' };
        }

        try {
            // 1. Cr√©er ou r√©cup√©rer l'utilisateur
            let userId = this.currentUser.id;
            
            if (!userId) {
                this.log('üîç Recherche utilisateur par email:', this.currentUser.email);
                console.log('üîç Recherche utilisateur par email:', this.currentUser.email);
                // Chercher par email
                const { data: existingUser, error: searchError } = await this.client
                    .from('users')
                    .select('id')
                    .eq('email', this.currentUser.email)
                    .maybeSingle();

                if (existingUser) {
                    userId = existingUser.id;
                    this.currentUser.id = userId;
                    this.log('‚úÖ Utilisateur existant trouv√©:', userId);
                    console.log('‚úÖ Utilisateur existant trouv√©:', userId);
                } else {
                    // Cr√©er le user
                    this.log('‚ûï Cr√©ation nouvel utilisateur...');
                    console.log('‚ûï Cr√©ation nouvel utilisateur...');
                    const { data: newUser, error: createError } = await this.client
                        .from('users')
                        .insert({
                            email: this.currentUser.email,
                            pseudo: this.currentUser.pseudo,
                            ville: this.currentUser.ville,
                            pays: this.currentUser.pays,
                            age: this.currentUser.age,
                            genre: this.currentUser.genre,
                            avatar: this.currentUser.avatar
                        })
                        .select()
                        .single();

                    if (createError) {
                        this.error('Erreur cr√©ation user:', createError);
                        throw createError;
                    }
                    userId = newUser.id;
                    this.currentUser.id = userId;
                    this.log('‚úÖ Nouvel utilisateur cr√©√©:', userId);
                    console.log('‚úÖ Nouvel utilisateur cr√©√©:', userId);
                }
            }

            // 2. Ins√©rer le score
            this.log('üíæ Insertion score pour user_id:', userId);
            console.log('üíæ Insertion score pour user_id:', userId);
            const { data, error } = await this.client
                .from('scores')
                .insert({
                    user_id: userId,
                    game_id: this.currentGameId,
                    score: score,
                    niveau_atteint: options.niveau_atteint || null,
                    temps_jeu: options.temps_jeu || null,
                    donnees_extra: options.donnees_extra || null
                })
                .select()
                .single();

            if (error) {
                this.error('Erreur insertion score:', error);
                throw error;
            }

            this.log('‚úÖ Score enregistr√©:', data);
            console.log('‚úÖ Score enregistr√© directement:', data);
            return {
                success: true,
                user_id: userId,
                score_id: data.id
            };

        } catch (error) {
            this.error('Exception saveScoreDirect:', error);
            console.error('‚ùå Erreur saveScoreDirect:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    // M√©thode de sauvegarde classique (fallback si Edge Function indisponible)
    async saveScoreClassic(score, options = {}) {
        if (!this.currentUser) {
            console.error('‚ùå Aucun utilisateur connect√©');
            return null;
        }

        if (!this.currentGameId) {
            console.error('‚ùå Aucun jeu d√©fini');
            return null;
        }

        try {
            // V√©rifier si un score existe d√©j√†
            const { data: existingScore, error: searchError } = await this.client
                .from('scores')
                .select('*')
                .eq('user_id', this.currentUser.id)
                .eq('game_id', this.currentGameId)
                .single();

            // Si un score existe
            if (existingScore) {
                // Mettre √† jour seulement si le nouveau score est meilleur
                if (score > existingScore.score) {
                    const { data, error } = await this.client
                        .from('scores')
                        .update({
                            score: score,
                            niveau_atteint: options.niveau_atteint || null,
                            temps_jeu: options.temps_jeu || null,
                            donnees_extra: options.donnees_extra || null
                        })
                        .eq('user_id', this.currentUser.id)
                        .eq('game_id', this.currentGameId)
                        .select()
                        .single();

                    if (error) throw error;

                    console.log('‚úÖ Score mis √† jour:', score, '(ancien:', existingScore.score, ')');
                    return data;
                } else {
                    console.log('‚ÑπÔ∏è Score existant meilleur:', existingScore.score, '(nouveau:', score, ')');
                    return existingScore;
                }
            }

            // Sinon, cr√©er un nouveau score
            const { data, error } = await this.client
                .from('scores')
                .insert([{
                    user_id: this.currentUser.id,
                    game_id: this.currentGameId,
                    score: score,
                    niveau_atteint: options.niveau_atteint || null,
                    temps_jeu: options.temps_jeu || null,
                    donnees_extra: options.donnees_extra || null
                }])
                .select()
                .single();

            if (error) throw error;

            console.log('üíæ Premier score sauvegard√©:', score);
            return data;

        } catch (error) {
            console.error('‚ùå Erreur saveScore:', error);
            return null;
        }
    }

    // R√©cup√©rer le meilleur score de l'utilisateur pour le jeu actuel
    async getBestScore() {
        if (!this.currentUser || !this.currentGameId) return null;
        
        // Si on n'a pas de user_id, essayer de chercher via l'email (fallback)
        if (!this.currentUser.id) {
            return await this.getBestScoreByEmail();
        }

        try {
            const { data, error } = await this.client
                .from('scores')
                .select('*')
                .eq('user_id', this.currentUser.id)
                .eq('game_id', this.currentGameId)
                .order('score', { ascending: false })
                .limit(1)
                .single();

            if (error && error.code !== 'PGRST116') throw error;

            return data;

        } catch (error) {
            console.error('‚ùå Erreur getBestScore:', error);
            return null;
        }
    }

    // R√©cup√©rer le meilleur score via email (quand user_id n'est pas encore connu)
    async getBestScoreByEmail() {
        if (!this.currentUser?.email || !this.currentGameId) return null;

        try {
            // Joindre avec users pour trouver via email
            const { data, error } = await this.client
                .from('scores')
                .select(`
                    *,
                    users!inner(email)
                `)
                .eq('users.email', this.currentUser.email)
                .eq('game_id', this.currentGameId)
                .order('score', { ascending: false })
                .limit(1)
                .single();

            if (error && error.code !== 'PGRST116') throw error;

            console.log('‚úÖ Meilleur score trouv√© via email:', data?.score);
            return data;

        } catch (error) {
            console.error('‚ùå Erreur getBestScoreByEmail:', error);
            return null;
        }
    }

    // Supprimer les doublons en gardant le meilleur score pour chaque utilisateur
    async removeDuplicates() {
        if (!this.currentGameId) {
            console.error('‚ùå Aucun jeu d√©fini');
            return null;
        }

        try {
            console.log('üßπ Nettoyage des doublons...');

            // R√©cup√©rer tous les scores du jeu
            const { data: allScores, error: fetchError } = await this.client
                .from('scores')
                .select('*')
                .eq('game_id', this.currentGameId)
                .order('score', { ascending: false });

            if (fetchError) throw fetchError;

            console.log('üìä Scores trouv√©s:', allScores.length);

            // Grouper par utilisateur
            const scoresByUser = {};
            allScores.forEach(score => {
                if (!scoresByUser[score.user_id]) {
                    scoresByUser[score.user_id] = [];
                }
                scoresByUser[score.user_id].push(score);
            });

            // Pour chaque utilisateur, garder le meilleur et supprimer les autres
            let totalDeleted = 0;
            for (const userId in scoresByUser) {
                const userScores = scoresByUser[userId];

                if (userScores.length > 1) {
                    // Le premier est le meilleur (d√©j√† tri√© par score DESC)
                    const bestScore = userScores[0];
                    const duplicates = userScores.slice(1);

                    console.log(`üë§ Utilisateur ${userId}: ${userScores.length} scores, meilleur: ${bestScore.score}`);

                    // Supprimer les doublons
                    for (const duplicate of duplicates) {
                        const { error: deleteError } = await this.client
                            .from('scores')
                            .delete()
                            .eq('id', duplicate.id);

                        if (deleteError) {
                            console.error('‚ùå Erreur suppression:', deleteError);
                        } else {
                            totalDeleted++;
                            console.log(`  üóëÔ∏è Supprim√©: ${duplicate.score} (ID: ${duplicate.id})`);
                        }
                    }
                }
            }

            console.log(`‚úÖ Nettoyage termin√©: ${totalDeleted} doublons supprim√©s`);
            return { deleted: totalDeleted, total: allScores.length };

        } catch (error) {
            console.error('‚ùå Erreur removeDuplicates:', error);
            return null;
        }
    }

    // R√©cup√©rer le classement du jeu actuel (top 10)
    async getLeaderboard(limit = 10) {
        if (!this.currentGameId) return [];

        try {
            const { data, error } = await this.client
                .from('scores')
                .select(`
                    score,
                    niveau_atteint,
                    temps_jeu,
                    created_at,
                    donnees_extra,
                    users (pseudo, avatar, pays)
                `)
                .eq('game_id', this.currentGameId)
                .order('score', { ascending: false })
                .limit(limit);

            if (error) throw error;

            console.log('üèÜ Classement r√©cup√©r√©:', data.length, 'scores');
            return data;

        } catch (error) {
            console.error('‚ùå Erreur getLeaderboard:', error);
            return [];
        }
    }

    // R√©cup√©rer tous les scores d'un utilisateur (tous jeux confondus)
    async getUserAllScores() {
        if (!this.currentUser) return [];

        try {
            const { data, error } = await this.client
                .from('scores')
                .select(`
                    score,
                    niveau_atteint,
                    temps_jeu,
                    created_at,
                    games (nom, icone, url)
                `)
                .eq('user_id', this.currentUser.id)
                .order('created_at', { ascending: false });

            if (error) throw error;

            console.log('üìä Scores de l\'utilisateur:', data.length);
            return data;

        } catch (error) {
            console.error('‚ùå Erreur getUserAllScores:', error);
            return [];
        }
    }

    // Afficher un formulaire de connexion simple
    showLoginForm(callback) {
        const html = `
            <div id="supabase-login" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: white; padding: 40px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); z-index: 10000;">
                <h2 style="margin: 0 0 20px 0; text-align: center;">üö¢ Connexion</h2>
                <input type="email" id="supabase-email" placeholder="Email" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px;">
                <input type="text" id="supabase-pseudo" placeholder="Pseudo" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px;">
                <button id="supabase-login-btn" style="width: 100%; padding: 12px; margin: 10px 0; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Se connecter
                </button>
                <button id="supabase-cancel-btn" style="width: 100%; padding: 12px; margin: 10px 0; background: #666; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Annuler
                </button>
            </div>
            <div id="supabase-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;"></div>
        `;

        document.body.insertAdjacentHTML('beforeend', html);

        document.getElementById('supabase-login-btn').onclick = async () => {
            const email = document.getElementById('supabase-email').value;
            const pseudo = document.getElementById('supabase-pseudo').value;

            if (!email || !pseudo) {
                alert('Email et pseudo requis !');
                return;
            }

            const user = await this.getOrCreateUser(email, pseudo);

            document.getElementById('supabase-login').remove();
            document.getElementById('supabase-overlay').remove();

            if (callback) callback(user);
        };

        document.getElementById('supabase-cancel-btn').onclick = () => {
            document.getElementById('supabase-login').remove();
            document.getElementById('supabase-overlay').remove();
        };
    }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SupabaseScores;
}
